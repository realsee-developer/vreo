import {
  AddEquation,
  AdditiveBlending,
  AlwaysStencilFunc,
  AmbientLight,
  AnimationClip,
  AnimationMixer,
  ArrayCamera,
  BackSide,
  Bone,
  Box3,
  BoxBufferGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  CircleBufferGeometry,
  ClampToEdgeWrapping,
  Clock,
  Color,
  CompressedTexture,
  CubeCamera,
  CubeTexture,
  Curve,
  CurvePath,
  CustomBlending,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  EquirectangularReflectionMapping,
  Euler,
  Face3,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  Geometry,
  GreaterEqualStencilFunc,
  Group,
  HalfFloatType,
  ImmediateRenderObject,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  Int16BufferAttribute,
  Int32BufferAttribute,
  Int8BufferAttribute,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve3,
  LineLoop,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  MultiplyOperation,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoBlending,
  NormalBlending,
  NumberKeyframeTrack,
  Object3D,
  OneFactor,
  OneMinusSrcAlphaFactor,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBAFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RepeatWrapping,
  ReplaceStencilOp,
  SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene,
  ShaderLib,
  ShaderMaterial,
  ShapeUtils,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereBufferGeometry,
  SphereGeometry,
  SpotLight,
  SrcAlphaFactor,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  Uint8BufferAttribute,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  VideoTexture,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  sRGBEncoding
} from "./chunk-P7TF6BZ5.js";

// ../../node_modules/.pnpm/@realsee+five@6.4.0-alpha.40_@types+react@18.3.23_react@18.3.1_three@0.117.1/node_modules/@realsee/five/five/index.mjs
var version = Number(REVISION);
if (version < 115 || version > 117)
  throw new Error('"Five" needs "THREE.js" version between 125 - 117.');
var KJUR = {};
var CryptoJS = CryptoJS || function(n45, t) {
  var e = {}, r = e.lib = {}, o = r.Base = /* @__PURE__ */ function() {
    function v() {
    }
    return {
      extend: function(A) {
        v.prototype = this;
        var g = new v();
        return A && g.mixIn(A), g.hasOwnProperty("init") || (g.init = function() {
          g.$super.init.apply(this, arguments);
        }), g.init.prototype = g, g.$super = this, g;
      },
      create: function() {
        var A = this.extend();
        return A.init.apply(A, arguments), A;
      },
      init: function() {
      },
      mixIn: function(A) {
        for (var g in A)
          A.hasOwnProperty(g) && (this[g] = A[g]);
        A.hasOwnProperty("toString") && (this.toString = A.toString);
      },
      clone: function() {
        return this.init.prototype.extend(this);
      }
    };
  }(), s = r.WordArray = o.extend({
    init: function(v, A) {
      v = this.words = v || [], A != t ? this.sigBytes = A : this.sigBytes = v.length * 4;
    },
    toString: function(v) {
      return (v || l).stringify(this);
    },
    concat: function(v) {
      var A = this.words, g = v.words, p = this.sigBytes, y = v.sigBytes;
      if (this.clamp(), p % 4)
        for (var m = 0; m < y; m++) {
          var E = g[m >>> 2] >>> 24 - m % 4 * 8 & 255;
          A[p + m >>> 2] |= E << 24 - (p + m) % 4 * 8;
        }
      else
        for (var m = 0; m < y; m += 4)
          A[p + m >>> 2] = g[m >>> 2];
      return this.sigBytes += y, this;
    },
    clamp: function() {
      var v = this.words, A = this.sigBytes;
      v[A >>> 2] &= 4294967295 << 32 - A % 4 * 8, v.length = n45.ceil(A / 4);
    },
    clone: function() {
      var v = o.clone.call(this);
      return v.words = this.words.slice(0), v;
    },
    random: function(v) {
      for (var A = [], g = 0; g < v; g += 4)
        A.push(n45.random() * 4294967296 | 0);
      return new s.init(A, v);
    }
  }), u = e.enc = {}, l = u.Hex = {
    stringify: function(v) {
      for (var A = v.words, g = v.sigBytes, p = [], y = 0; y < g; y++) {
        var m = A[y >>> 2] >>> 24 - y % 4 * 8 & 255;
        p.push((m >>> 4).toString(16)), p.push((m & 15).toString(16));
      }
      return p.join("");
    },
    parse: function(v) {
      for (var A = v.length, g = [], p = 0; p < A; p += 2)
        g[p >>> 3] |= parseInt(v.substr(p, 2), 16) << 24 - p % 8 * 4;
      return new s.init(g, A / 2);
    }
  }, c = u.Latin1 = {
    stringify: function(v) {
      for (var A = v.words, g = v.sigBytes, p = [], y = 0; y < g; y++) {
        var m = A[y >>> 2] >>> 24 - y % 4 * 8 & 255;
        p.push(String.fromCharCode(m));
      }
      return p.join("");
    },
    parse: function(v) {
      for (var A = v.length, g = [], p = 0; p < A; p++)
        g[p >>> 2] |= (v.charCodeAt(p) & 255) << 24 - p % 4 * 8;
      return new s.init(g, A);
    }
  }, f = u.Utf8 = {
    stringify: function(v) {
      try {
        return decodeURIComponent(escape(c.stringify(v)));
      } catch (A) {
        throw new Error("Malformed UTF-8 data");
      }
    },
    parse: function(v) {
      return c.parse(unescape(encodeURIComponent(v)));
    }
  }, d = r.BufferedBlockAlgorithm = o.extend({
    reset: function() {
      this._data = new s.init(), this._nDataBytes = 0;
    },
    _append: function(v) {
      typeof v == "string" && (v = f.parse(v)), this._data.concat(v), this._nDataBytes += v.sigBytes;
    },
    _process: function(v) {
      var A = this._data, g = A.words, p = A.sigBytes, y = this.blockSize, m = y * 4, E = p / m;
      v ? E = n45.ceil(E) : E = n45.max((E | 0) - this._minBufferSize, 0);
      var b = E * y, T = n45.min(b * 4, p);
      if (b) {
        for (var R = 0; R < b; R += y)
          this._doProcessBlock(g, R);
        var S = g.splice(0, b);
        A.sigBytes -= T;
      }
      return new s.init(S, T);
    },
    clone: function() {
      var v = o.clone.call(this);
      return v._data = this._data.clone(), v;
    },
    _minBufferSize: 0
  });
  r.Hasher = d.extend({
    cfg: o.extend(),
    init: function(v) {
      this.cfg = this.cfg.extend(v), this.reset();
    },
    reset: function() {
      d.reset.call(this), this._doReset();
    },
    update: function(v) {
      return this._append(v), this._process(), this;
    },
    finalize: function(v) {
      v && this._append(v);
      var A = this._doFinalize();
      return A;
    },
    blockSize: 512 / 32,
    _createHelper: function(v) {
      return function(A, g) {
        return new v.init(g).finalize(A);
      };
    },
    _createHmacHelper: function(v) {
      return function(A, g) {
        return new h.HMAC.init(v, g).finalize(A);
      };
    }
  });
  var h = e.algo = {};
  return e;
}(Math);
(function(n45) {
  for (var t = CryptoJS, A = t.lib, e = A.WordArray, r = A.Hasher, A = t.algo, o = [], s = [], u = function(p) {
    return 4294967296 * (p - (p | 0)) | 0;
  }, l = 2, c = 0; 64 > c; ) {
    var f;
    e: {
      f = l;
      for (var d = n45.sqrt(f), h = 2; h <= d; h++)
        if (!(f % h)) {
          f = false;
          break e;
        }
      f = true;
    }
    f && (8 > c && (o[c] = u(n45.pow(l, 0.5))), s[c] = u(n45.pow(l, 1 / 3)), c++), l++;
  }
  var v = [], A = A.SHA256 = r.extend({
    _doReset: function() {
      this._hash = new e.init(o.slice(0));
    },
    _doProcessBlock: function(g, p) {
      for (var y = this._hash.words, m = y[0], E = y[1], b = y[2], T = y[3], R = y[4], S = y[5], M = y[6], w = y[7], H = 0; 64 > H; H++) {
        if (16 > H)
          v[H] = g[p + H] | 0;
        else {
          var L = v[H - 15], C = v[H - 2];
          v[H] = ((L << 25 | L >>> 7) ^ (L << 14 | L >>> 18) ^ L >>> 3) + v[H - 7] + ((C << 15 | C >>> 17) ^ (C << 13 | C >>> 19) ^ C >>> 10) + v[H - 16];
        }
        L = w + ((R << 26 | R >>> 6) ^ (R << 21 | R >>> 11) ^ (R << 7 | R >>> 25)) + (R & S ^ ~R & M) + s[H] + v[H], C = ((m << 30 | m >>> 2) ^ (m << 19 | m >>> 13) ^ (m << 10 | m >>> 22)) + (m & E ^ m & b ^ E & b), w = M, M = S, S = R, R = T + L | 0, T = b, b = E, E = m, m = L + C | 0;
      }
      y[0] = y[0] + m | 0, y[1] = y[1] + E | 0, y[2] = y[2] + b | 0, y[3] = y[3] + T | 0, y[4] = y[4] + R | 0, y[5] = y[5] + S | 0, y[6] = y[6] + M | 0, y[7] = y[7] + w | 0;
    },
    _doFinalize: function() {
      var g = this._data, p = g.words, y = 8 * this._nDataBytes, m = 8 * g.sigBytes;
      return p[m >>> 5] |= 128 << 24 - m % 32, p[(m + 64 >>> 9 << 4) + 14] = n45.floor(y / 4294967296), p[(m + 64 >>> 9 << 4) + 15] = y, g.sigBytes = 4 * p.length, this._process(), this._hash;
    },
    clone: function() {
      var g = r.clone.call(this);
      return g._hash = this._hash.clone(), g;
    }
  });
  t.SHA256 = r._createHelper(A), t.HmacSHA256 = r._createHmacHelper(A);
})(Math);
CryptoJS.lib.Cipher || function(n45) {
  var A = CryptoJS, t = A.lib, e = t.Base, r = t.WordArray, o = t.BufferedBlockAlgorithm, s = A.enc.Base64, u = A.algo.EvpKDF, l = t.Cipher = o.extend({
    cfg: e.extend(),
    createEncryptor: function(p, y) {
      return this.create(this._ENC_XFORM_MODE, p, y);
    },
    createDecryptor: function(p, y) {
      return this.create(this._DEC_XFORM_MODE, p, y);
    },
    init: function(p, y, m) {
      this.cfg = this.cfg.extend(m), this._xformMode = p, this._key = y, this.reset();
    },
    reset: function() {
      o.reset.call(this), this._doReset();
    },
    process: function(p) {
      return this._append(p), this._process();
    },
    finalize: function(p) {
      return p && this._append(p), this._doFinalize();
    },
    keySize: 4,
    ivSize: 4,
    _ENC_XFORM_MODE: 1,
    _DEC_XFORM_MODE: 2,
    _createHelper: function(p) {
      return {
        encrypt: function(y, m, E) {
          return (typeof m == "string" ? g : v).encrypt(p, y, m, E);
        },
        decrypt: function(y, m, E) {
          return (typeof m == "string" ? g : v).decrypt(p, y, m, E);
        }
      };
    }
  });
  t.StreamCipher = l.extend({
    _doFinalize: function() {
      return this._process(true);
    },
    blockSize: 1
  });
  var h = A.mode = {}, c = function(p, y, m) {
    var E = this._iv;
    E ? this._iv = n45 : E = this._prevBlock;
    for (var b = 0; b < m; b++)
      p[y + b] ^= E[b];
  }, f = (t.BlockCipherMode = e.extend({
    createEncryptor: function(p, y) {
      return this.Encryptor.create(p, y);
    },
    createDecryptor: function(p, y) {
      return this.Decryptor.create(p, y);
    },
    init: function(p, y) {
      this._cipher = p, this._iv = y;
    }
  })).extend();
  f.Encryptor = f.extend({
    processBlock: function(p, y) {
      var m = this._cipher, E = m.blockSize;
      c.call(this, p, y, E), m.encryptBlock(p, y), this._prevBlock = p.slice(y, y + E);
    }
  }), f.Decryptor = f.extend({
    processBlock: function(p, y) {
      var m = this._cipher, E = m.blockSize, b = p.slice(y, y + E);
      m.decryptBlock(p, y), c.call(this, p, y, E), this._prevBlock = b;
    }
  }), h = h.CBC = f, f = (A.pad = {}).Pkcs7 = {
    pad: function(p, y) {
      for (var m = 4 * y, m = m - p.sigBytes % m, E = m << 24 | m << 16 | m << 8 | m, b = [], T = 0; T < m; T += 4)
        b.push(E);
      m = r.create(b, m), p.concat(m);
    },
    unpad: function(p) {
      p.sigBytes -= p.words[p.sigBytes - 1 >>> 2] & 255;
    }
  }, t.BlockCipher = l.extend({
    cfg: l.cfg.extend({
      mode: h,
      padding: f
    }),
    reset: function() {
      l.reset.call(this);
      var y = this.cfg, p = y.iv, y = y.mode;
      if (this._xformMode == this._ENC_XFORM_MODE)
        var m = y.createEncryptor;
      else
        m = y.createDecryptor, this._minBufferSize = 1;
      this._mode = m.call(y, this, p && p.words);
    },
    _doProcessBlock: function(p, y) {
      this._mode.processBlock(p, y);
    },
    _doFinalize: function() {
      var p = this.cfg.padding;
      if (this._xformMode == this._ENC_XFORM_MODE) {
        p.pad(this._data, this.blockSize);
        var y = this._process(true);
      } else
        y = this._process(true), p.unpad(y);
      return y;
    },
    blockSize: 4
  });
  var d = t.CipherParams = e.extend({
    init: function(p) {
      this.mixIn(p);
    },
    toString: function(p) {
      return (p || this.formatter).stringify(this);
    }
  }), h = (A.format = {}).OpenSSL = {
    stringify: function(p) {
      var y = p.ciphertext;
      return p = p.salt, (p ? r.create([1398893684, 1701076831]).concat(p).concat(y) : y).toString(s);
    },
    parse: function(p) {
      p = s.parse(p);
      var y = p.words;
      if (y[0] == 1398893684 && y[1] == 1701076831) {
        var m = r.create(y.slice(2, 4));
        y.splice(0, 4), p.sigBytes -= 16;
      }
      return d.create({
        ciphertext: p,
        salt: m
      });
    }
  }, v = t.SerializableCipher = e.extend({
    cfg: e.extend({
      format: h
    }),
    encrypt: function(p, y, m, E) {
      E = this.cfg.extend(E);
      var b = p.createEncryptor(m, E);
      return y = b.finalize(y), b = b.cfg, d.create({
        ciphertext: y,
        key: m,
        iv: b.iv,
        algorithm: p,
        mode: b.mode,
        padding: b.padding,
        blockSize: p.blockSize,
        formatter: E.format
      });
    },
    decrypt: function(p, y, m, E) {
      return E = this.cfg.extend(E), y = this._parse(y, E.format), p.createDecryptor(m, E).finalize(y.ciphertext);
    },
    _parse: function(p, y) {
      return typeof p == "string" ? y.parse(p, this) : p;
    }
  }), A = (A.kdf = {}).OpenSSL = {
    execute: function(p, y, m, E) {
      return E || (E = r.random(8)), p = u.create({
        keySize: y + m
      }).compute(p, E), m = r.create(p.words.slice(y), 4 * m), p.sigBytes = 4 * y, d.create({
        key: p,
        iv: m,
        salt: E
      });
    }
  }, g = t.PasswordBasedCipher = v.extend({
    cfg: v.cfg.extend({
      kdf: A
    }),
    encrypt: function(p, y, m, E) {
      return E = this.cfg.extend(E), m = E.kdf.execute(m, p.keySize, p.ivSize), E.iv = m.iv, p = v.encrypt.call(this, p, y, m.key, E), p.mixIn(m), p;
    },
    decrypt: function(p, y, m, E) {
      return E = this.cfg.extend(E), y = this._parse(y, E.format), m = E.kdf.execute(m, p.keySize, p.ivSize, y.salt), E.iv = m.iv, v.decrypt.call(this, p, y, m.key, E);
    }
  });
}();
(function() {
  for (var n45 = CryptoJS, t = n45.lib.BlockCipher, S = n45.algo, e = [], r = [], o = [], s = [], u = [], l = [], c = [], f = [], d = [], h = [], v = [], A = 0; 256 > A; A++)
    v[A] = 128 > A ? A << 1 : A << 1 ^ 283;
  for (var g = 0, p = 0, A = 0; 256 > A; A++) {
    var y = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4, y = y >>> 8 ^ y & 255 ^ 99;
    e[g] = y, r[y] = g;
    var m = v[g], E = v[m], b = v[E], T = 257 * v[y] ^ 16843008 * y;
    o[g] = T << 24 | T >>> 8, s[g] = T << 16 | T >>> 16, u[g] = T << 8 | T >>> 24, l[g] = T, T = 16843009 * b ^ 65537 * E ^ 257 * m ^ 16843008 * g, c[y] = T << 24 | T >>> 8, f[y] = T << 16 | T >>> 16, d[y] = T << 8 | T >>> 24, h[y] = T, g ? (g = m ^ v[v[v[b ^ m]]], p ^= v[v[p]]) : g = p = 1;
  }
  var R = [
    0,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    27,
    54
  ], S = S.AES = t.extend({
    _doReset: function() {
      for (var H = this._key, M = H.words, w = H.sigBytes / 4, H = 4 * ((this._nRounds = w + 6) + 1), L = this._keySchedule = [], C = 0; C < H; C++)
        if (C < w)
          L[C] = M[C];
        else {
          var I = L[C - 1];
          C % w ? 6 < w && C % w == 4 && (I = e[I >>> 24] << 24 | e[I >>> 16 & 255] << 16 | e[I >>> 8 & 255] << 8 | e[I & 255]) : (I = I << 8 | I >>> 24, I = e[I >>> 24] << 24 | e[I >>> 16 & 255] << 16 | e[I >>> 8 & 255] << 8 | e[I & 255], I ^= R[C / w | 0] << 24), L[C] = L[C - w] ^ I;
        }
      for (M = this._invKeySchedule = [], w = 0; w < H; w++)
        C = H - w, I = w % 4 ? L[C] : L[C - 4], M[w] = 4 > w || 4 >= C ? I : c[e[I >>> 24]] ^ f[e[I >>> 16 & 255]] ^ d[e[I >>> 8 & 255]] ^ h[e[I & 255]];
    },
    encryptBlock: function(M, w) {
      this._doCryptBlock(M, w, this._keySchedule, o, s, u, l, e);
    },
    decryptBlock: function(M, w) {
      var H = M[w + 1];
      M[w + 1] = M[w + 3], M[w + 3] = H, this._doCryptBlock(M, w, this._invKeySchedule, c, f, d, h, r), H = M[w + 1], M[w + 1] = M[w + 3], M[w + 3] = H;
    },
    _doCryptBlock: function(M, w, H, L, C, I, _, O) {
      for (var P = this._nRounds, Q = M[w] ^ H[0], G = M[w + 1] ^ H[1], X = M[w + 2] ^ H[2], z = M[w + 3] ^ H[3], N = 4, k = 1; k < P; k++)
        var U = L[Q >>> 24] ^ C[G >>> 16 & 255] ^ I[X >>> 8 & 255] ^ _[z & 255] ^ H[N++], D = L[G >>> 24] ^ C[X >>> 16 & 255] ^ I[z >>> 8 & 255] ^ _[Q & 255] ^ H[N++], q = L[X >>> 24] ^ C[z >>> 16 & 255] ^ I[Q >>> 8 & 255] ^ _[G & 255] ^ H[N++], z = L[z >>> 24] ^ C[Q >>> 16 & 255] ^ I[G >>> 8 & 255] ^ _[X & 255] ^ H[N++], Q = U, G = D, X = q;
      U = (O[Q >>> 24] << 24 | O[G >>> 16 & 255] << 16 | O[X >>> 8 & 255] << 8 | O[z & 255]) ^ H[N++], D = (O[G >>> 24] << 24 | O[X >>> 16 & 255] << 16 | O[z >>> 8 & 255] << 8 | O[Q & 255]) ^ H[N++], q = (O[X >>> 24] << 24 | O[z >>> 16 & 255] << 16 | O[Q >>> 8 & 255] << 8 | O[G & 255]) ^ H[N++], z = (O[z >>> 24] << 24 | O[Q >>> 16 & 255] << 16 | O[G >>> 8 & 255] << 8 | O[X & 255]) ^ H[N++], M[w] = U, M[w + 1] = D, M[w + 2] = q, M[w + 3] = z;
    },
    keySize: 8
  });
  n45.AES = t._createHelper(S);
})();
var dbits;
function BigInteger(n45, t, e) {
  n45 != null && (typeof n45 == "number" ? this.fromNumber(n45, t, e) : t == null && typeof n45 != "string" ? this.fromString(n45, 256) : this.fromString(n45, t));
}
function nbi() {
  return new BigInteger(null);
}
function am1(n45, t, e, r, o, s) {
  for (; --s >= 0; ) {
    var u = t * this[n45++] + e[r] + o;
    o = Math.floor(u / 67108864), e[r++] = u & 67108863;
  }
  return o;
}
function am2(n45, t, e, r, o, s) {
  for (var u = t & 32767, l = t >> 15; --s >= 0; ) {
    var c = this[n45] & 32767, f = this[n45++] >> 15, d = l * c + f * u;
    c = u * c + ((d & 32767) << 15) + e[r] + (o & 1073741823), o = (c >>> 30) + (d >>> 15) + l * f + (o >>> 30), e[r++] = c & 1073741823;
  }
  return o;
}
function am3(n45, t, e, r, o, s) {
  for (var u = t & 16383, l = t >> 14; --s >= 0; ) {
    var c = this[n45] & 16383, f = this[n45++] >> 14, d = l * c + f * u;
    c = u * c + ((d & 16383) << 14) + e[r] + o, o = (c >> 28) + (d >> 14) + l * f, e[r++] = c & 268435455;
  }
  return o;
}
typeof navigator != "undefined" && navigator.appName == "Microsoft Internet Explorer" ? (BigInteger.prototype.am = am2, dbits = 30) : typeof navigator != "undefined" && navigator.appName != "Netscape" ? (BigInteger.prototype.am = am1, dbits = 26) : (BigInteger.prototype.am = am3, dbits = 28);
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr;
var vv;
rr = 48;
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = 97;
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = 65;
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function int2char(n45) {
  return BI_RM.charAt(n45);
}
function intAt(n45, t) {
  var e = BI_RC[n45.charCodeAt(t)];
  return e == null ? -1 : e;
}
function bnpCopyTo(n45) {
  for (var t = this.t - 1; t >= 0; --t)
    n45[t] = this[t];
  n45.t = this.t, n45.s = this.s;
}
function bnpFromInt(n45) {
  this.t = 1, this.s = n45 < 0 ? -1 : 0, n45 > 0 ? this[0] = n45 : n45 < -1 ? this[0] = n45 + this.DV : this.t = 0;
}
function nbv(n45) {
  var t = nbi();
  return t.fromInt(n45), t;
}
function bnpFromString(n45, t) {
  var e;
  if (t == 16)
    e = 4;
  else if (t == 8)
    e = 3;
  else if (t == 256)
    e = 8;
  else if (t == 2)
    e = 1;
  else if (t == 32)
    e = 5;
  else if (t == 4)
    e = 2;
  else {
    this.fromRadix(n45, t);
    return;
  }
  this.t = 0, this.s = 0;
  for (var r = n45.length, o = false, s = 0; --r >= 0; ) {
    var u = e == 8 ? n45[r] & 255 : intAt(n45, r);
    if (u < 0) {
      n45.charAt(r) == "-" && (o = true);
      continue;
    }
    o = false, s == 0 ? this[this.t++] = u : s + e > this.DB ? (this[this.t - 1] |= (u & (1 << this.DB - s) - 1) << s, this[this.t++] = u >> this.DB - s) : this[this.t - 1] |= u << s, s += e, s >= this.DB && (s -= this.DB);
  }
  e == 8 && n45[0] & 128 && (this.s = -1, s > 0 && (this[this.t - 1] |= (1 << this.DB - s) - 1 << s)), this.clamp(), o && BigInteger.ZERO.subTo(this, this);
}
function bnpClamp() {
  for (var n45 = this.s & this.DM; this.t > 0 && this[this.t - 1] == n45; )
    --this.t;
}
function bnToString(n45) {
  if (this.s < 0)
    return "-" + this.negate().toString(n45);
  var t;
  if (n45 == 16)
    t = 4;
  else if (n45 == 8)
    t = 3;
  else if (n45 == 2)
    t = 1;
  else if (n45 == 32)
    t = 5;
  else if (n45 == 4)
    t = 2;
  else
    return this.toRadix(n45);
  var e = (1 << t) - 1, r, o = false, s = "", u = this.t, l = this.DB - u * this.DB % t;
  if (u-- > 0)
    for (l < this.DB && (r = this[u] >> l) > 0 && (o = true, s = int2char(r)); u >= 0; )
      l < t ? (r = (this[u] & (1 << l) - 1) << t - l, r |= this[--u] >> (l += this.DB - t)) : (r = this[u] >> (l -= t) & e, l <= 0 && (l += this.DB, --u)), r > 0 && (o = true), o && (s += int2char(r));
  return o ? s : "0";
}
function bnNegate() {
  var n45 = nbi();
  return BigInteger.ZERO.subTo(this, n45), n45;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(n45) {
  var t = this.s - n45.s;
  if (t != 0)
    return t;
  var e = this.t;
  if (t = e - n45.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --e >= 0; )
    if ((t = this[e] - n45[e]) != 0)
      return t;
  return 0;
}
function nbits(n45) {
  var t = 1, e;
  return (e = n45 >>> 16) != 0 && (n45 = e, t += 16), (e = n45 >> 8) != 0 && (n45 = e, t += 8), (e = n45 >> 4) != 0 && (n45 = e, t += 4), (e = n45 >> 2) != 0 && (n45 = e, t += 2), (e = n45 >> 1) != 0 && (n45 = e, t += 1), t;
}
function bnBitLength() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n45, t) {
  var e;
  for (e = this.t - 1; e >= 0; --e)
    t[e + n45] = this[e];
  for (e = n45 - 1; e >= 0; --e)
    t[e] = 0;
  t.t = this.t + n45, t.s = this.s;
}
function bnpDRShiftTo(n45, t) {
  for (var e = n45; e < this.t; ++e)
    t[e - n45] = this[e];
  t.t = Math.max(this.t - n45, 0), t.s = this.s;
}
function bnpLShiftTo(n45, t) {
  var e = n45 % this.DB, r = this.DB - e, o = (1 << r) - 1, s = Math.floor(n45 / this.DB), u = this.s << e & this.DM, l;
  for (l = this.t - 1; l >= 0; --l)
    t[l + s + 1] = this[l] >> r | u, u = (this[l] & o) << e;
  for (l = s - 1; l >= 0; --l)
    t[l] = 0;
  t[s] = u, t.t = this.t + s + 1, t.s = this.s, t.clamp();
}
function bnpRShiftTo(n45, t) {
  t.s = this.s;
  var e = Math.floor(n45 / this.DB);
  if (e >= this.t) {
    t.t = 0;
    return;
  }
  var r = n45 % this.DB, o = this.DB - r, s = (1 << r) - 1;
  t[0] = this[e] >> r;
  for (var u = e + 1; u < this.t; ++u)
    t[u - e - 1] |= (this[u] & s) << o, t[u - e] = this[u] >> r;
  r > 0 && (t[this.t - e - 1] |= (this.s & s) << o), t.t = this.t - e, t.clamp();
}
function bnpSubTo(n45, t) {
  for (var e = 0, r = 0, o = Math.min(n45.t, this.t); e < o; )
    r += this[e] - n45[e], t[e++] = r & this.DM, r >>= this.DB;
  if (n45.t < this.t) {
    for (r -= n45.s; e < this.t; )
      r += this[e], t[e++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; e < n45.t; )
      r -= n45[e], t[e++] = r & this.DM, r >>= this.DB;
    r -= n45.s;
  }
  t.s = r < 0 ? -1 : 0, r < -1 ? t[e++] = this.DV + r : r > 0 && (t[e++] = r), t.t = e, t.clamp();
}
function bnpMultiplyTo(n45, t) {
  var e = this.abs(), r = n45.abs(), o = e.t;
  for (t.t = o + r.t; --o >= 0; )
    t[o] = 0;
  for (o = 0; o < r.t; ++o)
    t[o + e.t] = e.am(0, r[o], t, o, 0, e.t);
  t.s = 0, t.clamp(), this.s != n45.s && BigInteger.ZERO.subTo(t, t);
}
function bnpSquareTo(n45) {
  for (var t = this.abs(), e = n45.t = 2 * t.t; --e >= 0; )
    n45[e] = 0;
  for (e = 0; e < t.t - 1; ++e) {
    var r = t.am(e, t[e], n45, 2 * e, 0, 1);
    (n45[e + t.t] += t.am(e + 1, 2 * t[e], n45, 2 * e + 1, r, t.t - e - 1)) >= t.DV && (n45[e + t.t] -= t.DV, n45[e + t.t + 1] = 1);
  }
  n45.t > 0 && (n45[n45.t - 1] += t.am(e, t[e], n45, 2 * e, 0, 1)), n45.s = 0, n45.clamp();
}
function bnpDivRemTo(n45, t, e) {
  var r = n45.abs();
  if (!(r.t <= 0)) {
    var o = this.abs();
    if (o.t < r.t) {
      t != null && t.fromInt(0), e != null && this.copyTo(e);
      return;
    }
    e == null && (e = nbi());
    var s = nbi(), u = this.s, l = n45.s, c = this.DB - nbits(r[r.t - 1]);
    c > 0 ? (r.lShiftTo(c, s), o.lShiftTo(c, e)) : (r.copyTo(s), o.copyTo(e));
    var f = s.t, d = s[f - 1];
    if (d != 0) {
      var h = d * (1 << this.F1) + (f > 1 ? s[f - 2] >> this.F2 : 0), v = this.FV / h, A = (1 << this.F1) / h, g = 1 << this.F2, p = e.t, y = p - f, m = t == null ? nbi() : t;
      for (s.dlShiftTo(y, m), e.compareTo(m) >= 0 && (e[e.t++] = 1, e.subTo(m, e)), BigInteger.ONE.dlShiftTo(f, m), m.subTo(s, s); s.t < f; )
        s[s.t++] = 0;
      for (; --y >= 0; ) {
        var E = e[--p] == d ? this.DM : Math.floor(e[p] * v + (e[p - 1] + g) * A);
        if ((e[p] += s.am(0, E, e, y, 0, f)) < E)
          for (s.dlShiftTo(y, m), e.subTo(m, e); e[p] < --E; )
            e.subTo(m, e);
      }
      t != null && (e.drShiftTo(f, t), u != l && BigInteger.ZERO.subTo(t, t)), e.t = f, e.clamp(), c > 0 && e.rShiftTo(c, e), u < 0 && BigInteger.ZERO.subTo(e, e);
    }
  }
}
function bnMod(n45) {
  var t = nbi();
  return this.abs().divRemTo(n45, null, t), this.s < 0 && t.compareTo(BigInteger.ZERO) > 0 && n45.subTo(t, t), t;
}
function Classic(n45) {
  this.m = n45;
}
function cConvert(n45) {
  return n45.s < 0 || n45.compareTo(this.m) >= 0 ? n45.mod(this.m) : n45;
}
function cRevert(n45) {
  return n45;
}
function cReduce(n45) {
  n45.divRemTo(this.m, null, n45);
}
function cMulTo(n45, t, e) {
  n45.multiplyTo(t, e), this.reduce(e);
}
function cSqrTo(n45, t) {
  n45.squareTo(t), this.reduce(t);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var n45 = this[0];
  if (!(n45 & 1))
    return 0;
  var t = n45 & 3;
  return t = t * (2 - (n45 & 15) * t) & 15, t = t * (2 - (n45 & 255) * t) & 255, t = t * (2 - ((n45 & 65535) * t & 65535)) & 65535, t = t * (2 - n45 * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function Montgomery(n45) {
  this.m = n45, this.mp = n45.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << n45.DB - 15) - 1, this.mt2 = 2 * n45.t;
}
function montConvert(n45) {
  var t = nbi();
  return n45.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), n45.s < 0 && t.compareTo(BigInteger.ZERO) > 0 && this.m.subTo(t, t), t;
}
function montRevert(n45) {
  var t = nbi();
  return n45.copyTo(t), this.reduce(t), t;
}
function montReduce(n45) {
  for (; n45.t <= this.mt2; )
    n45[n45.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var e = n45[t] & 32767, r = e * this.mpl + ((e * this.mph + (n45[t] >> 15) * this.mpl & this.um) << 15) & n45.DM;
    for (e = t + this.m.t, n45[e] += this.m.am(0, r, n45, t, 0, this.m.t); n45[e] >= n45.DV; )
      n45[e] -= n45.DV, n45[++e]++;
  }
  n45.clamp(), n45.drShiftTo(this.m.t, n45), n45.compareTo(this.m) >= 0 && n45.subTo(this.m, n45);
}
function montSqrTo(n45, t) {
  n45.squareTo(t), this.reduce(t);
}
function montMulTo(n45, t, e) {
  n45.multiplyTo(t, e), this.reduce(e);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this[0] & 1 : this.s) == 0;
}
function bnpExp(n45, t) {
  if (n45 > 4294967295 || n45 < 1)
    return BigInteger.ONE;
  var e = nbi(), r = nbi(), o = t.convert(this), s = nbits(n45) - 1;
  for (o.copyTo(e); --s >= 0; )
    if (t.sqrTo(e, r), (n45 & 1 << s) > 0)
      t.mulTo(r, o, e);
    else {
      var u = e;
      e = r, r = u;
    }
  return t.revert(e);
}
function bnModPowInt(n45, t) {
  var e;
  return n45 < 256 || t.isEven() ? e = new Classic(t) : e = new Montgomery(t), this.exp(n45, e);
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this[0];
    if (this.t == 0)
      return 0;
  }
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function bnpChunkSize(n45) {
  return Math.floor(Math.LN2 * this.DB / Math.log(n45));
}
function bnSigNum() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
}
function bnpToRadix(n45) {
  if (n45 == null && (n45 = 10), this.signum() == 0 || n45 < 2 || n45 > 36)
    return "0";
  var t = this.chunkSize(n45), e = Math.pow(n45, t), r = nbv(e), o = nbi(), s = nbi(), u = "";
  for (this.divRemTo(r, o, s); o.signum() > 0; )
    u = (e + s.intValue()).toString(n45).substr(1) + u, o.divRemTo(r, o, s);
  return s.intValue().toString(n45) + u;
}
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.signum = bnSigNum;
var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(n45) {
  var t, e, r = "";
  for (t = 0; t + 3 <= n45.length; t += 3)
    e = parseInt(n45.substring(t, t + 3), 16), r += b64map.charAt(e >> 6) + b64map.charAt(e & 63);
  for (t + 1 == n45.length ? (e = parseInt(n45.substring(t, t + 1), 16), r += b64map.charAt(e << 2)) : t + 2 == n45.length && (e = parseInt(n45.substring(t, t + 2), 16), r += b64map.charAt(e >> 2) + b64map.charAt((e & 3) << 4)); (r.length & 3) > 0; )
    r += b64pad;
  return r;
}
function b64tohex(n45) {
  var t = "", e, r = 0, o, s;
  for (e = 0; e < n45.length && n45.charAt(e) != b64pad; ++e)
    s = b64map.indexOf(n45.charAt(e)), !(s < 0) && (r == 0 ? (t += int2char(s >> 2), o = s & 3, r = 1) : r == 1 ? (t += int2char(o << 2 | s >> 4), o = s & 15, r = 2) : r == 2 ? (t += int2char(o), t += int2char(s >> 2), o = s & 3, r = 3) : (t += int2char(o << 2 | s >> 4), t += int2char(s & 15), r = 0));
  return r == 1 && (t += int2char(o << 2)), t;
}
function parseBigInt(n45, t) {
  return new BigInteger(n45, t);
}
function pkcs1pad2(n45, t) {
  if (t < n45.length + 11)
    throw "Message too long for RSA";
  for (var e = new Array(), r = n45.length - 1; r >= 0 && t > 0; ) {
    var o = n45.charCodeAt(r--);
    o < 128 ? e[--t] = o : o > 127 && o < 2048 ? (e[--t] = o & 63 | 128, e[--t] = o >> 6 | 192) : (e[--t] = o & 63 | 128, e[--t] = o >> 6 & 63 | 128, e[--t] = o >> 12 | 224);
  }
  e[--t] = 0;
  for (var s = new SecureRandom(), u = new Array(); t > 2; ) {
    for (u[0] = 0; u[0] == 0; )
      s.nextBytes(u);
    e[--t] = u[0];
  }
  return e[--t] = 2, e[--t] = 0, new BigInteger(e);
}
function oaep_mgf1_arr(n45, t, e) {
  for (var r = "", o = 0; r.length < t; )
    r += e(String.fromCharCode.apply(String, n45.concat([(o & 4278190080) >> 24, (o & 16711680) >> 16, (o & 65280) >> 8, o & 255]))), o += 1;
  return r;
}
function oaep_pad(n45, t, e, r) {
  var o = KJUR.crypto.MessageDigest, s = KJUR.crypto.Util, u = null;
  if (e || (e = "sha1"), typeof e == "string" && (u = o.getCanonicalAlgName(e), r = o.getHashLength(u), e = function(p) {
    return hextorstr(s.hashHex(rstrtohex(p), u));
  }), n45.length + 2 * r + 2 > t)
    throw "Message too long for RSA";
  var l = "", c;
  for (c = 0; c < t - n45.length - 2 * r - 2; c += 1)
    l += "\0";
  var f = e("") + l + "" + n45, d = new Array(r);
  new SecureRandom().nextBytes(d);
  var h = oaep_mgf1_arr(d, f.length, e), v = [];
  for (c = 0; c < f.length; c += 1)
    v[c] = f.charCodeAt(c) ^ h.charCodeAt(c);
  var A = oaep_mgf1_arr(v, d.length, e), g = [0];
  for (c = 0; c < d.length; c += 1)
    g[c + 1] = d[c] ^ A.charCodeAt(c);
  return new BigInteger(g.concat(v));
}
function RSAKey() {
  this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;
}
function RSASetPublic(n45, t) {
  if (this.isPublic = true, this.isPrivate = false, typeof n45 != "string")
    this.n = n45, this.e = t;
  else if (n45 != null && t != null && n45.length > 0 && t.length > 0)
    this.n = parseBigInt(n45, 16), this.e = parseInt(t, 16);
  else
    throw "Invalid RSA public key";
}
function RSADoPublic(n45) {
  return n45.modPowInt(this.e, this.n);
}
function RSAEncrypt(n45) {
  var t = pkcs1pad2(n45, this.n.bitLength() + 7 >> 3);
  if (t == null)
    return null;
  var e = this.doPublic(t);
  if (e == null)
    return null;
  var r = e.toString(16);
  return r.length & 1 ? "0" + r : r;
}
function RSAEncryptOAEP(n45, t, e) {
  var r = oaep_pad(n45, this.n.bitLength() + 7 >> 3, t, e);
  if (r == null)
    return null;
  var o = this.doPublic(r);
  if (o == null)
    return null;
  var s = o.toString(16);
  return s.length & 1 ? "0" + s : s;
}
RSAKey.prototype.doPublic = RSADoPublic;
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;
RSAKey.prototype.type = "RSA";
function pkcs1unpad2(n45, t) {
  for (var e = n45.toByteArray(), r = 0; r < e.length && e[r] == 0; )
    ++r;
  if (e.length - r != t - 1 || e[r] != 2)
    return null;
  for (++r; e[r] != 0; )
    if (++r >= e.length)
      return null;
  for (var o = ""; ++r < e.length; ) {
    var s = e[r] & 255;
    s < 128 ? o += String.fromCharCode(s) : s > 191 && s < 224 ? (o += String.fromCharCode((s & 31) << 6 | e[r + 1] & 63), ++r) : (o += String.fromCharCode((s & 15) << 12 | (e[r + 1] & 63) << 6 | e[r + 2] & 63), r += 2);
  }
  return o;
}
function oaep_mgf1_str(n45, t, e) {
  for (var r = "", o = 0; r.length < t; )
    r += e(n45 + String.fromCharCode.apply(String, [(o & 4278190080) >> 24, (o & 16711680) >> 16, (o & 65280) >> 8, o & 255])), o += 1;
  return r;
}
function oaep_unpad(n45, t, e, r) {
  var o = KJUR.crypto.MessageDigest, s = KJUR.crypto.Util, u = null;
  e || (e = "sha1"), typeof e == "string" && (u = o.getCanonicalAlgName(e), r = o.getHashLength(u), e = function(y) {
    return hextorstr(s.hashHex(rstrtohex(y), u));
  }), n45 = n45.toByteArray();
  var h;
  for (h = 0; h < n45.length; h += 1)
    n45[h] &= 255;
  for (; n45.length < t; )
    n45.unshift(0);
  if (n45 = String.fromCharCode.apply(String, n45), n45.length < 2 * r + 2)
    throw "Cipher too short";
  var l = n45.substr(1, r), c = n45.substr(r + 1), f = oaep_mgf1_str(c, r, e), d = [], h;
  for (h = 0; h < l.length; h += 1)
    d[h] = l.charCodeAt(h) ^ f.charCodeAt(h);
  var v = oaep_mgf1_str(String.fromCharCode.apply(String, d), n45.length - r, e), A = [];
  for (h = 0; h < c.length; h += 1)
    A[h] = c.charCodeAt(h) ^ v.charCodeAt(h);
  if (A = String.fromCharCode.apply(String, A), A.substr(0, r) !== e(""))
    throw "Hash mismatch";
  A = A.substr(r);
  var g = A.indexOf(""), p = g != -1 ? A.substr(0, g).lastIndexOf("\0") : -1;
  if (p + 1 != g)
    throw "Malformed data";
  return A.substr(g + 1);
}
function RSASetPrivate(n45, t, e) {
  if (this.isPrivate = true, typeof n45 != "string")
    this.n = n45, this.e = t, this.d = e;
  else if (n45 != null && t != null && n45.length > 0 && t.length > 0)
    this.n = parseBigInt(n45, 16), this.e = parseInt(t, 16), this.d = parseBigInt(e, 16);
  else
    throw "Invalid RSA private key";
}
function RSASetPrivateEx(n45, t, e, r, o, s, u, l) {
  if (this.isPrivate = true, this.isPublic = false, n45 == null)
    throw "RSASetPrivateEx N == null";
  if (t == null)
    throw "RSASetPrivateEx E == null";
  if (n45.length == 0)
    throw "RSASetPrivateEx N.length == 0";
  if (t.length == 0)
    throw "RSASetPrivateEx E.length == 0";
  if (n45 != null && t != null && n45.length > 0 && t.length > 0)
    this.n = parseBigInt(n45, 16), this.e = parseInt(t, 16), this.d = parseBigInt(e, 16), this.p = parseBigInt(r, 16), this.q = parseBigInt(o, 16), this.dmp1 = parseBigInt(s, 16), this.dmq1 = parseBigInt(u, 16), this.coeff = parseBigInt(l, 16);
  else
    throw "Invalid RSA private key in RSASetPrivateEx";
}
function RSADoPrivate(n45) {
  if (this.p == null || this.q == null)
    return n45.modPow(this.d, this.n);
  for (var t = n45.mod(this.p).modPow(this.dmp1, this.p), e = n45.mod(this.q).modPow(this.dmq1, this.q); t.compareTo(e) < 0; )
    t = t.add(this.p);
  return t.subtract(e).multiply(this.coeff).mod(this.p).multiply(this.q).add(e);
}
function RSADecrypt(n45) {
  if (n45.length != Math.ceil(this.n.bitLength() / 4))
    throw new Error("wrong ctext length");
  var t = parseBigInt(n45, 16), e = this.doPrivate(t);
  return e == null ? null : pkcs1unpad2(e, this.n.bitLength() + 7 >> 3);
}
function RSADecryptOAEP(n45, t, e) {
  if (n45.length != Math.ceil(this.n.bitLength() / 4))
    throw new Error("wrong ctext length");
  var r = parseBigInt(n45, 16), o = this.doPrivate(r);
  return o == null ? null : oaep_unpad(o, this.n.bitLength() + 7 >> 3, t, e);
}
RSAKey.prototype.doPrivate = RSADoPrivate;
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
(typeof KJUR.lang == "undefined" || !KJUR.lang) && (KJUR.lang = {});
KJUR.lang.String = function() {
};
function b64utob64(n45) {
  return n45.length % 4 == 2 ? n45 = n45 + "==" : n45.length % 4 == 3 && (n45 = n45 + "="), n45 = n45.replace(/-/g, "+"), n45 = n45.replace(/_/g, "/"), n45;
}
function b64utohex(n45) {
  return b64tohex(b64utob64(n45));
}
function hextoutf8(n45) {
  return decodeURIComponent(hextouricmp(n45));
}
function hextorstr(n45) {
  for (var t = "", e = 0; e < n45.length - 1; e += 2)
    t += String.fromCharCode(parseInt(n45.substr(e, 2), 16));
  return t;
}
function rstrtohex(n45) {
  for (var t = "", e = 0; e < n45.length; e++)
    t += ("0" + n45.charCodeAt(e).toString(16)).slice(-2);
  return t;
}
function hextob64(n45) {
  return hex2b64(n45);
}
function hextob64nl(n45) {
  var t = hextob64(n45), e = t.replace(/(.{64})/g, `$1\r
`);
  return e = e.replace(/\r\n$/, ""), e;
}
function b64nltohex(n45) {
  var t = n45.replace(/[^0-9A-Za-z\/+=]*/g, ""), e = b64tohex(t);
  return e;
}
function hextopem(n45, t) {
  var e = hextob64nl(n45);
  return "-----BEGIN " + t + `-----\r
` + e + `\r
-----END ` + t + `-----\r
`;
}
function pemtohex(n45, t) {
  if (n45.indexOf("-----BEGIN ") == -1)
    throw "can't find PEM header: " + t;
  return t !== void 0 ? (n45 = n45.replace(new RegExp("^[^]*-----BEGIN " + t + "-----"), ""), n45 = n45.replace(new RegExp("-----END " + t + "-----[^]*$"), "")) : (n45 = n45.replace(/^[^]*-----BEGIN [^-]+-----/, ""), n45 = n45.replace(/-----END [^-]+-----[^]*$/, "")), b64nltohex(n45);
}
function hextouricmp(n45) {
  return n45.replace(/(..)/g, "%$1");
}
function hextoipv6(n45) {
  if (!n45.match(/^[0-9A-Fa-f]{32}$/))
    throw "malformed IPv6 address octet";
  n45 = n45.toLowerCase();
  for (var t = n45.match(/.{1,4}/g), e = 0; e < 8; e++)
    t[e] = t[e].replace(/^0+/, ""), t[e] == "" && (t[e] = "0");
  n45 = ":" + t.join(":") + ":";
  var r = n45.match(/:(0:){2,}/g);
  if (r === null)
    return n45.slice(1, -1);
  for (var o = "", e = 0; e < r.length; e++)
    r[e].length > o.length && (o = r[e]);
  return n45 = n45.replace(o, "::"), n45.slice(1, -1);
}
function hextoip(n45) {
  var t = "malformed hex value";
  if (!n45.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/))
    throw t;
  if (n45.length == 8) {
    var e;
    try {
      return e = parseInt(n45.substr(0, 2), 16) + "." + parseInt(n45.substr(2, 2), 16) + "." + parseInt(n45.substr(4, 2), 16) + "." + parseInt(n45.substr(6, 2), 16), e;
    } catch (r) {
      throw t;
    }
  } else
    return n45.length == 32 ? hextoipv6(n45) : n45;
}
function ucs2hextoutf8(n45) {
  function t(o) {
    var s = parseInt(o.substr(0, 2), 16), u = parseInt(o.substr(2), 16);
    if (s == 0 & u < 128)
      return String.fromCharCode(u);
    if (s < 8) {
      var l = 192 | (s & 7) << 3 | (u & 192) >> 6, c = 128 | u & 63;
      return hextoutf8(l.toString(16) + c.toString(16));
    }
    var l = 224 | (s & 240) >> 4, c = 128 | (s & 15) << 2 | (u & 192) >> 6, f = 128 | u & 63;
    return hextoutf8(l.toString(16) + c.toString(16) + f.toString(16));
  }
  var e = n45.match(/.{4}/g), r = e.map(t);
  return r.join("");
}
KJUR.lang.String.isHex = function(n45) {
  return ishex(n45);
};
function ishex(n45) {
  return !!(n45.length % 2 == 0 && (n45.match(/^[0-9a-f]+$/) || n45.match(/^[0-9A-F]+$/)));
}
KJUR.lang.String.isMail = function(n45) {
  return n45.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/) !== null;
};
function hextoposhex(n45) {
  return n45.length % 2 == 1 ? "0" + n45 : n45.substr(0, 1) > "7" ? "00" + n45 : n45;
}
function hextooid(n45) {
  if (!ishex(n45))
    return null;
  try {
    var t = [], e = n45.substr(0, 2), r = parseInt(e, 16);
    t[0] = new String(Math.floor(r / 40)), t[1] = new String(r % 40);
    for (var o = n45.substr(2), s = [], u = 0; u < o.length / 2; u++)
      s.push(parseInt(o.substr(u * 2, 2), 16));
    for (var l = [], c = "", u = 0; u < s.length; u++)
      s[u] & 128 ? c = c + strpad((s[u] & 127).toString(2), 7) : (c = c + strpad((s[u] & 127).toString(2), 7), l.push(new String(parseInt(c, 2))), c = "");
    var f = t.join(".");
    return l.length > 0 && (f = f + "." + l.join(".")), f;
  } catch (d) {
    return null;
  }
}
var strpad = function(n45, t, e) {
  return e == null && (e = "0"), n45.length >= t ? n45 : new Array(t - n45.length + 1).join(e) + n45;
};
function bitstrtoint(n45) {
  try {
    var t = n45.substr(0, 2);
    if (t == "00")
      return parseInt(n45.substr(2), 16);
    var e = parseInt(t, 16), r = n45.substr(2), o = parseInt(r, 16).toString(2);
    return o == "0" && (o = "00000000"), o = o.slice(0, 0 - e), parseInt(o, 2);
  } catch (s) {
    return -1;
  }
}
(typeof KJUR.crypto == "undefined" || !KJUR.crypto) && (KJUR.crypto = {});
KJUR.crypto.Util = new function() {
  this.DIGESTINFOHEAD = {
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    ripemd160: "3021300906052b2403020105000414"
  }, this.DEFAULTPROVIDER = {
    md5: "cryptojs",
    sha1: "cryptojs",
    sha224: "cryptojs",
    sha256: "cryptojs",
    sha384: "cryptojs",
    sha512: "cryptojs",
    ripemd160: "cryptojs",
    hmacmd5: "cryptojs",
    hmacsha1: "cryptojs",
    hmacsha224: "cryptojs",
    hmacsha256: "cryptojs",
    hmacsha384: "cryptojs",
    hmacsha512: "cryptojs",
    hmacripemd160: "cryptojs",
    MD5withRSA: "cryptojs/jsrsa",
    SHA1withRSA: "cryptojs/jsrsa",
    SHA224withRSA: "cryptojs/jsrsa",
    SHA256withRSA: "cryptojs/jsrsa",
    SHA384withRSA: "cryptojs/jsrsa",
    SHA512withRSA: "cryptojs/jsrsa",
    RIPEMD160withRSA: "cryptojs/jsrsa",
    MD5withECDSA: "cryptojs/jsrsa",
    SHA1withECDSA: "cryptojs/jsrsa",
    SHA224withECDSA: "cryptojs/jsrsa",
    SHA256withECDSA: "cryptojs/jsrsa",
    SHA384withECDSA: "cryptojs/jsrsa",
    SHA512withECDSA: "cryptojs/jsrsa",
    RIPEMD160withECDSA: "cryptojs/jsrsa",
    SHA1withDSA: "cryptojs/jsrsa",
    SHA224withDSA: "cryptojs/jsrsa",
    SHA256withDSA: "cryptojs/jsrsa",
    MD5withRSAandMGF1: "cryptojs/jsrsa",
    SHAwithRSAandMGF1: "cryptojs/jsrsa",
    SHA1withRSAandMGF1: "cryptojs/jsrsa",
    SHA224withRSAandMGF1: "cryptojs/jsrsa",
    SHA256withRSAandMGF1: "cryptojs/jsrsa",
    SHA384withRSAandMGF1: "cryptojs/jsrsa",
    SHA512withRSAandMGF1: "cryptojs/jsrsa",
    RIPEMD160withRSAandMGF1: "cryptojs/jsrsa"
  }, this.CRYPTOJSMESSAGEDIGESTNAME = {
    md5: CryptoJS.algo.MD5,
    sha1: CryptoJS.algo.SHA1,
    sha224: CryptoJS.algo.SHA224,
    sha256: CryptoJS.algo.SHA256,
    sha384: CryptoJS.algo.SHA384,
    sha512: CryptoJS.algo.SHA512,
    ripemd160: CryptoJS.algo.RIPEMD160
  }, this.hashString = function(n45, t) {
    var e = new KJUR.crypto.MessageDigest({
      alg: t
    });
    return e.digestString(n45);
  }, this.hashHex = function(n45, t) {
    var e = new KJUR.crypto.MessageDigest({
      alg: t
    });
    return e.digestHex(n45);
  }, this.sha1 = function(n45) {
    return this.hashString(n45, "sha1");
  }, this.sha256 = function(n45) {
    return this.hashString(n45, "sha256");
  }, this.sha256Hex = function(n45) {
    return this.hashHex(n45, "sha256");
  }, this.sha512 = function(n45) {
    return this.hashString(n45, "sha512");
  }, this.sha512Hex = function(n45) {
    return this.hashHex(n45, "sha512");
  };
}();
KJUR.crypto.MessageDigest = function(n45) {
  this.setAlgAndProvider = function(t, e) {
    if (t = KJUR.crypto.MessageDigest.getCanonicalAlgName(t), t !== null && e === void 0 && (e = KJUR.crypto.Util.DEFAULTPROVIDER[t]), ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(t) != -1 && e == "cryptojs") {
      try {
        this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[t].create();
      } catch (r) {
        throw "setAlgAndProvider hash alg set fail alg=" + t + "/" + r;
      }
      this.updateString = function(r) {
        this.md.update(r);
      }, this.updateHex = function(r) {
        var o = CryptoJS.enc.Hex.parse(r);
        this.md.update(o);
      }, this.digest = function() {
        var r = this.md.finalize();
        return r.toString(CryptoJS.enc.Hex);
      }, this.digestString = function(r) {
        return this.updateString(r), this.digest();
      }, this.digestHex = function(r) {
        return this.updateHex(r), this.digest();
      };
    }
    if (":sha256:".indexOf(t) != -1 && e == "sjcl") {
      try {
        this.md = new sjcl.hash.sha256();
      } catch (r) {
        throw "setAlgAndProvider hash alg set fail alg=" + t + "/" + r;
      }
      this.updateString = function(r) {
        this.md.update(r);
      }, this.updateHex = function(r) {
        var o = sjcl.codec.hex.toBits(r);
        this.md.update(o);
      }, this.digest = function() {
        var r = this.md.finalize();
        return sjcl.codec.hex.fromBits(r);
      }, this.digestString = function(r) {
        return this.updateString(r), this.digest();
      }, this.digestHex = function(r) {
        return this.updateHex(r), this.digest();
      };
    }
  }, this.updateString = function(t) {
    throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
  }, this.updateHex = function(t) {
    throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
  }, this.digest = function() {
    throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
  }, this.digestString = function(t) {
    throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
  }, this.digestHex = function(t) {
    throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
  }, n45 !== void 0 && n45.alg !== void 0 && (this.algName = n45.alg, n45.prov === void 0 && (this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]), this.setAlgAndProvider(this.algName, this.provName));
};
KJUR.crypto.MessageDigest.getCanonicalAlgName = function(n45) {
  return typeof n45 == "string" && (n45 = n45.toLowerCase(), n45 = n45.replace(/-/, "")), n45;
};
KJUR.crypto.MessageDigest.getHashLength = function(n45) {
  var t = KJUR.crypto.MessageDigest, e = t.getCanonicalAlgName(n45);
  if (t.HASHLENGTH[e] === void 0)
    throw "not supported algorithm: " + n45;
  return t.HASHLENGTH[e];
};
KJUR.crypto.MessageDigest.HASHLENGTH = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  ripemd160: 20
};
KJUR.crypto.Signature = function(n45) {
  var t = null;
  if (this._setAlgNames = function() {
    var e = this.algName.match(/^(.+)with(.+)$/);
    e && (this.mdAlgName = e[1].toLowerCase(), this.pubkeyAlgName = e[2].toLowerCase(), this.pubkeyAlgName == "rsaandmgf1" && this.mdAlgName == "sha" && (this.mdAlgName = "sha1"));
  }, this._zeroPaddingOfSignature = function(e, r) {
    for (var o = "", s = r / 4 - e.length, u = 0; u < s; u++)
      o = o + "0";
    return o + e;
  }, this.setAlgAndProvider = function(e, r) {
    if (this._setAlgNames(), r != "cryptojs/jsrsa")
      throw new Error("provider not supported: " + r);
    if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName) != -1) {
      try {
        this.md = new KJUR.crypto.MessageDigest({
          alg: this.mdAlgName
        });
      } catch (o) {
        throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + o);
      }
      this.init = function(o, s) {
        var u = null;
        try {
          s === void 0 ? u = KEYUTIL.getKey(o) : u = KEYUTIL.getKey(o, s);
        } catch (l) {
          throw "init failed:" + l;
        }
        if (u.isPrivate === true)
          this.prvKey = u, this.state = "SIGN";
        else if (u.isPublic === true)
          this.pubKey = u, this.state = "VERIFY";
        else
          throw "init failed.:" + u;
      }, this.updateString = function(o) {
        this.md.updateString(o);
      }, this.updateHex = function(o) {
        this.md.updateHex(o);
      }, this.verify = function(o) {
        if (this.sHashHex = this.md.digest(), this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1")
          return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, o, this.mdAlgName, this.pssSaltLen);
        if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsa")
          return this.pubKey.verifyWithMessageHash(this.sHashHex, o);
        throw "Signature: unsupported public key alg: " + this.pubkeyAlgName;
      };
    }
  }, this.init = function(e, r) {
    throw "init(key, pass) not supported for this alg:prov=" + this.algProvName;
  }, this.updateString = function(e) {
    throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
  }, this.updateHex = function(e) {
    throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
  }, this.verify = function(e) {
    throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
  }, this.initParams = n45, n45 !== void 0 && (n45.alg !== void 0 && (this.algName = n45.alg, n45.prov === void 0 ? this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName] : this.provName = n45.prov, this.algProvName = this.algName + ":" + this.provName, this.setAlgAndProvider(this.algName, this.provName), this._setAlgNames()), n45.psssaltlen !== void 0 && (this.pssSaltLen = n45.psssaltlen), n45.prvkeypem !== void 0)) {
    if (n45.prvkeypas !== void 0)
      throw "both prvkeypem and prvkeypas parameters not supported";
    try {
      var t = KEYUTIL.getKey(n45.prvkeypem);
      this.init(t);
    } catch (e) {
      throw "fatal error to load pem private key: " + e;
    }
  }
};
KJUR.crypto.OID = new function() {
  this.oidhex2name = {
    "2a864886f70d010101": "rsaEncryption",
    "2a8648ce3d0201": "ecPublicKey",
    "2a8648ce380401": "dsa",
    "2a8648ce3d030107": "secp256r1",
    "2b8104001f": "secp192k1",
    "2b81040021": "secp224r1",
    "2b8104000a": "secp256k1",
    "2b81040023": "secp521r1",
    "2b81040022": "secp384r1",
    "2a8648ce380403": "SHA1withDSA",
    "608648016503040301": "SHA224withDSA",
    "608648016503040302": "SHA256withDSA"
  };
}();
var KEYUTIL = /* @__PURE__ */ function() {
  var n45 = function(g, p, y) {
    return r(CryptoJS.AES, g, p, y);
  }, t = function(g, p, y) {
    return r(CryptoJS.TripleDES, g, p, y);
  }, e = function(g, p, y) {
    return r(CryptoJS.DES, g, p, y);
  }, r = function(g, p, y, m) {
    var E = CryptoJS.enc.Hex.parse(p), b = CryptoJS.enc.Hex.parse(y), T = CryptoJS.enc.Hex.parse(m), R = {};
    R.key = b, R.iv = T, R.ciphertext = E;
    var S = g.decrypt(R, b, {
      iv: T
    });
    return CryptoJS.enc.Hex.stringify(S);
  }, o = function(g, p, y) {
    return l(CryptoJS.AES, g, p, y);
  }, s = function(g, p, y) {
    return l(CryptoJS.TripleDES, g, p, y);
  }, u = function(g, p, y) {
    return l(CryptoJS.DES, g, p, y);
  }, l = function(g, p, y, m) {
    var E = CryptoJS.enc.Hex.parse(p), b = CryptoJS.enc.Hex.parse(y), T = CryptoJS.enc.Hex.parse(m), R = g.encrypt(E, b, {
      iv: T
    }), S = CryptoJS.enc.Hex.parse(R.toString()), M = CryptoJS.enc.Base64.stringify(S);
    return M;
  }, c = {
    "AES-256-CBC": {
      proc: n45,
      eproc: o,
      keylen: 32,
      ivlen: 16
    },
    "AES-192-CBC": {
      proc: n45,
      eproc: o,
      keylen: 24,
      ivlen: 16
    },
    "AES-128-CBC": {
      proc: n45,
      eproc: o,
      keylen: 16,
      ivlen: 16
    },
    "DES-EDE3-CBC": {
      proc: t,
      eproc: s,
      keylen: 24,
      ivlen: 8
    },
    "DES-CBC": {
      proc: e,
      eproc: u,
      keylen: 8,
      ivlen: 8
    }
  }, f = function(g) {
    var p = CryptoJS.lib.WordArray.random(g), y = CryptoJS.enc.Hex.stringify(p);
    return y;
  }, d = function(g) {
    var p = {}, y = g.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
    y && (p.cipher = y[1], p.ivsalt = y[2]);
    var m = g.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
    m && (p.type = m[1]);
    var E = -1, b = 0;
    g.indexOf(`\r
\r
`) != -1 && (E = g.indexOf(`\r
\r
`), b = 2), g.indexOf(`

`) != -1 && (E = g.indexOf(`

`), b = 1);
    var T = g.indexOf("-----END");
    if (E != -1 && T != -1) {
      var R = g.substring(E + b * 2, T - b);
      R = R.replace(/\s+/g, ""), p.data = R;
    }
    return p;
  }, h = function(g, p, y) {
    for (var m = y.substring(0, 16), E = CryptoJS.enc.Hex.parse(m), b = CryptoJS.enc.Utf8.parse(p), T = c[g].keylen + c[g].ivlen, R = "", S = null; ; ) {
      var M = CryptoJS.algo.MD5.create();
      if (S != null && M.update(S), M.update(b), M.update(E), S = M.finalize(), R = R + CryptoJS.enc.Hex.stringify(S), R.length >= T * 2)
        break;
    }
    var w = {};
    return w.keyhex = R.substr(0, c[g].keylen * 2), w.ivhex = R.substr(c[g].keylen * 2, c[g].ivlen * 2), w;
  }, v = function(g, p, y, m) {
    var E = CryptoJS.enc.Base64.parse(g), b = CryptoJS.enc.Hex.stringify(E), T = c[p].proc, R = T(b, y, m);
    return R;
  }, A = function(g, p, y, m) {
    var E = c[p].eproc, b = E(g, y, m);
    return b;
  };
  return {
    version: "1.0.0",
    parsePKCS5PEM: function(g) {
      return d(g);
    },
    getKeyAndUnusedIvByPasscodeAndIvsalt: function(g, p, y) {
      return h(g, p, y);
    },
    decryptKeyB64: function(g, p, y, m) {
      return v(g, p, y, m);
    },
    getDecryptedKeyHex: function(g, p) {
      var y = d(g), m = y.cipher, E = y.ivsalt, b = y.data, T = h(m, p, E), R = T.keyhex, S = v(b, m, R, E);
      return S;
    },
    getEncryptedPKCS5PEMFromPrvKeyHex: function(g, p, y, m, E) {
      var H = "";
      if ((typeof m == "undefined" || m == null) && (m = "AES-256-CBC"), typeof c[m] == "undefined")
        throw "KEYUTIL unsupported algorithm: " + m;
      if (typeof E == "undefined" || E == null) {
        var b = c[m].ivlen, T = f(b);
        E = T.toUpperCase();
      }
      var R = h(m, y, E), S = R.keyhex, M = A(p, m, S, E), w = M.replace(/(.{64})/g, `$1\r
`), H = "-----BEGIN " + g + ` PRIVATE KEY-----\r
`;
      return H += `Proc-Type: 4,ENCRYPTED\r
`, H += "DEK-Info: " + m + "," + E + `\r
`, H += `\r
`, H += w, H += `\r
-----END ` + g + ` PRIVATE KEY-----\r
`, H;
    },
    parseHexOfEncryptedPKCS8: function(g) {
      var p = ASN1HEX, y = p.getChildIdx, m = p.getV, E = {}, b = y(g, 0);
      if (b.length != 2)
        throw "malformed format: SEQUENCE(0).items != 2: " + b.length;
      E.ciphertext = m(g, b[1]);
      var T = y(g, b[0]);
      if (T.length != 2)
        throw "malformed format: SEQUENCE(0.0).items != 2: " + T.length;
      if (m(g, T[0]) != "2a864886f70d01050d")
        throw "this only supports pkcs5PBES2";
      var R = y(g, T[1]);
      if (T.length != 2)
        throw "malformed format: SEQUENCE(0.0.1).items != 2: " + R.length;
      var S = y(g, R[1]);
      if (S.length != 2)
        throw "malformed format: SEQUENCE(0.0.1.1).items != 2: " + S.length;
      if (m(g, S[0]) != "2a864886f70d0307")
        throw "this only supports TripleDES";
      E.encryptionSchemeAlg = "TripleDES", E.encryptionSchemeIV = m(g, S[1]);
      var M = y(g, R[0]);
      if (M.length != 2)
        throw "malformed format: SEQUENCE(0.0.1.0).items != 2: " + M.length;
      if (m(g, M[0]) != "2a864886f70d01050c")
        throw "this only supports pkcs5PBKDF2";
      var w = y(g, M[1]);
      if (w.length < 2)
        throw "malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + w.length;
      E.pbkdf2Salt = m(g, w[0]);
      var H = m(g, w[1]);
      try {
        E.pbkdf2Iter = parseInt(H, 16);
      } catch (L) {
        throw "malformed format pbkdf2Iter: " + H;
      }
      return E;
    },
    getPBKDF2KeyHexFromParam: function(g, p) {
      var y = CryptoJS.enc.Hex.parse(g.pbkdf2Salt), m = g.pbkdf2Iter, E = CryptoJS.PBKDF2(p, y, {
        keySize: 192 / 32,
        iterations: m
      }), b = CryptoJS.enc.Hex.stringify(E);
      return b;
    },
    _getPlainPKCS8HexFromEncryptedPKCS8PEM: function(g, p) {
      var y = pemtohex(g, "ENCRYPTED PRIVATE KEY"), m = this.parseHexOfEncryptedPKCS8(y), E = KEYUTIL.getPBKDF2KeyHexFromParam(m, p), b = {};
      b.ciphertext = CryptoJS.enc.Hex.parse(m.ciphertext);
      var T = CryptoJS.enc.Hex.parse(E), R = CryptoJS.enc.Hex.parse(m.encryptionSchemeIV), S = CryptoJS.TripleDES.decrypt(b, T, {
        iv: R
      }), M = CryptoJS.enc.Hex.stringify(S);
      return M;
    },
    getKeyFromEncryptedPKCS8PEM: function(g, p) {
      var y = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(g, p), m = this.getKeyFromPlainPrivatePKCS8Hex(y);
      return m;
    },
    parsePlainPrivatePKCS8Hex: function(g) {
      var p = ASN1HEX, y = p.getChildIdx, m = p.getV, E = {};
      if (E.algparam = null, g.substr(0, 2) != "30")
        throw new Error("malformed plain PKCS8 private key(code:001)");
      var b = y(g, 0);
      if (b.length < 3)
        throw new Error("malformed plain PKCS8 private key(code:002)");
      if (g.substr(b[1], 2) != "30")
        throw new Error("malformed PKCS8 private key(code:003)");
      var T = y(g, b[1]);
      if (T.length != 2)
        throw new Error("malformed PKCS8 private key(code:004)");
      if (g.substr(T[0], 2) != "06")
        throw new Error("malformed PKCS8 private key(code:005)");
      if (E.algoid = m(g, T[0]), g.substr(T[1], 2) == "06" && (E.algparam = m(g, T[1])), g.substr(b[2], 2) != "04")
        throw new Error("malformed PKCS8 private key(code:006)");
      return E.keyidx = p.getVidx(g, b[2]), E;
    },
    getKeyFromPlainPrivatePKCS8PEM: function(g) {
      var p = pemtohex(g, "PRIVATE KEY"), y = this.getKeyFromPlainPrivatePKCS8Hex(p);
      return y;
    },
    getKeyFromPlainPrivatePKCS8Hex: function(g) {
      var p = this.parsePlainPrivatePKCS8Hex(g), y;
      if (p.algoid == "2a864886f70d010101")
        y = new RSAKey();
      else if (KJUR.crypto.DSA && p.algoid == "2a8648ce380401")
        y = new KJUR.crypto.DSA();
      else if (KJUR.crypto.ECDSA && p.algoid == "2a8648ce3d0201")
        y = new KJUR.crypto.ECDSA();
      else
        throw "unsupported private key algorithm";
      return y.readPKCS8PrvKeyHex(g), y;
    },
    _getKeyFromPublicPKCS8Hex: function(g) {
      var p, y = ASN1HEX.getVbyList(g, 0, [0, 0], "06");
      if (y === "2a864886f70d010101")
        p = new RSAKey();
      else if (KJUR.crypto.DSA && y === "2a8648ce380401")
        p = new KJUR.crypto.DSA();
      else if (KJUR.crypto.ECDSA && y === "2a8648ce3d0201")
        p = new KJUR.crypto.ECDSA();
      else
        throw "unsupported PKCS#8 public key hex";
      return p.readPKCS8PubKeyHex(g), p;
    },
    parsePublicRawRSAKeyHex: function(g) {
      var p = ASN1HEX, y = p.getChildIdx, m = p.getV, E = {};
      if (g.substr(0, 2) != "30")
        throw "malformed RSA key(code:001)";
      var b = y(g, 0);
      if (b.length != 2)
        throw "malformed RSA key(code:002)";
      if (g.substr(b[0], 2) != "02")
        throw "malformed RSA key(code:003)";
      if (E.n = m(g, b[0]), g.substr(b[1], 2) != "02")
        throw "malformed RSA key(code:004)";
      return E.e = m(g, b[1]), E;
    },
    parsePublicPKCS8Hex: function(g) {
      var p = ASN1HEX, y = p.getChildIdx, m = p.getV, E = {};
      E.algparam = null;
      var b = y(g, 0);
      if (b.length != 2)
        throw "outer DERSequence shall have 2 elements: " + b.length;
      var T = b[0];
      if (g.substr(T, 2) != "30")
        throw "malformed PKCS8 public key(code:001)";
      var R = y(g, T);
      if (R.length != 2)
        throw "malformed PKCS8 public key(code:002)";
      if (g.substr(R[0], 2) != "06")
        throw "malformed PKCS8 public key(code:003)";
      if (E.algoid = m(g, R[0]), g.substr(R[1], 2) == "06" ? E.algparam = m(g, R[1]) : g.substr(R[1], 2) == "30" && (E.algparam = {}, E.algparam.p = p.getVbyList(g, R[1], [0], "02"), E.algparam.q = p.getVbyList(g, R[1], [1], "02"), E.algparam.g = p.getVbyList(g, R[1], [2], "02")), g.substr(b[1], 2) != "03")
        throw "malformed PKCS8 public key(code:004)";
      return E.key = m(g, b[1]).substr(2), E;
    }
  };
}();
KEYUTIL.getKey = function(n45, t, e) {
  var r = ASN1HEX, o = r.getChildIdx;
  r.getV;
  var s = r.getVbyList, u = KJUR.crypto, l = u.ECDSA, c = u.DSA, f = RSAKey, d = pemtohex, h = KEYUTIL;
  if (typeof f != "undefined" && n45 instanceof f || typeof l != "undefined" && n45 instanceof l || typeof c != "undefined" && n45 instanceof c)
    return n45;
  if (n45.curve !== void 0 && n45.xy !== void 0 && n45.d === void 0)
    return new l({
      pub: n45.xy,
      curve: n45.curve
    });
  if (n45.curve !== void 0 && n45.d !== void 0)
    return new l({
      prv: n45.d,
      curve: n45.curve
    });
  if (n45.kty === void 0 && n45.n !== void 0 && n45.e !== void 0 && n45.d === void 0) {
    var v = new f();
    return v.setPublic(n45.n, n45.e), v;
  }
  if (n45.kty === void 0 && n45.n !== void 0 && n45.e !== void 0 && n45.d !== void 0 && n45.p !== void 0 && n45.q !== void 0 && n45.dp !== void 0 && n45.dq !== void 0 && n45.co !== void 0 && n45.qi === void 0) {
    var v = new f();
    return v.setPrivateEx(n45.n, n45.e, n45.d, n45.p, n45.q, n45.dp, n45.dq, n45.co), v;
  }
  if (n45.kty === void 0 && n45.n !== void 0 && n45.e !== void 0 && n45.d !== void 0 && n45.p === void 0) {
    var v = new f();
    return v.setPrivate(n45.n, n45.e, n45.d), v;
  }
  if (n45.p !== void 0 && n45.q !== void 0 && n45.g !== void 0 && n45.y !== void 0 && n45.x === void 0) {
    var v = new c();
    return v.setPublic(n45.p, n45.q, n45.g, n45.y), v;
  }
  if (n45.p !== void 0 && n45.q !== void 0 && n45.g !== void 0 && n45.y !== void 0 && n45.x !== void 0) {
    var v = new c();
    return v.setPrivate(n45.p, n45.q, n45.g, n45.y, n45.x), v;
  }
  if (n45.kty === "RSA" && n45.n !== void 0 && n45.e !== void 0 && n45.d === void 0) {
    var v = new f();
    return v.setPublic(b64utohex(n45.n), b64utohex(n45.e)), v;
  }
  if (n45.kty === "RSA" && n45.n !== void 0 && n45.e !== void 0 && n45.d !== void 0 && n45.p !== void 0 && n45.q !== void 0 && n45.dp !== void 0 && n45.dq !== void 0 && n45.qi !== void 0) {
    var v = new f();
    return v.setPrivateEx(b64utohex(n45.n), b64utohex(n45.e), b64utohex(n45.d), b64utohex(n45.p), b64utohex(n45.q), b64utohex(n45.dp), b64utohex(n45.dq), b64utohex(n45.qi)), v;
  }
  if (n45.kty === "RSA" && n45.n !== void 0 && n45.e !== void 0 && n45.d !== void 0) {
    var v = new f();
    return v.setPrivate(b64utohex(n45.n), b64utohex(n45.e), b64utohex(n45.d)), v;
  }
  if (n45.kty === "EC" && n45.crv !== void 0 && n45.x !== void 0 && n45.y !== void 0 && n45.d === void 0) {
    var A = new l({
      curve: n45.crv
    }), g = A.ecparams.keylen / 4, p = ("0000000000" + b64utohex(n45.x)).slice(-g), y = ("0000000000" + b64utohex(n45.y)).slice(-g), m = "04" + p + y;
    return A.setPublicKeyHex(m), A;
  }
  if (n45.kty === "EC" && n45.crv !== void 0 && n45.x !== void 0 && n45.y !== void 0 && n45.d !== void 0) {
    var A = new l({
      curve: n45.crv
    }), g = A.ecparams.keylen / 4, p = ("0000000000" + b64utohex(n45.x)).slice(-g), y = ("0000000000" + b64utohex(n45.y)).slice(-g), m = "04" + p + y, E = ("0000000000" + b64utohex(n45.d)).slice(-g);
    return A.setPublicKeyHex(m), A.setPrivateKeyHex(E), A;
  }
  if (e === "pkcs5prv") {
    var b = n45, r = ASN1HEX, T, v;
    if (T = o(b, 0), T.length === 9)
      v = new f(), v.readPKCS5PrvKeyHex(b);
    else if (T.length === 6)
      v = new c(), v.readPKCS5PrvKeyHex(b);
    else if (T.length > 2 && b.substr(T[1], 2) === "04")
      v = new l(), v.readPKCS5PrvKeyHex(b);
    else
      throw "unsupported PKCS#1/5 hexadecimal key";
    return v;
  }
  if (e === "pkcs8prv") {
    var v = h.getKeyFromPlainPrivatePKCS8Hex(n45);
    return v;
  }
  if (e === "pkcs8pub")
    return h._getKeyFromPublicPKCS8Hex(n45);
  if (e === "x509pub")
    return X509.getPublicKeyFromCertHex(n45);
  if (n45.indexOf("-END CERTIFICATE-", 0) != -1 || n45.indexOf("-END X509 CERTIFICATE-", 0) != -1 || n45.indexOf("-END TRUSTED CERTIFICATE-", 0) != -1)
    return X509.getPublicKeyFromCertPEM(n45);
  if (n45.indexOf("-END PUBLIC KEY-") != -1) {
    var R = pemtohex(n45, "PUBLIC KEY");
    return h._getKeyFromPublicPKCS8Hex(R);
  }
  if (n45.indexOf("-END RSA PRIVATE KEY-") != -1 && n45.indexOf("4,ENCRYPTED") == -1) {
    var S = d(n45, "RSA PRIVATE KEY");
    return h.getKey(S, null, "pkcs5prv");
  }
  if (n45.indexOf("-END DSA PRIVATE KEY-") != -1 && n45.indexOf("4,ENCRYPTED") == -1) {
    var M = d(n45, "DSA PRIVATE KEY"), w = s(M, 0, [1], "02"), H = s(M, 0, [2], "02"), L = s(M, 0, [3], "02"), C = s(M, 0, [4], "02"), I = s(M, 0, [5], "02"), v = new c();
    return v.setPrivate(new BigInteger(w, 16), new BigInteger(H, 16), new BigInteger(L, 16), new BigInteger(C, 16), new BigInteger(I, 16)), v;
  }
  if (n45.indexOf("-END EC PRIVATE KEY-") != -1 && n45.indexOf("4,ENCRYPTED") == -1) {
    var S = d(n45, "EC PRIVATE KEY");
    return h.getKey(S, null, "pkcs5prv");
  }
  if (n45.indexOf("-END PRIVATE KEY-") != -1)
    return h.getKeyFromPlainPrivatePKCS8PEM(n45);
  if (n45.indexOf("-END RSA PRIVATE KEY-") != -1 && n45.indexOf("4,ENCRYPTED") != -1) {
    var _ = h.getDecryptedKeyHex(n45, t), O = new RSAKey();
    return O.readPKCS5PrvKeyHex(_), O;
  }
  if (n45.indexOf("-END EC PRIVATE KEY-") != -1 && n45.indexOf("4,ENCRYPTED") != -1) {
    var M = h.getDecryptedKeyHex(n45, t), v = s(M, 0, [1], "04"), P = s(M, 0, [2, 0], "06"), N = s(M, 0, [3, 0], "03").substr(2), k = "";
    if (KJUR.crypto.OID.oidhex2name[P] !== void 0)
      k = KJUR.crypto.OID.oidhex2name[P];
    else
      throw "undefined OID(hex) in KJUR.crypto.OID: " + P;
    var A = new l({
      curve: k
    });
    return A.setPublicKeyHex(N), A.setPrivateKeyHex(v), A.isPublic = false, A;
  }
  if (n45.indexOf("-END DSA PRIVATE KEY-") != -1 && n45.indexOf("4,ENCRYPTED") != -1) {
    var M = h.getDecryptedKeyHex(n45, t), w = s(M, 0, [1], "02"), H = s(M, 0, [2], "02"), L = s(M, 0, [3], "02"), C = s(M, 0, [4], "02"), I = s(M, 0, [5], "02"), v = new c();
    return v.setPrivate(new BigInteger(w, 16), new BigInteger(H, 16), new BigInteger(L, 16), new BigInteger(C, 16), new BigInteger(I, 16)), v;
  }
  if (n45.indexOf("-END ENCRYPTED PRIVATE KEY-") != -1)
    return h.getKeyFromEncryptedPKCS8PEM(n45, t);
  throw new Error("not supported argument");
};
(typeof KJUR.asn1 == "undefined" || !KJUR.asn1) && (KJUR.asn1 = {});
KJUR.asn1.ASN1Util = {};
KJUR.asn1.ASN1Util.oidHexToInt = function(n45) {
  for (var o = "", t = parseInt(n45.substr(0, 2), 16), e = Math.floor(t / 40), r = t % 40, o = e + "." + r, s = "", u = 2; u < n45.length; u += 2) {
    var l = parseInt(n45.substr(u, 2), 16), c = ("00000000" + l.toString(2)).slice(-8);
    if (s = s + c.substr(1, 7), c.substr(0, 1) == "0") {
      var f = new BigInteger(s, 2);
      o = o + "." + f.toString(10), s = "";
    }
  }
  return o;
};
var ASN1HEX = new function() {
}();
ASN1HEX.getLblen = function(n45, t) {
  if (n45.substr(t + 2, 1) != "8")
    return 1;
  var e = parseInt(n45.substr(t + 3, 1));
  return e == 0 ? -1 : 0 < e && e < 10 ? e + 1 : -2;
};
ASN1HEX.getL = function(n45, t) {
  var e = ASN1HEX.getLblen(n45, t);
  return e < 1 ? "" : n45.substr(t + 2, e * 2);
};
ASN1HEX.getVblen = function(n45, t) {
  var e, r;
  return e = ASN1HEX.getL(n45, t), e == "" ? -1 : (e.substr(0, 1) === "8" ? r = new BigInteger(e.substr(2), 16) : r = new BigInteger(e, 16), r.intValue());
};
ASN1HEX.getVidx = function(n45, t) {
  var e = ASN1HEX.getLblen(n45, t);
  return e < 0 ? e : t + (e + 1) * 2;
};
ASN1HEX.getV = function(n45, t) {
  var e = ASN1HEX.getVidx(n45, t), r = ASN1HEX.getVblen(n45, t);
  return n45.substr(e, r * 2);
};
ASN1HEX.getTLV = function(n45, t) {
  return n45.substr(t, 2) + ASN1HEX.getL(n45, t) + ASN1HEX.getV(n45, t);
};
ASN1HEX.getTLVblen = function(n45, t) {
  return 2 + ASN1HEX.getLblen(n45, t) * 2 + ASN1HEX.getVblen(n45, t) * 2;
};
ASN1HEX.getNextSiblingIdx = function(n45, t) {
  var e = ASN1HEX.getVidx(n45, t), r = ASN1HEX.getVblen(n45, t);
  return e + r * 2;
};
ASN1HEX.getChildIdx = function(n45, t) {
  var e = ASN1HEX, r = [], o, s, u;
  o = e.getVidx(n45, t), s = e.getVblen(n45, t) * 2, n45.substr(t, 2) == "03" && (o += 2, s -= 2), u = 0;
  for (var l = o; u <= s; ) {
    var c = e.getTLVblen(n45, l);
    if (u += c, u <= s && r.push(l), l += c, u >= s)
      break;
  }
  return r;
};
ASN1HEX.getNthChildIdx = function(n45, t, e) {
  var r = ASN1HEX.getChildIdx(n45, t);
  return r[e];
};
ASN1HEX.getIdxbyList = function(n45, t, e, r) {
  var o = ASN1HEX, s, u;
  return e.length == 0 ? r !== void 0 && n45.substr(t, 2) !== r ? -1 : t : (s = e.shift(), u = o.getChildIdx(n45, t), s >= u.length ? -1 : o.getIdxbyList(n45, u[s], e, r));
};
ASN1HEX.getIdxbyListEx = function(n45, t, e, r) {
  var o = ASN1HEX, s, u;
  if (e.length == 0)
    return r !== void 0 && n45.substr(t, 2) !== r ? -1 : t;
  s = e.shift(), u = o.getChildIdx(n45, t);
  for (var l = 0, c = 0; c < u.length; c++) {
    var f = n45.substr(u[c], 2);
    if (typeof s == "number" && !o.isContextTag(f) && l == s || typeof s == "string" && o.isContextTag(f, s))
      return o.getIdxbyListEx(n45, u[c], e, r);
    o.isContextTag(f) || l++;
  }
  return -1;
};
ASN1HEX.getTLVbyList = function(n45, t, e, r) {
  var o = ASN1HEX, s = o.getIdxbyList(n45, t, e, r);
  return s == -1 || s >= n45.length ? null : o.getTLV(n45, s);
};
ASN1HEX.getTLVbyListEx = function(n45, t, e, r) {
  var o = ASN1HEX, s = o.getIdxbyListEx(n45, t, e, r);
  return s == -1 ? null : o.getTLV(n45, s);
};
ASN1HEX.getVbyList = function(n45, t, e, r, o) {
  var s = ASN1HEX, u, l;
  return u = s.getIdxbyList(n45, t, e, r), u == -1 || u >= n45.length ? null : (l = s.getV(n45, u), o === true && (l = l.substr(2)), l);
};
ASN1HEX.getVbyListEx = function(n45, t, e, r, o) {
  var s = ASN1HEX, u, l;
  return u = s.getIdxbyListEx(n45, t, e, r), u == -1 ? null : (l = s.getV(n45, u), n45.substr(u, 2) == "03" && o !== false && (l = l.substr(2)), l);
};
ASN1HEX.getInt = function(n45, t, e) {
  e == null && (e = -1);
  try {
    var r = n45.substr(t, 2);
    if (r != "02" && r != "03")
      return e;
    var o = ASN1HEX.getV(n45, t);
    return r == "02" ? parseInt(o, 16) : bitstrtoint(o);
  } catch (s) {
    return e;
  }
};
ASN1HEX.getOID = function(n45, t, e) {
  e == null && (e = null);
  try {
    if (n45.substr(t, 2) != "06")
      return e;
    var r = ASN1HEX.getV(n45, t);
    return hextooid(r);
  } catch (o) {
    return e;
  }
};
ASN1HEX.getOIDName = function(n45, t, e) {
  e == null && (e = null);
  try {
    var r = ASN1HEX.getOID(n45, t, e);
    if (r == e)
      return e;
    var o = KJUR.asn1.x509.OID.oid2name(r);
    return o == "" ? r : o;
  } catch (s) {
    return e;
  }
};
ASN1HEX.getString = function(n45, t, e) {
  e == null && (e = null);
  try {
    var r = ASN1HEX.getV(n45, t);
    return hextorstr(r);
  } catch (o) {
    return e;
  }
};
ASN1HEX.hextooidstr = function(n45) {
  var t = function(h, v) {
    return h.length >= v ? h : new Array(v - h.length + 1).join("0") + h;
  }, e = [], r = n45.substr(0, 2), o = parseInt(r, 16);
  e[0] = new String(Math.floor(o / 40)), e[1] = new String(o % 40);
  for (var s = n45.substr(2), u = [], l = 0; l < s.length / 2; l++)
    u.push(parseInt(s.substr(l * 2, 2), 16));
  for (var c = [], f = "", l = 0; l < u.length; l++)
    u[l] & 128 ? f = f + t((u[l] & 127).toString(2), 7) : (f = f + t((u[l] & 127).toString(2), 7), c.push(new String(parseInt(f, 2))), f = "");
  var d = e.join(".");
  return c.length > 0 && (d = d + "." + c.join(".")), d;
};
ASN1HEX.isContextTag = function(n45, t) {
  n45 = n45.toLowerCase();
  var e, r;
  try {
    e = parseInt(n45, 16);
  } catch (s) {
    return -1;
  }
  if (t === void 0)
    return (e & 192) == 128;
  try {
    var o = t.match(/^\[[0-9]+\]$/);
    return o == null || (r = parseInt(t.substr(1, t.length - 1), 10), r > 31) ? false : (e & 192) == 128 && (e & 31) == r;
  } catch (s) {
    return false;
  }
};
ASN1HEX.isASN1HEX = function(n45) {
  var t = ASN1HEX;
  if (n45.length % 2 == 1)
    return false;
  var e = t.getVblen(n45, 0), r = n45.substr(0, 2), o = t.getL(n45, 0), s = n45.length - r.length - o.length;
  return s == e * 2;
};
ASN1HEX.checkStrictDER = function(n45, t, e, r, o) {
  var s = ASN1HEX;
  if (e === void 0) {
    if (typeof n45 != "string")
      throw new Error("not hex string");
    if (n45 = n45.toLowerCase(), !KJUR.lang.String.isHex(n45))
      throw new Error("not hex string");
    e = n45.length, r = n45.length / 2, r < 128 ? o = 1 : o = Math.ceil(r.toString(16)) + 1;
  }
  var u = s.getL(n45, t);
  if (u.length > o * 2)
    throw new Error("L of TLV too long: idx=" + t);
  var l = s.getVblen(n45, t);
  if (l > r)
    throw new Error("value of L too long than hex: idx=" + t);
  var c = s.getTLV(n45, t), f = c.length - 2 - s.getL(n45, t).length;
  if (f !== l * 2)
    throw new Error("V string length and L's value not the same:" + f + "/" + l * 2);
  if (t === 0 && n45.length != c.length)
    throw new Error("total length and TLV length unmatch:" + n45.length + "!=" + c.length);
  var d = n45.substr(t, 2);
  if (d === "02") {
    var h = s.getVidx(n45, t);
    if (n45.substr(h, 2) == "00" && n45.charCodeAt(h + 2) < 56)
      throw new Error("not least zeros for DER INTEGER");
  }
  if (parseInt(d, 16) & 32) {
    for (var v = s.getVblen(n45, t), A = 0, g = s.getChildIdx(n45, t), p = 0; p < g.length; p++) {
      var y = s.getTLV(n45, g[p]);
      A += y.length, s.checkStrictDER(n45, g[p], e, r, o);
    }
    if (v * 2 != A)
      throw new Error("sum of children's TLV length and L unmatch: " + v * 2 + "!=" + A);
  }
};
ASN1HEX.oidname = function(n45) {
  var t = KJUR.asn1;
  KJUR.lang.String.isHex(n45) && (n45 = t.ASN1Util.oidHexToInt(n45));
  var e = t.x509.OID.oid2name(n45);
  return e === "" && (e = n45), e;
};
(typeof KJUR.asn1 == "undefined" || !KJUR.asn1) && (KJUR.asn1 = {});
(typeof KJUR.asn1.x509 == "undefined" || !KJUR.asn1.x509) && (KJUR.asn1.x509 = {});
KJUR.asn1.x509.AlgorithmIdentifier = {};
KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = {
  SHAwithRSAandMGF1: "300d06092a864886f70d01010a3000",
  SHA256withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120",
  SHA384withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130",
  SHA512withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140"
};
KJUR.asn1.x509.OID = new function(n45) {
  this.atype2oidList = {
    CN: "2.5.4.3",
    L: "2.5.4.7",
    ST: "2.5.4.8",
    O: "2.5.4.10",
    OU: "2.5.4.11",
    C: "2.5.4.6",
    STREET: "2.5.4.9",
    DC: "0.9.2342.19200300.100.1.25",
    UID: "0.9.2342.19200300.100.1.1",
    SN: "2.5.4.4",
    T: "2.5.4.12",
    DN: "2.5.4.49",
    E: "1.2.840.113549.1.9.1",
    description: "2.5.4.13",
    businessCategory: "2.5.4.15",
    postalCode: "2.5.4.17",
    serialNumber: "2.5.4.5",
    uniqueIdentifier: "2.5.4.45",
    organizationIdentifier: "2.5.4.97",
    jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
    jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
    jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3"
  }, this.name2oidList = {
    sha1: "1.3.14.3.2.26",
    sha256: "2.16.840.1.101.3.4.2.1",
    sha384: "2.16.840.1.101.3.4.2.2",
    sha512: "2.16.840.1.101.3.4.2.3",
    sha224: "2.16.840.1.101.3.4.2.4",
    md5: "1.2.840.113549.2.5",
    md2: "1.3.14.7.2.2.1",
    ripemd160: "1.3.36.3.2.1",
    MD2withRSA: "1.2.840.113549.1.1.2",
    MD4withRSA: "1.2.840.113549.1.1.3",
    MD5withRSA: "1.2.840.113549.1.1.4",
    SHA1withRSA: "1.2.840.113549.1.1.5",
    "pkcs1-MGF": "1.2.840.113549.1.1.8",
    rsaPSS: "1.2.840.113549.1.1.10",
    SHA224withRSA: "1.2.840.113549.1.1.14",
    SHA256withRSA: "1.2.840.113549.1.1.11",
    SHA384withRSA: "1.2.840.113549.1.1.12",
    SHA512withRSA: "1.2.840.113549.1.1.13",
    SHA1withECDSA: "1.2.840.10045.4.1",
    SHA224withECDSA: "1.2.840.10045.4.3.1",
    SHA256withECDSA: "1.2.840.10045.4.3.2",
    SHA384withECDSA: "1.2.840.10045.4.3.3",
    SHA512withECDSA: "1.2.840.10045.4.3.4",
    dsa: "1.2.840.10040.4.1",
    SHA1withDSA: "1.2.840.10040.4.3",
    SHA224withDSA: "2.16.840.1.101.3.4.3.1",
    SHA256withDSA: "2.16.840.1.101.3.4.3.2",
    rsaEncryption: "1.2.840.113549.1.1.1",
    commonName: "2.5.4.3",
    countryName: "2.5.4.6",
    localityName: "2.5.4.7",
    stateOrProvinceName: "2.5.4.8",
    streetAddress: "2.5.4.9",
    organizationName: "2.5.4.10",
    organizationalUnitName: "2.5.4.11",
    domainComponent: "0.9.2342.19200300.100.1.25",
    userId: "0.9.2342.19200300.100.1.1",
    surname: "2.5.4.4",
    givenName: "2.5.4.42",
    title: "2.5.4.12",
    distinguishedName: "2.5.4.49",
    emailAddress: "1.2.840.113549.1.9.1",
    description: "2.5.4.13",
    businessCategory: "2.5.4.15",
    postalCode: "2.5.4.17",
    uniqueIdentifier: "2.5.4.45",
    organizationIdentifier: "2.5.4.97",
    jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
    jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
    jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3",
    subjectDirectoryAttributes: "2.5.29.9",
    subjectKeyIdentifier: "2.5.29.14",
    keyUsage: "2.5.29.15",
    subjectAltName: "2.5.29.17",
    issuerAltName: "2.5.29.18",
    basicConstraints: "2.5.29.19",
    cRLNumber: "2.5.29.20",
    cRLReason: "2.5.29.21",
    nameConstraints: "2.5.29.30",
    cRLDistributionPoints: "2.5.29.31",
    certificatePolicies: "2.5.29.32",
    anyPolicy: "2.5.29.32.0",
    authorityKeyIdentifier: "2.5.29.35",
    policyConstraints: "2.5.29.36",
    extKeyUsage: "2.5.29.37",
    authorityInfoAccess: "1.3.6.1.5.5.7.1.1",
    ocsp: "1.3.6.1.5.5.7.48.1",
    ocspBasic: "1.3.6.1.5.5.7.48.1.1",
    ocspNonce: "1.3.6.1.5.5.7.48.1.2",
    ocspNoCheck: "1.3.6.1.5.5.7.48.1.5",
    caIssuers: "1.3.6.1.5.5.7.48.2",
    anyExtendedKeyUsage: "2.5.29.37.0",
    serverAuth: "1.3.6.1.5.5.7.3.1",
    clientAuth: "1.3.6.1.5.5.7.3.2",
    codeSigning: "1.3.6.1.5.5.7.3.3",
    emailProtection: "1.3.6.1.5.5.7.3.4",
    timeStamping: "1.3.6.1.5.5.7.3.8",
    ocspSigning: "1.3.6.1.5.5.7.3.9",
    dateOfBirth: "1.3.6.1.5.5.7.9.1",
    placeOfBirth: "1.3.6.1.5.5.7.9.2",
    gender: "1.3.6.1.5.5.7.9.3",
    countryOfCitizenship: "1.3.6.1.5.5.7.9.4",
    countryOfResidence: "1.3.6.1.5.5.7.9.5",
    ecPublicKey: "1.2.840.10045.2.1",
    "P-256": "1.2.840.10045.3.1.7",
    secp256r1: "1.2.840.10045.3.1.7",
    secp256k1: "1.3.132.0.10",
    secp384r1: "1.3.132.0.34",
    pkcs5PBES2: "1.2.840.113549.1.5.13",
    pkcs5PBKDF2: "1.2.840.113549.1.5.12",
    "des-EDE3-CBC": "1.2.840.113549.3.7",
    data: "1.2.840.113549.1.7.1",
    "signed-data": "1.2.840.113549.1.7.2",
    "enveloped-data": "1.2.840.113549.1.7.3",
    "digested-data": "1.2.840.113549.1.7.5",
    "encrypted-data": "1.2.840.113549.1.7.6",
    "authenticated-data": "1.2.840.113549.1.9.16.1.2",
    tstinfo: "1.2.840.113549.1.9.16.1.4",
    signingCertificate: "1.2.840.113549.1.9.16.2.12",
    timeStampToken: "1.2.840.113549.1.9.16.2.14",
    signaturePolicyIdentifier: "1.2.840.113549.1.9.16.2.15",
    etsArchiveTimeStamp: "1.2.840.113549.1.9.16.2.27",
    signingCertificateV2: "1.2.840.113549.1.9.16.2.47",
    etsArchiveTimeStampV2: "1.2.840.113549.1.9.16.2.48",
    extensionRequest: "1.2.840.113549.1.9.14",
    contentType: "1.2.840.113549.1.9.3",
    messageDigest: "1.2.840.113549.1.9.4",
    signingTime: "1.2.840.113549.1.9.5",
    counterSignature: "1.2.840.113549.1.9.6",
    archiveTimeStampV3: "0.4.0.1733.2.4",
    pdfRevocationInfoArchival: "1.2.840.113583.1.1.8",
    adobeTimeStamp: "1.2.840.113583.1.1.9.1"
  }, this.objCache = {}, this.name2obj = function(t) {
    if (typeof this.objCache[t] != "undefined")
      return this.objCache[t];
    if (typeof this.name2oidList[t] == "undefined")
      throw "Name of ObjectIdentifier not defined: " + t;
    var e = this.name2oidList[t], r = new KJUR.asn1.DERObjectIdentifier({
      oid: e
    });
    return this.objCache[t] = r, r;
  }, this.atype2obj = function(t) {
    if (this.objCache[t] !== void 0)
      return this.objCache[t];
    var e;
    if (t.match(/^\d+\.\d+\.[0-9.]+$/))
      e = t;
    else if (this.atype2oidList[t] !== void 0)
      e = this.atype2oidList[t];
    else if (this.name2oidList[t] !== void 0)
      e = this.name2oidList[t];
    else
      throw "AttributeType name undefined: " + t;
    var r = new KJUR.asn1.DERObjectIdentifier({
      oid: e
    });
    return this.objCache[t] = r, r;
  };
}();
KJUR.asn1.x509.OID.oid2name = function(n45) {
  var t = KJUR.asn1.x509.OID.name2oidList;
  for (var e in t)
    if (t[e] == n45)
      return e;
  return "";
};
KJUR.asn1.x509.OID.oid2atype = function(n45) {
  var t = KJUR.asn1.x509.OID.atype2oidList;
  for (var e in t)
    if (t[e] == n45)
      return e;
  return n45;
};
KJUR.asn1.x509.OID.name2oid = function(n45) {
  if (n45.match(/^[0-9.]+$/))
    return n45;
  var t = KJUR.asn1.x509.OID.name2oidList;
  return t[n45] === void 0 ? "" : t[n45];
};
RSAKey.getPosArrayOfChildrenFromHex = function(n45) {
  return ASN1HEX.getChildIdx(n45, 0);
};
RSAKey.getHexValueArrayOfChildrenFromHex = function(n45) {
  var t = ASN1HEX, e = t.getV, v = RSAKey.getPosArrayOfChildrenFromHex(n45), r = e(n45, v[0]), o = e(n45, v[1]), s = e(n45, v[2]), u = e(n45, v[3]), l = e(n45, v[4]), c = e(n45, v[5]), f = e(n45, v[6]), d = e(n45, v[7]), h = e(n45, v[8]), v = new Array();
  return v.push(r, o, s, u, l, c, f, d, h), v;
};
RSAKey.prototype.readPrivateKeyFromPEMString = function(n45) {
  var t = pemtohex(n45), e = RSAKey.getHexValueArrayOfChildrenFromHex(t);
  this.setPrivateEx(e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
};
RSAKey.prototype.readPKCS5PrvKeyHex = function(n45) {
  var t = RSAKey.getHexValueArrayOfChildrenFromHex(n45);
  this.setPrivateEx(t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
};
RSAKey.prototype.readPKCS8PrvKeyHex = function(n45) {
  var t, e, r, o, s, u, l, c, f = ASN1HEX, d = f.getVbyListEx;
  if (f.isASN1HEX(n45) === false)
    throw new Error("not ASN.1 hex string");
  try {
    t = d(n45, 0, [2, 0, 1], "02"), e = d(n45, 0, [2, 0, 2], "02"), r = d(n45, 0, [2, 0, 3], "02"), o = d(n45, 0, [2, 0, 4], "02"), s = d(n45, 0, [2, 0, 5], "02"), u = d(n45, 0, [2, 0, 6], "02"), l = d(n45, 0, [2, 0, 7], "02"), c = d(n45, 0, [2, 0, 8], "02");
  } catch (h) {
    throw new Error("malformed PKCS#8 plain RSA private key");
  }
  this.setPrivateEx(t, e, r, o, s, u, l, c);
};
RSAKey.prototype.readPKCS5PubKeyHex = function(n45) {
  var t = ASN1HEX, e = t.getV;
  if (t.isASN1HEX(n45) === false)
    throw new Error("keyHex is not ASN.1 hex string");
  var r = t.getChildIdx(n45, 0);
  if (r.length !== 2 || n45.substr(r[0], 2) !== "02" || n45.substr(r[1], 2) !== "02")
    throw new Error("wrong hex for PKCS#5 public key");
  var o = e(n45, r[0]), s = e(n45, r[1]);
  this.setPublic(o, s);
};
RSAKey.prototype.readPKCS8PubKeyHex = function(n45) {
  var t = ASN1HEX;
  if (t.isASN1HEX(n45) === false)
    throw new Error("not ASN.1 hex string");
  if (t.getTLVbyListEx(n45, 0, [0, 0]) !== "06092a864886f70d010101")
    throw new Error("not PKCS8 RSA public key");
  var e = t.getTLVbyListEx(n45, 0, [1, 0]);
  this.readPKCS5PubKeyHex(e);
};
RSAKey.prototype.readCertPubKeyHex = function(n45, t) {
  var e, r;
  e = new X509(), e.readCertHex(n45), r = e.getPublicKeyHex(), this.readPKCS8PubKeyHex(r);
};
function _rsasign_getAlgNameAndHashFromHexDisgestInfo(n45) {
  for (var t in KJUR.crypto.Util.DIGESTINFOHEAD) {
    var e = KJUR.crypto.Util.DIGESTINFOHEAD[t], r = e.length;
    if (n45.substring(0, r) == e) {
      var o = [t, n45.substring(r)];
      return o;
    }
  }
  return [];
}
RSAKey.prototype.verify = function(n45, t) {
  if (t = t.toLowerCase(), t.match(/^[0-9a-f]+$/) == null)
    return false;
  var e = parseBigInt(t, 16), r = this.n.bitLength();
  if (e.bitLength() > r)
    return false;
  var o = this.doPublic(e), s = o.toString(16);
  if (s.length + 3 != r / 4)
    return false;
  var u = s.replace(/^1f+00/, ""), l = _rsasign_getAlgNameAndHashFromHexDisgestInfo(u);
  if (l.length == 0)
    return false;
  var c = l[0], f = l[1], d = function(v) {
    return KJUR.crypto.Util.hashString(v, c);
  }, h = d(n45);
  return f == h;
};
RSAKey.prototype.verifyWithMessageHash = function(n45, t) {
  if (t.length != Math.ceil(this.n.bitLength() / 4))
    return false;
  var e = parseBigInt(t, 16);
  if (e.bitLength() > this.n.bitLength())
    return 0;
  var r = this.doPublic(e), o = r.toString(16).replace(/^1f+00/, ""), s = _rsasign_getAlgNameAndHashFromHexDisgestInfo(o);
  if (s.length == 0)
    return false;
  s[0];
  var u = s[1];
  return u == n45;
};
RSAKey.prototype.verifyPSS = function(n45, t, e, r) {
  var o = function(u) {
    return KJUR.crypto.Util.hashHex(u, e);
  }, s = o(rstrtohex(n45));
  return r === void 0 && (r = -1), this.verifyWithMessageHashPSS(s, t, e, r);
};
RSAKey.prototype.verifyWithMessageHashPSS = function(n45, t, e, r) {
  if (t.length != Math.ceil(this.n.bitLength() / 4))
    return false;
  var o = new BigInteger(t, 16), s = function(E) {
    return KJUR.crypto.Util.hashHex(E, e);
  }, u = hextorstr(n45), l = u.length, c = this.n.bitLength() - 1, f = Math.ceil(c / 8), d;
  if (r === -1 || r === void 0)
    r = l;
  else if (r === -2)
    r = f - l - 2;
  else if (r < -2)
    throw new Error("invalid salt length");
  if (f < l + r + 2)
    throw new Error("data too long");
  var h = this.doPublic(o).toByteArray();
  for (d = 0; d < h.length; d += 1)
    h[d] &= 255;
  for (; h.length < f; )
    h.unshift(0);
  if (h[f - 1] !== 188)
    throw new Error("encoded message does not end in 0xbc");
  h = String.fromCharCode.apply(String, h);
  var v = h.substr(0, f - l - 1), A = h.substr(v.length, l), g = 65280 >> 8 * f - c & 255;
  if (v.charCodeAt(0) & g)
    throw new Error("bits beyond keysize not zero");
  var p = pss_mgf1_str(A, v.length, s), y = [];
  for (d = 0; d < v.length; d += 1)
    y[d] = v.charCodeAt(d) ^ p.charCodeAt(d);
  y[0] &= ~g;
  var m = f - l - r - 2;
  for (d = 0; d < m; d += 1)
    if (y[d] !== 0)
      throw new Error("leftmost octets not zero");
  if (y[m] !== 1)
    throw new Error("0x01 marker not found");
  return A === hextorstr(s(rstrtohex("\0\0\0\0\0\0\0\0" + u + String.fromCharCode.apply(String, y.slice(-r)))));
};
RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;
RSAKey.SALT_LEN_RECOVER = -2;
function X509(n45) {
  var t = ASN1HEX, e = t.getChildIdx, r = t.getV, o = t.getTLV, s = t.getVbyList, u = t.getVbyListEx, l = t.getTLVbyList, c = t.getTLVbyListEx, f = t.getIdxbyList, d = t.getIdxbyListEx, h = t.getVidx, v = t.getInt, A = t.oidname, g = t.hextooidstr, p = pemtohex, y;
  try {
    y = KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
  } catch (m) {
  }
  this.HEX2STAG = {
    "0c": "utf8",
    13: "prn",
    16: "ia5",
    "1a": "vis",
    "1e": "bmp"
  }, this.hex = null, this.version = 0, this.foffset = 0, this.aExtInfo = null, this.getVersion = function() {
    if (this.hex === null || this.version !== 0)
      return this.version;
    var m = l(this.hex, 0, [0, 0]);
    if (m.substr(0, 2) == "a0") {
      var E = l(m, 0, [0]), b = v(E, 0);
      if (b < 0 || 2 < b)
        throw new Error("malformed version field");
      return this.version = b + 1, this.version;
    } else
      return this.version = 1, this.foffset = -1, 1;
  }, this.getSerialNumberHex = function() {
    return u(this.hex, 0, [0, 0], "02");
  }, this.getSignatureAlgorithmField = function() {
    var m = c(this.hex, 0, [0, 1]);
    return this.getAlgorithmIdentifierName(m);
  }, this.getAlgorithmIdentifierName = function(m) {
    for (var E in y)
      if (m === y[E])
        return E;
    return A(u(m, 0, [0], "06"));
  }, this.getIssuer = function() {
    return this.getX500Name(this.getIssuerHex());
  }, this.getIssuerHex = function() {
    return l(this.hex, 0, [0, 3 + this.foffset], "30");
  }, this.getIssuerString = function() {
    var m = this.getIssuer();
    return m.str;
  }, this.getSubject = function() {
    return this.getX500Name(this.getSubjectHex());
  }, this.getSubjectHex = function() {
    return l(this.hex, 0, [0, 5 + this.foffset], "30");
  }, this.getSubjectString = function() {
    var m = this.getSubject();
    return m.str;
  }, this.getNotBefore = function() {
    var m = s(this.hex, 0, [0, 4 + this.foffset, 0]);
    return m = m.replace(/(..)/g, "%$1"), m = decodeURIComponent(m), m;
  }, this.getNotAfter = function() {
    var m = s(this.hex, 0, [0, 4 + this.foffset, 1]);
    return m = m.replace(/(..)/g, "%$1"), m = decodeURIComponent(m), m;
  }, this.getPublicKeyHex = function() {
    return t.getTLVbyList(this.hex, 0, [0, 6 + this.foffset], "30");
  }, this.getPublicKeyIdx = function() {
    return f(this.hex, 0, [0, 6 + this.foffset], "30");
  }, this.getPublicKeyContentIdx = function() {
    var m = this.getPublicKeyIdx();
    return f(this.hex, m, [1, 0], "30");
  }, this.getPublicKey = function() {
    return KEYUTIL.getKey(this.getPublicKeyHex(), null, "pkcs8pub");
  }, this.getSignatureAlgorithmName = function() {
    var m = l(this.hex, 0, [1], "30");
    return this.getAlgorithmIdentifierName(m);
  }, this.getSignatureValueHex = function() {
    return s(this.hex, 0, [2], "03", true);
  }, this.verifySignature = function(m) {
    var E = this.getSignatureAlgorithmField(), b = this.getSignatureValueHex(), T = l(this.hex, 0, [0], "30"), R = new KJUR.crypto.Signature({
      alg: E
    });
    return R.init(m), R.updateHex(T), R.verify(b);
  }, this.parseExt = function(m) {
    var E, b, T;
    if (m === void 0) {
      if (T = this.hex, this.version !== 3)
        return -1;
      E = f(T, 0, [0, 7, 0], "30"), b = e(T, E);
    } else {
      T = pemtohex(m);
      var R = f(T, 0, [0, 3, 0, 0], "06");
      if (r(T, R) != "2a864886f70d01090e") {
        this.aExtInfo = new Array();
        return;
      }
      E = f(T, 0, [0, 3, 0, 1, 0], "30"), b = e(T, E), this.hex = T;
    }
    this.aExtInfo = new Array();
    for (var S = 0; S < b.length; S++) {
      var M = {};
      M.critical = false;
      var w = e(T, b[S]), H = 0;
      w.length === 3 && (M.critical = true, H = 1), M.oid = t.hextooidstr(s(T, b[S], [0], "06"));
      var L = f(T, b[S], [1 + H]);
      M.vidx = h(T, L), this.aExtInfo.push(M);
    }
  }, this.getExtInfo = function(m) {
    var E = this.aExtInfo, b = m;
    if (m.match(/^[0-9.]+$/) || (b = KJUR.asn1.x509.OID.name2oid(m)), b !== "") {
      for (var T = 0; T < E.length; T++)
        if (E[T].oid === b)
          return E[T];
    }
  }, this.getExtBasicConstraints = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("basicConstraints");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "basicConstraints"
    };
    if (E && (T.critical = true), m === "3000")
      return T;
    if (m === "30030101ff")
      return T.cA = true, T;
    if (m.substr(0, 12) === "30060101ff02") {
      var R = r(m, 10), S = parseInt(R, 16);
      return T.cA = true, T.pathLen = S, T;
    }
    throw new Error("hExtV parse error: " + m);
  }, this.getExtKeyUsage = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("keyUsage");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "keyUsage"
    };
    return E && (T.critical = true), T.names = this.getExtKeyUsageString(m).split(","), T;
  }, this.getExtKeyUsageBin = function(m) {
    if (m === void 0) {
      var E = this.getExtInfo("keyUsage");
      if (E === void 0)
        return "";
      m = o(this.hex, E.vidx);
    }
    if (m.length != 8 && m.length != 10)
      throw new Error("malformed key usage value: " + m);
    var b = "000000000000000" + parseInt(m.substr(6), 16).toString(2);
    return m.length == 8 && (b = b.slice(-8)), m.length == 10 && (b = b.slice(-16)), b = b.replace(/0+$/, ""), b == "" && (b = "0"), b;
  }, this.getExtKeyUsageString = function(m) {
    for (var E = this.getExtKeyUsageBin(m), b = new Array(), T = 0; T < E.length; T++)
      E.substr(T, 1) == "1" && b.push(X509.KEYUSAGE_NAME[T]);
    return b.join(",");
  }, this.getExtSubjectKeyIdentifier = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("subjectKeyIdentifier");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "subjectKeyIdentifier"
    };
    E && (T.critical = true);
    var R = r(m, 0);
    return T.kid = {
      hex: R
    }, T;
  }, this.getExtAuthorityKeyIdentifier = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("authorityKeyIdentifier");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "authorityKeyIdentifier"
    };
    E && (T.critical = true);
    for (var R = e(m, 0), S = 0; S < R.length; S++) {
      var M = m.substr(R[S], 2);
      if (M === "80" && (T.kid = {
        hex: r(m, R[S])
      }), M === "a1") {
        var w = o(m, R[S]), H = this.getGeneralNames(w);
        T.issuer = H[0].dn;
      }
      M === "82" && (T.sn = {
        hex: r(m, R[S])
      });
    }
    return T;
  }, this.getExtExtKeyUsage = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("extKeyUsage");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "extKeyUsage",
      array: []
    };
    E && (T.critical = true);
    for (var R = e(m, 0), S = 0; S < R.length; S++)
      T.array.push(A(r(m, R[S])));
    return T;
  }, this.getExtExtKeyUsageName = function() {
    var m = this.getExtInfo("extKeyUsage");
    if (m === void 0)
      return m;
    var E = new Array(), b = o(this.hex, m.vidx);
    if (b === "")
      return E;
    for (var T = e(b, 0), R = 0; R < T.length; R++)
      E.push(A(r(b, T[R])));
    return E;
  }, this.getExtSubjectAltName = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("subjectAltName");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "subjectAltName",
      array: []
    };
    return E && (T.critical = true), T.array = this.getGeneralNames(m), T;
  }, this.getExtIssuerAltName = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("issuerAltName");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "issuerAltName",
      array: []
    };
    return E && (T.critical = true), T.array = this.getGeneralNames(m), T;
  }, this.getGeneralNames = function(m) {
    for (var E = e(m, 0), b = [], T = 0; T < E.length; T++) {
      var R = this.getGeneralName(o(m, E[T]));
      R !== void 0 && b.push(R);
    }
    return b;
  }, this.getGeneralName = function(m) {
    var E = m.substr(0, 2), b = r(m, 0), T = hextorstr(b);
    if (E == "81")
      return {
        rfc822: T
      };
    if (E == "82")
      return {
        dns: T
      };
    if (E == "86")
      return {
        uri: T
      };
    if (E == "87")
      return {
        ip: hextoip(b)
      };
    if (E == "a4")
      return {
        dn: this.getX500Name(b)
      };
  }, this.getExtSubjectAltName2 = function() {
    var m, E, b, T = this.getExtInfo("subjectAltName");
    if (T === void 0)
      return T;
    for (var R = new Array(), S = o(this.hex, T.vidx), M = e(S, 0), w = 0; w < M.length; w++)
      b = S.substr(M[w], 2), m = r(S, M[w]), b === "81" && (E = hextoutf8(m), R.push(["MAIL", E])), b === "82" && (E = hextoutf8(m), R.push(["DNS", E])), b === "84" && (E = X509.hex2dn(m, 0), R.push(["DN", E])), b === "86" && (E = hextoutf8(m), R.push(["URI", E])), b === "87" && (E = hextoip(m), R.push(["IP", E]));
    return R;
  }, this.getExtCRLDistributionPoints = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("cRLDistributionPoints");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "cRLDistributionPoints",
      array: []
    };
    E && (T.critical = true);
    for (var R = e(m, 0), S = 0; S < R.length; S++) {
      var M = o(m, R[S]);
      T.array.push(this.getDistributionPoint(M));
    }
    return T;
  }, this.getDistributionPoint = function(m) {
    for (var E = {}, b = e(m, 0), T = 0; T < b.length; T++) {
      var R = m.substr(b[T], 2), S = o(m, b[T]);
      R == "a0" && (E.dpname = this.getDistributionPointName(S));
    }
    return E;
  }, this.getDistributionPointName = function(m) {
    for (var E = {}, b = e(m, 0), T = 0; T < b.length; T++) {
      var R = m.substr(b[T], 2), S = o(m, b[T]);
      R == "a0" && (E.full = this.getGeneralNames(S));
    }
    return E;
  }, this.getExtCRLDistributionPointsURI = function() {
    var m = this.getExtInfo("cRLDistributionPoints");
    if (m === void 0)
      return m;
    for (var E = new Array(), b = e(this.hex, m.vidx), T = 0; T < b.length; T++)
      try {
        var R = s(this.hex, b[T], [0, 0, 0], "86"), S = hextoutf8(R);
        E.push(S);
      } catch (M) {
      }
    return E;
  }, this.getExtAIAInfo = function() {
    var m = this.getExtInfo("authorityInfoAccess");
    if (m === void 0)
      return m;
    for (var E = {
      ocsp: [],
      caissuer: []
    }, b = e(this.hex, m.vidx), T = 0; T < b.length; T++) {
      var R = s(this.hex, b[T], [0], "06"), S = s(this.hex, b[T], [1], "86");
      R === "2b06010505073001" && E.ocsp.push(hextoutf8(S)), R === "2b06010505073002" && E.caissuer.push(hextoutf8(S));
    }
    return E;
  }, this.getExtAuthorityInfoAccess = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("authorityInfoAccess");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "authorityInfoAccess",
      array: []
    };
    E && (T.critical = true);
    for (var R = e(m, 0), S = 0; S < R.length; S++) {
      var M = u(m, R[S], [0], "06"), w = s(m, R[S], [1], "86"), H = hextoutf8(w);
      if (M == "2b06010505073001")
        T.array.push({
          ocsp: H
        });
      else if (M == "2b06010505073002")
        T.array.push({
          caissuer: H
        });
      else
        throw new Error("unknown method: " + M);
    }
    return T;
  }, this.getExtCertificatePolicies = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("certificatePolicies");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "certificatePolicies",
      array: []
    };
    E && (T.critical = true);
    for (var R = e(m, 0), S = 0; S < R.length; S++) {
      var M = o(m, R[S]), w = this.getPolicyInformation(M);
      T.array.push(w);
    }
    return T;
  }, this.getPolicyInformation = function(m) {
    var E = {}, b = s(m, 0, [0], "06");
    E.policyoid = A(b);
    var T = d(m, 0, [1], "30");
    if (T != -1) {
      E.array = [];
      for (var R = e(m, T), S = 0; S < R.length; S++) {
        var M = o(m, R[S]), w = this.getPolicyQualifierInfo(M);
        E.array.push(w);
      }
    }
    return E;
  }, this.getPolicyQualifierInfo = function(m) {
    var E = {}, b = s(m, 0, [0], "06");
    if (b === "2b06010505070201") {
      var T = u(m, 0, [1], "16");
      E.cps = hextorstr(T);
    } else if (b === "2b06010505070202") {
      var R = l(m, 0, [1], "30");
      E.unotice = this.getUserNotice(R);
    }
    return E;
  }, this.getUserNotice = function(m) {
    for (var E = {}, b = e(m, 0), T = 0; T < b.length; T++) {
      var R = o(m, b[T]);
      R.substr(0, 2) != "30" && (E.exptext = this.getDisplayText(R));
    }
    return E;
  }, this.getDisplayText = function(m) {
    var E = {
      "0c": "utf8",
      16: "ia5",
      "1a": "vis",
      "1e": "bmp"
    }, b = {};
    return b.type = E[m.substr(0, 2)], b.str = hextorstr(r(m, 0)), b;
  }, this.getExtCRLNumber = function(m, E) {
    var b = {
      extname: "cRLNumber"
    };
    if (E && (b.critical = true), m.substr(0, 2) == "02")
      return b.num = {
        hex: r(m, 0)
      }, b;
    throw new Error("hExtV parse error: " + m);
  }, this.getExtCRLReason = function(m, E) {
    var b = {
      extname: "cRLReason"
    };
    if (E && (b.critical = true), m.substr(0, 2) == "0a")
      return b.code = parseInt(r(m, 0), 16), b;
    throw new Error("hExtV parse error: " + m);
  }, this.getExtOcspNonce = function(m, E) {
    var b = {
      extname: "ocspNonce"
    };
    E && (b.critical = true);
    var T = r(m, 0);
    return b.hex = T, b;
  }, this.getExtOcspNoCheck = function(m, E) {
    var b = {
      extname: "ocspNoCheck"
    };
    return E && (b.critical = true), b;
  }, this.getExtAdobeTimeStamp = function(m, E) {
    if (m === void 0 && E === void 0) {
      var b = this.getExtInfo("adobeTimeStamp");
      if (b === void 0)
        return;
      m = o(this.hex, b.vidx), E = b.critical;
    }
    var T = {
      extname: "adobeTimeStamp"
    };
    E && (T.critical = true);
    var R = e(m, 0);
    if (R.length > 1) {
      var S = o(m, R[1]), M = this.getGeneralName(S);
      M.uri != null && (T.uri = M.uri);
    }
    if (R.length > 2) {
      var w = o(m, R[2]);
      w == "0101ff" && (T.reqauth = true), w == "010100" && (T.reqauth = false);
    }
    return T;
  }, this.getX500NameRule = function(m) {
    for (var E = null, b = [], T = 0; T < m.length; T++)
      for (var R = m[T], S = 0; S < R.length; S++)
        b.push(R[S]);
    for (var T = 0; T < b.length; T++) {
      var M = b[T], w = M.ds, H = M.value, L = M.type;
      if (w != "prn" && w != "utf8" && w != "ia5")
        return "mixed";
      if (w == "ia5") {
        if (L != "CN")
          return "mixed";
        if (KJUR.lang.String.isMail(H))
          continue;
        return "mixed";
      }
      if (L == "C") {
        if (w == "prn")
          continue;
        return "mixed";
      }
      if (E == null)
        E = w;
      else if (E !== w)
        return "mixed";
    }
    return E == null ? "prn" : E;
  }, this.getX500Name = function(m) {
    var E = this.getX500NameArray(m), b = this.dnarraytostr(E);
    return {
      array: E,
      str: b
    };
  }, this.getX500NameArray = function(m) {
    for (var E = [], b = e(m, 0), T = 0; T < b.length; T++)
      E.push(this.getRDN(o(m, b[T])));
    return E;
  }, this.getRDN = function(m) {
    for (var E = [], b = e(m, 0), T = 0; T < b.length; T++)
      E.push(this.getAttrTypeAndValue(o(m, b[T])));
    return E;
  }, this.getAttrTypeAndValue = function(m) {
    var E = {
      type: null,
      value: null,
      ds: null
    }, b = e(m, 0), T = s(m, b[0], [], "06"), R = s(m, b[1], []), S = KJUR.asn1.ASN1Util.oidHexToInt(T);
    return E.type = KJUR.asn1.x509.OID.oid2atype(S), E.ds = this.HEX2STAG[m.substr(b[1], 2)], E.ds != "bmp" ? E.value = hextoutf8(R) : E.value = ucs2hextoutf8(R), E;
  }, this.readCertPEM = function(m) {
    this.readCertHex(p(m));
  }, this.readCertHex = function(m) {
    this.hex = m, this.getVersion();
    try {
      f(this.hex, 0, [0, 7], "a3"), this.parseExt();
    } catch (E) {
    }
  }, this.getParam = function() {
    var m = {};
    return m.version = this.getVersion(), m.serial = {
      hex: this.getSerialNumberHex()
    }, m.sigalg = this.getSignatureAlgorithmField(), m.issuer = this.getIssuer(), m.notbefore = this.getNotBefore(), m.notafter = this.getNotAfter(), m.subject = this.getSubject(), m.sbjpubkey = hextopem(this.getPublicKeyHex(), "PUBLIC KEY"), this.aExtInfo.length > 0 && (m.ext = this.getExtParamArray()), m.sighex = this.getSignatureValueHex(), m;
  }, this.getExtParamArray = function(m) {
    if (m == null) {
      var E = d(this.hex, 0, [0, "[3]"]);
      E != -1 && (m = c(this.hex, 0, [0, "[3]", 0], "30"));
    }
    for (var b = [], T = e(m, 0), R = 0; R < T.length; R++) {
      var S = o(m, T[R]), M = this.getExtParam(S);
      M != null && b.push(M);
    }
    return b;
  }, this.getExtParam = function(m) {
    var E = e(m, 0), b = E.length;
    if (b != 2 && b != 3)
      throw new Error("wrong number elements in Extension: " + b + " " + m);
    var T = g(s(m, 0, [0], "06")), R = false;
    b == 3 && l(m, 0, [1]) == "0101ff" && (R = true);
    var S = l(m, 0, [b - 1, 0]), M = void 0;
    if (T == "2.5.29.14" ? M = this.getExtSubjectKeyIdentifier(S, R) : T == "2.5.29.15" ? M = this.getExtKeyUsage(S, R) : T == "2.5.29.17" ? M = this.getExtSubjectAltName(S, R) : T == "2.5.29.18" ? M = this.getExtIssuerAltName(S, R) : T == "2.5.29.19" ? M = this.getExtBasicConstraints(S, R) : T == "2.5.29.31" ? M = this.getExtCRLDistributionPoints(S, R) : T == "2.5.29.32" ? M = this.getExtCertificatePolicies(S, R) : T == "2.5.29.35" ? M = this.getExtAuthorityKeyIdentifier(S, R) : T == "2.5.29.37" ? M = this.getExtExtKeyUsage(S, R) : T == "1.3.6.1.5.5.7.1.1" ? M = this.getExtAuthorityInfoAccess(S, R) : T == "2.5.29.20" ? M = this.getExtCRLNumber(S, R) : T == "2.5.29.21" ? M = this.getExtCRLReason(S, R) : T == "1.3.6.1.5.5.7.48.1.2" ? M = this.getExtOcspNonce(S, R) : T == "1.3.6.1.5.5.7.48.1.5" ? M = this.getExtOcspNoCheck(S, R) : T == "1.2.840.113583.1.1.9.1" && (M = this.getExtAdobeTimeStamp(S, R)), M != null)
      return M;
    var w = {
      extname: T,
      extn: S
    };
    return R && (w.critical = true), w;
  }, this.findExt = function(m, E) {
    for (var b = 0; b < m.length; b++)
      if (m[b].extname == E)
        return m[b];
    return null;
  }, this.dnarraytostr = function(m) {
    function E(T) {
      return T.map(function(R) {
        return b(R).replace(/\+/, "\\+");
      }).join("+");
    }
    function b(T) {
      return T.type + "=" + T.value;
    }
    return "/" + m.map(function(T) {
      return E(T).replace(/\//, "\\/");
    }).join("/");
  }, this.getInfo = function() {
    var m = function(U) {
      var D = JSON.stringify(U.array).replace(/[\[\]\{\}\"]/g, "");
      return D;
    }, E = function(U) {
      for (var D = "", q = U.array, z = 0; z < q.length; z++) {
        var Q = q[z];
        if (D += "    policy oid: " + Q.policyoid + `
`, Q.array !== void 0)
          for (var G = 0; G < Q.array.length; G++) {
            var X = Q.array[G];
            X.cps !== void 0 && (D += "    cps: " + X.cps + `
`);
          }
      }
      return D;
    }, b = function(U) {
      for (var D = "", q = U.array, z = 0; z < q.length; z++) {
        var Q = q[z];
        try {
          Q.dpname.full[0].uri !== void 0 && (D += "    " + Q.dpname.full[0].uri + `
`);
        } catch (G) {
        }
        try {
          Q.dname.full[0].dn.hex !== void 0 && (D += "    " + X509.hex2dn(Q.dpname.full[0].dn.hex) + `
`);
        } catch (G) {
        }
      }
      return D;
    }, T = function(U) {
      for (var D = "", q = U.array, z = 0; z < q.length; z++) {
        var Q = q[z];
        Q.caissuer !== void 0 && (D += "    caissuer: " + Q.caissuer + `
`), Q.ocsp !== void 0 && (D += "    ocsp: " + Q.ocsp + `
`);
      }
      return D;
    }, R, S, M;
    if (R = `Basic Fields
`, R += "  serial number: " + this.getSerialNumberHex() + `
`, R += "  signature algorithm: " + this.getSignatureAlgorithmField() + `
`, R += "  issuer: " + this.getIssuerString() + `
`, R += "  notBefore: " + this.getNotBefore() + `
`, R += "  notAfter: " + this.getNotAfter() + `
`, R += "  subject: " + this.getSubjectString() + `
`, R += `  subject public key info: 
`, S = this.getPublicKey(), R += "    key algorithm: " + S.type + `
`, S.type === "RSA" && (R += "    n=" + hextoposhex(S.n.toString(16)).substr(0, 16) + `...
`, R += "    e=" + hextoposhex(S.e.toString(16)) + `
`), M = this.aExtInfo, M != null) {
      R += `X509v3 Extensions:
`;
      for (var w = 0; w < M.length; w++) {
        var H = M[w], L = KJUR.asn1.x509.OID.oid2name(H.oid);
        L === "" && (L = H.oid);
        var C = "";
        if (H.critical === true && (C = "CRITICAL"), R += "  " + L + " " + C + `:
`, L === "basicConstraints") {
          var I = this.getExtBasicConstraints();
          I.cA === void 0 ? R += `    {}
` : (R += "    cA=true", I.pathLen !== void 0 && (R += ", pathLen=" + I.pathLen), R += `
`);
        } else if (L === "keyUsage")
          R += "    " + this.getExtKeyUsageString() + `
`;
        else if (L === "subjectKeyIdentifier")
          R += "    " + this.getExtSubjectKeyIdentifier().kid.hex + `
`;
        else if (L === "authorityKeyIdentifier") {
          var _ = this.getExtAuthorityKeyIdentifier();
          _.kid !== void 0 && (R += "    kid=" + _.kid.hex + `
`);
        } else if (L === "extKeyUsage") {
          var O = this.getExtExtKeyUsage().array;
          R += "    " + O.join(", ") + `
`;
        } else if (L === "subjectAltName") {
          var P = m(this.getExtSubjectAltName());
          R += "    " + P + `
`;
        } else if (L === "cRLDistributionPoints") {
          var N = this.getExtCRLDistributionPoints();
          R += b(N);
        } else if (L === "authorityInfoAccess") {
          var k = this.getExtAuthorityInfoAccess();
          R += T(k);
        } else
          L === "certificatePolicies" && (R += E(this.getExtCertificatePolicies()));
      }
    }
    return R += "signature algorithm: " + this.getSignatureAlgorithmName() + `
`, R += "signature: " + this.getSignatureValueHex().substr(0, 16) + `...
`, R;
  }, typeof n45 == "string" && (n45.indexOf("-----BEGIN") != -1 ? this.readCertPEM(n45) : KJUR.lang.String.isHex(n45) && this.readCertHex(n45));
}
X509.hex2dn = function(n45, t) {
  t === void 0 && (t = 0);
  var e = new X509();
  ASN1HEX.getTLV(n45, t);
  var r = e.getX500Name(n45);
  return r.str;
};
X509.hex2rdn = function(n45, t) {
  if (t === void 0 && (t = 0), n45.substr(t, 2) !== "31")
    throw new Error("malformed RDN");
  for (var e = new Array(), r = ASN1HEX.getChildIdx(n45, t), o = 0; o < r.length; o++)
    e.push(X509.hex2attrTypeValue(n45, r[o]));
  return e = e.map(function(s) {
    return s.replace("+", "\\+");
  }), e.join("+");
};
X509.hex2attrTypeValue = function(n45, t) {
  var e = ASN1HEX, r = e.getV;
  if (t === void 0 && (t = 0), n45.substr(t, 2) !== "30")
    throw new Error("malformed attribute type and value");
  var o = e.getChildIdx(n45, t);
  o.length !== 2 || n45.substr(o[0], 2);
  var s = r(n45, o[0]), u = KJUR.asn1.ASN1Util.oidHexToInt(s), l = KJUR.asn1.x509.OID.oid2atype(u), c = r(n45, o[1]), f = hextorstr(c);
  return l + "=" + f;
};
X509.getPublicKeyFromCertHex = function(n45) {
  var t = new X509();
  return t.readCertHex(n45), t.getPublicKey();
};
X509.getPublicKeyFromCertPEM = function(n45) {
  var t = new X509();
  return t.readCertPEM(n45), t.getPublicKey();
};
X509.getPublicKeyInfoPropOfCertPEM = function(n45) {
  var t = ASN1HEX, e = t.getVbyList, r = {}, o, s;
  return r.algparam = null, o = new X509(), o.readCertPEM(n45), s = o.getPublicKeyHex(), r.keyhex = e(s, 0, [1], "03").substr(2), r.algoid = e(s, 0, [0, 0], "06"), r.algoid === "2a8648ce3d0201" && (r.algparam = e(s, 0, [0, 1], "06")), r;
};
X509.KEYUSAGE_NAME = ["digitalSignature", "nonRepudiation", "keyEncipherment", "dataEncipherment", "keyAgreement", "keyCertSign", "cRLSign", "encipherOnly", "decipherOnly"];
function sha256(n45) {
  return CryptoJS.SHA256(n45).toString();
}
var certificates = [function() {
  var n45 = new X509();
  return n45.readCertPEM(function() {
    var t = 113, e = 126, r = 0, o = "";
    return arguments[r].split(o).map(function(s) {
      return s.charCodeAt(r) > e ? s : String.fromCharCode((s.charCodeAt(r) + t) % e);
    }).join(o);
  }(":::::ORTV[-PR_aVSVPNaR:::::ZVVS@	PPNErtNVONtVWNZR}@]nU\0ZaZN=TP`\0T`Vo@Q^ROPbNZVTSZ^P^fQc^^TRWQawR^ZNATN>bRPNU^zc}nzyg	R^ZNATN>bROU^zc}nzyg	R]ZN=TN>bRPtTn?bf?FZ_NQtfQc^^YQNq`gdSp?cyZ^P^fQc^^QQNWQ^aRvZPNTP`\0T`Vo@Q^RWN_fapzFqSFwfbOndSnzyuYz[oaNrS=\x07\\QN>Z	N\\Q^B[QqnS=\b\\QN>Zwp\\Q^B[QqnZVTSZ^P^fQc^^TRWQawR^ZNATN>bRPNU^zc}nzyg	R^ZNATN>bROU^zc}nzyg	R]ZN=TN>bRPtTn?bf?FZ_NQtfQc^^YQNq`gdSp?cyZ^P^fQc^^QQNWQ^aRvZPNTP`\0T`Vo@Q^RWN_fapzFqSFwfbOndSnzyuYz[oaPPNvVQ^fWX|gVup[N^ROO^NQttV]NQPPNt|PttVONZU|C\b\\@@e^Xv{[vTtd8`nyO@\x07ebN[bqx=ng?	S^w@|XAz|qUTwfzn]Bu<qs_ae\\y<}u`eRAoE`_\\s\0r|b{rp_o<oC@o=x\bw_cUUZPApQevD\\FxFo\x07FgE=<sq[p<coqyn>TEpP@aSC_YDU8\0|8TB?c>r\\=rp`pcwP}c\0PP_\\RS\\EPVSy8x`\0?R|NP	P>}A^VP}Ex\bU\x07Za=syDw}>Ya\x078wPp[pRnn\brU^dE8U?a\bcW|<FEbbupn^`ZNr	sof[wA}e{\\z}w[YDQ|dt=wC	Nv\x07bR\x07Z@@U|ZAYpFsabCBB\\`wrqxsYW8uFyWdaWezeUeA_8VoVupvY[TD[OYdpO\bC[wX\\O]=[QRpV\0d`\x07N\0RXt^Z}vEpdC=\bY?\x07=V}?^W\bad|qN@Ww>@PycaqANE]asPcE^OB_VA?>wzeftac	Z	guf\bF]\x07DCP?znNYf	uaYu[`\x07=b|v]Bp=RAS``\\PRDW]_`UXdUg=SuqwVFDeB	D8{B>\\sPY\x07bEU	FQXz\0@\x07`zsqgfD\0[WY\bPeZc}	\0bx?Rfed\x07}BUe\x07|Uo\0y?\bsSXZOSBCgbFqf\0Bs?b?d<VE\\Zzns\\d@?dPvf\\{}_\0Sd[<q_YB\x07Y`Ffg=sY>{t<fu]x\x07rFNtZONNTwbQO\\ZO=TN>bqQt^dOOaAFXw=	PCVxsv?{`a\bvS8YQ[aNsOt[cU`ZRTQNdtOaAFXw=	PCVxsv?{`a\bvS8YQ[aNZOt[cU_ZROaNQN^U<ZN=TP`\0T`Vo@Q^ROPbNNAVPN^P\0{y\0Bs\\8\0R[z]w??qZP?NpgdenSuvv?>|f_?UpYPcQ\\gCb8zxtSvsOQNg>[\\\0\bx\b_o@8\0g`Z<PyUE`8yu}\\g{@`s`zUgErRtve{YdCvoO@>WFDtABNp\0feUWszpQaEYNAc]^xB[@]BDAN8\b}XA=E\x07nO}Pud8TA	?yPrVv{\\>E]o`BO^RE^X[W[rEU?x\bf>V	OUwY=>X[\\E`tW[8}VwpF\x07BQcnrPF}yUtd8<Doe_\b[oOVU\x07ep@pYY\0cegY{r	?\bAbq?ff8}UaXoN_D]_X_8yozYFT`N{`\\{zvu?\bDWT}=_<\x07StX	Nx\x07\0\b	\0aT=c@ucnWfR[vf>RFxAFV}{N`dN^\\<eawBPxx}quT=|{T_R@Fp^Y<ZevRsWaZ]V	CVrRVtAAc[	Qp|d|tqoQ=T|XX	=u\\N8XNCx\\aU>wz	X<e@Vc?dy\\|^FEq|=p`pBdF@bs^d<]vp\\^TZ	P\bZ\b\\YNNSZ_\\w^|TsD8db	_	Y\\o^Cw>Z\0x\\^aN]wWf\bA}	C^d_{\x07ZC@\by]gY@E	BFY?OsaqbDcVgQbZeFc	ovtucxnq|<TnuyXRveYFOegCpAs{YTe|>bE<OXsSqCBWD_SVepfvCCUg]z	ZvQ[\0s|U>pFz\b=OwT``fNJJ:::::R[Q-PR_aVSVPNaR:::::")), n45;
}()];
function getCertificateBySubjectHex(n45, t) {
  for (var e = 0, r = t; e < r.length; e++) {
    var o = r[e];
    if (o.getSubjectHex() === n45)
      return o;
  }
}
function verifyCertificate_(n45, t) {
  var e = n45.getIssuerHex();
  if (e === n45.getSubjectHex())
    return n45.verifySignature(n45.getPublicKey());
  var r = getCertificateBySubjectHex(e, t);
  return !r || n45.verifySignature(r.getPublicKey()) === false ? false : verifyCertificate_(r, t);
}
function verifyCertificate(n45) {
  var t = n45.getIssuerHex();
  return t === n45.getSubjectHex() ? false : verifyCertificate_(n45, certificates);
}
function addCertificate(n45) {
  var t = new X509();
  typeof n45 == "string" ? t.readCertPEM(n45) : t.readCertHex(n45.hex);
  var e = verifyCertificate(t);
  return certificates.push(t), e;
}
function verifyMessage(n45, t, e) {
  var r = new X509();
  if (typeof e == "string" ? r.readCertPEM(e) : r.readCertHex(e.hex), verifyCertificate(r) === false)
    return false;
  var o = new RSAKey();
  return o.readCertPubKeyHex(r.hex, 6), !!o.verify(n45, b64tohex(t));
}
addCertificate(function() {
  var t = 113, e = 126, r = 0, o = "";
  return arguments[r].split(o).map(function(s) {
    return s.charCodeAt(r) > e ? s : String.fromCharCode((s.charCodeAt(r) + t) % e);
  }).join(o);
}(":::::ORTV[-PR_aVSVPNaR:::::ZVVTU	PPONrtNVONtVWNW=_SVw	VE=ZN=TP`\0T`Vo@Q^ROPbNZVTSZ^P^fQc^^TRWQawR^ZNATN>bRPNU^zc}nzyg	R^ZNATN>bROU^zc}nzyg	R]ZN=TN>bRPtTn?bf?FZ_NQtfQc^^YQNq`gdSp?cyZ^P^fQc^^QQNWQ^aRvZPNTP`\0T`Vo@Q^RWN_fapzFqSFwfbOndSnzyuYz[oaNrS=\bZQNAZaN\\aZ	[QSnS=\b[aNBZQZ\\aZ	[QSnZVTaZ^P^fQc^^TRWQawR^ZNATN>bRPNU^zc}nzyg	R^ZNATN>bROU^zc}nzyg	RbZOVTN>bRPtYoTyuoz}}f`Bwo?=\x07RQN\\Ot[cONZO>Wyfd\x07	gdb\x07RaN]Ot[cONZZPRuupz_@feWyZ`bVfWX|gVup[N^xOSugnec|fdy\x07ndB{^T\x07}fdB\0ndRf?FZVVPVwN[Otx\0uxvTF=ON^RSNN\\PNtENZVVPPtXPNtRN?=?]q[VD|{\\oyo`oOu}F	SA\x07e`tn[t	u\b8^a]qx\bE_^\x07ZN?[QC\0yuOpybY8r\\RPAS=8rUq\0E8>xean^e\bf]Y`XO}{C[Ur^?\0x[SRXvVQ\\CFr}QnAPRQ\x07FO=Yw\0_TePCOFV@|\x07N>ROXcDrT<>bW<ssO?NOT{^s]uU\0gS\bBffsfE\0AfDyQEZR`]XBo|Qw}yYdwwTvOFcBndUz^\\{]	b=^yQYSTQ`]\0?tR{WRUun\\\0bVe_E|VWWV|r	Ao\0	F`fdzCnRtq\br	\b8eBp=Z\\TRaadc}@Eub`\x07quuNqAdF\0aUay{}x>tgVz`	_YBFwu_q?egt8v[o\x008	wTQcrA	<z{DZoEE^rZTrpaZQzqpBY]^zt8[bQv}yEWw	XDYQB\0QB\bx_^X]|uEDtPf[n[r_bpB[bE}?ung|bnU|NYOoedY_tvXySZfYP\x07\x07dWV]OE^\bOFwA}<uXoO}_NDz8aon\x07zWOfcv@?>snfqu@FeEx^\\\bVfuO`\\\0tSg]zDU}QrAT|	OZV|OvpVD<sN@z`<_cSrNCW>?=Au?g_8v{|}}WF>Sr>QBxO	d_D}eBb?Uq^b	[y}x]}{?P|BQtecTB[pQBW>|p|nfv\0zU\x07xOO}WqwE=<PURZy@X8r\\]u=<pPNRNNn\\OtaO<ZOETPdPT`NTT8RVOQ^^`SuO`gdSp?cyVRg\bo?B=VR[OZO=TN>bqQt^dOO`Fy\x07WadZcAD	peXybcW@}Qf\\QNsOt[cU`ZRTQNdtOaAFXw=	PCVxsv?{`a\bvS8YQ[aN]Ot[cU_ZONsEROaNQN^U<ZNTN>bqQ^RNVOOwN[Otx\0uxvTF=ON^SNN\\PNtRNrx	a[}tP_g8FbD\0^\0qt<f88ufuN]^}]gp\bqYudF88Fas_Ef`	?^x>X}esa{>\\r?eE]CC_cZ[vQs		>gX[szONg=^pn=<e]nbSz\bZvac\b[w^nA_`vP|@8w[}nQobe=??oRYf{vpRxcC}yCd>8[NDx{Ne\\t8oou=guC\x07>>g\x07vb}ACd	``Ntq\0yC[Q{|ynpNQqSqzxF<_PFDw<]Bnnu>F<XgU_Zf\\\\A=gu\\codOwQ]oQ<f>gv_pwozwC}xX>C`c]suEdfW?cbeo\b`BbyR@eFTUwSud=t]sS\\onc	XSq	{\0\x07DvAVBbnTqEE[QzDyqF`bF}R=Q?VeDo<Vzb\0w}D}NZ\0t}^?OyFP\bVaVNrTNYqe?[NRYTSQby@yzWvT`wQo}y]c_WgxBYCy	RNRg@\x07NZCaaq8?`	^`?ryD	=obzw?E]Ou\x07]n@>bVzqAQT?@_zo@}CxWVTUsAYdNd?{APQr8{P]]AZ>aR\0[D<z?Tr@`u@X|YDwd_<p<>zWE>]\0=X`\b@uucp|^_Qb@uZouTX^o\0\\{PCq{ug\x078^f[YQAWad8FNqxFQE?ZOo	}RnO\bsQc	xyccn=nxvs>bDBf\b\bW\\TuTnvAO^U\0QXC>xx8FxRFf<tJ:::::R[Q-PR_aVSVPNaR:::::"));
var extendStatics = function(n45, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {
    e.__proto__ = r;
  } || function(e, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]);
  }, extendStatics(n45, t);
};
function __extends(n45, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics(n45, t);
  function e() {
    this.constructor = n45;
  }
  n45.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var e, r = 1, o = arguments.length; r < o; r++) {
      e = arguments[r];
      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __decorate(n45, t, e, r) {
  var o = arguments.length, s = o < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(n45, t, e, r);
  else for (var l = n45.length - 1; l >= 0; l--) (u = n45[l]) && (s = (o < 3 ? u(s) : o > 3 ? u(t, e, s) : u(t, e)) || s);
  return o > 3 && s && Object.defineProperty(t, e, s), s;
}
function __metadata(n45, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(n45, t);
}
function __awaiter(n45, t, e, r) {
  function o(s) {
    return s instanceof e ? s : new e(function(u) {
      u(s);
    });
  }
  return new (e || (e = Promise))(function(s, u) {
    function l(d) {
      try {
        f(r.next(d));
      } catch (h) {
        u(h);
      }
    }
    function c(d) {
      try {
        f(r.throw(d));
      } catch (h) {
        u(h);
      }
    }
    function f(d) {
      d.done ? s(d.value) : o(d.value).then(l, c);
    }
    f((r = r.apply(n45, t || [])).next());
  });
}
function __generator(n45, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, o, s, u = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return u.next = l(0), u.throw = l(1), u.return = l(2), typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function l(f) {
    return function(d) {
      return c([f, d]);
    };
  }
  function c(f) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; u && (u = 0, f[0] && (e = 0)), e; ) try {
      if (r = 1, o && (s = f[0] & 2 ? o.return : f[0] ? o.throw || ((s = o.return) && s.call(o), 0) : o.next) && !(s = s.call(o, f[1])).done) return s;
      switch (o = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
        case 0:
        case 1:
          s = f;
          break;
        case 4:
          return e.label++, { value: f[1], done: false };
        case 5:
          e.label++, o = f[1], f = [0];
          continue;
        case 7:
          f = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
            e = 0;
            continue;
          }
          if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
            e.label = f[1];
            break;
          }
          if (f[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = f;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(f);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      f = t.call(n45, e);
    } catch (d) {
      f = [6, d], o = 0;
    } finally {
      r = s = 0;
    }
    if (f[0] & 5) throw f[1];
    return { value: f[0] ? f[1] : void 0, done: true };
  }
}
function __spreadArray(n45, t, e) {
  if (e || arguments.length === 2) for (var r = 0, o = t.length, s; r < o; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return n45.concat(s || Array.prototype.slice.call(t));
}
function createSymbol(n45) {
  return typeof Symbol == "undefined" ? "$Symbol<".concat(n45, ">$") : Symbol(n45);
}
var EVENT_SYMBOL = createSymbol("$$FIVE_EVENT$$");
function __generateEventIfNotExisted(n45) {
  return n45[EVENT_SYMBOL] || (n45[EVENT_SYMBOL] = {}), n45[EVENT_SYMBOL];
}
function __removeEvents(n45) {
  n45[EVENT_SYMBOL] && delete n45[EVENT_SYMBOL];
}
var Subscribe = (
  /** @class */
  function() {
    function n45() {
    }
    return n45.prototype.hasListener = function(t) {
      var e = __generateEventIfNotExisted(this);
      return e && e[t] && e[t].callbacks.length > 0;
    }, n45.prototype.on = function(t, e, r) {
      var o = this, s = __generateEventIfNotExisted(this);
      return s[t] || (s[t] = {
        callbacks: []
      }), s[t].callbacks.push([e, r || false]), function() {
        return o.off(t, e);
      };
    }, n45.prototype.once = function(t, e) {
      return this.on(t, e, true);
    }, n45.prototype.off = function(t, e) {
      if (t === void 0) {
        __removeEvents(this);
        return;
      }
      var r = __generateEventIfNotExisted(this);
      if (r[t] || (r[t] = {
        callbacks: []
      }), e === void 0) {
        r[t].callbacks.length = 0;
        return;
      }
      for (var o = 0; o < r[t].callbacks.length && r[t].callbacks[o][0] !== e; o++)
        ;
      o < r[t].callbacks.length && r[t].callbacks.splice(o, 1);
    }, n45.prototype.emit = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
      var o = false, s = __generateEventIfNotExisted(this);
      s[t] || (s[t] = {
        callbacks: []
      });
      for (var u = s[t].callbacks.slice(), l = 0, c = u; l < c.length; l++) {
        var f = c[l], d = f[0], h = f[1], v = h === void 0 ? false : h, A = d.apply(void 0, e);
        v && this.off(t, d), A === false && (o = true);
      }
      return o;
    }, n45.prototype.waitUntil = function(t, e) {
      var r = this;
      return new Promise(function(o) {
        var s = r.on(t, function() {
          for (var u = [], l = 0; l < arguments.length; l++)
            u[l] = arguments[l];
          (!e || e.apply(void 0, u) !== false) && (o(u), s());
        });
      });
    }, n45;
  }()
);
function noop$1() {
}
var start = typeof performance != "undefined" && typeof performance.timing != "undefined" ? performance.timing.navigationStart : Date.now();
var now = typeof performance != "undefined" ? function() {
  return start + performance.now();
} : function() {
  return Date.now();
};
function deepFreeze(n45) {
  Object.freeze(n45);
  var t = typeof n45 == "function", e = Object.prototype.hasOwnProperty;
  return Object.getOwnPropertyNames(n45).forEach(function(r) {
    e.call(n45, r) && (!t || r !== "caller" && r !== "callee" && r !== "arguments") && n45[r] !== null && (typeof n45[r] == "object" || typeof n45[r] == "function") && !Object.isFrozen(n45[r]) && deepFreeze(n45[r]);
  }), n45;
}
var domainRegex = /^([^.]+)(\.([^.]+))*$/;
function match(n45, t) {
  if (n45 === "*")
    return true;
  var e = n45.split(".").reverse(), r = t.split(".").reverse();
  if (e.length <= 1)
    return n45 === t;
  for (var o = 0; o < e.length; o++)
    if (e[o] !== r[o])
      return false;
  return true;
}
function isIPDomain(n45) {
  return /^(([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])(\.(?!$)|$)){4}$/.test(n45);
}
function matchDomain(n45, t) {
  return domainRegex.test(n45) && domainRegex.test(t) && match(n45, t);
}
var JSONP_REGEXPS = [/\.([0-9a-z]+)\.jsonp([\?\#].*)?$/i, /jsonp_([0-9a-z]+)([\?\#].*)?$/i];
var BUILDIN_ALLOW_HOST = deepFreeze(JSON.parse(function() {
  var t = 113, e = 126, r = 0, o = "";
  return arguments[r].split(o).map(function(s) {
    return s.charCodeAt(r) > e ? s : String.fromCharCode((s.charCodeAt(r) + t) % e);
  }).join(o);
}("h/y|pnyu|/9/xr;p|z/9/yvn{wvn;p|z/9/rnyrr;p|z/9/rnyrr;p{/9/rnyrr;w}/9/uv;p|z/9/uv;p{/9/rnyrr;p{/9/rnyrr;p|z/9/ywpq{;p|z/9/rnyrr:pq{;p|z/9/rnyrr:pq{;p{/9/rnyrr;nv/9/;p{/9/pq{;p{/9/pnyp{|qr;vr/j")));
var NetworkProxyError = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      return n45.call(this, "[NETWORK]: request proxy error(type: ".concat(r, ", reason: ").concat(o, "): ").concat(e)) || this;
    }
    return t;
  }(Error)
);
var NetworkResponseError = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      var s = n45.call(this, "[NETWORK]: response error(type: ".concat(r, ", status: ").concat(o, "): ").concat(e)) || this;
      return s.httpStatus = o, s;
    }
    return t;
  }(Error)
);
(function(n45) {
  __extends(t, n45);
  function t(e, r) {
    return n45.call(this, "[NETWORK]: request abort(type: ".concat(r, "): ").concat(e)) || this;
  }
  return t;
})(Error);
var NetworkTimeoutError = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      return n45.call(this, "[NETWORK]: request timeout(type: ".concat(r, ", timeout: ").concat(o, "ms): ").concat(e)) || this;
    }
    return t;
  }(Error)
);
var NetworkFirbiddenError = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      return n45.call(this, "[NETWORK]: request forbidden(type: ".concat(r, ", reason: ").concat(o, "): ").concat(e)) || this;
    }
    return t;
  }(Error)
);
function parseHeaders(n45) {
  if (!n45)
    return {};
  for (var t = {}, e = n45.trim().split(`
`), r = 0; r < e.length; r++) {
    var o = e[r], s = o.indexOf(":"), u = o.slice(0, s).trim().toLowerCase(), l = o.slice(s + 1).trim();
    l && (t[u] ? t[u] += ", " + l : t[u] = l);
  }
  return t;
}
function matchJsonpFunctionName(n45) {
  for (var t = 0, e = JSONP_REGEXPS; t < e.length; t++) {
    var r = e[t], o = n45.match(r);
    if (o)
      return "jsonp_" + o[1];
  }
  return null;
}
function isJsonpSource(n45) {
  return matchJsonpFunctionName(n45) !== null;
}
function getProtocol(n45) {
  var t = n45.match(/^([0-9a-z]+\:)\/\/(([^:/?#]*)(?::[0-9]+)?)/);
  return t ? t[1] : location.protocol;
}
function hostnameFromURL(n45) {
  if (/^blob\:/i.test(n45))
    return "blob:";
  if (/^data\:/i.test(n45))
    return "data:";
  var t = n45.match(/^[0-9a-z]+\:\/\/(([^:/?#]*)(?::[0-9]+)?)/i);
  return t ? t[2] : location.hostname;
}
var NetworkSubscribe = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t;
  }(Subscribe)
);
function ajax(n45, t, e, r, o) {
  t === void 0 && (t = {}), e === void 0 && (e = noop$1), r === void 0 && (r = noop$1), o === void 0 && (o = noop$1);
  var s = now(), u = n45;
  return Promise.resolve().then(function() {
    return t.requestProxy ? t.requestProxy(n45) : n45;
  }).then(function(l) {
    return /^https\:/.test(location.href) && /^http\:/.test(l) ? (console.warn("The page at '".concat(location.href, "' was loaded over HTTPS, but requested an insecure element '").concat(l, "'. This request was automatically upgraded to HTTPS")), l.replace(/^http\:/, "https:")) : l;
  }).catch(function(l) {
    var c, f = matchJsonpFunctionName(n45), d = f ? "Script" : "XMLHttpRequest", h = new NetworkProxyError(u, d, l && l.message ? String(l.message) : String(l));
    return (c = t.networkSubscribe) === null || c === void 0 || c.emit("network", n45, d, "proxy-error", h.message), Promise.reject(h);
  }).then(function(l) {
    return new Promise(function(c, f) {
      var d, h = t.allowHosts ? BUILDIN_ALLOW_HOST.concat(t.allowHosts) : BUILDIN_ALLOW_HOST.slice(), v = hostnameFromURL(l), A = matchJsonpFunctionName(l);
      if (location.hostname.length !== 0 && !isIPDomain(location.hostname) && BUILDIN_ALLOW_HOST.filter(function(_) {
        return matchDomain(_, location.hostname);
      }).length === 0 && !isIPDomain(v) && h.filter(function(_) {
        return matchDomain(_, v);
      }).length === 0) {
        var g = A ? "Script" : "XMLHttpRequest", p = new NetworkFirbiddenError(l, g, "request host(".concat(v, ") is not allowed"));
        r(p), f(p), (d = t.networkSubscribe) === null || d === void 0 || d.emit("network", l, g, "forbidden", p.message);
        return;
      }
      if (A) {
        var y = window, m = null, E = false, b = document.createElement("script"), T = function() {
          var _;
          if (m = null, E !== true) {
            E = true;
            var O = new NetworkTimeoutError(l, "Script", t.timeout || NaN);
            r(O), f(O), (_ = t.networkSubscribe) === null || _ === void 0 || _.emit("network", l, "Script", "timeout", O.message);
          }
        }, R = function(_) {
          var O, P, N = now(), k = N - s;
          if (delete y[A], b.parentNode && b.parentNode.removeChild(b), m !== null && (window.clearTimeout(m), m = null), E !== true) {
            if (_.indexOf("data:") !== 0) {
              var U = new NetworkResponseError(l, "Script", 500);
              r(U), f(U), (O = t.networkSubscribe) === null || O === void 0 || O.emit("network", l, "Script", "error", U.message);
              return;
            }
            var D = _.split(","), q = (D[0].match(/:(.*?);/) || [])[1], z = D[1];
            if (t.responseType === "arraybuffer" || t.responseType === "blob") {
              for (var Q = atob(D[1]), G = Q.length, X = new Uint8Array(G), $ = 0; $ < G; $++)
                X[$] = Q.charCodeAt($);
              t.responseType === "arraybuffer" ? z = X.buffer : z = new Blob([X], { type: q });
            }
            var W = {}, oe = {
              body: z,
              meta: { origin: u, source: l, requestTime: s, responseTime: N, costs: k, headers: W }
            };
            e(oe), c(oe), (P = t.networkSubscribe) === null || P === void 0 || P.emit("network", l, "Script", "ok", JSON.stringify(oe.meta)), E = true;
          }
        };
        y[A] = R, b.src = l, document.body.appendChild(b), typeof t.timeout == "number" && (m = window.setTimeout(T, t.timeout));
      } else {
        var S = false, M = new XMLHttpRequest(), w = function() {
          M && (M.removeEventListener("timeout", H, false), M.removeEventListener("progress", L, false), M.removeEventListener("load", C, false), M.removeEventListener("error", I, false)), M = null, w = noop$1;
        }, H = function() {
          var _;
          if (S !== true) {
            S = true, w();
            var O = new NetworkTimeoutError(l, "XMLHttpRequest", t.timeout || NaN);
            r(O), f(O), (_ = t.networkSubscribe) === null || _ === void 0 || _.emit("network", l, "XMLHttpRequest", "timeout", O.message);
          }
        }, L = function(_) {
          S !== true && _.lengthComputable && (_.total <= 0 || o(_.loaded / _.total));
        }, C = function(_) {
          var O;
          if (S !== true) {
            var P = this.status;
            if (P === 0 || P >= 200 && P < 400) {
              S = true, w();
              var N = now(), k = N - s, U = parseHeaders(this.getAllResponseHeaders()), D = _.total, q = {
                body: this.response,
                meta: { origin: u, source: l, requestTime: s, responseTime: N, costs: k, headers: U, size: D }
              };
              e(q), c(q), (O = t.networkSubscribe) === null || O === void 0 || O.emit("network", l, "XMLHttpRequest", "ok", JSON.stringify(q.meta));
            } else
              I.call(this);
          }
        }, I = function() {
          var _;
          if (S !== true) {
            S = true, w();
            var O = new NetworkResponseError(l, "XMLHttpRequest", this.status);
            r(O), f(O), (_ = t.networkSubscribe) === null || _ === void 0 || _.emit("network", l, "XMLHttpRequest", "error", O.message);
          }
        };
        M.addEventListener("timeout", H, false), M.addEventListener("progress", L, false), M.addEventListener("load", C, false), M.addEventListener("error", I, false), t.responseType && (M.responseType = t.responseType), typeof t.timeout == "number" && (M.timeout = t.timeout), M.open("GET", l, true), M.send(null);
      }
    });
  });
}
var preloadCache = {};
function preload(n45, t) {
  t === void 0 && (t = {});
  var e = now(), r = n45;
  return Promise.resolve().then(function() {
    return t.requestProxy ? t.requestProxy(n45) : n45;
  }).then(function(o) {
    return /^https\:/.test(location.href) && /^http\:/.test(o) ? (console.warn("The page at '".concat(location.href, "' was loaded over HTTPS, but requested an insecure element '").concat(o, "'. This request was automatically upgraded to HTTPS")), o.replace(/^http\:/, "https:")) : o;
  }).catch(function(o) {
    var s, u = new NetworkProxyError(r, "Link", o && o.message ? String(o.message) : String(o));
    return (s = t.networkSubscribe) === null || s === void 0 || s.emit("network", n45, "Link", "proxy-error", u.message), Promise.reject(u);
  }).then(function(o) {
    return o in preloadCache ? preloadCache[o] : preloadCache[o] = new Promise(function(s, u) {
      var l, c = t.allowHosts ? BUILDIN_ALLOW_HOST.concat(t.allowHosts) : BUILDIN_ALLOW_HOST.slice(), f = hostnameFromURL(o);
      if (location.hostname.length !== 0 && !isIPDomain(location.hostname) && BUILDIN_ALLOW_HOST.filter(function(p) {
        return matchDomain(p, location.hostname);
      }).length === 0 && !isIPDomain(f) && c.filter(function(p) {
        return matchDomain(p, f);
      }).length === 0) {
        var d = new NetworkFirbiddenError(o, "Link", "request host(".concat(f, ") is not allowed"));
        u(d), (l = t.networkSubscribe) === null || l === void 0 || l.emit("network", o, "Link", "forbidden", d.message);
        return;
      }
      var h = document.createElement("link"), v = false, A = null;
      h.onload = function(p) {
        var y;
        if (A !== null && (clearTimeout(A), A = null), v !== true) {
          v = true, s();
          var m = now(), E = m - e, b = {}, T = { origin: r, source: o, requestTime: e, responseTime: m, costs: E, headers: b };
          (y = t.networkSubscribe) === null || y === void 0 || y.emit("network", o, "Link", "preload", JSON.stringify(T));
        }
      }, h.onerror = function(p) {
        var y;
        if (A !== null && (clearTimeout(A), A = null), v !== true) {
          v = true;
          var m = new NetworkResponseError(o, "Link", 0);
          u(m), (y = t.networkSubscribe) === null || y === void 0 || y.emit("network", o, "Link", "error", m.message);
        }
      }, typeof t.timeout == "number" && (A = window.setTimeout(function() {
        var p;
        if (A = null, v !== true) {
          v = true, s();
          var y = now(), m = y - e, E = {}, b = { origin: r, source: o, requestTime: e, responseTime: y, costs: m, headers: E };
          (p = t.networkSubscribe) === null || p === void 0 || p.emit("network", o, "Link", "timeout", JSON.stringify(b));
        }
      }, t.timeout)), h.rel = h.relList && h.relList.supports("prefetch") ? "prefetch" : "preload", h.as = "fetch", h.crossOrigin = "", h.fetchPriority = "high", h.href = o;
      var g = document.head || document.getElementsByTagName("head")[0];
      g && g.appendChild(h);
    });
  });
}
function loadImage(n45, t, e, r, o, s) {
  t === void 0 && (t = {}), e === void 0 && (e = noop$1), r === void 0 && (r = noop$1), o === void 0 && (o = noop$1);
  var u = now(), l = n45;
  return Promise.resolve().then(function() {
    return t.requestProxy ? t.requestProxy(n45) : n45;
  }).then(function(c) {
    return /^https\:/.test(location.href) && /^http\:/.test(c) ? (console.warn("The page at '".concat(location.href, "' was loaded over HTTPS, but requested an insecure element '").concat(c, "'. This request was automatically upgraded to HTTPS")), c.replace(/^http\:/, "https:")) : c;
  }).catch(function(c) {
    var f, d = new NetworkProxyError(l, "Image", c && c.message ? String(c.message) : String(c));
    return (f = t.networkSubscribe) === null || f === void 0 || f.emit("network", n45, "Image", "proxy-error", d.message), Promise.reject(d);
  }).then(function(c) {
    return new Promise(function(f, d) {
      var h, v = t.allowHosts ? BUILDIN_ALLOW_HOST.concat(t.allowHosts) : BUILDIN_ALLOW_HOST.slice(), A = hostnameFromURL(c);
      if (location.hostname.length !== 0 && !isIPDomain(location.hostname) && BUILDIN_ALLOW_HOST.filter(function(T) {
        return matchDomain(T, location.hostname);
      }).length === 0 && !isIPDomain(A) && v.filter(function(T) {
        return matchDomain(T, A);
      }).length === 0) {
        var g = new NetworkFirbiddenError(c, "Image", "request host(".concat(A, ") is not allowed"));
        r(g), d(g), (h = t.networkSubscribe) === null || h === void 0 || h.emit("network", c, "Image", "forbidden", g.message);
        return;
      }
      var p = s != null ? s : new Image(), y = false, m = null, E = function() {
        var T;
        if (p.onload = noop$1, p.onerror = noop$1, m !== null && (clearTimeout(m), m = null), y !== true) {
          var R = now(), S = {
            headers: {},
            origin: l,
            source: c,
            requestTime: u,
            responseTime: R,
            costs: R - u
          };
          y = true;
          var M = { body: p, meta: S };
          o(1), e(M), f(M), (T = t.networkSubscribe) === null || T === void 0 || T.emit("network", c, "Image", "ok", JSON.stringify(M.meta));
        }
      }, b = function() {
        var T;
        if (p.onload = noop$1, p.onerror = noop$1, m !== null && (clearTimeout(m), m = null), y !== true) {
          y = true;
          var R = new NetworkResponseError(c, "Image", 0);
          r(R), d(R), (T = t.networkSubscribe) === null || T === void 0 || T.emit("network", c, "Image", "ok", R.message);
        }
      };
      typeof t.timeout == "number" && (m = window.setTimeout(function() {
        var T;
        if (p.onload = noop$1, p.onerror = noop$1, m = null, y !== true) {
          y = true;
          var R = new NetworkTimeoutError(c, "Image", t.timeout);
          r(R), d(R), (T = t.networkSubscribe) === null || T === void 0 || T.emit("network", c, "Image", "timeout", R.message);
        }
      }, t.timeout)), p.onload = E, p.onerror = b, o(0), p.src = c;
    });
  });
}
var Fetcher = (
  /** @class */
  function() {
    function n45(t) {
      t === void 0 && (t = {}), this.options = Object.freeze(t), this.options.allowHosts && Object.freeze(this.options.allowHosts);
    }
    return n45.prototype.ajax = function(t, e, r, o, s) {
      var u;
      e === void 0 && (e = {}), r === void 0 && (r = noop$1), o === void 0 && (o = noop$1), s === void 0 && (s = noop$1);
      var l = this.options, c = {
        responseType: e.responseType,
        timeout: (u = e.timeout) !== null && u !== void 0 ? u : l.timeout,
        get allowHosts() {
          var f;
          return (f = e.allowHosts) !== null && f !== void 0 ? f : l.allowHosts;
        },
        get requestProxy() {
          var f;
          return (f = e.requestProxy) !== null && f !== void 0 ? f : l.requestProxy;
        },
        get networkSubscribe() {
          var f;
          return (f = e.networkSubscribe) !== null && f !== void 0 ? f : l.networkSubscribe;
        }
      };
      return ajax(t, c, r, o, s);
    }, n45.prototype.loadImage = function(t, e, r, o, s, u) {
      var l;
      e === void 0 && (e = {}), r === void 0 && (r = noop$1), o === void 0 && (o = noop$1), s === void 0 && (s = noop$1);
      var c = this.options, f = {
        timeout: (l = e.timeout) !== null && l !== void 0 ? l : c.timeout,
        get allowHosts() {
          var d;
          return (d = e.allowHosts) !== null && d !== void 0 ? d : c.allowHosts;
        },
        get requestProxy() {
          var d;
          return (d = e.requestProxy) !== null && d !== void 0 ? d : c.requestProxy;
        },
        get networkSubscribe() {
          var d;
          return (d = e.networkSubscribe) !== null && d !== void 0 ? d : c.networkSubscribe;
        }
      };
      return loadImage(t, f, r, o, s, u);
    }, n45.prototype.preload = function(t, e) {
      var r;
      e === void 0 && (e = {});
      var o = this.options, s = {
        timeout: (r = e.timeout) !== null && r !== void 0 ? r : o.timeout,
        get allowHosts() {
          var u;
          return (u = e.allowHosts) !== null && u !== void 0 ? u : o.allowHosts;
        },
        get requestProxy() {
          var u;
          return (u = e.requestProxy) !== null && u !== void 0 ? u : o.requestProxy;
        },
        get networkSubscribe() {
          var u;
          return (u = e.networkSubscribe) !== null && u !== void 0 ? u : o.networkSubscribe;
        }
      };
      return preload(t, s);
    }, n45;
  }()
);
var internalFetcher = new Fetcher();
function clamp$1(n45, t, e) {
  return n45 < t ? t : n45 > e ? e : n45;
}
var windowSTOContext = function() {
  var n45 = now();
  return {
    requestAnimationFrame: function(t) {
      var e = now(), r = clamp$1(16 + (e - n45), 16, 33), o = setTimeout(function() {
        t(e + r);
      }, r);
      return n45 = e + r, o;
    },
    cancelAnimationFrame: function(t) {
      return clearTimeout(t);
    }
  };
}();
var windowRAFContext = function() {
  if (typeof window != "undefined") {
    var n45 = window;
    if (n45.requestAnimationFrame)
      return {
        requestAnimationFrame: n45.requestAnimationFrame.bind(n45),
        cancelAnimationFrame: n45.cancelAnimationFrame.bind(n45)
      };
    if (n45.mozRequestAnimationFrame)
      return {
        requestAnimationFrame: n45.mozRequestAnimationFrame.bind(n45),
        cancelAnimationFrame: n45.mozCancelAnimationFrame.bind(n45)
      };
    if (n45.webkitRequestAnimationFrame)
      return {
        requestAnimationFrame: n45.webkitRequestAnimationFrame.bind(n45),
        cancelAnimationFrame: n45.webkitCancelAnimationFrame.bind(n45)
      };
    if (n45.msRequestAnimationFrame)
      return {
        requestAnimationFrame: n45.msRequestAnimationFrame.bind(n45),
        cancelAnimationFrame: n45.msCancelAnimationFrame.bind(n45)
      };
  }
  return windowSTOContext;
}();
var DEFAULT_ORDER = 5;
var deviceFrameTime = 16;
var AnimationFrameLoop = (
  /** @class */
  function() {
    function n45() {
      this.loopType = "raf", this.frames = [], this.isAnimating = false, this.context = null;
      var t = now();
      this.loop = (function() {
        for (var e = [], r = 0; r < arguments.length; r++)
          e[r] = arguments[r];
        if (this.isAnimating !== false) {
          var o = now(), s = o - t;
          t = o, deviceFrameTime = s;
          for (var u = 0; u < this.frames.length; u++) {
            var l = this.frames[u];
            if (l.delay > 0) {
              l.delay = l.delay - 1;
              continue;
            }
            try {
              l.callback.apply(l, __spreadArray([o, s], e, false));
            } catch (c) {
              console.error(c);
            }
            l.once && (this.frames.splice(u, 1), u--);
          }
          this.requestId = this.requestAnimationFrame(this.loop);
        }
      }).bind(this), this.start();
    }
    return Object.defineProperty(n45, "shared", {
      get: function() {
        return this.sharedInstance || (this.sharedInstance = new n45()), this.sharedInstance;
      },
      enumerable: false,
      configurable: true
    }), n45.getFrameTime = function() {
      return deviceFrameTime;
    }, n45.prototype.start = function() {
      this.isAnimating !== true && (this.isAnimating = true, this.requestId = this.requestAnimationFrame(this.loop));
    }, n45.prototype.stop = function() {
      this.isAnimating = false, this.cancelAnimationFrame(this.requestId);
    }, n45.prototype.setContext = function(t) {
      t !== this.context && (this.stop(), this.context = t, this.start());
    }, n45.prototype.getContext = function() {
      return this.context;
    }, n45.prototype.setLoopType = function(t) {
      t !== this.loopType && (this.stop(), this.loopType = t, this.start());
    }, n45.prototype.getLoopType = function() {
      return this.loopType;
    }, n45.prototype.requestAnimationFrame = function(t) {
      if (this.context)
        return this.context.requestAnimationFrame(t);
      if (this.loopType === "raf")
        return windowRAFContext.requestAnimationFrame(t);
      if (this.loopType === "sto")
        return windowSTOContext.requestAnimationFrame(t);
    }, n45.prototype.cancelAnimationFrame = function(t) {
      if (this.context)
        this.context.cancelAnimationFrame(t);
      else if (this.loopType === "raf")
        windowRAFContext.cancelAnimationFrame(t);
      else if (this.loopType === "sto")
        return windowSTOContext.cancelAnimationFrame(t);
    }, n45.prototype.remove = function(t) {
      var e = this.frames.indexOf(t);
      e >= 0 && this.frames.splice(e, 1);
    }, n45.prototype.add = function(t, e, r, o) {
      var s = this;
      e === void 0 && (e = false), r === void 0 && (r = 0), o === void 0 && (o = DEFAULT_ORDER);
      for (var u = { callback: t, once: e, delay: r, order: o }, l = this.frames.length; --l >= 0; )
        if (this.frames[l].order <= o) {
          this.frames.splice(l + 1, 0, u);
          break;
        }
      return l < 0 && this.frames.unshift(u), function() {
        return s.remove(u);
      };
    }, n45.prototype.clear = function() {
      this.frames.length = 0;
    }, n45;
  }()
);
var webp = "data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoCAAIAAUAmJaQAA3AA/vz0AAA=";
var avif = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAAGhbWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAsaWxvYwAAAABEAAACAAEAAAABAAAB3gAAABkAAgAAAAEAAAHJAAAAFQAAAEJpaW5mAAAAAAACAAAAGmluZmUCAAAAAAEAAGF2MDFDb2xvcgAAAAAaaW5mZQIAAAAAAgAAYXYwMUFscGhhAAAAABppcmVmAAAAAAAAAA5hdXhsAAIAAQABAAAA12lwcnAAAACxaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIAAoAAAAAUaXNwZQAAAAAAAAACAAAAAgAAAA5waXhpAAAAAAEIAAAADGF2MUOBABwAAAAAOGF1eEMAAAAAdXJuOm1wZWc6bXBlZ0I6Y2ljcDpzeXN0ZW1zOmF1eGlsaWFyeTphbHBoYQAAAAAeaXBtYQAAAAAAAAACAAEEAQKDBAACBAUGhwgAAAA2bWRhdBIACgQYADLVMgsWQBhhIAQqrNj/+BIACgUYADLEoDIOFkADDDDCQAACDaqCCb4=";
var heif = "data:image/heif;base64,AAAAGGZ0eXBoZWljAAAAAG1pZjFoZWljAAABL21ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAHBpY3QAAAAAAAAAAAAAAAAAAAAADnBpdG0AAAAAAAEAAAAjaWluZgAAAAAAAQAAABVpbmZlAgAAAAABAABodmMxAAAAAK9pcHJwAAAAkmlwY28AAAB2aHZjQwEBYAAAAAAAAAAAAADwAPz9+PgAACcDoAABAB5AAQwG//8BYAAAAwAAAwAAAwAAAwAAAwAAreTLgSChAAEAI0IBBwFgAAADAAADAAADAAADAAADAAChInJJlreTLySZNdggogABAAdEAcA98DMkAAAAFGlzcGUAAAAAAAAAAgAAAAIAAAAVaXBtYQAAAAAAAAABAAECgQIAAAAiaWxvYwAAAABEQAABAAEAAAAAAU8AAQAAAAAAAAAOAAAAFm1kYXQAAAAKJgGvLvkQwuWM4A==";
function checkImage(n45) {
  return new Promise(function(t) {
    if (typeof Image == "undefined") {
      t(false);
      return;
    }
    var e = new Image(), r = setTimeout(function() {
      e.onload = e.onerror = function() {
      }, clearTimeout(r), t(false);
    }, 100);
    e.onload = e.onerror = function() {
      e.onload = e.onerror = function() {
      }, clearTimeout(r), t(e.height === 2);
    }, e.src = n45;
  });
}
var imageSupportCache = null;
function imageSupport() {
  return imageSupportCache || (imageSupportCache = Promise.all([
    checkImage(webp),
    checkImage(avif),
    checkImage(heif)
  ]).then(function(n45) {
    return {
      webp: n45[0],
      avif: n45[1],
      heif: n45[2]
    };
  }));
}
var supportAvif = false;
var supportWebp = false;
var supportHeif = false;
imageSupport().then(function(n45) {
  supportAvif = n45.avif, supportWebp = n45.webp, supportHeif = n45.heif;
});
var IMAGE_FORMATS = ["jpg", "jpeg", "png", "heif", "heic", "webp", "avif"];
function isImageExt(n45) {
  return IMAGE_FORMATS.indexOf(n45) >= 0;
}
var DEFAULT_IMAGE_URL_MAPPINGS = {
  // 
  "vrlab-public.ljcdn.com": {
    type: "tencentCloud",
    pano: [
      "vrlab-image1.ljcdn.com",
      "vrlab-image2.ljcdn.com"
    ],
    texture: [
      "vrlab-image3.ljcdn.com"
    ],
    tile: [
      "vr-tile-1.realsee-cdn.cn",
      "vr-tile-2.realsee-cdn.cn"
    ],
    model: [
      "vr-model-1.realsee-cdn.cn",
      "vr-model-2.realsee-cdn.cn"
    ],
    default: [
      "vrlab-image4.ljcdn.com"
    ]
  },
  // 
  "vr-public.realsee-cdn.cn": {
    type: "tencentCloud",
    pano: [
      "vr-image-1.realsee-cdn.cn",
      "vr-image-2.realsee-cdn.cn"
    ],
    texture: [
      "vr-image-3.realsee-cdn.cn"
    ],
    tile: [
      "vr-tile-1.realsee-cdn.cn",
      "vr-tile-2.realsee-cdn.cn"
    ],
    model: [
      "vr-model-1.realsee-cdn.cn",
      "vr-model-2.realsee-cdn.cn"
    ],
    default: [
      "vr-image-4.realsee-cdn.cn"
    ]
  },
  // rscdn 
  "vr-public.rscdn.cn": {
    type: "tencentCloud",
    pano: [
      "vr-image-1.rscdn.cn",
      "vr-image-2.rscdn.cn"
    ],
    texture: [
      "vr-image-3.rscdn.cn"
    ],
    tile: [
      "vr-tile-1.rscdn.cn",
      "vr-tile-2.rscdn.cn"
    ],
    model: [
      "vr-model-1.rscdn.cn",
      "vr-model-2.rscdn.cn"
    ],
    default: [
      "vr-image-4.rscdn.cn"
    ]
  },
  // 
  "mars-public.realsee-cdn.cn": {
    type: "aliyun",
    pano: [
      "mars-image-1.realsee-cdn.cn",
      "mars-image-2.realsee-cdn.cn"
    ],
    texture: [
      "mars-image-3.realsee-cdn.cn"
    ],
    tile: [
      "mars-tile-1.realsee-cdn.cn",
      "mars-tile-2.realsee-cdn.cn"
    ],
    model: [
      "mars-model-1.realsee-cdn.cn",
      "mars-model-2.realsee-cdn.cn"
    ],
    default: [
      "mars-image-4.realsee-cdn.cn"
    ]
  },
  // 
  "global-public.realsee-cdn.com": {
    type: "tencentCloud",
    pano: [
      "global-image-1.realsee-cdn.com",
      "global-image-2.realsee-cdn.com"
    ],
    texture: [
      "global-image-3.realsee-cdn.com"
    ],
    tile: [
      "global-tile-1.realsee-cdn.com",
      "global-tile-2.realsee-cdn.com"
    ],
    model: [
      "global-model-1.realsee-cdn.com",
      "global-model-2.realsee-cdn.com"
    ],
    default: [
      "global-image-4.realsee-cdn.com"
    ]
  },
  // 
  "earth-ga-public.realsee-cdn.cn": {
    type: "tencentCloud",
    pano: [
      "earth-ga-image-1.realsee-cdn.cn",
      "earth-ga-image-2.realsee-cdn.cn"
    ],
    texture: [
      "earth-ga-image-3.realsee-cdn.cn"
    ],
    tile: [
      "earth-ga-tile-1.realsee-cdn.cn",
      "earth-ga-tile-2.realsee-cdn.cn"
    ],
    model: [
      "earth-ga-model-1.realsee-cdn.cn",
      "earth-ga-model-2.realsee-cdn.cn"
    ],
    default: [
      "earth-ga-image-4.realsee-cdn.cn"
    ]
  },
  // 
  "test-vr-public.realsee-cdn.com": {
    type: "tencentCloud",
    pano: [
      "test-vr-image.realsee-cdn.com",
      "test-vr-image.realsee-cdn.com"
    ],
    texture: [
      "test-vr-image.realsee-cdn.com"
    ],
    tile: [
      "test-vr-image.realsee-cdn.com",
      "test-vr-image.realsee-cdn.com"
    ],
    model: [
      "test-vr-image.realsee-cdn.com",
      "test-vr-image.realsee-cdn.com"
    ],
    default: [
      "test-vr-image.realsee-cdn.com"
    ]
  },
  // 
  "test-vr-public.realsee-cdn.cn": {
    type: "tencentCloud",
    pano: [
      "test-vr-image.realsee-cdn.cn",
      "test-vr-image.realsee-cdn.cn"
    ],
    texture: [
      "test-vr-image.realsee-cdn.cn"
    ],
    tile: [
      "test-vr-image.realsee-cdn.cn",
      "test-vr-image.realsee-cdn.cn"
    ],
    model: [
      "test-vr-image.realsee-cdn.cn",
      "test-vr-image.realsee-cdn.cn"
    ],
    default: [
      "test-vr-image.realsee-cdn.cn"
    ]
  }
};
var URL_DOMAIN_REGEX = /^https?\:\/\/?([^\/]+)/;
function getDomain(n45) {
  var t = n45.match(URL_DOMAIN_REGEX);
  return t === null ? null : t[1];
}
function replaceDomain(n45, t) {
  return n45.replace(URL_DOMAIN_REGEX, function(e, r) {
    return e.slice(0, e.length - r.length) + t;
  });
}
function route(n45, t, e) {
  var r = t.split("."), o = r[0], s = r.slice(1);
  if (o === "texture")
    return replaceDomain(n45, e.texture[0]);
  if (o === "pano" || o === "pano_luminance") {
    s[0];
    var u = s[1];
    switch (u) {
      case "front":
      case "left":
      case "up":
        return replaceDomain(n45, e.pano[0]);
      case "down":
      case "right":
      case "back":
        return replaceDomain(n45, e.pano[1]);
    }
  } else if (o === "pano_tile" || o === "pano_tile_luminance") {
    s[0], s[1];
    var l = s[2], c = s[3], f = s[4], d = Math.pow(2, Number(l)) * Number(c) + Number(f);
    if (!isNaN(d))
      return replaceDomain(n45, e.tile[d % 2]);
  } else if (o === "model") {
    var h = s[0], d = Number(h);
    if (!isNaN(d))
      return replaceDomain(n45, e.model[d % 2]);
  }
  return replaceDomain(n45, e.default[0]);
}
var tencentCloudImageProcesser = function(n45, t) {
  var e = n45.split("?")[0], r = e.split(".").pop();
  if (r === "jpeg" && (r = "jpg"), r === "heif" && (r = "heic"), r && !isImageExt(r))
    return n45;
  var o = [], s = t.format, u = t.cut, l = t.quality, c = t.size, f = t.sharpen;
  if (s === "jpeg" && (s = "jpg"), s === "heif" && (s = "heic"), (!supportAvif && (s != null ? s : r) === "avif" || !supportWebp && (s != null ? s : r) === "webp" || !supportHeif && (s != null ? s : r) === "heic") && (s = "jpg"), s !== void 0 && s !== r && o.push("format/".concat(s)), u !== void 0 && o.push("cut/".concat(u[2], "x").concat(u[3], "x").concat(u[0], "x").concat(u[1])), l !== void 0) {
    var d = s != null ? s : r;
    d && ["jpg", "webp", "heic", "avif"].indexOf(d) >= 0 && o.push("quality/".concat(l));
  }
  if (c !== void 0) {
    var h = n45.match(/\/cube_(\d+)\//), v = h ? Number(h[1]) : NaN;
    v !== Number(c) && o.push("thumbnail/".concat(c, "x"));
  }
  f !== void 0 && o.push("sharpen/".concat(f));
  var A = "";
  return o.length && (A = "?imageMogr2/" + o.join("/")), e + A;
};
var aliyunOOSImageProcesser = function(n45, t) {
  var e = n45.split("?")[0], r = e.split(".").pop();
  if (r === "jpeg" && (r = "jpg"), r === "heif" && (r = "heic"), r && !isImageExt(r))
    return n45;
  var o = [], s = t.format, u = t.cut, l = t.quality, c = t.size, f = t.sharpen;
  if (s === "jpeg" && (s = "jpg"), s === "heif" && (s = "heic"), (!supportAvif && (s != null ? s : r) === "avif" || !supportWebp && (s != null ? s : r) === "webp" || !supportHeif && (s != null ? s : r) === "heic") && (s = "jpg"), s !== void 0 && s !== r && o.push("format,".concat(s)), u !== void 0) {
    var d = u[0], h = u[1], v = u[2], A = u[3];
    o.push("crop,x_".concat(d, ",y_").concat(h, ",w_").concat(v, ",h_").concat(A, ",g_nw"));
  }
  if (l !== void 0 && l !== 100) {
    var g = s != null ? s : r;
    g && ["jpg", "webp", "heic", "avif"].indexOf(g) >= 0 && o.push("quality,Q_".concat(l));
  }
  c && c !== 2048 && o.push("resize,w_".concat(c)), f !== void 0 && o.push("sharpen,".concat(f));
  var p = "";
  return o.length && (p = "?x-oss-process=image/" + o.join("/")), e + p;
};
var MAX_SAFE_INTEGER = 9007199254740991;
function formatNumber(n45) {
  var t = Math.round(n45);
  return Math.abs(t - n45) < 1e-3 ? t : Math.floor(n45);
}
function formatOptions(n45) {
  return n45 = Object.assign({}, n45), n45.size !== void 0 && (n45.size = formatNumber(clamp$1(n45.size, 0, MAX_SAFE_INTEGER))), n45.quality !== void 0 && (n45.quality = formatNumber(clamp$1(n45.quality, 0, 100))), n45.cut !== void 0 && (n45.cut = [
    formatNumber(clamp$1(n45.cut[0], 0, MAX_SAFE_INTEGER)),
    formatNumber(clamp$1(n45.cut[1], 0, MAX_SAFE_INTEGER)),
    formatNumber(clamp$1(n45.cut[2], 0, MAX_SAFE_INTEGER)),
    formatNumber(clamp$1(n45.cut[3], 0, MAX_SAFE_INTEGER))
  ]), n45.sharpen !== void 0 && (n45.sharpen = formatNumber(clamp$1(n45.sharpen, 0, MAX_SAFE_INTEGER))), n45;
}
function imageURL(n45, t) {
  var e = __assign(__assign({}, DEFAULT_IMAGE_URL_MAPPINGS), t.mappings), r = getDomain(n45);
  if (r === null)
    return n45;
  t = formatOptions(t);
  var o = e[r];
  return o ? (n45 = route(n45, t.key, o), /\.basis(\?|$)/.test(n45) && (n45 = n45.replace(/\.basis(\?|$)/, ".jpg$1")), o.type === "tencentCloud" ? tencentCloudImageProcesser(n45, t) : o.type === "aliyun" ? aliyunOOSImageProcesser(n45, t) : n45) : n45;
}
function applyImageURLOptions(n45, t, e) {
  t === void 0 && (t = imageURL);
  var r = t(n45, e);
  if (r === n45 && e.cut)
    throw new Error("ImageURL: cut option not applied.");
  return r;
}
var IMAGE_SIZE_REG = /\/cube_(\d+)\//;
function getImageSizeFromURL(n45) {
  var t = n45.match(IMAGE_SIZE_REG);
  return t ? Number(t[1]) : null;
}
function replaceImageSize(n45, t) {
  return n45.replace(IMAGE_SIZE_REG, "/cube_".concat(t, "/"));
}
var PANO_ID_REG = /^(.*)\[(\d+)\]$/;
function panoStringify(n45) {
  if (!isNaN(n45.panoIndex) && isFinite(n45.panoIndex))
    return "".concat(n45.workCode, "[").concat(n45.panoIndex, "]");
  throw new Error("Invalid Pano");
}
function panoParse(n45) {
  var t = n45.match(PANO_ID_REG);
  if (t) {
    t[0];
    var e = t[1], r = t[2], o = Math.floor(Number(r));
    if (!isNaN(o) && isFinite(o))
      return {
        workCode: e,
        panoIndex: o
      };
  }
  throw new Error("Invalid PanoId");
}
function panoEqual(n45, t) {
  return panoStringify(n45) === panoStringify(t);
}
function isPanoId(n45) {
  return typeof n45 == "string" && PANO_ID_REG.test(n45);
}
var PBMGroup = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t;
  }(Group)
);
var PBMMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      var o = n45.call(this, e, r) || this;
      return o.castShadow = true, o.receiveShadow = true, o;
    }
    return t.prototype.update = function(e, r, o, s) {
      for (var u = 0, l = this.material; u < l.length; u++) {
        var c = l[u];
        c.update(e, r, o);
      }
    }, t;
  }(Mesh)
);
var PBMSkinnedMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      var s = n45.call(this, e, r, o) || this;
      return s.castShadow = true, s.receiveShadow = true, s;
    }
    return t.prototype.update = function(e, r, o, s) {
      for (var u = 0, l = this.material; u < l.length; u++) {
        var c = l[u];
        c.update(e, r, o);
      }
    }, t;
  }(SkinnedMesh)
);
function jsonStableStrinfiy_(n45, t) {
  t === void 0 && (t = false);
  var e = typeof n45;
  if (e === "string")
    return JSON.stringify(n45);
  if (n45 === true)
    return "true";
  if (n45 === false)
    return "false";
  if (n45 === null)
    return "null";
  if (n45 instanceof Array) {
    for (var r = "[", o = n45.length - 1, s = 0; s < o; s++)
      r += jsonStableStrinfiy_(n45[s], false) + ",";
    return o > -1 && (r += jsonStableStrinfiy_(n45[s], false)), r + "]";
  }
  if (n45 instanceof Object) {
    if (typeof n45.toJSON == "function")
      return jsonStableStrinfiy_(n45.toJSON(), t);
    for (var u = Object.keys(n45).sort(), l = u.length, r = "", s = 0; s < l; ) {
      var c = u[s], f = jsonStableStrinfiy_(n45[c], true);
      f !== void 0 && (s && r !== "" && (r += ","), r += JSON.stringify(c) + ":" + f), s++;
    }
    return "{" + r + "}";
  }
  switch (e) {
    case "function":
      return JSON.stringify(n45.toString());
    case "undefined":
      return t ? void 0 : null;
    case "number":
      return n45;
    default:
      return isFinite(n45) ? n45 : null;
  }
}
function jsonHash(n45) {
  return "hash::".concat(jsonStableStrinfiy_(n45, false));
}
var CustomShader = (
  /** @class */
  function() {
    function n45(t) {
      var e, r, o, s, u, l, c, f, d, h, v, A, g, p, y, m;
      this.uniforms = (e = t.uniforms) !== null && e !== void 0 ? e : {}, this.defines = (r = t.defines) !== null && r !== void 0 ? r : {}, this.type = t.type, this.vertex = {
        mainBefore: (s = (o = t.vertex) === null || o === void 0 ? void 0 : o.mainBefore) !== null && s !== void 0 ? s : "",
        mainStart: (l = (u = t.vertex) === null || u === void 0 ? void 0 : u.mainStart) !== null && l !== void 0 ? l : "",
        mainEnd: (f = (c = t.vertex) === null || c === void 0 ? void 0 : c.mainEnd) !== null && f !== void 0 ? f : ""
      }, this.fragment = {
        mainBefore: (h = (d = t.fragment) === null || d === void 0 ? void 0 : d.mainBefore) !== null && h !== void 0 ? h : "",
        mainStart: (A = (v = t.fragment) === null || v === void 0 ? void 0 : v.mainStart) !== null && A !== void 0 ? A : "",
        mainModelColor: (p = (g = t.fragment) === null || g === void 0 ? void 0 : g.mainModelColor) !== null && p !== void 0 ? p : "",
        mainEnd: (m = (y = t.fragment) === null || y === void 0 ? void 0 : y.mainEnd) !== null && m !== void 0 ? m : ""
      };
    }
    return n45.prototype.getHash = function() {
      return jsonHash({ vertex: this.vertex, fragment: this.fragment, defines: this.defines });
    }, n45.prototype.onBeforeCompile = function(t, e) {
    }, n45;
  }()
);
var gradientTexture = function() {
  return typeof document != "undefined" ? new TextureLoader().load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAABCAYAAACouxZ2AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAACAKADAAQAAAABAAAAAQAAAAB7UD0+AAACA0lEQVRIDXWUW3YjIQxEwdnV/GT/q8kO3FO3pAJst3PSAaR6Cbszf//9XeMxxpjXmI+pVXudp2s6PC4dqHff9e6D7/PZLy46xQvG+sZvrfK8xgXUeq85yINe9bdmtOK1+kun5vjgq58a+eZPna9jvmjiserqG/+Whathvo3L3WhV89L9sXI/m18z2uene9ap/ftsuT9WZxoHXzW56/fpj8l7+tTw7P011NdpqnY19sRsfuHMA9u8oZWfDz4+fra/dfG1V60ydZ7qba1g7UNAeK0JP7ydD7/OqH6wO2f7HTq+B/lbL9qsB3/N1/UzR81XfPzw4tp5OPvRneacteq8Xo0xR3vuv/kPz0KtX0Nhg0eHuaNXdWI3X/ld427h++vzyp99V6VPrzWFhbv4ayay4oFecm198MmUXN/mL+x7npq/uJXBGb/MTw4+t+SvbLoTZnUW5uHhz7nWcTxT73OwXV7cxT9wbBf/0LnDBgcnHmtPLYba32Hp808sMy1u88yhr58n70/v4xX92GSN19l/2UsqGmiH94Hpxjcs+DO/ccpIVNVp62PUWXu//ur1GQy1Cf+GZ13rtNYN1po3/NI79fGXibHkq4z25xvV2pW3szpneXsW8SsreTe/NIPrtXMnH7wPf+LEN6tqhUVHj3XKD/72p9eafCeYB3zuonnbv7yqP8d/o4K6gRb1wbYAAAAASUVORK5CYII=") : new Texture();
}();
gradientTexture.minFilter = NearestFilter;
gradientTexture.magFilter = NearestFilter;
gradientTexture.wrapS = RepeatWrapping;
gradientTexture.wrapT = RepeatWrapping;
var defaultPbmParameters = {
  customShaders: [],
  pano0: null,
  pano1: null,
  floorStyle: "OPACITY",
  colorStyle: "RGB",
  constantColor: new Vector3(0.6, 0.6, 0.6),
  shownFloorIndex: -1,
  modelAlpha: 1,
  opacity: 1,
  progress: 0,
  transition: "FADE",
  clippers: null,
  brightness: 1,
  useEDL: false,
  useHQWeight: false,
  useHQDepth: false,
  pointSize: "ATTENUATION",
  pointBack: "DARK",
  pointShape: "CIRCLE",
  pointScale: 0.03,
  pointMaxPixel: 40,
  pointMinPixel: 1,
  gradientTexture,
  colorSaturation: 0,
  colorBrightness: 0,
  outlineGain: 0,
  distanceGain: 0,
  useAddBlend: false
};
function isEqualClipperParameters(n45, t) {
  var e = n45 != null ? n45 : [], r = t != null ? t : [];
  if (r.length !== e.length)
    return false;
  for (var o = 0; o < r.length; o++)
    if (!e[o].clippingBoxMatrix.equals(r[o].clippingBoxMatrix) || e[o].floorIndex !== r[o].floorIndex)
      return false;
  return true;
}
function isEqualPBMPanoPicture(n45, t) {
  return n45 && t ? n45.luminanceMap === t.luminanceMap && n45.map === t.map && n45.zoom === t.zoom && n45.matrix.equals(t.matrix) : !n45 && !t;
}
function updatePBMParameters(n45, t) {
  var e = false;
  for (var r in t)
    if (t[r] !== void 0)
      switch (r) {
        case "clippers":
          isEqualClipperParameters(n45[r], t[r]) || (n45[r] = t[r], e = true);
          break;
        case "pano0":
        case "pano1":
          isEqualPBMPanoPicture(n45[r], t[r]) || (n45[r] = t[r], e = true);
          break;
        default:
          n45[r] !== t[r] && (n45[r] = t[r], e = true);
          break;
      }
  return e;
}
function mixNumber(n45, t, e) {
  return n45 + (t - n45) * e;
}
function value(n45, t, e, r) {
  var o = (t * e + 2 * n45) / Math.pow(e, 3), s = -(2 * t * e + 3 * n45) / Math.pow(e, 2), u = t, l = n45;
  return o * Math.pow(r, 3) + s * Math.pow(r, 2) + u * r + l;
}
function velocity(n45, t, e, r) {
  var o = (t * e + 2 * n45) / Math.pow(e, 3), s = -(2 * t * e + 3 * n45) / Math.pow(e, 2), u = t;
  return 3 * o * Math.pow(r, 2) + 2 * s * r + u;
}
function mixCircle(n45, t, e, r) {
  var o = r[1] - r[0];
  return n45 = circleValue(n45, r), t = circleValue(t, r), t - n45 > o / 2 ? mixNumber(n45 + o, t, e) : n45 - t > o / 2 ? mixNumber(n45 - o, t, e) : mixNumber(n45, t, e);
}
function circleValue(n45, t) {
  var e = t[1] - t[0];
  return n45 < t[0] ? circleValue(n45 + e, t) : n45 >= t[1] ? circleValue(n45 - e, t) : n45;
}
function mixValue(n45, t, e, r) {
  return r ? mixCircle(n45, t, e, r) : mixNumber(n45, t, e);
}
function toNumber(n45) {
  var t = Number(n45);
  return isNaN(t) || !isFinite(t) ? 0 : t;
}
var Motion = (
  /** @class */
  function() {
    function n45(t) {
      this.config = {}, this.progress = 1, this.ended = true, this.value = {}, this.startTime = now(), this.startVelocity = 0, this.duration = 0, this.keyframes = [];
      for (var e in t) {
        var r = t[e];
        typeof r == "object" ? (this.value[e] = toNumber(r.value), this.config[e] = { circle: r.circle }) : (this.value[e] = toNumber(r), this.config[e] = { circle: false });
      }
      this.keyframes = [
        { progress: 0, value: __assign({}, this.value) },
        { progress: 1, value: __assign({}, this.value) }
      ];
    }
    return n45.prototype.getProgress = function(t) {
      var e = t - this.startTime;
      return e < 0 ? 0 : e >= this.duration ? 1 : 1 - value(1, this.startVelocity, this.duration, e);
    }, n45.prototype.getValue = function(t) {
      for (var e = 1; e < this.keyframes.length; e++)
        if (this.keyframes[e].progress > t) {
          var r = this.keyframes[e - 1], o = this.keyframes[e], s = {};
          for (var u in this.config) {
            var l = (t - r.progress) / (o.progress - r.progress);
            s[u] = mixValue(r.value[u], o.value[u], l, this.config[u].circle);
          }
          return s;
        }
      return __assign({}, this.keyframes[this.keyframes.length - 1].value);
    }, n45.prototype.getProgressVelocity = function(t) {
      var e = t - this.startTime;
      return e >= this.duration ? 0 : velocity(1, this.startVelocity, this.duration, e);
    }, n45.prototype.update = function(t) {
      return this.ended ? true : (this.progress = Math.min(1, Math.max(0, this.progress, this.getProgress(t))), this.value = this.getValue(this.progress), this.ended = this.progress >= 1, this.ended && this.callbacks && (this.callbacks[0](), this.callbacks = void 0), this.ended);
    }, n45.prototype.getKeyFrameSegment = function(t) {
      for (var e = this.getProgress(t), r = 1; r < this.keyframes.length; r++)
        if (this.keyframes[r].progress > e)
          return [this.keyframes[r - 1], this.keyframes[r]];
      return [this.keyframes[this.keyframes.length - 2], this.keyframes[this.keyframes.length - 1]];
    }, n45.prototype.getTargetKeyframe = function() {
      return this.keyframes[this.keyframes.length - 1];
    }, n45.prototype.set = function(t, e, r, o) {
      var s;
      r === void 0 && (r = 0), isNaN(e) && (e = 0), isNaN(r) && (r = 0), o = o != null ? o : now();
      var u = this.getProgress(o), l = this.getValue(u), c = {};
      for (var f in this.config)
        c[f] = (s = t[f]) !== null && s !== void 0 ? s : l[f];
      var d = [
        { progress: 0, value: l },
        { progress: 1, value: c }
      ];
      return this.setKeyframes(d, e, r, o);
    }, n45.prototype.setKeyframes = function(t, e, r, o) {
      var s = this;
      if (r === void 0 && (r = 0), t.length < 2)
        throw new Error("keyframes invalid.");
      return isNaN(e) && (e = 0), isNaN(r) && (r = 0), this.callbacks && (this.callbacks[1](new Error("motion aborted.")), this.callbacks = void 0), new Promise(function(u, l) {
        o = o != null ? o : now(), s.progress = 0, s.ended = false, s.startTime = o, s.startVelocity = r, s.keyframes = t, s.duration = e, e === 0 ? (s.progress = 1, s.value = __assign({}, t[t.length - 1].value)) : s.value = __assign({}, t[0].value), s.callbacks = [u, l];
      });
    }, n45.prototype.dispose = function() {
      this.callbacks && (this.callbacks[1](new Error("motion dispose.")), this.callbacks = void 0);
    }, n45;
  }()
);
var APPEAR_ANIMATION_DURATION = 500;
function easeInCubic(n45) {
  return n45 * n45 * n45;
}
var PBMPointCloud = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      var o = n45.call(this, e, r) || this;
      return o.appearMotion = new Motion({ appear: 0 }), o;
    }
    return t.prototype.update = function(e, r, o, s) {
      var u, l;
      if (this.material.update(e, r, o), s && s.refine === "ADD" && s.tileset.rootMeta.pntsOrder === "RANDOM") {
        var c = this.geometry, f = this.appearMotion, d = o.visible && s.state.selectedFrameNumber === s.tileset.frameNumber, h = s.tileset.currentMaxScreenSpaceError, v = s.state.screenSpaceError, A = (l = (u = s.parent) === null || u === void 0 ? void 0 : u.state.screenSpaceError) !== null && l !== void 0 ? l : v, g = 1;
        if (A !== v && (g = (A - h) / (A - v)), g = clamp$1(g, 0, 1), g = easeInCubic(g), d) {
          var p = 1;
          f.getTargetKeyframe().value.appear !== p && f.set({ appear: p }, APPEAR_ANIMATION_DURATION).catch(noop$1);
        } else {
          var p = 0;
          f.getTargetKeyframe().value.appear !== p && f.set({ appear: p }, 0).catch(noop$1);
        }
        f.ended !== true && f.update(r.time);
        var y = c.index ? c.index.count : c.attributes.position ? c.attributes.position.count : 1 / 0, m = Math.floor(y * g * f.value.appear);
        c.drawRange.count !== m && (this.geometry.setDrawRange(0, m), o.needsRender = true);
      }
    }, t;
  }(Points)
);
var scratchMaterialSet = /* @__PURE__ */ new Set();
var PBMContainer = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      return e.needsRender = true, e.pbmMaterialParametersVersion = 0, e.materialParameters = __assign({}, defaultPbmParameters), e;
    }
    return t.prototype.getMaterial = function() {
      return __assign({}, this.materialParameters);
    }, t.prototype.setMaterial = function(e) {
      var r = this;
      Object.assign(this.materialParameters, e), scratchMaterialSet.clear(), this.traverse(function(o) {
        if (o instanceof PBMMesh || o instanceof PBMSkinnedMesh)
          for (var s = 0, u = o.material; s < u.length; s++) {
            var l = u[s];
            scratchMaterialSet.has(l) || (Object.assign(l, r.materialParameters), scratchMaterialSet.add(l));
          }
        o instanceof PBMPointCloud && (scratchMaterialSet.has(o.material) || (Object.assign(o.material, r.materialParameters), scratchMaterialSet.add(o.material)));
      }), scratchMaterialSet.clear(), this.needsRender = true;
    }, t;
  }(Group)
);
var FACE_ORDER$1 = ["right", "left", "up", "down", "front", "back"];
function getBox(n45, t, e, r) {
  var o = new Box3();
  switch (n45) {
    case "up":
      o.min.y = 0.5, o.max.y = 0.5, o.min.x = +t - 0.5, o.max.x = +t - 0.5 + r, o.min.z = -e + 0.5 - r, o.max.z = -e + 0.5;
      break;
    case "down":
      o.min.y = -0.5, o.max.y = -0.5, o.min.x = +t - 0.5, o.max.x = +t - 0.5 + r, o.min.z = +e - 0.5, o.max.z = +e - 0.5 + r;
      break;
    case "left":
      o.min.x = -0.5, o.max.x = -0.5, o.min.z = -t + 0.5 - r, o.max.z = -t + 0.5, o.min.y = -e + 0.5 - r, o.max.y = -e + 0.5;
      break;
    case "right":
      o.min.x = 0.5, o.max.x = 0.5, o.min.z = +t - 0.5, o.max.z = +t - 0.5 + r, o.min.y = -e + 0.5 - r, o.max.y = -e + 0.5;
      break;
    case "front":
      o.min.z = -0.5, o.max.z = -0.5, o.min.x = +t - 0.5, o.max.x = +t - 0.5 + r, o.min.y = -e + 0.5 - r, o.max.y = -e + 0.5;
      break;
    case "back":
      o.min.z = 0.5, o.max.z = 0.5, o.min.x = -t + 0.5 - r, o.max.x = -t + 0.5, o.min.y = -e + 0.5 - r, o.max.y = -e + 0.5;
      break;
  }
  return o.applyMatrix4(new Matrix4().makeRotationY(Math.PI));
}
var createChildren = function(n45, t) {
  if (!(n45.level >= t))
    for (var e = n45.level + 1, r = n45.size / 2, o = [
      new Vector2(n45.position.x, n45.position.y),
      new Vector2(n45.position.x + r, n45.position.y),
      new Vector2(n45.position.x, n45.position.y + r),
      new Vector2(n45.position.x + r, n45.position.y + r)
    ], s = 0, u = o; s < u.length; s++) {
      var l = u[s], c = {
        face: n45.face,
        level: e,
        size: r,
        position: l,
        box: getBox(n45.face, l.x, l.y, r),
        parent: n45,
        children: []
      };
      n45.children.push(c), createChildren(c, t);
    }
};
function createTileCubeNode(n45, t) {
  var e = {
    level: 0,
    face: n45,
    position: new Vector2(0, 0),
    size: 1,
    box: getBox(n45, 0, 0, 1),
    parent: null,
    children: []
  };
  return createChildren(e, t), e;
}
function createTileCubeTree(n45) {
  var t = FACE_ORDER$1.map(function(e) {
    return createTileCubeNode(e, n45);
  });
  return { children: t };
}
function traverseTileCubeNode(n45, t) {
  for (var e = 0, r = n45.children; e < r.length; e++) {
    var o = r[e], s = t(o);
    s !== false && traverseTileCubeNode(o, t);
  }
}
function pick(n45, t) {
  for (var e = {}, r = 0, o = t; r < o.length; r++) {
    var s = o[r];
    s in n45 && (e[s] = n45[s]);
  }
  return e;
}
function omit(n45, t) {
  for (var e = __assign({}, n45), r = 0, o = t; r < o.length; r++) {
    var s = o[r];
    s in e && delete e[s];
  }
  return e;
}
var CUBE_GEOMETRY = new BoxBufferGeometry(1, 1, 1, 1, 1);
CUBE_GEOMETRY.deleteAttribute("uv");
CUBE_GEOMETRY.deleteAttribute("normal");
CUBE_GEOMETRY.groups = [];
CUBE_GEOMETRY.scale(-1, 1, 1);
var CUBE_VERTEX_SHADER = `
varying vec3 worldPosition;
void main() {
  vec4 transform = vec4(position, 1.0);
  worldPosition = (modelMatrix * transform).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * transform;
}
`;
var CUBE_RAGMENT_SHADER = `
uniform samplerCube map;
varying vec3 worldPosition;
void main() {
  gl_FragColor = textureCube(map, worldPosition);
}
`;
var CUBE_MATERIAL = new ShaderMaterial({
  uniforms: {
    map: {
      value: null
    }
  },
  vertexShader: CUBE_VERTEX_SHADER,
  fragmentShader: CUBE_RAGMENT_SHADER,
  depthTest: false,
  depthWrite: false,
  stencilWrite: false,
  blending: NoBlending,
  lights: false,
  toneMapped: false,
  fog: false
});
var scene$3 = new Scene();
scene$3.matrixAutoUpdate = false;
var mesh$5 = new Mesh(CUBE_GEOMETRY, CUBE_MATERIAL);
mesh$5.matrixAutoUpdate = false;
scene$3.add(mesh$5);
function renderCubeTextureToCubeRenderTarget(n45, t, e) {
  CUBE_MATERIAL.uniforms.map.value = n45;
  var r = e.autoClear;
  e.autoClear = false;
  var o = new CubeCamera(0.1, 2, t);
  o.matrixAutoUpdate = false, o.update(e, scene$3), e.autoClear = r, CUBE_MATERIAL.uniforms.map.value = null;
}
var _a$5;
var SQRT1_2$1 = (_a$5 = Math.SQRT1_2) !== null && _a$5 !== void 0 ? _a$5 : Math.sqrt(2);
var QUATERNION = {
  up: new Quaternion(SQRT1_2$1, 0, 0, SQRT1_2$1),
  down: new Quaternion(-SQRT1_2$1, 0, 0, SQRT1_2$1),
  left: new Quaternion(0, SQRT1_2$1, 0, SQRT1_2$1),
  right: new Quaternion(0, -SQRT1_2$1, 0, SQRT1_2$1),
  front: new Quaternion(0, 0, 0, 1),
  back: new Quaternion(0, 1, 0, 0)
};
var PLAME_GEOMETRY = function() {
  var n45 = new Float32Array([
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0,
    -0.5,
    0.5,
    0,
    0.5,
    0.5,
    0
  ]), t = new Float32Array([
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    1
  ]), e = new Uint8Array([
    0,
    1,
    2,
    1,
    3,
    2
  ]), r = new BufferGeometry();
  return r.setAttribute("position", new BufferAttribute(n45, 3)), r.setAttribute("uv", new BufferAttribute(t, 2)), r.setIndex(new BufferAttribute(e, 1)), r;
}();
var PLANE_VERTEX_SHADER = `
varying vec2 vUv;
uniform float flipY;
void main() {
  vUv = vec2(uv.x, mix(uv.y, (1.0 - uv.y), flipY));
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
var PLANE_FRAGMENT_SHADER = `
uniform sampler2D map;
varying vec2 vUv;
void main() {
  gl_FragColor = texture2D(map, vUv);
}
`;
var cacheMaterials = [];
var cameraPX = new PerspectiveCamera(90, 1, 0.1, 2);
cameraPX.up.set(0, -1, 0);
cameraPX.lookAt(new Vector3(1, 0, 0));
cameraPX.updateMatrix();
cameraPX.matrixAutoUpdate = false;
var cameraNX = new PerspectiveCamera(90, 1, 0.1, 2);
cameraNX.up.set(0, -1, 0);
cameraNX.lookAt(new Vector3(-1, 0, 0));
cameraNX.updateMatrix();
cameraNX.matrixAutoUpdate = false;
var cameraPY = new PerspectiveCamera(90, 1, 0.1, 2);
cameraPY.up.set(0, 0, 1);
cameraPY.lookAt(new Vector3(0, 1, 0));
cameraPY.updateMatrix();
cameraPY.matrixAutoUpdate = false;
var cameraNY = new PerspectiveCamera(90, 1, 0.1, 2);
cameraNY.up.set(0, 0, -1);
cameraNY.lookAt(new Vector3(0, -1, 0));
cameraNY.updateMatrix();
cameraNY.matrixAutoUpdate = false;
var cameraPZ = new PerspectiveCamera(90, 1, 0.1, 2);
cameraPZ.up.set(0, -1, 0);
cameraPZ.lookAt(new Vector3(0, 0, 1));
cameraPZ.updateMatrix();
cameraPZ.matrixAutoUpdate = false;
var cameraNZ = new PerspectiveCamera(90, 1, 0.1, 2);
cameraNZ.up.set(0, -1, 0);
cameraNZ.lookAt(new Vector3(0, 0, -1));
cameraNZ.updateMatrix();
cameraNZ.matrixAutoUpdate = false;
var FACES = {
  front: {
    camera: cameraPZ,
    index: 4
  },
  back: {
    camera: cameraNZ,
    index: 5
  },
  up: {
    camera: cameraPY,
    index: 2
  },
  down: {
    camera: cameraNY,
    index: 3
  },
  left: {
    camera: cameraNX,
    index: 1
  },
  right: {
    camera: cameraPX,
    index: 0
  }
};
function getMaterial() {
  var n45 = cacheMaterials.pop();
  return n45 || new ShaderMaterial({
    uniforms: {
      map: {
        value: null
      },
      flipY: {
        value: 0
      }
    },
    vertexShader: PLANE_VERTEX_SHADER,
    fragmentShader: PLANE_FRAGMENT_SHADER,
    depthTest: false,
    depthWrite: false,
    stencilWrite: false,
    blending: NoBlending,
    lights: false,
    toneMapped: false,
    fog: false
  });
}
function releaseMaterial(n45) {
  n45.uniforms.map.value = null, cacheMaterials.push(n45);
}
function renderTexturesToCubeRenderTarget(n45, t, e) {
  var r = new Scene();
  r.matrixAutoUpdate = false;
  var o = new Group();
  o.scale.set(1, 1, -1), r.add(o);
  for (var s = [], u = /* @__PURE__ */ new Set(), l = 0, c = n45; l < c.length; l++) {
    var f = c[l];
    u.add(f.face);
    var d = getMaterial();
    s.push(d), d.uniforms.map.value = f.texture, d.uniforms.flipY.value = f.flipY ? 1 : 0;
    var h = new Group(), v = new Mesh(PLAME_GEOMETRY, d);
    v.position.set(f.position.x + f.size.x / 2 - 0.5, 1 - (f.position.y + f.size.y / 2) - 0.5, -0.5), v.scale.set(f.size.x, f.size.y, 1), h.quaternion.copy(QUATERNION[f.face]), h.add(v), o.add(h);
  }
  var A = e.autoClear, g = e.sortObjects, p = e.xr.enabled, y = t.texture.generateMipmaps;
  e.autoClear = false, e.sortObjects = false, e.xr.enabled = false, t.texture.generateMipmaps = false;
  var m = e.getRenderTarget(), E = 0;
  u.forEach(function(R) {
    ++E === u.size && (t.texture.generateMipmaps = y), e.setRenderTarget(t, FACES[R].index), e.render(r, FACES[R].camera);
  }), e.setRenderTarget(m), e.autoClear = A, e.sortObjects = g, e.xr.enabled = p;
  for (var b = 0, T = s; b < T.length; b++) {
    var d = T[b];
    releaseMaterial(d);
  }
}
var canUseNativeImageBitmap = /* @__PURE__ */ function() {
  return false;
}();
function createImageBitmapLikeImage(n45) {
  n45 === void 0 && (n45 = {});
  var t = Object.assign(document.createElementNS("http://www.w3.org/1999/xhtml", "img"), {
    crossOrigin: "",
    close: function() {
      n45.onClose && n45.onClose.call(this), this.onerror = this.onload = this.close = noop$1, this.removeAttribute("src");
    }
  });
  return t;
}
function createImageBitmapLike(n45) {
  return new Promise(function(t, e) {
    var r = URL.createObjectURL(n45), o = createImageBitmapLikeImage({
      onClose: function() {
        this.src === r && URL.revokeObjectURL(r);
      }
    });
    o.onload = function() {
      o.src === r && URL.revokeObjectURL(r), o.onload = o.onerror = noop$1, setTimeout(function() {
        t(o);
      }, 10);
    }, o.onerror = function() {
      var s = o.src;
      o.onload = o.onerror = noop$1, o.close(), e(new Error("image load error: ".concat(s)));
    }, o.decoding = "async", o.src = r;
  });
}
var canvasPool = [];
function createCanvas(n45, t) {
  var e = canvasPool.shift();
  if (e)
    return e.width = n45, e.height = t, e;
  var r = Object.assign(document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), {
    close: function() {
      r.close = noop$1, canvasPool.push(r);
    }
  });
  return r;
}
function poolImageToTexture(n45, t) {
  if (t && (n45.width > t.width || n45.height > t.height)) {
    var e = createCanvas(Math.min(n45.width, t.width), Math.min(n45.height, t.height)), r = e.getContext("2d");
    r.clearRect(0, 0, e.width, e.height), r.drawImage(n45, 0, 0, e.width, e.height), n45.close();
    var o = new Texture(e);
    o.needsUpdate = true, o.flipY = true;
    var s = o.dispose;
    return o.dispose = function() {
      e.close(), s.call(o), o.dispose = s;
    }, o;
  } else {
    var u = new Texture(n45);
    u.needsUpdate = true, typeof ImageBitmap != "undefined" && n45 instanceof ImageBitmap ? u.flipY = false : u.flipY = true;
    var l = u.dispose;
    return u.dispose = function() {
      n45.close(), l.call(u), u.dispose = l;
    }, u;
  }
}
function poolImagesToCubeTexture(n45) {
  var t = new CubeTexture(n45);
  t.needsUpdate = true, t.flipY = false;
  var e = t.dispose;
  return t.dispose = function() {
    for (var r = 0, o = n45; r < o.length; r++) {
      var s = o[r];
      s.close();
    }
    e.call(t), t.dispose = e;
  }, t;
}
var sharedSortVector3$1 = new Vector3();
var FACE_ORDER = ["right", "left", "up", "down", "front", "back"];
var TileCubeTextureTarget = (
  /** @class */
  function() {
    function n45(t, e, r, o, s) {
      var u, l, c;
      this.tileTree = e, this.tileSources = r, this.options = o, this.renderer = s, this.name = "", this.needsRender = false, this.baseLevel = 0, this.maxRequest = n45.DEFAULT_MAX_REQUEST, this.disposed = false, this.loadedCubeNodes = /* @__PURE__ */ new Set(), this.loadingCubeNodes = /* @__PURE__ */ new Set(), this.drawedCubeNodes = /* @__PURE__ */ new Set(), this.baseCubeTexture = null, this._cubeRenderTarget = null, this.prepareToRender = [], this.baseCubeTexture = t;
      var f = (u = this.baseCubeTexture.images) !== null && u !== void 0 ? u : [], d = Array.isArray(f) && f[0] && f[0].width || ((c = (l = o.imageURL) === null || l === void 0 ? void 0 : l.options) === null || c === void 0 ? void 0 : c.size);
      typeof d != "number" && (d = 2048), this.baseLevel = Math.floor(d / 512) - 1;
    }
    return Object.defineProperty(n45.prototype, "cubeRenderTarget", {
      get: function() {
        return this._cubeRenderTarget;
      },
      set: function(t) {
        var e, r, o, s, u, l;
        if (t === null)
          throw new Error("cannot set cubeRenderTarget to null.");
        t.width !== this.options.textureSize && t.setSize(this.options.textureSize, this.options.textureSize), t.texture.format = (e = this.options.format) !== null && e !== void 0 ? e : RGBAFormat, t.texture.minFilter = (r = this.options.minFilter) !== null && r !== void 0 ? r : LinearFilter, t.texture.magFilter = (o = this.options.magFilter) !== null && o !== void 0 ? o : LinearFilter, t.texture.wrapS = (s = this.options.wrapS) !== null && s !== void 0 ? s : ClampToEdgeWrapping, t.texture.wrapT = (u = this.options.wrapT) !== null && u !== void 0 ? u : ClampToEdgeWrapping, t.texture.generateMipmaps = (l = this.options.generateMipmaps) !== null && l !== void 0 ? l : true, this.baseCubeTexture && (renderCubeTextureToCubeRenderTarget(this.baseCubeTexture, t, this.renderer), this.baseCubeTexture.dispose(), this.baseCubeTexture = null), this._cubeRenderTarget && renderCubeTextureToCubeRenderTarget(this._cubeRenderTarget.texture, t, this.renderer), this._cubeRenderTarget = t;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.requestTile = function(t) {
      var e = this, r, o, s, u, l, c, f = this.tileSources.filter(function(p) {
        return p.level === t.level;
      })[0];
      if (this.baseLevel >= t.level || !f)
        return this.loadedCubeNodes.add(t), this.prepareToRender.push({
          node: t,
          texture: null
        }), false;
      var d = f.size, h = Math.pow(2, t.level) * t.position.y, v = Math.pow(2, t.level) * t.position.x, A = "".concat(((s = (o = (r = this.options.imageURL) === null || r === void 0 ? void 0 : r.options) === null || o === void 0 ? void 0 : o.key) !== null && s !== void 0 ? s : "pano.0").replace(/^pano/, "pano_tile"), ".").concat(t.face, ".").concat(t.level, ".").concat(h, ".").concat(v), g = __assign(__assign({}, pick((l = (u = this.options.imageURL) === null || u === void 0 ? void 0 : u.options) !== null && l !== void 0 ? l : { key: "unknown" }, ["format", "sharpen", "mappings"])), { key: A, size: f.scale >= 1 ? void 0 : d * t.size * f.scale, cut: t.size === 1 ? void 0 : [
        d * t.position.x,
        d * t.position.y,
        d * t.size,
        d * t.size
      ] });
      return t.size === 1 && console.warn("tile: ".concat(g.key, " should not appear.")), t.level === 1 && f.scale >= 0.5 && (g.format === "jpg" || /\.jpg$/.test(f[t.face])) && (g.size = void 0, g.quality || (g.quality = 70)), this.loadingCubeNodes.add(t), this.options.textureLoader.loadTexture(f[t.face], {
        imageURL: {
          transform: (c = this.options.imageURL) === null || c === void 0 ? void 0 : c.transform,
          options: __assign({}, g)
        },
        format: RGBAFormat,
        timeout: this.options.timeout,
        magFilter: this.options.magFilter,
        minFilter: this.options.minFilter,
        fetcher: this.options.fetcher
      }).then(function(p) {
        if (e.disposed) {
          p.body.dispose();
          return;
        }
        e.prepareToRender.push({
          node: t,
          texture: p.body
        }), e.loadedCubeNodes.add(t);
      }).catch(noop$1).then(function() {
        e.disposed || e.loadingCubeNodes.delete(t);
      }), true;
    }, n45.prototype.update = function(t, e) {
      var r = this;
      if (!this.disposed) {
        var o = t.planes[5].normal, s = Math.max(this.maxRequest - this.loadingCubeNodes.size, 0), u = [];
        traverseTileCubeNode(this.tileTree, function(m) {
          if (m.level > e || !t.intersectsBox(m.box))
            return false;
          !r.loadedCubeNodes.has(m) && !r.loadingCubeNodes.has(m) && u.push(m);
        }), u.sort(function(m, E) {
          return m.level !== E.level ? m.level - E.level : m.box.getCenter(sharedSortVector3$1).angleTo(o) - E.box.getCenter(sharedSortVector3$1).angleTo(o);
        });
        for (var l = 0, c = u; l < c.length; l++) {
          var f = c[l];
          if (s <= 0)
            break;
          var d = this.requestTile(f);
          d && s--;
        }
        if (this.cubeRenderTarget && this.prepareToRender.length) {
          this.prepareToRender.sort(function(m, E) {
            return m.node.level - E.node.level;
          });
          for (var h = [], v = 0; v < this.prepareToRender.length; v++) {
            var A = this.prepareToRender[v], f = A.node, g = A.texture;
            (f.parent === null || this.drawedCubeNodes.has(f.parent)) && (this.drawedCubeNodes.add(f), g && h.push({
              face: f.face,
              position: f.position,
              size: new Vector2(f.size, f.size),
              texture: g,
              flipY: !g.flipY
            }), this.prepareToRender.splice(v, 1), v--);
          }
          if (h.length) {
            renderTexturesToCubeRenderTarget(h, this.cubeRenderTarget, this.renderer);
            for (var p = 0, y = h; p < y.length; p++) {
              var g = y[p];
              g.texture.dispose();
            }
            this.needsRender = true;
          }
        }
      }
    }, Object.defineProperty(n45.prototype, "tilePending", {
      get: function() {
        return this.loadingCubeNodes.size;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "texture", {
      get: function() {
        if (!this._cubeRenderTarget)
          throw new Error("cubeRenderTarget never set.");
        return this._cubeRenderTarget.texture;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.dispose = function() {
      if (!this.disposed) {
        this.disposed = true, this.baseCubeTexture && (this.baseCubeTexture.dispose(), this.baseCubeTexture = null), this.loadingCubeNodes.clear(), this.loadedCubeNodes.clear();
        for (var t = 0, e = this.prepareToRender; t < e.length; t++) {
          var r = e[t];
          r.texture && r.texture.dispose();
        }
        this.prepareToRender.length = 0;
      }
    }, n45.DEFAULT_MAX_REQUEST = 3, n45;
  }()
);
var TextureLoader2 = (
  /** @class */
  function() {
    function n45() {
    }
    return n45.prototype.loadTexture = function(t, e, r, o, s, u) {
      var l, c, f, d, h, v, A;
      r === void 0 && (r = noop$1), o === void 0 && (o = noop$1), s === void 0 && (s = noop$1);
      var g = {};
      typeof e.flipY != "undefined" && (g.flipY = e.flipY), typeof e.format != "undefined" && (g.format = e.format), typeof e.encoding != "undefined" && (g.encoding = e.encoding), g.generateMipmaps = (l = e.generateMipmaps) !== null && l !== void 0 ? l : false, g.minFilter = (c = e.minFilter) !== null && c !== void 0 ? c : LinearFilter, g.magFilter = (f = e.magFilter) !== null && f !== void 0 ? f : LinearFilter;
      var p = (h = (d = e.imageURL) === null || d === void 0 ? void 0 : d.options) !== null && h !== void 0 ? h : { key: "unknown" };
      t = applyImageURLOptions(t, (v = e.imageURL) === null || v === void 0 ? void 0 : v.transform, p);
      var y = getProtocol(t), m = (A = e.viaAjax) !== null && A !== void 0 ? A : canUseNativeImageBitmap, E = isJsonpSource(t), b = /^https?:/.test(y);
      if (E ? m = true : b || (m = false), m) {
        var T = null, R = "blob";
        return e.fetcher.ajax(t, { timeout: e.timeout, responseType: R }, void 0, void 0, s).then(function(w) {
          return createImageBitmapLike(w.body);
        }).then(function(w) {
          return poolImageToTexture(w, e.maxSize);
        }).then(function(w) {
          return Object.assign(w, g), w;
        }).then(function(w) {
          var H = { meta: T, body: w };
          return r(H), H;
        }).catch(function(w) {
          return o(w), Promise.reject(w);
        });
      } else {
        var S = null, M;
        return Promise.resolve().then(function() {
          return createImageBitmapLikeImage();
        }).then(function(w) {
          return M = w, e.fetcher.loadImage(t, { timeout: e.timeout }, void 0, void 0, s, w);
        }).then(function(w) {
          return S = w.meta, poolImageToTexture(w.body, e.maxSize);
        }).then(function(w) {
          return Object.assign(w, g), w;
        }).then(function(w) {
          var H = { meta: S, body: w };
          return r(H), H;
        }).catch(function(w) {
          return M && M.close(), o(w), Promise.reject(w);
        });
      }
    }, n45.prototype.loadCubeTexture = function(t, e, r, o, s, u) {
      var l, c, f, d, h, v, A;
      r === void 0 && (r = noop$1), o === void 0 && (o = noop$1), s === void 0 && (s = noop$1);
      var g = {};
      typeof e.format != "undefined" && (g.format = e.format), g.generateMipmaps = (l = e.generateMipmaps) !== null && l !== void 0 ? l : false, g.minFilter = (c = e.minFilter) !== null && c !== void 0 ? c : LinearFilter, g.magFilter = (f = e.magFilter) !== null && f !== void 0 ? f : LinearFilter;
      for (var p = [
        t[FACE_ORDER[0]],
        t[FACE_ORDER[1]],
        t[FACE_ORDER[2]],
        t[FACE_ORDER[3]],
        t[FACE_ORDER[4]],
        t[FACE_ORDER[5]]
      ], y = [], m = [0, 0, 0, 0, 0, 0], E = [], b = function(R) {
        var S = (h = (d = e.imageURL) === null || d === void 0 ? void 0 : d.options) !== null && h !== void 0 ? h : { key: "unknown" }, M = applyImageURLOptions(p[R], (v = e.imageURL) === null || v === void 0 ? void 0 : v.transform, __assign(__assign({}, S), { key: S.key + "." + FACE_ORDER[R] })), w = getProtocol(M), H = function(N) {
          m[R] = N, s(m.reduce(function(k, U) {
            return k + U;
          }, 0) / 6);
        }, L = (A = e.viaAjax) !== null && A !== void 0 ? A : false, C = /^https?:$/.test(w), I = isJsonpSource(M);
        if (I ? L = true : C || (L = false), L) {
          var _ = "blob", O = e.fetcher.ajax(M, { timeout: e.timeout, responseType: _ }, void 0, void 0, H).then(function(N) {
            return E[R] = N.meta, createImageBitmapLike(N.body);
          });
          y.push(O);
        } else {
          var P, O = Promise.resolve().then(function() {
            return createImageBitmapLikeImage();
          }).then(function(k) {
            return P = k, e.fetcher.loadImage(M, { timeout: e.timeout }, void 0, void 0, H, k);
          }).then(function(k) {
            return E[R] = k.meta, k.body;
          }).catch(function(k) {
            return P && P.close(), Promise.reject(k);
          });
          y.push(O);
        }
      }, T = 0; T < 6; T++)
        b(T);
      return Promise.all(y).then(function(R) {
        return poolImagesToCubeTexture(R);
      }).then(function(R) {
        return Object.assign(R, __assign({ encoding: sRGBEncoding }, g)), R;
      }).then(function(R) {
        var S = {
          body: R,
          meta: E
        };
        return r(S), S;
      }).catch(function(R) {
        for (var S = 0, M = y; S < M.length; S++) {
          var w = M[S];
          w.then(function(H) {
            return H.close();
          }).catch(noop$1);
        }
        return o(R), Promise.reject(R);
      });
    }, n45.prototype.loadTiledCubeTexture = function(t, e, r, o, s, u, l) {
      var c = this;
      return o === void 0 && (o = noop$1), s === void 0 && (s = noop$1), u === void 0 && (u = noop$1), new Promise(function(f, d) {
        var h, v;
        c.loadCubeTexture(t, {
          imageURL: {
            transform: (h = r.imageURL) === null || h === void 0 ? void 0 : h.transform,
            options: (v = r.imageURL) === null || v === void 0 ? void 0 : v.options
          },
          format: RGBAFormat,
          viaAjax: r.viaAjax,
          timeout: r.timeout,
          fetcher: r.fetcher,
          magFilter: r.magFilter,
          minFilter: r.minFilter,
          generateMipmaps: r.generateMipmaps
        }, function(A) {
          var g, p = A.meta, y = A.body, m = (g = r.tileMaxLevel) !== null && g !== void 0 ? g : 2, E = Math.max(1024 * m, 512), b = createTileCubeTree(m), T = new TileCubeTextureTarget(y, b, e, {
            textureSize: E,
            textureLoader: c,
            imageURL: r.imageURL,
            magFilter: r.magFilter,
            minFilter: r.minFilter,
            generateMipmaps: r.generateMipmaps,
            timeout: r.timeout,
            fetcher: r.fetcher
          }, l), R = { meta: p, body: T };
          o(R), f(R);
        }, function(A) {
          s(A), d(A);
        }, u, l).catch(noop$1);
      });
    }, n45;
  }()
);
var meshNoneVertexShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("n\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{H0v{pyqr-Ip|zz|{K0v{pyqr-Iz|}untrl}nlrr\x07K0v{pyqr-Ixv{{v{tl}nlrr\x07K0v{pyqr-Iy|tqr}uosl}nlrr\x07K0v{pyqr-Ipyv}}v{tl}yn{rl}nlrr\x07KZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--0v{pyqr-Ixv{onrlrr\x07K--0v{pyqr-Iortv{lrr\x07K--0v{pyqr-Iz|}untrlrr\x07K--0v{pyqr-Ixv{{v{tlrr\x07K--0v{pyqr-I}|wrplrr\x07K--0v{pyqr-Iy|tqr}uoslrr\x07K--0v{pyqr-Ipyv}}v{tl}yn{rlrr\x07K--Sv{ny]|vv|{-J-rpA5n{s|zrq9->;=6H--0vsqrs-b`RlV[`aN[PV[T----Sv{ny]|vv|{-J-v{n{prZnv\x07-7-Sv{ny]|vv|{H--0r{qvs--Sv{ny]|vv|{-J-z|qryZnv\x07-7-Sv{ny]|vv|{H--zn@-pnzrn_|nv|{Znv\x07-J-zn@5vrZnv\x07h=jh=j9-vrZnv\x07h>jh=j9-vrZnv\x07h?jh=j9-vrZnv\x07h=jh>j9-vrZnv\x07h>jh>j9-vrZnv\x07h?jh>j9-vrZnv\x07h=jh?j9-vrZnv\x07h>jh?j9-vrZnv\x07h?jh?j6H--PnzrnQvrpv|{-J-{|znyv	r5pnzrn_|nv|{Znv\x07-7-rp@5=;=9-=;=9-:>;=66H--0v{pyqr-I|yq}|lrr\x07K--0v{pyqr-Is|tlrr\x07K--ZNV[lR[Q\f");
var meshNoneFragmentShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-OYNPXlP\\Y\\_-rpA5=;=EC9-=;>=C9-=;>AF9->;=6{vs|z-nz}yrPor-}n{|=lzn}H{vs|z-znA-}n{|=lznv\x07H{vs|z-sy|n-}n{|=l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|=lyzv{n{prZn}H0r{qvs{vs|z-nz}yrPor-}n{|>lzn}H{vs|z-znA-}n{|>lznv\x07H{vs|z-sy|n-}n{|>l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|>lyzv{n{prZn}H0r{qvs{vs|z-sy|n-z|qryNy}unH{vs|z-sy|n-}|trHn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{H{vs|z-sy|n-u|{Sy||V{qr\x07H{vs|z-rp?-r|yv|{H{vs|z-sy|n-}v\x07ry_nv|H0vs{qrs-SYNal`UNQRQ--n\bv{t-rp@-[|znyH0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-Iqvurv{tl}nlsntzr{K0v{pyqr-Is|tl}nlsntzr{K0v{pyqr-I}rpynzn}l}nlsntzr{K0v{pyqr-Iy|tqr}uosl}nlsntzr{K0v{pyqr-Ipyv}}v{tl}yn{rl}nlsntzr{Krp@-	||zcrp|5rp@-qvrpv|{9-rp@-rp|9-sy|n-	||z6-\n--sy|n-urn-J-q|5qvrpv|{9-rp|6H--rp@-q-J-qvrpv|{-7-urnH--rp@-}-J-rp|-:-qH--rp@-\0-J-}-7-	||zH--r{-{|znyv	r5q-8-\x006H\fZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--0v{pyqr-Ipyv}}v{tl}yn{rlsntzr{K--<<-JJJ--JJJ--rp@-}n{|=a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|=lznv\x07h@j;\x07\b	6H--}n{|=a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|=a|crr\x079-}n{|=l	||z6H--}n{|=a|crr\x07-J-}n{|=a|crr\x07-7-zn@5}n{|=lznv\x076H--rp@-}n{|>a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|>lznv\x07h@j;\x07\b	6H--}n{|>a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|>a|crr\x079-}n{|>l	||z6H--}n{|>a|crr\x07-J-}n{|>a|crr\x07-7-zn@5}n{|>lznv\x076H--rpA-}n{|P|y|H--rpA-}n{|=P|y|-J-r\x07rPor5}n{|=lzn}9-}n{|=a|crr\x076H--rpA-}n{|>P|y|-J-r\x07rPor5}n{|>lzn}9-}n{|>a|crr\x076H--0vs-qrsv{rq5b`RlYbZV[N[PR6----}n{|=P|y|;n-J->;=-:-r\x07rPor5}n{|=lyzv{n{prZn}9-}n{|=a|crr\x076;H----}n{|>P|y|;n-J->;=-:-r\x07rPor5}n{|>lyzv{n{prZn}9-}n{|>a|crr\x076;H--0r{qvs--0vs-qrsv{rq5b`RlOYNPXla_N[`VaV\\[6----sy|n-oynpx]|tr-J-np|5:?;=-7-}|tr-8->;=6H----}n{|P|y|-J-zv\x075}n{|=P|y|9-OYNPXlP\\Y\\_9-zv{5>;=9-oynpx]|tr66H----}n{|P|y|-J-zv\x075}n{|P|y|9-}n{|>P|y|9-zn\x075=;=9-oynpx]|tr-:-]V-8->;=66H--0ryvs-qrsv{rq5b`Rl`]_RNQla_N[`VaV\\[6----rp?-prr{Pr{rP||q-J-r|yv|{-7-}v\x07ry_nv|-<-?;=H----sy|n-n{vv|{_nqv-J-qvn{pr5rp?5=;=9-=;=69-prr{Pr{rP||q6-7->;?H----sy|n-n{vv|{]|tr-J--qvn{pr5tylSntP||q;\x07\b9-prr{Pr{rP||q6-<-n{vv|{_nqvH----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-z||ur}5=;=9-=;?9-}|tr-:-n{vv|{]|tr66H--0ryr----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-}|tr6H--0r{qvs--tylSntP|y|-J-zv\x075}n{|P|y|9-rpA5}n{|P|y|;to9-=;=69-pynz}5z|qryNy}un-7-@=;=9-=;=9->;=66H--<<-JJJJJJJJJJJJJJJJ--ZNV[lZ\\QRYlP\\Y\\_--0v{pyqr-Is|tlsntzr{K--0v{pyqr-I}rzyv}yvrqlny}unlsntzr{K--0v{pyqr-Iqvurv{tlsntzr{K--ZNV[lR[Q\f");
var meshBasicVertexShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-ZN_Xl`aR]->;=0qrsv{r-_\\\\SlZN_X->;=0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvs0vs-qrsv{rq5b`RlcR_aRelZN_X6--nvor-sy|n-lsrnrlvqlznxH0r{qvsn\bv{t-sy|n-_||sZnxHn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-rp@-cvr]|vv|{H0vs{qrs-SYNal`UNQRQ--n\bv{t-rp@-[|znyH--0vsqrs-b`RlaN[TR[a----n\bv{t-rp@-an{tr{H----n\bv{t-rp@-Ovn{tr{H--0r{qvs0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-Il}nlrr\x07K0v{pyqr-I?l}nlrr\x07K0v{pyqr-Ir{zn}l}nlrr\x07K0v{pyqr-Ip|y|l}nlrr\x07K0v{pyqr-Is|tl}nlrr\x07K0v{pyqr-Iz|}untrl}nlrr\x07K0v{pyqr-Ixv{{v{tl}nlrr\x07K0v{pyqr-Iy|tqr}uosl}nlrr\x07K0v{pyqr-Ipyv}}v{tl}yn{rl}nlrr\x07KZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--0v{pyqr-Ilrr\x07K--0v{pyqr-I?lrr\x07K--0v{pyqr-Ip|y|lrr\x07K--0v{pyqr-Ixv{onrlrr\x07K--0v{pyqr-Iortv{{|znylrr\x07K--0v{pyqr-Iz|}u{|znylrr\x07K--0v{pyqr-Ixv{{|znylrr\x07K--0v{pyqr-Iqrsny{|znylrr\x07K--0vs{qrs-SYNal`UNQRQ-<<-[|zny-p|z}rq-vu-qrvnvr-ur{-SYNal`UNQRQ--[|zny-J-{|znyv	r5-n{s|zrq[|zny-6H--0r{qvs--0v{pyqr-Iortv{lrr\x07K--0v{pyqr-Iz|}untrlrr\x07K--0v{pyqr-Ixv{{v{tlrr\x07K--0v{pyqr-I}|wrplrr\x07K--0v{pyqr-Iy|tqr}uoslrr\x07K--0v{pyqr-Ipyv}}v{tl}yn{rlrr\x07K--cvr]|vv|{-J-:z]|vv|{;\x07\b	H--Sv{ny]|vv|{-J-rpA5n{s|zrq9->;=6H--0vsqrs-b`RlV[`aN[PV[T----Sv{ny]|vv|{-J-v{n{prZnv\x07-7-Sv{ny]|vv|{H--0r{qvs--Sv{ny]|vv|{-J-z|qryZnv\x07-7-Sv{ny]|vv|{H--zn@-pnzrn_|nv|{Znv\x07-J-zn@5vrZnv\x07h=jh=j9-vrZnv\x07h>jh=j9-vrZnv\x07h?jh=j9-vrZnv\x07h=jh>j9-vrZnv\x07h>jh>j9-vrZnv\x07h?jh>j9-vrZnv\x07h=jh?j9-vrZnv\x07h>jh?j9-vrZnv\x07h?jh?j6H--PnzrnQvrpv|{-J-{|znyv	r5pnzrn_|nv|{Znv\x07-7-rp@5=;=9-=;=9-:>;=66H--0vs-qrsv{rq5b`RlRQY6----Y|tQr}u-J-y|t?5:z]|vv|{;	6H--0r{qvs--_||sZnx-J-=;=H--0vs-qrsv{rq5b`RlcR_aRelZN_X6----_||sZnx-J-z||ur}5_\\\\SlZN_X-:-ZN_Xl`aR]9-_\\\\SlZN_X9-lsrnrlvqlznx6H--0r{qvs--0v{pyqr-I|yq}|lrr\x07K--0v{pyqr-Ir{zn}lrr\x07K--0v{pyqr-Is|tlrr\x07K--ZNV[lR[Q\f");
var meshBasicFragmentShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-OYNPXlP\\Y\\_-rpA5=;=EC9-=;>=C9-=;>AF9->;=6{vs|z-sy|n-sy||V{qr\x07H{vs|z-nz}yrPor-}n{|=lzn}H{vs|z-znA-}n{|=lznv\x07H{vs|z-sy|n-}n{|=l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|=lyzv{n{prZn}H0r{qvs{vs|z-nz}yrPor-}n{|>lzn}H{vs|z-znA-}n{|>lznv\x07H{vs|z-sy|n-}n{|>l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|>lyzv{n{prZn}H0r{qvs{vs|z-sy|n-z|qryNy}unH{vs|z-sy|n-}|trH0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6--{vs|z-rp@-p|{n{P|y|H0r{qvs0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6--{vs|z-nz}yr?Q-tnqvr{ar\x07rH0r{qvsp-Pyv}}r-\n--znA-znv\x07V{rrH--sy|n-sy||V{qr\x07H\fH0vs-[bZlPYV]]R_`-K-=--{vs|z-Pyv}}r-pyv}}rh[bZlPYV]]R_`jH0r{qvs0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvsn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-rp@-cvr]|vv|{Hn\bv{t-sy|n-_||sZnxH{vs|z-sy|n-u|{Sy||V{qr\x07H{vs|z-rp?-r|yv|{H{vs|z-sy|n-}v\x07ry_nv|H{vs|z-rp@-qvssrH{vs|z-sy|n-p|y|Ny}unH{vs|z-sy|n-|}npv\bH{vs|z-sy|n-ovtu{rH{vs|z-rp@-z|qryO|{qv{tZn\x07H{vs|z-rp@-z|qryO|{qv{tZv{H<<u{vs|z-sy|n-p|y|`nnv|{H{vs|z-sy|n-p|y|Ovtu{rH0vs{qrs-SYNal`UNQRQ--n\bv{t-rp@-[|znyH--0vsqrs-b`RlaN[TR[a----n\bv{t-rp@-an{tr{H----n\bv{t-rp@-Ovn{tr{H--0r{qvs0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-Iqvurv{tl}nlsntzr{K0v{pyqr-Ip|y|l}nlsntzr{K0v{pyqr-Il}nlsntzr{K0v{pyqr-I?l}nlsntzr{K0v{pyqr-Izn}l}nlsntzr{K0v{pyqr-Iny}unzn}l}nlsntzr{K0v{pyqr-In|zn}l}nlsntzr{K0v{pyqr-Iyvtuzn}l}nlsntzr{K0v{pyqr-Ir{zn}lp|zz|{l}nlsntzr{K0v{pyqr-Ir{zn}l}nlsntzr{K0v{pyqr-Iporllrsyrpv|{lsntzr{K0v{pyqr-Is|tl}nlsntzr{K0v{pyqr-I}rpynzn}l}nlsntzr{K0v{pyqr-Iy|tqr}uosl}nlsntzr{K0v{pyqr-Ipyv}}v{tl}yn{rl}nlsntzr{Krp@-	||zcrp|5rp@-qvrpv|{9-rp@-rp|9-sy|n-	||z6-\n--sy|n-urn-J-q|5qvrpv|{9-rp|6H--rp@-q-J-qvrpv|{-7-urnH--rp@-}-J-rp|-:-qH--rp@-\0-J-}-7-	||zH--r{-{|znyv	r5q-8-\x006H\frp@-to?u5rp@-p6-\n----rpA-X-J-rpA5=;=9-:>;=-<-@;=9-?;=-<-@;=9-:>;=6H----rpA-}-J-zv\x075rpA5p;ot9-X;	69-rpA5p;to9-X;\x07\b69-r}5p;o9-p;t66H----rpA-\0-J-zv\x075rpA5};\x07\b9-p;69-rpA5p;9-};\b	\x0769-r}5};\x079-p;66H----sy|n-q-J-\0;\x07-:-zv{5\0;9-\0;\b6H----sy|n-r-J->;=r:>=H----r{-rp@5no5\0;	-8-5\0;-:-\0;\b6-<-5C;=-7-q-8-r669-q-<-5\0;\x07-8-r69-\0;\x076H\frp@-u?to5rp@-p6-\n----rpA-X-J-rpA5>;=9-?;=-<-@;=9->;=-<-@;=9-@;=6H----rp@-}-J-no5snp5p;\x07\x07\x07-8-X;\x07\b	6-7-C;=-:-X;6H----r{-p;	-7-zv\x075X;\x07\x07\x079-pynz}5}-:-X;\x07\x07\x079-=;=9->;=69-p;\b6H\frp@-trP|y|O\bUrvtu5nz}yr?Q-tnqvr{ar\x07r9-rpA-Sv{ny]|vv|{6-\n--sy|n--J-5Sv{ny]|vv|{;\b-:-z|qryO|{qv{tZv{;\b6-<-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6H--r{-r\x07r?Q5tnqvr{ar\x07r9-rp?59-=;B66;toH\fZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--<<-JJJ--JJJ--sy|n-||sP]|tr-J-}|5pynz}5:PnzrnQvrpv|{;\b9-=;=9->;=69-@;=6H--vs-5----_||sZnx-K-=;==>-33----Sv{ny]|vv|{;\b-K-z|qryO|{qv{tZn\x07;\b-:-||sP]|tr-7-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6--6-\n----qvpnqH--\f--<<-JJJJJJJJJJJJJJ--<<-JJJ--JJJ--0vs-[bZlPYV]]R_`-K-=----o||y-pyv}}rqH----rpA-pyv}}r]|vv|{H----0}ntzn-{|yyly||}ln----s|-5-v{-v-J-=H-v-I-[bZlPYV]]R_`H-v-88-6-\n------pyv}}r]|vv|{-J-pyv}}rh-v-j;znv\x07V{rr-7-Sv{ny]|vv|{H------pyv}}rq-J-5pyv}}rh-v-j;sy||V{qr\x07-I-=;=-\v\v-no5sy||V{qr\x07-:-pyv}}rh-v-j;sy||V{qr\x076-I->;=6H------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\x07-K-:=;B-33-pyv}}r]|vv|{;\x07-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\b-K-:=;B-33-pyv}}r]|vv|{;\b-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;	-K-:=;B-33-pyv}}r]|vv|{;	-I-=;BH------vs-5pyv}}rq6-\n--------qvpnqH------\f----\f----0}ntzn-{|yyly||}lr{q--0r{qvs--<<-JJJJJJJJJJJJJJJJJJ--0v{pyqr-Ipyv}}v{tl}yn{rlsntzr{K--rpA-qvssrP|y|-J-rpA5-qvssr9-p|y|Ny}un-7-|}npv\b-6H--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6----qvssrP|y|;to-J-trP|y|O\bUrvtu5tnqvr{ar\x07r9-Sv{ny]|vv|{6H--0r{qvs--<<-JJJJJJJJJJJ--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6----qvssrP|y|;to-J-p|{n{P|y|H--0r{qvs--<<-JJJJJJJJJJJ--0v{pyqr-Iy|tqr}uoslsntzr{K--0v{pyqr-Izn}lsntzr{K--0v{pyqr-Ip|y|lsntzr{K--0v{pyqr-Iny}unzn}lsntzr{K--0v{pyqr-Iny}unrlsntzr{K--0v{pyqr-I}rpynzn}lsntzr{K--0v{pyqr-I{|znylsntzr{lortv{K--_rsyrprqYvtu-rsyrprqYvtu-J-_rsyrprqYvtu5-rp@5-=;=-69-rp@5-=;=-69-rp@5-=;=-69-rp@5-=;=-6-6H--<<-nppzynv|{-5onxrq-v{qvrp-yvtuv{t-|{y\b6--0vsqrs-b`RlYVTUaZN]----rpA-yvtuZn}ar\x07ryJ-r\x07r?Q5-yvtuZn}9-b?-6H----rsyrprqYvtu;v{qvrpQvssr-8J-yvtuZn}ar\x07rya|Yv{rn5-yvtuZn}ar\x07ry-6;to-7-yvtuZn}V{r{v\bH--0ryr----rsyrprqYvtu;v{qvrpQvssr-8J-rp@5->;=-6H--0r{qvs--<<-z|qynv|{--0v{pyqr-In|zn}lsntzr{K--rsyrprqYvtu;v{qvrpQvssr-7J-qvssrP|y|;toH--rp@-|t|v{tYvtu-J-rsyrprqYvtu;v{qvrpQvssrH--0v{pyqr-Ir{zn}lsntzr{K--tylSntP|y|-J-rpA5-|t|v{tYvtu9-qvssrP|y|;n-6H--<<-JJJ--JJJ--sy|n-sy||\\}npv\b-J->;=H--vs-5u|{Sy||V{qr\x07-K-:=;=>-33-no5sy||V{qr\x07-:-u|{Sy||V{qr\x076-K-=;FF6-\n----sy||\\}npv\b-J-=;?-7-zv{55>;=-8-PnzrnQvrpv|{;\b69->;=6H--\f--tylSntP|y|;n-J-tylSntP|y|;n-7-sy||\\}npv\b-7-ovtu{rH--<<-JJJJJJJJJJJJJJ--ZNV[lZ\\QRYlP\\Y\\_--<<---0v{pyqr-I|{rzn}}v{tlsntzr{K--0v{pyqr-Ir{p|qv{tlsntzr{K--<<-JJJ--JJJ--rp@-toP|y|-J-tylSntP|y|;toH--rp@-uP|y|-J-to?u5toP|y|6H--uP|y|;\b-8J-p|y|`nnv|{H--uP|y|;	-8J-p|y|Ovtu{rH--tylSntP|y|;to-J-u?to5uP|y|6H--<<-JJJ--JJJ--rp@-}n{|=a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|=lznv\x07h@j;\x07\b	6H--}n{|=a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|=a|crr\x079-}n{|=l	||z6H--}n{|=a|crr\x07-J-}n{|=a|crr\x07-7-zn@5}n{|=lznv\x076H--rp@-}n{|>a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|>lznv\x07h@j;\x07\b	6H--}n{|>a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|>a|crr\x079-}n{|>l	||z6H--}n{|>a|crr\x07-J-}n{|>a|crr\x07-7-zn@5}n{|>lznv\x076H--rpA-}n{|P|y|H--rpA-}n{|=P|y|-J-r\x07rPor5}n{|=lzn}9-}n{|=a|crr\x076H--rpA-}n{|>P|y|-J-r\x07rPor5}n{|>lzn}9-}n{|>a|crr\x076H--0vs-qrsv{rq5b`RlYbZV[N[PR6----}n{|=P|y|;n-J->;=-:-r\x07rPor5}n{|=lyzv{n{prZn}9-}n{|=a|crr\x076;H----}n{|>P|y|;n-J->;=-:-r\x07rPor5}n{|>lyzv{n{prZn}9-}n{|>a|crr\x076;H--0r{qvs--0vs-qrsv{rq5b`RlOYNPXla_N[`VaV\\[6----sy|n-oynpx]|tr-J-np|5:?;=-7-}|tr-8->;=6H----}n{|P|y|-J-zv\x075}n{|=P|y|9-OYNPXlP\\Y\\_9-zv{5>;=9-oynpx]|tr66H----}n{|P|y|-J-zv\x075}n{|P|y|9-}n{|>P|y|9-zn\x075=;=9-oynpx]|tr-:-]V-8->;=66H--0ryvs-qrsv{rq5b`Rl`]_RNQla_N[`VaV\\[6----rp?-prr{Pr{rP||q-J-r|yv|{-7-}v\x07ry_nv|-<-?;=H----sy|n-n{vv|{_nqv-J-qvn{pr5rp?5=;=9-=;=69-prr{Pr{rP||q6-7->;?H----sy|n-n{vv|{]|tr-J-qvn{pr5tylSntP||q;\x07\b9-prr{Pr{rP||q6-<-n{vv|{_nqvH----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-z||ur}5=;=9-=;?9-}|tr-:-n{vv|{]|tr66H--0ryr----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-}|tr6H--0r{qvs--tylSntP|y|-J-zv\x075}n{|P|y|9-tylSntP|y|9-z|qryNy}un6H--<<-JJJJJJJJJJJJJ--0v{pyqr-Is|tlsntzr{K--0v{pyqr-I}rzyv}yvrqlny}unlsntzr{K--0v{pyqr-Iqvurv{tlsntzr{K--0vs-qrsv{rq5b`RlRQY6----tylSntP|y|;n-J-Y|tQr}uH--0r{qvs--ZNV[lR[Q\f");
var meshPhongVertexShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-]U\\[T0qrsv{r-ZN_Xl`aR]->;=0qrsv{r-_\\\\SlZN_X->;=0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvs0vs-qrsv{rq5b`RlcR_aRelZN_X6--nvor-sy|n-lsrnrlvqlznxH0r{qvsn\bv{t-sy|n-_||sZnxHn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-rp@-cvr]|vv|{H0vs{qrs-SYNal`UNQRQ--n\bv{t-rp@-[|znyH--0vsqrs-b`RlaN[TR[a----n\bv{t-rp@-an{tr{H----n\bv{t-rp@-Ovn{tr{H--0r{qvs0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-Il}nlrr\x07K0v{pyqr-I?l}nlrr\x07K0v{pyqr-Iqv}ynprzr{zn}l}nlrr\x07K0v{pyqr-Ir{zn}l}nlrr\x07K0v{pyqr-Ip|y|l}nlrr\x07K0v{pyqr-Is|tl}nlrr\x07K0v{pyqr-Iz|}untrl}nlrr\x07K0v{pyqr-Ixv{{v{tl}nlrr\x07K0v{pyqr-Iunq|zn}l}nlrr\x07K0v{pyqr-Iy|tqr}uosl}nlrr\x07K0v{pyqr-Ipyv}}v{tl}yn{rl}nlrr\x07KZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--0v{pyqr-Ilrr\x07K--0v{pyqr-I?lrr\x07K--0v{pyqr-Ip|y|lrr\x07K--0v{pyqr-Iortv{{|znylrr\x07K--0v{pyqr-Iz|}u{|znylrr\x07K--0v{pyqr-Ixv{onrlrr\x07K--0v{pyqr-Ixv{{|znylrr\x07K--0v{pyqr-Iqrsny{|znylrr\x07K--0vs{qrs-SYNal`UNQRQ-<<-[|zny-p|z}rq-vu-qrvnvr-ur{-SYNal`UNQRQ----[|zny-J-{|znyv	r5-n{s|zrq[|zny-6H----0vsqrs-b`RlaN[TR[a------an{tr{-J-{|znyv	r5-n{s|zrqan{tr{-6H------Ovn{tr{-J-{|znyv	r5-p|5-[|zny9-an{tr{-6-7-n{tr{;-6H----0r{qvs--0r{qvs--0v{pyqr-Iortv{lrr\x07K--0v{pyqr-Iz|}untrlrr\x07K--0v{pyqr-Ixv{{v{tlrr\x07K--0v{pyqr-Iqv}ynprzr{zn}lrr\x07K--0v{pyqr-I}|wrplrr\x07K--0v{pyqr-Iy|tqr}uoslrr\x07K--0v{pyqr-Ipyv}}v{tl}yn{rlrr\x07K--cvr]|vv|{-J-:-z]|vv|{;\x07\b	H--Sv{ny]|vv|{-J-rpA5n{s|zrq9->;=6H--0vsqrs-b`RlV[`aN[PV[T----Sv{ny]|vv|{-J-v{n{prZnv\x07-7-Sv{ny]|vv|{H--0r{qvs--Sv{ny]|vv|{-J-z|qryZnv\x07-7-Sv{ny]|vv|{H--zn@-pnzrn_|nv|{Znv\x07-J-zn@5vrZnv\x07h=jh=j9-vrZnv\x07h>jh=j9-vrZnv\x07h?jh=j9-vrZnv\x07h=jh>j9-vrZnv\x07h>jh>j9-vrZnv\x07h?jh>j9-vrZnv\x07h=jh?j9-vrZnv\x07h>jh?j9-vrZnv\x07h?jh?j6H--PnzrnQvrpv|{-J-{|znyv	r5pnzrn_|nv|{Znv\x07-7-rp@5=;=9-=;=9-:>;=66H--0vs-qrsv{rq5b`RlRQY6----Y|tQr}u-J-y|t?5:z]|vv|{;	6H--0r{qvs--_||sZnx-J-=;=H--0vs-qrsv{rq5b`RlcR_aRelZN_X6----_||sZnx-J-z||ur}5_\\\\SlZN_X-:-ZN_Xl`aR]9-_\\\\SlZN_X9-lsrnrlvqlznx6H--0r{qvs--0v{pyqr-I|yq}|lrr\x07K--0v{pyqr-Ir{zn}lrr\x07K--0v{pyqr-Iunq|zn}lrr\x07K--0v{pyqr-Is|tlrr\x07K--ZNV[lR[Q\f");
var meshPhongFragmentShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-]U\\[T0qrsv{r-OYNPXlP\\Y\\_-rpA5=;=EC9-=;>=C9-=;>AF9->;=6{vs|z-sy|n-sy||V{qr\x07H{vs|z-nz}yrPor-}n{|=lzn}H{vs|z-znA-}n{|=lznv\x07H{vs|z-sy|n-}n{|=l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|=lyzv{n{prZn}H0r{qvs{vs|z-nz}yrPor-}n{|>lzn}H{vs|z-znA-}n{|>lznv\x07H{vs|z-sy|n-}n{|>l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|>lyzv{n{prZn}H0r{qvs{vs|z-sy|n-z|qryNy}unH{vs|z-sy|n-}|trH0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6--{vs|z-rp@-p|{n{P|y|H0r{qvs0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6--{vs|z-nz}yr?Q-tnqvr{ar\x07rH0r{qvsp-Pyv}}r-\n--znA-znv\x07V{rrH--sy|n-sy||V{qr\x07H\fH0vs-[bZlPYV]]R_`-K-=--{vs|z-Pyv}}r-pyv}}rh[bZlPYV]]R_`jH0r{qvs0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvsn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-sy|n-_||sZnxH{vs|z-sy|n-u|{Sy||V{qr\x07H{vs|z-rp?-r|yv|{H{vs|z-sy|n-}v\x07ry_nv|H{vs|z-rp@-qvssrH{vs|z-sy|n-p|y|Ny}unH{vs|z-rp@-rzvvrH{vs|z-rp@-}rpynH{vs|z-sy|n-uv{v{rH{vs|z-sy|n-|}npv\bH{vs|z-sy|n-ovtu{rH{vs|z-rp@-z|qryO|{qv{tZn\x07H{vs|z-rp@-z|qryO|{qv{tZv{H<<u{vs|z-sy|n-p|y|`nnv|{H{vs|z-sy|n-p|y|Ovtu{rH0vs{qrs-SYNal`UNQRQ--0vsqrs-b`RlaN[TR[a----n\bv{t-rp@-an{tr{H----n\bv{t-rp@-Ovn{tr{H--0r{qvs0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-I}npxv{tK0v{pyqr-Iqvurv{tl}nlsntzr{K0v{pyqr-Ip|y|l}nlsntzr{K0v{pyqr-Il}nlsntzr{K0v{pyqr-I?l}nlsntzr{K0v{pyqr-Izn}l}nlsntzr{K0v{pyqr-Iny}unzn}l}nlsntzr{K0v{pyqr-In|zn}l}nlsntzr{K0v{pyqr-Iyvtuzn}l}nlsntzr{K0v{pyqr-Irzvvrzn}l}nlsntzr{K0v{pyqr-IoqsK0v{pyqr-Iporllrsyrpv|{lsntzr{K0v{pyqr-Ir{zn}lp|zz|{l}nlsntzr{K0v{pyqr-Ir{zn}l}nlsntzr{K0v{pyqr-Is|tl}nlsntzr{K0v{pyqr-Iyvtul}nlortv{K0v{pyqr-Iyvtul}u|{tl}nlsntzr{K0v{pyqr-Iunq|zn}l}nlsntzr{K0v{pyqr-Ioz}zn}l}nlsntzr{K0v{pyqr-I{|znyzn}l}nlsntzr{K0v{pyqr-I}rpynzn}l}nlsntzr{K0v{pyqr-Iy|tqr}uosl}nlsntzr{K0v{pyqr-Ipyv}}v{tl}yn{rl}nlsntzr{Krp@-	||zcrp|5rp@-qvrpv|{9-rp@-rp|9-sy|n-	||z6-\n--sy|n-urn-J-q|5qvrpv|{9-rp|6H--rp@-q-J-qvrpv|{-7-urnH--rp@-}-J-rp|-:-qH--rp@-\0-J-}-7-	||zH--r{-{|znyv	r5q-8-\x006H\frp@-to?u5rp@-p6-\n----rpA-X-J-rpA5=;=9-:>;=-<-@;=9-?;=-<-@;=9-:>;=6H----rpA-}-J-zv\x075rpA5p;ot9-X;	69-rpA5p;to9-X;\x07\b69-r}5p;o9-p;t66H----rpA-\0-J-zv\x075rpA5};\x07\b9-p;69-rpA5p;9-};\b	\x0769-r}5};\x079-p;66H----sy|n-q-J-\0;\x07-:-zv{5\0;9-\0;\b6H----sy|n-r-J->;=r:>=H----r{-rp@5no5\0;	-8-5\0;-:-\0;\b6-<-5C;=-7-q-8-r669-q-<-5\0;\x07-8-r69-\0;\x076H\frp@-u?to5rp@-p6-\n----rpA-X-J-rpA5>;=9-?;=-<-@;=9->;=-<-@;=9-@;=6H----rp@-}-J-no5snp5p;\x07\x07\x07-8-X;\x07\b	6-7-C;=-:-X;6H----r{-p;	-7-zv\x075X;\x07\x07\x079-pynz}5}-:-X;\x07\x07\x079-=;=9->;=69-p;\b6H\frp@-trP|y|O\bUrvtu5nz}yr?Q-tnqvr{ar\x07r9-rpA-Sv{ny]|vv|{6-\n--sy|n--J-5Sv{ny]|vv|{;\b-:-z|qryO|{qv{tZv{;\b6-<-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6H--r{-r\x07r?Q5tnqvr{ar\x07r9-rp?59-=;B66;toH\fZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--<<-JJJ--JJJ--sy|n-||sP]|tr-J-}|5pynz}5:PnzrnQvrpv|{;\b9-=;=9->;=69-@;=6H--vs-5----_||sZnx-K-=;==>-33----Sv{ny]|vv|{;\b-K-z|qryO|{qv{tZn\x07;\b-:-||sP]|tr-7-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6--6-\n----qvpnqH--\f--<<-JJJJJJJJJJJJJJ--<<-JJJ--JJJ--0vs-[bZlPYV]]R_`-K-=----o||y-pyv}}rqH----rpA-pyv}}r]|vv|{H----0}ntzn-{|yyly||}ln----s|-5-v{-v-J-=H-v-I-[bZlPYV]]R_`H-v-88-6-\n------pyv}}r]|vv|{-J-pyv}}rh-v-j;znv\x07V{rr-7-Sv{ny]|vv|{H------pyv}}rq-J-5pyv}}rh-v-j;sy||V{qr\x07-I-=;=-\v\v-no5sy||V{qr\x07-:-pyv}}rh-v-j;sy||V{qr\x076-I->;=6H------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\x07-K-:=;B-33-pyv}}r]|vv|{;\x07-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\b-K-:=;B-33-pyv}}r]|vv|{;\b-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;	-K-:=;B-33-pyv}}r]|vv|{;	-I-=;BH------vs-5pyv}}rq6-\n--------qvpnqH------\f----\f----0}ntzn-{|yyly||}lr{q--0r{qvs--<<-JJJJJJJJJJJJJJJJ--0v{pyqr-Ipyv}}v{tl}yn{rlsntzr{K--rpA-qvssrP|y|-J-rpA5-qvssr9-p|y|Ny}un-7-|}npv\b-6H--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6----qvssrP|y|;to-J-trP|y|O\bUrvtu5tnqvr{ar\x07r9-Sv{ny]|vv|{6H--0r{qvs--<<-JJJJJJJJJJJ--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6----qvssrP|y|;to-J-p|{n{P|y|H--0r{qvs--<<-JJJJJJJJJJJ--_rsyrprqYvtu-rsyrprqYvtu-J-_rsyrprqYvtu5-rp@5-=;=-69-rp@5-=;=-69-rp@5-=;=-69-rp@5-=;=-6-6H--rp@-|nyRzvvr_nqvn{pr-J-rzvvrH--0v{pyqr-Iy|tqr}uoslsntzr{K--0v{pyqr-Izn}lsntzr{K--0v{pyqr-Ip|y|lsntzr{K--0v{pyqr-Iny}unzn}lsntzr{K--0v{pyqr-Iny}unrlsntzr{K--0v{pyqr-I}rpynzn}lsntzr{K--0v{pyqr-I{|znylsntzr{lortv{K--0v{pyqr-I{|znylsntzr{lzn}K--0v{pyqr-Irzvvrzn}lsntzr{K--<<-nppzynv|{--0v{pyqr-Iyvtul}u|{tlsntzr{K--0v{pyqr-Iyvtulsntzr{lortv{K--0v{pyqr-Iyvtulsntzr{lzn}K--0v{pyqr-Iyvtulsntzr{lr{qK--<<-z|qynv|{--0v{pyqr-In|zn}lsntzr{K--rp@-|t|v{tYvtu-J-rsyrprqYvtu;qvrpQvssr-8-rsyrprqYvtu;v{qvrpQvssr-8-rsyrprqYvtu;qvrp`}rpyn-8-rsyrprqYvtu;v{qvrp`}rpyn-8-|nyRzvvr_nqvn{prH--0v{pyqr-Ir{zn}lsntzr{K--tylSntP|y|-J-rpA5-|t|v{tYvtu9-qvssrP|y|;n-6H--<<-JJJ--JJJ--sy|n-sy||\\}npv\b-J->;=H--vs-5u|{Sy||V{qr\x07-K-:=;=>-33-no5sy||V{qr\x07-:-u|{Sy||V{qr\x076-K-=;FF6-\n----sy||\\}npv\b-J-=;?-7-zv{55>;=-8-PnzrnQvrpv|{;\b69->;=6H--\f--tylSntP|y|;n-J-tylSntP|y|;n-7-sy||\\}npv\b-7-ovtu{rH--<<-JJJJJJJJJJJJJJ--ZNV[lZ\\QRYlP\\Y\\_--<<---0v{pyqr-I|{rzn}}v{tlsntzr{K--0v{pyqr-Ir{p|qv{tlsntzr{K--<<-JJJ--JJJ--rp@-toP|y|-J-tylSntP|y|;toH--rp@-uP|y|-J-to?u5toP|y|6H--uP|y|;\b-8J-p|y|`nnv|{H--uP|y|;	-8J-p|y|Ovtu{rH--tylSntP|y|;to-J-u?to5uP|y|6H--<<-JJJ--JJJ--rp@-}n{|=a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|=lznv\x07h@j;\x07\b	6H--}n{|=a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|=a|crr\x079-}n{|=l	||z6H--}n{|=a|crr\x07-J-}n{|=a|crr\x07-7-zn@5}n{|=lznv\x076H--rp@-}n{|>a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|>lznv\x07h@j;\x07\b	6H--}n{|>a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|>a|crr\x079-}n{|>l	||z6H--}n{|>a|crr\x07-J-}n{|>a|crr\x07-7-zn@5}n{|>lznv\x076H--rpA-}n{|P|y|H--rpA-}n{|=P|y|-J-r\x07rPor5}n{|=lzn}9-}n{|=a|crr\x076H--rpA-}n{|>P|y|-J-r\x07rPor5}n{|>lzn}9-}n{|>a|crr\x076H--0vs-qrsv{rq5b`RlYbZV[N[PR6----}n{|=P|y|;n-J->;=-:-r\x07rPor5}n{|=lyzv{n{prZn}9-}n{|=a|crr\x076;H----}n{|>P|y|;n-J->;=-:-r\x07rPor5}n{|>lyzv{n{prZn}9-}n{|>a|crr\x076;H--0r{qvs--0vs-qrsv{rq5b`RlOYNPXla_N[`VaV\\[6----sy|n-oynpx]|tr-J-np|5:?;=-7-}|tr-8->;=6H----}n{|P|y|-J-zv\x075}n{|=P|y|9-OYNPXlP\\Y\\_9-zv{5>;=9-oynpx]|tr66H----}n{|P|y|-J-zv\x075}n{|P|y|9-}n{|>P|y|9-zn\x075=;=9-oynpx]|tr-:-]V-8->;=66H--0ryvs-qrsv{rq5b`Rl`]_RNQla_N[`VaV\\[6----rp?-prr{Pr{rP||q-J-r|yv|{-7-}v\x07ry_nv|-<-?;=H----sy|n-n{vv|{_nqv-J-qvn{pr5rp?5=;=9-=;=69-prr{Pr{rP||q6-7->;?H----sy|n-n{vv|{]|tr-J-qvn{pr5tylSntP||q;\x07\b9-prr{Pr{rP||q6-<-n{vv|{_nqvH----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-z||ur}5=;=9-=;?9-}|tr-:-n{vv|{]|tr66H--0ryr----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-}|tr6H--0r{qvs--tylSntP|y|-J-zv\x075}n{|P|y|9-tylSntP|y|9-z|qryNy}un6H--<<-JJJJJJJJJJJJJJ--0v{pyqr-Is|tlsntzr{K--0v{pyqr-I}rzyv}yvrqlny}unlsntzr{K--0v{pyqr-Iqvurv{tlsntzr{K--0vs-qrsv{rq5b`RlRQY6----tylSntP|y|;n-J-Y|tQr}uH--0r{qvs--ZNV[lR[Q\f");
var meshStandardVertexShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-`aN[QN_Q0qrsv{r-ZN_Xl`aR]->;=0qrsv{r-_\\\\SlZN_X->;=0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvs0vs-qrsv{rq5b`RlcR_aRelZN_X6--nvor-sy|n-lsrnrlvqlznxH0r{qvsn\bv{t-sy|n-_||sZnxHn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-rp@-cvr]|vv|{H0vs{qrs-SYNal`UNQRQ--n\bv{t-rp@-[|znyH--0vsqrs-b`RlaN[TR[a----n\bv{t-rp@-an{tr{H----n\bv{t-rp@-Ovn{tr{H--0r{qvs0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-Il}nlrr\x07K0v{pyqr-I?l}nlrr\x07K0v{pyqr-Iqv}ynprzr{zn}l}nlrr\x07K0v{pyqr-Ir{zn}l}nlrr\x07K0v{pyqr-Ip|y|l}nlrr\x07K0v{pyqr-Is|tl}nlrr\x07K0v{pyqr-Iz|}untrl}nlrr\x07K0v{pyqr-Ixv{{v{tl}nlrr\x07K0v{pyqr-Iunq|zn}l}nlrr\x07K0v{pyqr-Iy|tqr}uosl}nlrr\x07K0v{pyqr-Ipyv}}v{tl}yn{rl}nlrr\x07KZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--0v{pyqr-Ilrr\x07K--0v{pyqr-I?lrr\x07K--0v{pyqr-Ip|y|lrr\x07K--0v{pyqr-Iortv{{|znylrr\x07K--0v{pyqr-Iz|}u{|znylrr\x07K--0v{pyqr-Ixv{onrlrr\x07K--0v{pyqr-Ixv{{|znylrr\x07K--0v{pyqr-Iqrsny{|znylrr\x07K0vs{qrs-SYNal`UNQRQ-<<-[|zny-p|z}rq-vu-qrvnvr-ur{-SYNal`UNQRQ--[|zny-J-{|znyv	r5-n{s|zrq[|zny-6H--0vsqrs-b`RlaN[TR[a----an{tr{-J-{|znyv	r5-n{s|zrqan{tr{-6H----Ovn{tr{-J-{|znyv	r5-p|5-[|zny9-an{tr{-6-7-n{tr{;-6H--0r{qvs0r{qvs--0v{pyqr-Iortv{lrr\x07K--0v{pyqr-Iz|}untrlrr\x07K--0v{pyqr-Ixv{{v{tlrr\x07K--0v{pyqr-Iqv}ynprzr{zn}lrr\x07K--0v{pyqr-I}|wrplrr\x07K--0v{pyqr-Iy|tqr}uoslrr\x07K--0v{pyqr-Ipyv}}v{tl}yn{rlrr\x07K--cvr]|vv|{-J-:-z]|vv|{;\x07\b	H--Sv{ny]|vv|{-J-rpA5n{s|zrq9->;=6H--0vsqrs-b`RlV[`aN[PV[T----Sv{ny]|vv|{-J-v{n{prZnv\x07-7-Sv{ny]|vv|{H--0r{qvs--Sv{ny]|vv|{-J-z|qryZnv\x07-7-Sv{ny]|vv|{H--zn@-pnzrn_|nv|{Znv\x07-J-zn@5vrZnv\x07h=jh=j9-vrZnv\x07h>jh=j9-vrZnv\x07h?jh=j9-vrZnv\x07h=jh>j9-vrZnv\x07h>jh>j9-vrZnv\x07h?jh>j9-vrZnv\x07h=jh?j9-vrZnv\x07h>jh?j9-vrZnv\x07h?jh?j6H--PnzrnQvrpv|{-J-{|znyv	r5pnzrn_|nv|{Znv\x07-7-rp@5=;=9-=;=9-:>;=66H--0vs-qrsv{rq5b`RlRQY6----Y|tQr}u-J-y|t?5:z]|vv|{;	6H--0r{qvs--_||sZnx-J-=;=H--0vs-qrsv{rq5b`RlcR_aRelZN_X6----_||sZnx-J-z||ur}5_\\\\SlZN_X-:-ZN_Xl`aR]9-_\\\\SlZN_X9-lsrnrlvqlznx6H--0r{qvs--0v{pyqr-I|yq}|lrr\x07K--0v{pyqr-Ir{zn}lrr\x07K--0v{pyqr-Iunq|zn}lrr\x07K--0v{pyqr-Is|tlrr\x07K--ZNV[lR[Q\f");
var meshStandardFragmentShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("0qrsv{r-`aN[QN_Q0qrsv{r-_RSYRPaVcVaf0qrsv{r-OYNPXlP\\Y\\_-rpA5=;=EC9-=;>=C9-=;>AF9->;=6{vs|z-sy|n-sy||V{qr\x07H{vs|z-nz}yrPor-}n{|=lzn}H{vs|z-znA-}n{|=lznv\x07H{vs|z-sy|n-}n{|=l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|=lyzv{n{prZn}H0r{qvs{vs|z-nz}yrPor-}n{|>lzn}H{vs|z-znA-}n{|>lznv\x07H{vs|z-sy|n-}n{|>l	||zH0vs-qrsv{rq5b`RlYbZV[N[PR6--{vs|z-nz}yrPor-}n{|>lyzv{n{prZn}H0r{qvs{vs|z-sy|n-z|qryNy}unH{vs|z-sy|n-}|trH0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6--{vs|z-rp@-p|{n{P|y|H0r{qvs0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6--{vs|z-nz}yr?Q-tnqvr{ar\x07rH0r{qvsp-Pyv}}r-\n--znA-znv\x07V{rrH--sy|n-sy||V{qr\x07H\fH0vs-[bZlPYV]]R_`-K-=--{vs|z-Pyv}}r-pyv}}rh[bZlPYV]]R_`jH0r{qvs0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvsn\bv{t-rpA-Sv{ny]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-sy|n-_||sZnxH{vs|z-sy|n-u|{Sy||V{qr\x07H{vs|z-rp?-r|yv|{H{vs|z-sy|n-}v\x07ry_nv|H{vs|z-rp@-qvssrH{vs|z-sy|n-p|y|Ny}unH{vs|z-rp@-rzvvrH{vs|z-sy|n-|tu{rH{vs|z-sy|n-zrny{rH{vs|z-sy|n-|}npv\bH{vs|z-sy|n-ovtu{rH0vsqrs-_RSYRPaVcVaf--{vs|z-sy|n-rsyrpvv\bH0r{qvs{vs|z-rp@-z|qryO|{qv{tZn\x07H{vs|z-rp@-z|qryO|{qv{tZv{H<<u{vs|z-sy|n-p|y|`nnv|{H{vs|z-sy|n-p|y|Ovtu{rHn\bv{t-rp@-cvr]|vv|{H0vs{qrs-SYNal`UNQRQ--n\bv{t-rp@-[|znyH--0vsqrs-b`RlaN[TR[a----n\bv{t-rp@-an{tr{H----n\bv{t-rp@-Ovn{tr{H--0r{qvs0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-I}npxv{tK0v{pyqr-Iqvurv{tl}nlsntzr{K0v{pyqr-Ip|y|l}nlsntzr{K0v{pyqr-Il}nlsntzr{K0v{pyqr-I?l}nlsntzr{K0v{pyqr-Izn}l}nlsntzr{K0v{pyqr-Iny}unzn}l}nlsntzr{K0v{pyqr-In|zn}l}nlsntzr{K0v{pyqr-Iyvtuzn}l}nlsntzr{K0v{pyqr-Irzvvrzn}l}nlsntzr{K0v{pyqr-IoqsK0v{pyqr-Iporllrsyrpv|{lsntzr{K0v{pyqr-Ir{zn}lp|zz|{l}nlsntzr{K0v{pyqr-Ir{zn}l}u\bvpnyl}nlsntzr{K0v{pyqr-Is|tl}nlsntzr{K0v{pyqr-Iyvtul}nlortv{K0v{pyqr-Iyvtul}u\bvpnyl}nlsntzr{K0v{pyqr-Iunq|zn}l}nlsntzr{K0v{pyqr-Ioz}zn}l}nlsntzr{K0v{pyqr-I{|znyzn}l}nlsntzr{K0v{pyqr-I|tu{rzn}l}nlsntzr{K0v{pyqr-Izrny{rzn}l}nlsntzr{K0v{pyqr-Iy|tqr}uosl}nlsntzr{K0v{pyqr-Ipyv}}v{tl}yn{rl}nlsntzr{Krp@-	||zcrp|5rp@-qvrpv|{9-rp@-rp|9-sy|n-	||z6-\n--sy|n-urn-J-q|5qvrpv|{9-rp|6H--rp@-q-J-qvrpv|{-7-urnH--rp@-}-J-rp|-:-qH--rp@-\0-J-}-7-	||zH--r{-{|znyv	r5q-8-\x006H\frp@-to?u5rp@-p6-\n----rpA-X-J-rpA5=;=9-:>;=-<-@;=9-?;=-<-@;=9-:>;=6H----rpA-}-J-zv\x075rpA5p;ot9-X;	69-rpA5p;to9-X;\x07\b69-r}5p;o9-p;t66H----rpA-\0-J-zv\x075rpA5};\x07\b9-p;69-rpA5p;9-};\b	\x0769-r}5};\x079-p;66H----sy|n-q-J-\0;\x07-:-zv{5\0;9-\0;\b6H----sy|n-r-J->;=r:>=H----r{-rp@5no5\0;	-8-5\0;-:-\0;\b6-<-5C;=-7-q-8-r669-q-<-5\0;\x07-8-r69-\0;\x076H\frp@-u?to5rp@-p6-\n----rpA-X-J-rpA5>;=9-?;=-<-@;=9->;=-<-@;=9-@;=6H----rp@-}-J-no5snp5p;\x07\x07\x07-8-X;\x07\b	6-7-C;=-:-X;6H----r{-p;	-7-zv\x075X;\x07\x07\x079-pynz}5}-:-X;\x07\x07\x079-=;=9->;=69-p;\b6H\frp@-trP|y|O\bUrvtu5nz}yr?Q-tnqvr{ar\x07r9-rpA-Sv{ny]|vv|{6-\n--sy|n--J-5Sv{ny]|vv|{;\b-:-z|qryO|{qv{tZv{;\b6-<-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6H--r{-r\x07r?Q5tnqvr{ar\x07r9-rp?59-=;B66;toH\fZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--<<-JJJ--JJJ--sy|n-||sP]|tr-J-}|5pynz}5:PnzrnQvrpv|{;\b9-=;=9->;=69-@;=6H--vs-5----_||sZnx-K-=;==>-33----Sv{ny]|vv|{;\b-K-z|qryO|{qv{tZn\x07;\b-:-||sP]|tr-7-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6--6-\n----qvpnqH--\f--<<-JJJJJJJJJJJJJJ--<<-JJJ--JJJ--0vs-[bZlPYV]]R_`-K-=----o||y-pyv}}rqH----rpA-pyv}}r]|vv|{H----0}ntzn-{|yyly||}ln----s|-5-v{-v-J-=H-v-I-[bZlPYV]]R_`H-v-88-6-\n------pyv}}r]|vv|{-J-pyv}}rh-v-j;znv\x07V{rr-7-Sv{ny]|vv|{H------pyv}}rq-J-5pyv}}rh-v-j;sy||V{qr\x07-I-=;=-\v\v-no5sy||V{qr\x07-:-pyv}}rh-v-j;sy||V{qr\x076-I->;=6H------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\x07-K-:=;B-33-pyv}}r]|vv|{;\x07-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\b-K-:=;B-33-pyv}}r]|vv|{;\b-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;	-K-:=;B-33-pyv}}r]|vv|{;	-I-=;BH------vs-5pyv}}rq6-\n--------qvpnqH------\f----\f----0}ntzn-{|yyly||}lr{q--0r{qvs--<<-JJJJJJJJJJJJJJJJ--0v{pyqr-Ipyv}}v{tl}yn{rlsntzr{K--rpA-qvssrP|y|-J-rpA5-qvssr9-p|y|Ny}un-7-|}npv\b-6H--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6----qvssrP|y|;to-J-trP|y|O\bUrvtu5tnqvr{ar\x07r9-Sv{ny]|vv|{6H--0r{qvs--<<-JJJJJJJJJJJ--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6----qvssrP|y|;to-J-p|{n{P|y|H--0r{qvs--<<-JJJJJJJJJJJ--_rsyrprqYvtu-rsyrprqYvtu-J-_rsyrprqYvtu5-rp@5-=;=-69-rp@5-=;=-69-rp@5-=;=-69-rp@5-=;=-6-6H--rp@-|nyRzvvr_nqvn{pr-J-rzvvrH--0v{pyqr-Iy|tqr}uoslsntzr{K--0v{pyqr-Izn}lsntzr{K--0v{pyqr-Ip|y|lsntzr{K--0v{pyqr-Iny}unzn}lsntzr{K--0v{pyqr-Iny}unrlsntzr{K--0v{pyqr-I|tu{rzn}lsntzr{K0v{pyqr-Izrny{rzn}lsntzr{K--0v{pyqr-I{|znylsntzr{lortv{K--0v{pyqr-I{|znylsntzr{lzn}K--0v{pyqr-Irzvvrzn}lsntzr{K--<<-nppzynv|{--0v{pyqr-Iyvtul}u\bvpnylsntzr{K--0v{pyqr-Iyvtulsntzr{lortv{K--0v{pyqr-Iyvtulsntzr{lzn}K--0v{pyqr-Iyvtulsntzr{lr{qK--<<-z|qynv|{--0v{pyqr-In|zn}lsntzr{K--rp@-|t|v{tYvtu-J-rsyrprqYvtu;qvrpQvssr-8-rsyrprqYvtu;v{qvrpQvssr-8-rsyrprqYvtu;qvrp`}rpyn-8-rsyrprqYvtu;v{qvrp`}rpyn-8-|nyRzvvr_nqvn{prH--tylSntP|y|-J-rpA5-|t|v{tYvtu9-qvssrP|y|;n-6H--<<-JJJ--JJJ--sy|n-sy||\\}npv\b-J->;=H--vs-5u|{Sy||V{qr\x07-K-:=;=>-33-no5sy||V{qr\x07-:-u|{Sy||V{qr\x076-K-=;FF6-\n----sy||\\}npv\b-J-=;?-7-zv{55>;=-8-PnzrnQvrpv|{;\b69->;=6H--\f--tylSntP|y|;n-J-tylSntP|y|;n-7-sy||\\}npv\b-7-ovtu{rH--<<-JJJJJJJJJJJJJJ--ZNV[lZ\\QRYlP\\Y\\_--<<---0v{pyqr-I|{rzn}}v{tlsntzr{K--0v{pyqr-Ir{p|qv{tlsntzr{K--<<-JJJ--JJJ--rp@-toP|y|-J-tylSntP|y|;toH--rp@-uP|y|-J-to?u5toP|y|6H--uP|y|;\b-8J-p|y|`nnv|{H--uP|y|;	-8J-p|y|Ovtu{rH--tylSntP|y|;to-J-u?to5uP|y|6H--<<-JJJ--JJJ--rp@-}n{|=a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|=lznv\x07h@j;\x07\b	6H--}n{|=a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|=a|crr\x079-}n{|=l	||z6H--}n{|=a|crr\x07-J-}n{|=a|crr\x07-7-zn@5}n{|=lznv\x076H--rp@-}n{|>a|crr\x07-J-{|znyv	r5Sv{ny]|vv|{;\x07\b	-:-}n{|>lznv\x07h@j;\x07\b	6H--}n{|>a|crr\x07-J-	||zcrp|5PnzrnQvrpv|{9-}n{|>a|crr\x079-}n{|>l	||z6H--}n{|>a|crr\x07-J-}n{|>a|crr\x07-7-zn@5}n{|>lznv\x076H--rpA-}n{|P|y|H--rpA-}n{|=P|y|-J-r\x07rPor5}n{|=lzn}9-}n{|=a|crr\x076H--rpA-}n{|>P|y|-J-r\x07rPor5}n{|>lzn}9-}n{|>a|crr\x076H--0vs-qrsv{rq5b`RlYbZV[N[PR6----}n{|=P|y|;n-J->;=-:-r\x07rPor5}n{|=lyzv{n{prZn}9-}n{|=a|crr\x076;H----}n{|>P|y|;n-J->;=-:-r\x07rPor5}n{|>lyzv{n{prZn}9-}n{|>a|crr\x076;H--0r{qvs--0vs-qrsv{rq5b`RlOYNPXla_N[`VaV\\[6----sy|n-oynpx]|tr-J-np|5:?;=-7-}|tr-8->;=6H----}n{|P|y|-J-zv\x075}n{|=P|y|9-OYNPXlP\\Y\\_9-zv{5>;=9-oynpx]|tr66H----}n{|P|y|-J-zv\x075}n{|P|y|9-}n{|>P|y|9-zn\x075=;=9-oynpx]|tr-:-]V-8->;=66H--0ryvs-qrsv{rq5b`Rl`]_RNQla_N[`VaV\\[6----rp?-prr{Pr{rP||q-J-r|yv|{-7-}v\x07ry_nv|-<-?;=H----sy|n-n{vv|{_nqv-J-qvn{pr5rp?5=;=9-=;=69-prr{Pr{rP||q6-7->;?H----sy|n-n{vv|{]|tr-J-qvn{pr5tylSntP||q;\x07\b9-prr{Pr{rP||q6-<-n{vv|{_nqvH----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-z||ur}5=;=9-=;?9-}|tr-:-n{vv|{]|tr66H--0ryr----}n{|P|y|-J-zv\x075}n{|=P|y|9-}n{|>P|y|9-}|tr6H--0r{qvs--tylSntP|y|-J-zv\x075}n{|P|y|9-tylSntP|y|9-z|qryNy}un6H--<<-JJJJJJJJJJJJJJ--0v{pyqr-Is|tlsntzr{K--0v{pyqr-I}rzyv}yvrqlny}unlsntzr{K--0v{pyqr-Iqvurv{tlsntzr{K--0vs-qrsv{rq5b`RlRQY6----tylSntP|y|;n-J-Y|tQr}uH--0r{qvs--ZNV[lR[Q\f");
var pbmUniforms$1 = {
  colorAlpha: new Uniform(0),
  modelAlpha: new Uniform(0),
  progress: new Uniform(0),
  pano0_map: new Uniform(null),
  pano0_luminanceMap: new Uniform(null),
  pano0_matrix: new Uniform(new Matrix4()),
  pano0_zoom: new Uniform(1),
  pano1_map: new Uniform(null),
  pano1_luminanceMap: new Uniform(null),
  pano1_matrix: new Uniform(new Matrix4()),
  pano1_zoom: new Uniform(1),
  gradientTexture: new Uniform(null),
  clippers: new Uniform([]),
  shownFloorIndex: new Uniform(-1),
  constantColor: new Uniform(new Vector3()),
  geometricError: new Uniform(0),
  pixelRatio: new Uniform(1),
  resolution: new Uniform(new Vector2(512, 512)),
  floorIndex: new Uniform(0),
  brightness: new Uniform(1),
  modelBoundingMin: new Uniform(new Vector3()),
  modelBoundingMax: new Uniform(new Vector3()),
  colorSaturation: new Uniform(0),
  colorBrightness: new Uniform(0),
  outlineGain: new Uniform(0),
  distanceGain: new Uniform(0)
};
var shaderLib = {
  none: {
    vertexShader: meshNoneVertexShader,
    fragmentShader: meshNoneFragmentShader,
    uniforms: UniformsUtils.merge([pbmUniforms$1, { opacity: { value: 1 } }, UniformsLib.fog]),
    lights: false,
    clipping: false
  },
  basic: {
    vertexShader: meshBasicVertexShader,
    fragmentShader: meshBasicFragmentShader,
    uniforms: UniformsUtils.merge([pbmUniforms$1, ShaderLib.basic.uniforms]),
    lights: false,
    clipping: true
  },
  phong: {
    vertexShader: meshPhongVertexShader,
    fragmentShader: meshPhongFragmentShader,
    uniforms: UniformsUtils.merge([pbmUniforms$1, ShaderLib.phong.uniforms]),
    lights: true,
    clipping: true
  },
  standard: {
    vertexShader: meshStandardVertexShader,
    fragmentShader: meshStandardFragmentShader,
    uniforms: UniformsUtils.merge([pbmUniforms$1, ShaderLib.standard.uniforms]),
    lights: true,
    clipping: true
  }
};
var PBMMeshMaterial = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      e === void 0 && (e = "basic"), r === void 0 && (r = {});
      var o = this, s, u, l, c, f, d, h, v, A, g, p, y, m, E, b, T, R, S, M, w, H, L, C, I, _, O, P, N, k = shaderLib[e];
      o = n45.call(this, {
        vertexShader: k.vertexShader,
        fragmentShader: k.fragmentShader,
        uniforms: UniformsUtils.clone(k.uniforms),
        lights: k.lights,
        clipping: k.clipping,
        defines: {
          USE_COLOR_CONSTANT: false,
          USE_COLOR_ALTITUDE: false,
          USE_EDL: false,
          USE_HQ_WEIGHT: false,
          USE_HQ_DEPTH: false,
          NUM_CLIPPING_BOX: false,
          USE_CLIPFLOOR: false,
          USE_VERTEX_MARK: false,
          USE_LUMINANCE: false,
          USE_BLACK_TRANSITION: false,
          USE_SPREAD_TRANSITION: false,
          USE_POINT_NORMAL: false,
          USE_POINT_CIRCLE: false,
          USE_POINT_ADAPTIVE_SIZE: false,
          USE_POINT_COLOR_ALTITUDE: false
        }
      }) || this, o.shaderType = e, o.vertexTangents = false, o.color = new Color(16777215), o.colorAlpha = 1, o.map = null, o.lightMap = null, o.lightMapIntensity = 1, o.aoMap = null, o.aoMapIntensity = 1, o.specularMap = null, o.specular = new Color(1118481), o.roughnessMap = null, o.roughness = 1, o.metalnessMap = null, o.metalness = 0, o.alphaMap = null, o.alphaMode = "OPAQUE", o.combine = null, o.envMap = null, o.envMapIntensity = 1, o.reflectivity = 0.4, o.refractionRatio = 0.98, o.emissiveMap = null, o.emissive = new Color(0), o.emissiveIntensity = 1, o.bumpMap = null, o.bumpScale = 1, o.normalMap = null, o.normalMapType = TangentSpaceNormalMap, o.normalScale = new Vector2(1, 1), o.displacementMap = null, o.displacementScale = 1, o.displacementBias = 0, o.shininess = 30;
      var U, D = null, q = null;
      return o.shaderType === "phong" && (o.combine = MultiplyOperation), Object.defineProperties(o, {
        /**  */
        pano0: {
          get: function() {
            return D;
          },
          set: function(z) {
            if (D !== z) {
              D = z, z === null ? (this.uniforms.pano0_map.value = null, this.uniforms.pano0_luminanceMap.value = null, this.uniforms.pano0_matrix.value.identity(), this.uniforms.pano0_zoom.value = 1) : (this.uniforms.pano0_map.value = z.map instanceof TileCubeTextureTarget ? z.map.texture : z.map, this.uniforms.pano0_luminanceMap.value = z.luminanceMap instanceof TileCubeTextureTarget ? z.luminanceMap.texture : z.luminanceMap, this.uniforms.pano0_matrix.value.copy(z.matrix), this.uniforms.pano0_zoom.value = z.zoom);
              var Q = this.uniforms.pano0_luminanceMap.value !== null && this.uniforms.pano1_luminanceMap.value !== null, G = this.defines.USE_LUMINANCE;
              G !== Q && (this.defines.USE_LUMINANCE = Q, this.needsUpdate = true);
            }
          }
        },
        /**  */
        pano1: {
          get: function() {
            return q;
          },
          set: function(z) {
            if (q !== z) {
              q = z, z === null ? (this.uniforms.pano1_map.value = null, this.uniforms.pano1_luminanceMap.value = null, this.uniforms.pano1_matrix.value.identity(), this.uniforms.pano1_zoom.value = 1) : (this.uniforms.pano1_map.value = z.map instanceof TileCubeTextureTarget ? z.map.texture : z.map, this.uniforms.pano1_luminanceMap.value = z.luminanceMap instanceof TileCubeTextureTarget ? z.luminanceMap.texture : z.luminanceMap, this.uniforms.pano1_matrix.value.copy(z.matrix), this.uniforms.pano1_zoom.value = z.zoom);
              var Q = this.uniforms.pano0_luminanceMap.value !== null && this.uniforms.pano1_luminanceMap.value !== null, G = this.defines.USE_LUMINANCE;
              G !== Q && (this.defines.USE_LUMINANCE = Q, this.needsUpdate = true);
            }
          }
        },
        /**  [0-1] */
        modelAlpha: {
          get: function() {
            return this.uniforms.modelAlpha.value;
          },
          set: function(z) {
            this.uniforms.modelAlpha.value = z;
          }
        },
        /**  [0-1] */
        progress: {
          get: function() {
            return this.uniforms.progress.value;
          },
          set: function(z) {
            this.uniforms.progress.value = z;
          }
        },
        /**  */
        transition: {
          get: function() {
            return this.defines.USE_BLACK_TRANSITION ? "BLACK" : this.defines.USE_SPREAD_TRANSITION ? "SPREAD" : "FADE";
          },
          set: function(z) {
            var Q = this.defines.USE_BLACK_TRANSITION, G = this.defines.USE_SPREAD_TRANSITION;
            this.defines.USE_BLACK_TRANSITION = false, this.defines.USE_SPREAD_TRANSITION = false, this.defines["USE_".concat(z, "_TRANSITION")] = true;
            var X = false;
            Q !== this.defines.USE_BLACK_TRANSITION && (X = true), G !== this.defines.USE_SPREAD_TRANSITION && (X = true), X && (this.needsUpdate = true);
          }
        },
        colorStyle: {
          get: function() {
            return this.defines.USE_COLOR_CONSTANT ? "CONSTANT" : this.defines.USE_COLOR_ALTITUDE ? "ALTITUDE" : "RGB";
          },
          set: function(z) {
            var Q = z === "CONSTANT", G = z === "ALTITUDE";
            this.defines.USE_COLOR_CONSTANT !== Q && (this.defines.USE_COLOR_CONSTANT = Q, this.needsUpdate = true), this.defines.USE_COLOR_ALTITUDE !== G && (this.defines.USE_COLOR_ALTITUDE = G, this.needsUpdate = true);
          }
        },
        /**  */
        constantColor: {
          get: function() {
            return this.uniforms.constantColor.value;
          },
          set: function(z) {
            this.uniforms.constantColor.value = z;
          }
        },
        /**  */
        opacity: {
          get: function() {
            return this.uniforms.opacity.value;
          },
          set: function(z) {
            this.uniforms.opacity.value = z;
          }
        },
        /** */
        shownFloorIndex: {
          get: function() {
            return this.uniforms.shownFloorIndex.value;
          },
          set: function(z) {
            this.uniforms.shownFloorIndex.value = z;
          }
        },
        gradientTexture: {
          get: function() {
            return this.uniforms.gradientTexture.value;
          },
          set: function(z) {
            this.uniforms.gradientTexture.value = z;
          }
        },
        /** */
        brightness: {
          get: function() {
            return this.uniforms.brightness.value;
          },
          set: function(z) {
            this.uniforms.brightness.value = z;
          }
        },
        /** */
        clippers: {
          get: function() {
            return U;
          },
          set: function(z) {
            U !== z && (U = z, this.uniforms.clippers.value = (U || []).map(function(Q) {
              var G = typeof Q.floorIndex == "number" ? Q.floorIndex : -1, X = new Matrix4().getInverse(Q.clippingBoxMatrix);
              return {
                matrixInverse: X,
                floorIndex: G
              };
            }), this.needsUpdate = true);
          }
        },
        /** edl*/
        useEDL: {
          get: function() {
            return this.defines.USE_EDL;
          },
          set: function(z) {
            z !== this.defines.USE_EDL && (this.defines.USE_EDL = z, this.needsUpdate = true);
          }
        },
        /** edl*/
        useHQWeight: {
          get: function() {
            return this.defines.USE_HQ_WEIGHT;
          },
          set: function(z) {
            z !== this.defines.USE_HQ_WEIGHT && (this.defines.USE_HQ_WEIGHT = z, this.needsUpdate = true);
          }
        },
        /** edl*/
        useHQDepth: {
          get: function() {
            return this.defines.USE_HQ_DEPTH;
          },
          set: function(z) {
            z !== this.defines.USE_HQ_DEPTH && (this.defines.USE_HQ_DEPTH = z, this.needsUpdate = true);
          }
        },
        floorIndex: {
          get: function() {
            return this.uniforms.floorIndex.value;
          },
          set: function(z) {
            this.uniforms.floorIndex.value = z;
          }
        },
        colorSaturation: {
          get: function() {
            return this.uniforms.colorSaturation.value;
          },
          set: function(z) {
            this.uniforms.colorSaturation.value = z;
          }
        },
        colorBrightness: {
          get: function() {
            return this.uniforms.colorBrightness.value;
          },
          set: function(z) {
            this.uniforms.colorBrightness.value = z;
          }
        },
        outlineGain: {
          get: function() {
            return this.uniforms.outlineGain.value;
          },
          set: function(z) {
            this.uniforms.outlineGain.value = z;
          }
        },
        distanceGain: {
          get: function() {
            return this.uniforms.distanceGain.value;
          },
          set: function(z) {
            this.uniforms.distanceGain.value = z;
          }
        }
      }), o.pano0 = (s = r.pano0) !== null && s !== void 0 ? s : defaultPbmParameters.pano0, o.pano1 = (u = r.pano1) !== null && u !== void 0 ? u : defaultPbmParameters.pano1, o.modelAlpha = (l = r.modelAlpha) !== null && l !== void 0 ? l : defaultPbmParameters.modelAlpha, o.progress = (c = r.progress) !== null && c !== void 0 ? c : defaultPbmParameters.progress, o.transition = (f = r.transition) !== null && f !== void 0 ? f : defaultPbmParameters.transition, o.constantColor = (d = r.constantColor) !== null && d !== void 0 ? d : defaultPbmParameters.constantColor, o.opacity = (h = r.opacity) !== null && h !== void 0 ? h : defaultPbmParameters.opacity, o.floorStyle = (v = r.floorStyle) !== null && v !== void 0 ? v : defaultPbmParameters.floorStyle, o.shownFloorIndex = (A = r.shownFloorIndex) !== null && A !== void 0 ? A : defaultPbmParameters.shownFloorIndex, o.clippers = (g = r.clippers) !== null && g !== void 0 ? g : defaultPbmParameters.clippers, o.useEDL = (p = r.useEDL) !== null && p !== void 0 ? p : defaultPbmParameters.useEDL, o.useHQWeight = (y = r.useHQWeight) !== null && y !== void 0 ? y : defaultPbmParameters.useHQWeight, o.useHQDepth = (m = r.useHQDepth) !== null && m !== void 0 ? m : defaultPbmParameters.useHQDepth, o.pointSize = (E = r.pointSize) !== null && E !== void 0 ? E : defaultPbmParameters.pointSize, o.colorStyle = (b = r.colorStyle) !== null && b !== void 0 ? b : defaultPbmParameters.colorStyle, o.pointShape = (T = r.pointShape) !== null && T !== void 0 ? T : defaultPbmParameters.pointShape, o.pointScale = (R = r.pointScale) !== null && R !== void 0 ? R : defaultPbmParameters.pointScale, o.pointBack = (S = r.pointBack) !== null && S !== void 0 ? S : defaultPbmParameters.pointBack, o.pointMinPixel = (M = r.pointMinPixel) !== null && M !== void 0 ? M : defaultPbmParameters.pointMinPixel, o.pointMaxPixel = (w = r.pointMaxPixel) !== null && w !== void 0 ? w : defaultPbmParameters.pointMaxPixel, o.gradientTexture = (H = r.gradientTexture) !== null && H !== void 0 ? H : defaultPbmParameters.gradientTexture, o.brightness = (L = r.brightness) !== null && L !== void 0 ? L : defaultPbmParameters.brightness, o.colorSaturation = (C = r.colorSaturation) !== null && C !== void 0 ? C : defaultPbmParameters.colorSaturation, o.colorBrightness = (I = r.colorBrightness) !== null && I !== void 0 ? I : defaultPbmParameters.colorBrightness, o.customShaders = (_ = r.customShaders) !== null && _ !== void 0 ? _ : defaultPbmParameters.customShaders, o.outlineGain = (O = r.outlineGain) !== null && O !== void 0 ? O : defaultPbmParameters.outlineGain, o.distanceGain = (P = r.distanceGain) !== null && P !== void 0 ? P : defaultPbmParameters.distanceGain, o.useAddBlend = (N = r.useAddBlend) !== null && N !== void 0 ? N : defaultPbmParameters.useAddBlend, o.customShaderHash = "", o.customShaderUniforms = {}, o.customShaderDefines = {}, o.floorIndex = 0, o.transparent = false, o;
    }
    return t.prototype.onBeforeCompile = function(e, r) {
      var o = this, s, u, l = this.customShaders.filter(function(y) {
        return y.type.includes(o.shaderType);
      }), c = l.reduce(function(y, m) {
        return y + m.vertex.mainBefore;
      }, ""), f = l.reduce(function(y, m) {
        return y + m.vertex.mainStart;
      }, ""), d = l.reduce(function(y, m) {
        return y + m.vertex.mainEnd;
      }, ""), h = l.reduce(function(y, m) {
        return y + m.fragment.mainBefore;
      }, ""), v = l.reduce(function(y, m) {
        return y + m.fragment.mainStart;
      }, ""), A = l.reduce(function(y, m) {
        return y + m.fragment.mainModelColor;
      }, ""), g = l.reduce(function(y, m) {
        return y + m.fragment.mainEnd;
      }, "");
      e.vertexShader = e.vertexShader.replace(/MAIN_BEFORE/g, c), e.fragmentShader = e.fragmentShader.replace(/MAIN_BEFORE/g, h), e.vertexShader = e.vertexShader.replace(/MAIN_START/g, f), e.fragmentShader = e.fragmentShader.replace(/MAIN_START/g, v), e.vertexShader = e.vertexShader.replace(/MAIN_END/g, d), e.fragmentShader = e.fragmentShader.replace(/MAIN_END/g, g), e.fragmentShader = e.fragmentShader.replace(/MAIN_MODEL_COLOR/g, A);
      var p = String((u = (s = this.clippers) === null || s === void 0 ? void 0 : s.length) !== null && u !== void 0 ? u : 0);
      e.vertexShader = e.vertexShader.replace(/NUM_CLIPPERS/g, p), e.fragmentShader = e.fragmentShader.replace(/NUM_CLIPPERS/g, p), l.forEach(function(y) {
        y.onBeforeCompile(e, r);
      });
    }, t.prototype.refreshUniforms = function(e) {
      var r, o, s = this.uniforms;
      s.diffuse && s.diffuse.value.copy(this.color), s.opacity && (s.opacity.value = this.opacity), s.color && s.diffuse.value.copy(this.color), s.colorAlpha && (s.colorAlpha.value = this.colorAlpha), s.emissive && s.emissive.value.copy(this.emissive).multiplyScalar(this.emissiveIntensity), s.roughness && (s.roughness.value = this.roughness), s.metalness && (s.metalness.value = this.metalness), s.map && (s.map.value = this.map), s.alphaMap && (s.alphaMap.value = this.alphaMap), s.specularMap && (s.specularMap.value = this.specularMap), s.roughnessMap && (s.roughnessMap.value = this.roughnessMap), s.metalnessMap && (s.metalnessMap.value = this.metalnessMap), s.envMap && (s.envMap.value = this.envMap, s.flipEnvMap.value = !((r = this.envMap) === null || r === void 0) && r.isCubeTexture ? -1 : 1, s.reflectivity.value = this.reflectivity, s.refractionRatio.value = this.refractionRatio, s.maxMipLevel.value = this.envMap && (o = e == null ? void 0 : e.properties.get(this.envMap).__maxMipLevel) !== null && o !== void 0 ? o : 0, s.envMapIntensity && (s.envMapIntensity.value = this.envMapIntensity)), s.lightMap && (s.lightMap.value = this.lightMap, s.lightMapIntensity.value = this.lightMapIntensity), s.aoMap && (s.aoMap.value = this.aoMap, s.aoMapIntensity.value = this.aoMapIntensity), s.specular && s.specular.value.copy(this.specular), s.shininess && (s.shininess.value = Math.max(this.shininess, 1e-4)), s.emissiveMap && (s.emissiveMap.value = this.emissiveMap), s.bumpMap && (s.bumpMap.value = this.bumpMap, s.bumpScale.value = this.bumpScale, this.side === BackSide && (s.bumpScale.value *= -1)), s.normalMap && (s.normalMap.value = this.normalMap, s.normalScale.value.copy(this.normalScale), this.side === BackSide && s.normalScale.value.negate()), s.displacementMap && (s.displacementMap.value = this.displacementMap, s.displacementScale.value = this.displacementScale, s.displacementBias.value = this.displacementBias);
      var u;
      this.map ? u = this.map : this.specularMap ? u = this.specularMap : this.displacementMap ? u = this.displacementMap : this.normalMap ? u = this.normalMap : this.bumpMap ? u = this.bumpMap : this.alphaMap ? u = this.alphaMap : this.emissiveMap && (u = this.emissiveMap), u !== void 0 && (u.matrixAutoUpdate === true && u.updateMatrix(), s.uvTransform.value.copy(u.matrix));
      var l;
      this.aoMap ? l = this.aoMap : this.lightMap && (l = this.lightMap), l !== void 0 && (l.matrixAutoUpdate === true && l.updateMatrix(), s.uv2Transform.value.copy(l.matrix));
    }, t.prototype.update = function(e, r, o) {
      var s = "".concat(o.id, ":").concat(o.materialVersion);
      s !== this.syncModelVersion && (Object.assign(this, o.getMaterial()), this.syncModelVersion = s);
      var u = this.customShaders.map(function(m) {
        return m.getHash();
      }).join("");
      this.customShaderHash !== u && (this.customShaderHash = u, this.needsUpdate = true);
      for (var l = this.customShaders.reduce(function(m, E) {
        return Object.assign(m, E.defines);
      }, {}), c = Object.keys(this.customShaderDefines), f = 0, d = c; f < d.length; f++) {
        var h = d[f];
        delete this.defines[h];
      }
      this.customShaderDefines = l, Object.assign(this.defines, this.customShaderDefines);
      for (var v = this.customShaders.reduce(function(m, E) {
        return Object.assign(m, E.uniforms);
      }, {}), A = Object.keys(this.customShaderUniforms), g = 0, p = A; g < p.length; g++) {
        var y = p[g];
        delete this.uniforms[y];
      }
      this.customShaderUniforms = v, Object.assign(this.uniforms, this.customShaderUniforms), this.visible = true, this.envMap || (this.envMap = r.environment), this.refreshUniforms(e), this.useAddBlend ? (this.depthWrite = false, this.depthTest = false, this.blending = AdditiveBlending) : (this.depthWrite = true, this.depthTest = true, this.blending = NormalBlending), this.shaderType === "none" ? (this.depthWrite = false, this.transparent = true) : (this.transparent = this.alphaMode === "BLEND", this.depthWrite = true, this.shownFloorIndex > -1 && this.shownFloorIndex !== this.floorIndex && (this.transparent = true), this.opacity * this.colorAlpha < 1 && (this.transparent = true), this.alphaMap && (this.transparent = true), this.brightness < 1 && (this.transparent = true), this.transparent && (this.depthWrite = false), this.floorStyle === "VISIBILITY" && this.shownFloorIndex !== -1 && this.floorIndex !== this.shownFloorIndex && (this.visible = false)), this.uniforms.pixelRatio.value = r.pixelRatio, this.uniforms.resolution.value.copy(r.resolution), this.uniforms.modelBoundingMax.value.copy(o.bounding.max), this.uniforms.modelBoundingMin.value.copy(o.bounding.min);
    }, t.prototype.copy = function(e) {
      return n45.prototype.copy.call(this, e), this.color.copy(e.color), this.colorAlpha = e.colorAlpha, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.specular.copy(e.specular), this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.emissiveMap = e.emissiveMap, this.emissive.copy(e.emissive), this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.shininess = e.shininess, this.customShaders = e.customShaders, this.pano0 = e.pano0, this.pano1 = e.pano1, this.modelAlpha = e.modelAlpha, this.progress = e.progress, this.transition = e.transition, this.opacity = e.opacity, this.floorStyle = e.floorStyle, this.colorStyle = e.colorStyle, this.constantColor = e.constantColor, this.shownFloorIndex = e.shownFloorIndex, this.brightness = e.brightness, this.clippers = e.clippers, this.useEDL = e.useEDL, this.useHQWeight = e.useHQWeight, this.useHQDepth = e.useHQDepth, this.pointSize = e.pointSize, this.pointShape = e.pointShape, this.pointScale = e.pointScale, this.pointBack = e.pointBack, this.pointMinPixel = e.pointMinPixel, this.pointMaxPixel = e.pointMaxPixel, this.gradientTexture = e.gradientTexture, this.floorIndex = e.floorIndex, this.colorSaturation = e.colorSaturation, this.colorBrightness = e.colorBrightness, this.outlineGain = e.outlineGain, this.distanceGain = e.distanceGain, this.useAddBlend = e.useAddBlend, this.refreshUniforms(), this;
    }, t.prototype.clone = function() {
      return new this.constructor(this.shaderType).copy(this);
    }, t;
  }(ShaderMaterial)
);
var pointCloudFragmentShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("{vs|z-sy|n-sy||V{qr\x07H0vs-qrsv{rq5b`Rl]\\V[al[\\_ZNY6--n\bv{t-rp@-[|znyH0r{qvs0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvsp-Pyv}}r-\n--znA-znv\x07V{rrH--sy|n-sy||V{qr\x07H\fH0vs-[bZlPYV]]R_`-K-=--{vs|z-Pyv}}r-pyv}}rh[bZlPYV]]R_`jH0r{qvsn\bv{t-rpA-d|yq]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-rp@-P|y|Hn\bv{t-sy|n-]|v{`v	rH{vs|z-sy|n-|}npv\bH{vs|z-sy|n-z|qryNy}unH{vs|z-sy|n-u|{Sy||V{qr\x07H<<u{vs|z-sy|n-p|y|`nnv|{H{vs|z-sy|n-p|y|Ovtu{rH{vs|z-rp@-z|qryO|{qv{tZn\x07H{vs|z-rp@-z|qryO|{qv{tZv{H<<-{vs|z-sy|n-|yv{rTnv{H{vs|z-sy|n-qvn{prTnv{H0v{pyqr-Ip|zz|{K0v{pyqr-Is|tl}nlsntzr{K0v{pyqr-Iy|tqr}uosl}nlsntzr{K0v{pyqr-Ipyv}}v{tl}yn{rl}nlsntzr{Krp@-nqwP|y|arz}rnr5rp@-p|y|9-sy|n-rz}rnr6\n----<<--:>;=-->;=-----sy|n-rz}-J-5rz}rnr-8->;=6-7-B===;=H-<<--=-->====----<<-----sy|n-lsnp|9-tlsnp|9-olsnp|H----vs-5rz}-IJ-CC==;=6-\n--------lsnp|-J->;=H--------tlsnp|-J-=;@F==E>BDEDCF=>FC=DEA-7-y|t5rz}-<->==;=6-:-=;C@>EA>AA@DEEC?DAB=FEH--------olsnp|-J-rz}-IJ->F==;=-L-=;=-G-=;BA@?=CDEF>>=>FC=DEA@-7-y|t5rz}-<->==;=-:->=;=6-:->;>FC?BA=EF>AH----\f-ryr-\n--------lsnp|-J->;?F?F@C>EC=C?DAB=FE=A-7-}|5rz}-<->==;=-:-C=;=9-:=;>@@?=ADBF?6H--------tlsnp|-J->;>?FEF=EC=EFB?FA>>DCB-7-}|5rz}-<->==;=-:-C=;=9-:=;=DBB>AEAF?6H--------olsnp|-J->;=H----\f----<<-----rp@-nqwrqP|y|H----nqwrqP|y|;-J-pynz}5p|y|;-7-lsnp|9-=;=9->;=6H----nqwrqP|y|;t-J-pynz}5p|y|;t-7-tlsnp|9-=;=9->;=6H----nqwrqP|y|;o-J-pynz}5p|y|;o-7-olsnp|9-=;=9->;=6H----r{-nqwrqP|y|H\frp@-to?u5rp@-p6-\n----rpA-X-J-rpA5=;=9-:>;=-<-@;=9-?;=-<-@;=9-:>;=6H----rpA-}-J-zv\x075rpA5p;ot9-X;	69-rpA5p;to9-X;\x07\b69-r}5p;o9-p;t66H----rpA-\0-J-zv\x075rpA5};\x07\b9-p;69-rpA5p;9-};\b	\x0769-r}5};\x079-p;66H----sy|n-q-J-\0;\x07-:-zv{5\0;9-\0;\b6H----sy|n-r-J->;=r:>=H----r{-rp@5no5\0;	-8-5\0;-:-\0;\b6-<-5C;=-7-q-8-r669-q-<-5\0;\x07-8-r69-\0;\x076H\frp@-u?to5rp@-p6-\n----rpA-X-J-rpA5>;=9-?;=-<-@;=9->;=-<-@;=9-@;=6H----rp@-}-J-no5snp5p;\x07\x07\x07-8-X;\x07\b	6-7-C;=-:-X;6H----r{-p;	-7-zv\x075X;\x07\x07\x079-pynz}5}-:-X;\x07\x07\x079-=;=9->;=69-p;\b6H\fZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--<<-JJJ--JJJ--vs-5]|v{`v	r-I-=;==>6-\n----qvpnqH--\f--<<-JJJ--JJJ--0vs-[bZlPYV]]R_`-K-=----o||y-pyv}}rqH----rpA-pyv}}r]|vv|{H----0}ntzn-{|yyly||}ln----s|-5-v{-v-J-=H-v-I-[bZlPYV]]R_`H-v-88-6-\n------pyv}}r]|vv|{-J-pyv}}rh-v-j;znv\x07V{rr-7-d|yq]|vv|{H------pyv}}rq-J-5pyv}}rh-v-j;sy||V{qr\x07-I-=;=-\v\v-no5sy||V{qr\x07-:-pyv}}rh-v-j;sy||V{qr\x076-I->;=6H------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\x07-K-:=;B-33-pyv}}r]|vv|{;\x07-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;\b-K-:=;B-33-pyv}}r]|vv|{;\b-I-=;BH------pyv}}rq-J-pyv}}rq-33-pyv}}r]|vv|{;	-K-:=;B-33-pyv}}r]|vv|{;	-I-=;BH------vs-5pyv}}rq6-\n--------qvpnqH------\f----\f----0}ntzn-{|yyly||}lr{q--0r{qvs--<<-JJJJJJJJJJJJJJJJ--sy|n-}-J-?;=-7-tyl]|v{P||q;\x07-:->;=H--sy|n-}-J-?;=-7-tyl]|v{P||q;\b-:->;=H--sy|n-}-J-}-7-}-8-}-7-}H--<<-JJJ--JJJ--0vs-qrsv{rq5b`Rl]\\V[al`UN]RlPV_PYR6----vs-5]|v{`v	r-K-@;=-33-}-K->;=6-\n------qvpnqH----\f--0r{qvs--<<-JJJJJJJJJJJJJ--0v{pyqr-Ipyv}}v{tl}yn{rlsntzr{K--0v{pyqr-Iy|tqr}uoslsntzr{K--<<-JJJ--JJJ--rpA-sv{nyP|y|-J-_TOa|Yv{rn5rpA5P|y|9-|}npv\b66H--0vs-qrsv{rq5b`Rl]\\V[al[\\_ZNY6----0vs-qrsv{rq5b`Rl]\\V[alONPXlUVQQR[6------rp@-pnzrnQvrpv|{-J-{|znyv	r5pnzrn]|vv|{-:-d|yq]|vv|{;\x07\b	6H------vs-5q|5pnzrnQvrpv|{9-[|zny6-I-=;=6-\n--------qvpnqH------\f----0ryvs-qrsv{rq5b`Rl]\\V[alONPXlQN_X6------rp@-pnzrnQvrpv|{-J-{|znyv	r5pnzrn]|vv|{-:-d|yq]|vv|{;\x07\b	6H------vs-5q|5pnzrnQvrpv|{9-[|zny6-I-=;=6-\n--------sv{nyP|y|;\x07\b	-J-sv{nyP|y|;\x07\b	-7-=;EH------\f----0r{qvs--0r{qvs--tylSntP|y|-J-sv{nyP|y|H--<<-JJJJJJJJJJJ--<<-JJJ--JJJ--sy|n-sy||\\}npv\b-J->;=H--vs-5u|{Sy||V{qr\x07-K-:=;=>-33-no5sy||V{qr\x07-:-u|{Sy||V{qr\x076-K-=;FF6-\n----sy||\\}npv\b-J-=;>-7-zv{55>;=-8-PnzrnQvrpv|{;\b69->;=6H--\f--tylSntP|y|;n-J-tylSntP|y|;n-7-sy||\\}npv\bH--<<-JJJJJJJJJJJJJJ--tylSntP|y|;n-J-tylSntP|y|;n-7-z|qryNy}unH--ZNV[lZ\\QRYlP\\Y\\_--0v{pyqr-I|{rzn}}v{tlsntzr{K--0v{pyqr-Ir{p|qv{tlsntzr{K--<<-JJJ--JJJ--rp@-toP|y|-J-tylSntP|y|;toH--rp@-uP|y|-J-to?u5toP|y|6H--uP|y|;\b-8J-p|y|`nnv|{H--uP|y|;	-8J-p|y|Ovtu{rH--tylSntP|y|;to-J-u?to5uP|y|6H--0v{pyqr-Is|tlsntzr{K--0v{pyqr-I}rzyv}yvrqlny}unlsntzr{K--<<---0vs-qrsv{rq5b`Rl]\\V[al[\\_ZNY6----rp@-toP|y|?-J-tylSntP|y|;toH----rp@-uP|y|?-J-to?u5toP|y|?6H----rp@-vrQv-J-{|znyv	r5v\\u|tn}uvp-L-PnzrnQvrpv|{-G-d|yq]|vv|{;\x07\b	-:-pnzrn]|vv|{6H----<<-----sy|n-p|aurn-J-q|5{|znyv	r5[|zny69-vrQv6H----sy|n-n{tyr-J-np|5p|aurn6H----sy|n-|yv{rSnp|-J-}|5>;=-:-no5n{tyr-:-]VlUNYS6-<-]VlUNYS9-B;=6H----uP|y|?;	-8J-|yv{rTnv{-7-|yv{rSnp|H-<<-----uP|y|?;	-J-pynz}5uP|y|?;	9-=;=9->;=6H------<<-----rp@-o|{qv{tPr{r-J-5z|qryO|{qv{tZn\x07-8-z|qryO|{qv{tZv{6-<-?;=H----sy|n-o|{qv{tYr{tu-J-yr{tu5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6-7->;BH----sy|n-nrntrQvn{pr-J->=;=H-<<-----rp@-pnzrna|]|v{-J-d|yq]|vv|{;\x07\b	-:-pnzrn]|vv|{H----sy|n-pnzrnO|{qv{tQvn{pr-J-zn\x075=;=9-yr{tu5pnzrn]|vv|{-:-o|{qv{tPr{r6-:-o|{qv{tYr{tu-<-?;=6H----sy|n-pnzrnQvn{pr-J-yr{tu5v\\u|tn}uvp-L-vrQv-7-q|5vrQv9-pnzrna|]|v{6-G-pnzrna|]|v{6-:-pnzrnO|{qv{tQvn{prH----sy|n-qvn{prSnp|-J-pynz}5zn\x075pnzrnQvn{pr-:-nrntrQvn{pr9-=;=6-<-o|{qv{tYr{tu9-=;=9->;=6H----qvn{prSnp|-J-5=;E-:-pynz}5>;=-:-}|5>;=-:-qvn{prSnp|9-@;=69-=;=9->;=66-7->?;=H----tylSntP|y|;n-8J-zv\x075tylSntP|y|;n-7-qvn{prTnv{-7-qvn{prSnp|9-=;=9-|yv{rSnp|6H-<<-----tylSntP|y|;n-J-pynz}5tylSntP|y|;n9-=;=9->;=6H----tylSntP|y|;to-J-u?to5uP|y|?6H--0r{qvs--0vs-qrsv{rq5b`RlRQY6----tylSntP|y|;n-J-Y|tQr}uH--0r{qvs--0vs-qrsv{rq5b`RlU^ldRVTUa6----sy|n-qvn{pr-J-?;=-7-yr{tu5tyl]|v{P||q;\x07\b-:-=;B6H----sy|n-rvtu-J-zn\x075=;=9->;=-:-qvn{pr6H----rvtu-J-}|5rvtu9->;B6H----tylSntP|y|;n-J-rvtuH----tylSntP|y|;\x07\b	-J-tylSntP|y|;\x07\b	-7-rvtuH--0r{qvs--ZNV[lR[Q\f");
var pointCloudVertexShader = function() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}("nvor-rp@-p|y|H0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6--{vs|z-rp@-p|{n{P|y|H0r{qvs0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6--{vs|z-nz}yr?Q-tnqvr{ar\x07rH0r{qvs0vs-qrsv{rq5b`RlRQY6--n\bv{t-sy|n-Y|tQr}uH0r{qvs{vs|z-rp?-r|yv|{H{vs|z-sy|n-}v\x07ry_nv|H{vs|z-sy|n-}|v{`pnyrH{vs|z-sy|n-}|v{Zv{]v\x07ryH{vs|z-sy|n-}|v{Zn\x07]v\x07ryH{vs|z-sy|n-|}npv\bH{vs|z-sy|n-tr|zrvpR|H{vs|z-rp@-z|qryO|{qv{tZn\x07H{vs|z-rp@-z|qryO|{qv{tZv{Hn\bv{t-rpA-d|yq]|vv|{Hn\bv{t-rp@-PnzrnQvrpv|{Hn\bv{t-rp@-P|y|Hn\bv{t-sy|n-]|v{`v	rH0vs-qrsv{rq5b`Rl]\\V[al[\\_ZNY6--n\bv{t-rp@-[|znyH0r{qvs0v{pyqr-Ip|zz|{K0v{pyqr-Is|tl}nlrr\x07K0v{pyqr-Iz|}untrl}nlrr\x07K0v{pyqr-Iy|tqr}uosl}nlrr\x07K0v{pyqr-Ipyv}}v{tl}yn{rl}nlrr\x07Krp@-trP|y|O\bUrvtu5nz}yr?Q-tnqvr{ar\x07r9-rpA-d|yq]|vv|{6-\n--sy|n--J-5d|yq]|vv|{;\b-:-z|qryO|{qv{tZv{;\b6-<-5z|qryO|{qv{tZn\x07;\b-:-z|qryO|{qv{tZv{;\b6H--r{-r\x07r?Q5tnqvr{ar\x07r9-rp?59-=;B66;toH\fZNV[lORS\\_R|vq-znv{56-\n--ZNV[l`aN_a--0v{pyqr-Iortv{lrr\x07K--d|yq]|vv|{-J-rpA5n{s|zrq9->;=6H--0vsqrs-b`RlV[`aN[PV[T----d|yq]|vv|{-J-v{n{prZnv\x07-7-d|yq]|vv|{H--0r{qvs--d|yq]|vv|{-J-z|qryZnv\x07-7-d|yq]|vv|{H--rpA-z]|vv|{-J-vrZnv\x07-7-d|yq]|vv|{H--tyl]|vv|{-J-}|wrpv|{Znv\x07-7-z]|vv|{H--0v{pyqr-Iy|tqr}uoslrr\x07K--0v{pyqr-Ipyv}}v{tl}yn{rlrr\x07K--zn@-pnzrn_|nv|{Znv\x07-J-zn@5vrZnv\x07h=jh=j9-vrZnv\x07h>jh=j9-vrZnv\x07h?jh=j9-vrZnv\x07h=jh>j9-vrZnv\x07h>jh>j9-vrZnv\x07h?jh>j9-vrZnv\x07h=jh?j9-vrZnv\x07h>jh?j9-vrZnv\x07h?jh?j6H--PnzrnQvrpv|{-J-{|znyv	r5pnzrn_|nv|{Znv\x07-7-rp@5=;=9-=;=9-:>;=66H--<<nvorp|y|s--<<}|v{`v	r--sy|n-rny]|v{`v	r-J-}|v{`pnyr-7-}v\x07ry_nv|H--0vs-qrsv{rq5b`Rl]\\V[al`VgRlTR\\ZRa_VP6----rny]|v{`v	r-7J-tr|zrvpR|H----sy|n-urvtu-J->;=-<-}|wrpv|{Znv\x07h>jh>j-7-zv\x075>;=9-:z]|vv|{;	9-:}|wrpv|{Znv\x07h?jh@j6-7-?;=H----rny]|v{`v	r-J-r|yv|{;\b-7-rny]|v{`v	r-<-urvtuH--0ryvs-qrsv{rq5b`Rl]\\V[al`VgRlNaaR[bNaV\\[6----sy|n-urvtu-J->;=-<-}|wrpv|{Znv\x07h>jh>j-7-zv\x075>;=9-:z]|vv|{;	9-:}|wrpv|{Znv\x07h?jh@j6-7-?;=H----rny]|v{`v	r-J-r|yv|{;\b-7-rny]|v{`v	r-<-urvtuH--0r{qvs--tyl]|v{`v	r-J-pynz}5rny]|v{`v	r9-}|v{Zv{]v\x07ry-7-}v\x07ry_nv|9-}|v{Zn\x07]v\x07ry-7-}v\x07ry_nv|6H--]|v{`v	r-J-tyl]|v{`v	rH--P|y|-J-p|y|H--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lNYaVabQR6----P|y|-J-trP|y|O\bUrvtu5tnqvr{ar\x07r9-d|yq]|vv|{6H--0r{qvs--<<-JJJJJJJJJJJ--<<-JJJ--JJJ--0vs-qrsv{rq5b`RlP\\Y\\_lP\\[`aN[a6----P|y|-J-p|{n{P|y|H--0r{qvs--<<-JJJJJJJJJJJ--0vs-qrsv{rq5b`Rl]\\V[al[\\_ZNY6----[|zny-J-{|znyv	r5zn@5z|qryZnv\x076-7-{|zny6H--0r{qvs--0vs-qrsv{rq5b`RlRQY6----Y|tQr}u-J-y|t?5:z]|vv|{;	6H--0r{qvs--0vs-qrsv{rq5b`RlU^lQR]aU6----<<-sy|n-}|wSnp|-J-:=;B-7-r|yv|{;\b-<-5n{5s|-<-?;=6-7-z]|vv|{;	6H----<<-sy|n-_nqv-J-rny]|v{`v	r-<-}|wSnp|H----sy|n-|vtv{nyQr}u-J-tyl]|vv|{;H----sy|n-nqwrqQr}u-J-|vtv{nyQr}u-8-=;>H----sy|n-nqw-J-nqwrqQr}u-<-|vtv{nyQr}uH----z]|vv|{;\x07\b	-J-z]|vv|{;\x07\b	-7-nqwH----tyl]|vv|{-J-}|wrpv|{Znv\x07-7-z]|vv|{H--0r{qvs--0v{pyqr-I|yq}|lrr\x07K--0v{pyqr-Is|tlrr\x07K--ZNV[lR[Q\f");
var pbmUniforms = Object.assign({
  pointScale: new Uniform(1),
  pointMinPixel: new Uniform(1),
  pointMaxPixel: new Uniform(1),
  opacity: new Uniform(1),
  gradientTexture: new Uniform(null),
  modelAlpha: new Uniform(0),
  clippers: new Uniform([]),
  shownFloorIndex: new Uniform(-1),
  constantColor: new Uniform(new Vector3()),
  geometricError: new Uniform(0),
  pixelRatio: new Uniform(1),
  resolution: new Uniform(new Vector2(512, 512)),
  floorIndex: new Uniform(0),
  brightness: new Uniform(1),
  modelBoundingMin: new Uniform(new Vector3()),
  modelBoundingMax: new Uniform(new Vector3()),
  colorSaturation: new Uniform(0),
  colorBrightness: new Uniform(0),
  outlineGain: new Uniform(0),
  distanceGain: new Uniform(0)
}, UniformsUtils.clone(UniformsLib.fog));
var PBMPointCloudMaterial = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      e === void 0 && (e = {});
      var r, o, s, u, l, c, f, d, h, v, A, g, p, y, m, E, b, T, R, S, M, w, H, L, C, I, _, O, P = n45.call(this, {
        vertexShader: pointCloudVertexShader,
        fragmentShader: pointCloudFragmentShader,
        uniforms: UniformsUtils.clone(pbmUniforms),
        lights: false,
        clipping: true,
        defines: {
          USE_COLOR_CONSTANT: false,
          USE_COLOR_ALTITUDE: false,
          USE_EDL: false,
          USE_HQ_WEIGHT: false,
          USE_HQ_DEPTH: false,
          NUM_CLIPPING_BOX: false,
          USE_CLIPFLOOR: false,
          USE_VERTEX_MARK: false,
          USE_MAP: true,
          USE_UV: true,
          USE_LUMINANCE: false,
          USE_BLACK_TRANSITION: false,
          USE_POINT_NORMAL: false,
          USE_POINT_SHAPE_CIRCLE: false,
          USE_POINT_SIZE_ATTENUATION: false,
          USE_POINT_SIZE_GEOMETRIC: false,
          USE_POINT_BACK_HIDDEN: false,
          USE_POINT_BACK_DARK: false
        }
      }) || this, N;
      return P.customShaderHash = "", P.customShaderUniforms = {}, P.customShaderDefines = {}, Object.defineProperties(P, {
        /**  */
        constantColor: {
          get: function() {
            return this.uniforms.constantColor.value;
          },
          set: function(k) {
            this.uniforms.constantColor.value = k;
          }
        },
        opacity: {
          get: function() {
            return this.uniforms.opacity.value;
          },
          set: function(k) {
            this.uniforms.opacity.value = k;
          }
        },
        modelAlpha: {
          get: function() {
            return this.uniforms.modelAlpha.value;
          },
          set: function(k) {
            this.uniforms.modelAlpha.value = k;
          }
        },
        /** */
        shownFloorIndex: {
          get: function() {
            return this.uniforms.shownFloorIndex.value;
          },
          set: function(k) {
            this.uniforms.shownFloorIndex.value = k;
          }
        },
        /** */
        /** */
        clippers: {
          get: function() {
            return N;
          },
          set: function(k) {
            N !== k && (N = k, this.uniforms.clippers.value = (N || []).map(function(U) {
              var D = typeof U.floorIndex == "number" ? U.floorIndex : -1, q = new Matrix4().getInverse(U.clippingBoxMatrix);
              return {
                matrixInverse: q,
                floorIndex: D
              };
            }), this.needsUpdate = true);
          }
        },
        colorStyle: {
          get: function() {
            return this.defines.USE_COLOR_CONSTANT ? "CONSTANT" : this.defines.USE_COLOR_ALTITUDE ? "ALTITUDE" : "RGB";
          },
          set: function(k) {
            var U = k === "CONSTANT", D = k === "ALTITUDE";
            this.defines.USE_COLOR_CONSTANT !== U && (this.defines.USE_COLOR_CONSTANT = U, this.needsUpdate = true), this.defines.USE_COLOR_ALTITUDE !== D && (this.defines.USE_COLOR_ALTITUDE = D, this.needsUpdate = true);
          }
        },
        pointSize: {
          get: function() {
            return this.defines.USE_POINT_SIZE_GEOMETRIC === true ? "GEOMETRIC" : this.defines.USE_POINT_SIZE_ATTENUATION === true ? "ATTENUATION" : "FIXED";
          },
          set: function(k) {
            var U = k === "ATTENUATION", D = k === "GEOMETRIC";
            this.defines.USE_POINT_SIZE_GEOMETRIC !== D && (this.defines.USE_POINT_SIZE_GEOMETRIC = D, this.needsUpdate = true), this.defines.USE_POINT_SIZE_ATTENUATION !== U && (this.defines.USE_POINT_SIZE_ATTENUATION = U, this.needsUpdate = true);
          }
        },
        pointShape: {
          get: function() {
            return this.defines.USE_POINT_SHAPE_CIRCLE === true ? "CIRCLE" : "SQUARE";
          },
          set: function(k) {
            var U = k === "CIRCLE";
            this.defines.USE_POINT_SHAPE_CIRCLE !== U && (this.defines.USE_POINT_SHAPE_CIRCLE = U, this.needsUpdate = true);
          }
        },
        pointScale: {
          get: function() {
            return this.uniforms.pointScale.value;
          },
          set: function(k) {
            this.uniforms.pointScale.value = k;
          }
        },
        pointBack: {
          get: function() {
            return this.defines.USE_POINT_BACK_HIDDEN === true ? "HIDDEN" : this.defines.USE_POINT_BACK_DARK === true ? "DARK" : "VISIBLE";
          },
          set: function(k) {
            var U = k === "HIDDEN", D = k === "DARK";
            this.defines.USE_POINT_BACK_HIDDEN !== U && (this.defines.USE_POINT_BACK_HIDDEN = U, this.needsUpdate = true), this.defines.USE_POINT_BACK_DARK !== D && (this.defines.USE_POINT_BACK_DARK = D, this.needsUpdate = true);
          }
        },
        pointMinPixel: {
          get: function() {
            return this.uniforms.pointMinPixel.value;
          },
          set: function(k) {
            this.uniforms.pointMinPixel.value = k;
          }
        },
        pointMaxPixel: {
          get: function() {
            return this.uniforms.pointMaxPixel.value;
          },
          set: function(k) {
            this.uniforms.pointMaxPixel.value = k;
          }
        },
        useEDL: {
          get: function() {
            return this.defines.USE_EDL;
          },
          set: function(k) {
            k !== this.defines.USE_EDL && (this.defines.USE_EDL = k, this.needsUpdate = true);
          }
        },
        useHQWeight: {
          get: function() {
            return this.defines.USE_HQ_WEIGHT;
          },
          set: function(k) {
            k !== this.defines.USE_HQ_WEIGHT && (this.defines.USE_HQ_WEIGHT = k, this.needsUpdate = true);
          }
        },
        useHQDepth: {
          get: function() {
            return this.defines.USE_HQ_DEPTH;
          },
          set: function(k) {
            k !== this.defines.USE_HQ_DEPTH && (this.defines.USE_HQ_DEPTH = k, this.needsUpdate = true);
          }
        },
        gradientTexture: {
          get: function() {
            return this.uniforms.gradientTexture.value;
          },
          set: function(k) {
            this.uniforms.gradientTexture.value = k;
          }
        },
        floorIndex: {
          get: function() {
            return this.uniforms.floorIndex.value;
          },
          set: function(k) {
            this.uniforms.floorIndex.value = k;
          }
        },
        brightness: {
          get: function() {
            return this.uniforms.brightness.value;
          },
          set: function(k) {
            this.uniforms.brightness.value = k;
          }
        },
        colorSaturation: {
          get: function() {
            return this.uniforms.colorSaturation.value;
          },
          set: function(k) {
            this.uniforms.colorSaturation.value = k;
          }
        },
        colorBrightness: {
          get: function() {
            return this.uniforms.colorBrightness.value;
          },
          set: function(k) {
            this.uniforms.colorBrightness.value = k;
          }
        },
        outlineGain: {
          get: function() {
            return this.uniforms.outlineGain.value;
          },
          set: function(k) {
            this.uniforms.outlineGain.value = k;
          }
        },
        distanceGain: {
          get: function() {
            return this.uniforms.distanceGain.value;
          },
          set: function(k) {
            this.uniforms.distanceGain.value = k;
          }
        }
      }), P.pano0 = (r = e.pano0) !== null && r !== void 0 ? r : defaultPbmParameters.pano0, P.pano1 = (o = e.pano1) !== null && o !== void 0 ? o : defaultPbmParameters.pano1, P.modelAlpha = (s = e.modelAlpha) !== null && s !== void 0 ? s : defaultPbmParameters.modelAlpha, P.progress = (u = e.progress) !== null && u !== void 0 ? u : defaultPbmParameters.progress, P.transition = (l = e.transition) !== null && l !== void 0 ? l : defaultPbmParameters.transition, P.colorStyle = (c = e.colorStyle) !== null && c !== void 0 ? c : defaultPbmParameters.colorStyle, P.constantColor = (f = e.constantColor) !== null && f !== void 0 ? f : defaultPbmParameters.constantColor, P.opacity = (d = e.opacity) !== null && d !== void 0 ? d : defaultPbmParameters.opacity, P.floorStyle = (h = e.floorStyle) !== null && h !== void 0 ? h : defaultPbmParameters.floorStyle, P.shownFloorIndex = (v = e.shownFloorIndex) !== null && v !== void 0 ? v : defaultPbmParameters.shownFloorIndex, P.clippers = (A = e.clippers) !== null && A !== void 0 ? A : defaultPbmParameters.clippers, P.useEDL = (g = e.useEDL) !== null && g !== void 0 ? g : defaultPbmParameters.useEDL, P.useHQWeight = (p = e.useHQWeight) !== null && p !== void 0 ? p : defaultPbmParameters.useHQWeight, P.useHQDepth = (y = e.useHQDepth) !== null && y !== void 0 ? y : defaultPbmParameters.useHQDepth, P.pointShape = (m = e.pointShape) !== null && m !== void 0 ? m : defaultPbmParameters.pointShape, P.pointSize = (E = e.pointSize) !== null && E !== void 0 ? E : defaultPbmParameters.pointSize, P.pointScale = (b = e.pointScale) !== null && b !== void 0 ? b : defaultPbmParameters.pointScale, P.pointBack = (T = e.pointBack) !== null && T !== void 0 ? T : defaultPbmParameters.pointBack, P.pointMinPixel = (R = e.pointMinPixel) !== null && R !== void 0 ? R : defaultPbmParameters.pointMinPixel, P.pointMaxPixel = (S = e.pointMaxPixel) !== null && S !== void 0 ? S : defaultPbmParameters.pointMaxPixel, P.gradientTexture = (M = e.gradientTexture) !== null && M !== void 0 ? M : defaultPbmParameters.gradientTexture, P.brightness = (w = e.brightness) !== null && w !== void 0 ? w : defaultPbmParameters.brightness, P.colorSaturation = (H = e.colorSaturation) !== null && H !== void 0 ? H : defaultPbmParameters.colorSaturation, P.colorBrightness = (L = e.colorBrightness) !== null && L !== void 0 ? L : defaultPbmParameters.colorBrightness, P.outlineGain = (C = e.outlineGain) !== null && C !== void 0 ? C : defaultPbmParameters.outlineGain, P.distanceGain = (I = e.distanceGain) !== null && I !== void 0 ? I : defaultPbmParameters.distanceGain, P.customShaders = (_ = e.customShaders) !== null && _ !== void 0 ? _ : defaultPbmParameters.customShaders, P.useAddBlend = (O = e.useAddBlend) !== null && O !== void 0 ? O : defaultPbmParameters.useAddBlend, P.customShaderHash = "", P.floorIndex = 0, P.transparent = true, P;
    }
    return t.prototype.onBeforeCompile = function(e, r) {
      var o, s, u = this.customShaders.filter(function(p) {
        return p.type.includes("pointcloud");
      }), l = u.reduce(function(p, y) {
        return p + y.vertex.mainBefore;
      }, ""), c = u.reduce(function(p, y) {
        return p + y.vertex.mainStart;
      }, ""), f = u.reduce(function(p, y) {
        return p + y.vertex.mainEnd;
      }, ""), d = u.reduce(function(p, y) {
        return p + y.fragment.mainBefore;
      }, ""), h = u.reduce(function(p, y) {
        return p + y.fragment.mainStart;
      }, ""), v = u.reduce(function(p, y) {
        return p + y.fragment.mainModelColor;
      }, ""), A = u.reduce(function(p, y) {
        return p + y.fragment.mainEnd;
      }, "");
      e.vertexShader = e.vertexShader.replace(/MAIN_BEFORE/g, l), e.fragmentShader = e.fragmentShader.replace(/MAIN_BEFORE/g, d), e.vertexShader = e.vertexShader.replace(/MAIN_START/g, c), e.fragmentShader = e.fragmentShader.replace(/MAIN_START/g, h), e.vertexShader = e.vertexShader.replace(/MAIN_END/g, f), e.fragmentShader = e.fragmentShader.replace(/MAIN_END/g, A), e.fragmentShader = e.fragmentShader.replace(/MAIN_MODEL_COLOR/g, v);
      var g = String((s = (o = this.clippers) === null || o === void 0 ? void 0 : o.length) !== null && s !== void 0 ? s : 0);
      e.vertexShader = e.vertexShader.replace(/NUM_CLIPPERS/g, g), e.fragmentShader = e.fragmentShader.replace(/NUM_CLIPPERS/g, g), u.forEach(function(p) {
        p.onBeforeCompile(e, r);
      });
    }, t.prototype.update = function(e, r, o) {
      var s = "".concat(o.id, ":").concat(o.materialVersion);
      s !== this.syncModelVersion && (Object.assign(this, o.getMaterial()), this.syncModelVersion = s);
      var u = this.customShaders.map(function(m) {
        return m.getHash();
      }).join("");
      this.customShaderHash !== u && (this.customShaderHash = u, this.needsUpdate = true);
      for (var l = this.customShaders.reduce(function(m, E) {
        return Object.assign(m, E.defines);
      }, {}), c = Object.keys(this.customShaderDefines), f = 0, d = c; f < d.length; f++) {
        var h = d[f];
        delete this.defines[h];
      }
      this.customShaderDefines = l, Object.assign(this.defines, this.customShaderDefines);
      for (var v = this.customShaders.reduce(function(m, E) {
        return Object.assign(m, E.uniforms);
      }, {}), A = Object.keys(this.customShaderUniforms), g = 0, p = A; g < p.length; g++) {
        var y = p[g];
        delete this.uniforms[y];
      }
      this.customShaderUniforms = v, Object.assign(this.uniforms, this.customShaderUniforms), this.visible = true, this.transparent = false, this.shownFloorIndex > -1 && (this.transparent = this.shownFloorIndex !== this.floorIndex), this.modelAlpha < 1 && (this.transparent = true), this.opacity < 1 && (this.transparent = true), this.brightness < 1 && (this.transparent = true), this.useAddBlend ? (this.depthWrite = false, this.depthTest = false, this.blending = AdditiveBlending) : (this.depthWrite = true, this.depthTest = true, this.blending = NormalBlending), this.useEDL && (this.transparent = false), this.useHQWeight ? (this.depthWrite = false, this.blending = CustomBlending, this.blendSrc = SrcAlphaFactor, this.blendSrcAlpha = SrcAlphaFactor, this.blendDst = OneFactor, this.blendDstAlpha = OneFactor) : (this.blending = NormalBlending, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null), this.floorStyle === "VISIBILITY" && this.shownFloorIndex !== -1 && this.floorIndex !== this.shownFloorIndex && (this.visible = false), this.uniforms.pixelRatio.value = r.pixelRatio, this.uniforms.resolution.value.copy(r.resolution), this.uniforms.modelBoundingMax.value.copy(o.bounding.max), this.uniforms.modelBoundingMin.value.copy(o.bounding.min);
    }, t.prototype.copy = function(e) {
      return n45.prototype.copy.call(this, this), this.customShaders = e.customShaders, this.pano0 = e.pano0, this.pano1 = e.pano1, this.progress = e.progress, this.transition = e.transition, this.floorStyle = e.floorStyle, this.shownFloorIndex = e.shownFloorIndex, this.brightness = e.brightness, this.clippers = e.clippers, this.constantColor = e.constantColor, this.modelAlpha = e.modelAlpha, this.useEDL = e.useEDL, this.useHQWeight = e.useHQWeight, this.useHQDepth = e.useHQDepth, this.colorStyle = e.colorStyle, this.pointSize = e.pointSize, this.pointShape = e.pointShape, this.pointScale = e.pointScale, this.pointBack = e.pointBack, this.pointMinPixel = e.pointMinPixel, this.pointMaxPixel = e.pointMaxPixel, this.gradientTexture = e.gradientTexture, this.colorSaturation = e.colorSaturation, this.colorBrightness = e.colorBrightness, this.outlineGain = e.outlineGain, this.distanceGain = e.distanceGain, this.useAddBlend = e.useAddBlend, this;
    }, t;
  }(ShaderMaterial)
);
var InternalWebGLRenderer = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = e.preserveDrawingBuffer, o = r === void 0 ? true : r, s = e.premultipliedAlpha, u = s === void 0 ? true : s, l = e.stencil, c = l === void 0 ? true : l, f = e.backgroundColor, d = f === void 0 ? 1579548 : f, h = e.backgroundAlpha, v = h === void 0 ? 1 : h, A = e.pixelRatio, g = A === void 0 ? 1 : A, p = e.antialias, y = p === void 0 ? false : p, m = e.webgl2, E = e.logarithmicDepthBuffer, b = e.precision, T = e.powerPreference, R = this, S = {
        antialias: y,
        alpha: true,
        // Mac Safari  alpha  ture
        depth: true,
        preserveDrawingBuffer: o,
        stencil: c,
        premultipliedAlpha: u,
        powerPreference: T
      }, M = {
        logarithmicDepthBuffer: E,
        precision: b
      };
      if (m) {
        var w = document.createElement("canvas"), H = w.getContext("webgl2", S);
        H ? R = n45.call(this, __assign(__assign(__assign({}, S), M), { antialias: true, canvas: w, context: H })) || this : (console.error("error occurred when getting webgl2 canvas context, mybe webgl2 not support, fallback to webgl."), R = n45.call(this, __assign(__assign({}, S), M)) || this);
      } else
        R = n45.call(this, __assign(__assign({}, S), M)) || this;
      return R.setPixelRatio(g), R.setClearColor(d, v), R.outputEncoding = sRGBEncoding, R.autoClear = true, R;
    }
    return t;
  }(WebGLRenderer)
);
var Scene2 = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.add = function() {
      for (var e = [], r = 0; r < arguments.length; r++)
        e[r] = arguments[r];
      return n45.prototype.add.apply(this, e);
    }, t.prototype.remove = function() {
      for (var e = [], r = 0; r < arguments.length; r++)
        e[r] = arguments[r];
      return n45.prototype.remove.apply(this, e);
    }, t;
  }(Scene)
);
function coordinatesToVector(n45, t) {
  var e = Math.abs(Math.cos(n45.latitude)), r = -Math.sin(n45.longitude) * e, o = -Math.sin(n45.latitude), s = -Math.cos(n45.longitude) * e;
  return t ? t.set(r, o, s) : new Vector3(r, o, s);
}
var DEFAULT_ASPECT = 1;
var DEFAULT_NEAR = 0.1;
var DEFAULT_FAR = 2e3;
var TAU$2 = Math.PI * 2;
var PI_2 = Math.PI / 2;
function formatRad$1(n45) {
  return n45 > 0 && n45 <= TAU$2 ? n45 : (n45 % TAU$2 + TAU$2) % TAU$2;
}
function matrixLerp(n45, t, e, r) {
  e = Math.pow(e, 4);
  for (var o = 0; o < 16; o++)
    r.elements[o] = n45.elements[o] + (t.elements[o] - n45.elements[o]) * e;
  return r;
}
var Camera2 = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o, s, u, l, c) {
      r === void 0 && (r = DEFAULT_ASPECT), o === void 0 && (o = DEFAULT_NEAR), s === void 0 && (s = DEFAULT_FAR), u === void 0 && (u = new Vector2()), l === void 0 && (l = new Vector2(512, 512)), c === void 0 && (c = 1);
      var f = n45.call(this) || this;
      f.fov = e, f.aspect = r, f.near = o, f.far = s, f.perspToOrtho = u, f.resolution = l, f.pixelRatio = c, f.time = 0, f.needsRender = true, f.refineModel = true, f.pose = {
        longitude: 0,
        latitude: 0,
        fov: e,
        distance: 0,
        offset: new Vector3()
      }, f.computePose(), f.perspectiveCamera = new PerspectiveCamera(f.fov, f.aspect, 1e-3, f.far);
      var d = Math.max(f.orthoDistance, 0.01) * Math.tan(0.5 * f.fov / 180 * Math.PI), h = -0.5 * f.aspect * 2 * d;
      return f.orthographicCamera = new OrthographicCamera(h, -h, d, -d, 1e-3, f.far), f.computeProjectionMatrix(), f.lastValues = {
        position: f.position.clone(),
        quaternion: f.quaternion.clone(),
        scale: f.scale.clone(),
        fov: f.fov,
        aspect: f.aspect,
        near: f.near,
        far: f.far,
        orthoDistance: f.orthoDistance,
        perspToOrtho: f.perspToOrtho.clone()
      }, f.type = f.perspToOrtho.x < 1 ? "PerspectiveCamera" : "OrthographicCamera", f.autoNearFar = true, f.environment = null, f;
    }
    return Object.defineProperty(t.prototype, "orthoDistance", {
      get: function() {
        return this.pose.distance > 1 ? this.pose.distance : 1 + (this.pose.distance - 1) * this.perspToOrtho.x;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "zoom", {
      get: function() {
        return this.type === "OrthographicCamera" ? this.orthographicCamera.zoom : this.type === "PerspectiveCamera" ? this.perspectiveCamera.zoom : 1;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "top", {
      get: function() {
        return this.type === "OrthographicCamera" ? this.orthographicCamera.top : 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "bottom", {
      get: function() {
        return this.type === "OrthographicCamera" ? this.orthographicCamera.bottom : 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "left", {
      get: function() {
        return this.type === "OrthographicCamera" ? this.orthographicCamera.left : 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "right", {
      get: function() {
        return this.type === "OrthographicCamera" ? this.orthographicCamera.right : 0;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.getDirection = function(e) {
      return coordinatesToVector(this.pose, e);
    }, t.prototype.computePose = function(e) {
      e === void 0 && (e = 0), this.updateMatrix();
      var r = this.matrix.elements;
      return this.pose.latitude = Math.asin(clamp$1(r[9], -1, 1)), Math.abs(r[9]) < 0.9999999 ? this.pose.longitude = formatRad$1(Math.atan2(r[8], r[10])) : this.pose.longitude = formatRad$1(Math.atan2(-r[2], r[0])), this.pose.fov = this.fov, this.pose.distance = e, this.pose.offset = new Vector3(-r[8], -r[9], -r[10]).setLength(this.pose.distance).add(this.position), this;
    }, t.prototype.setFromPose = function(e) {
      var r, o, s, u, l, c = formatRad$1((r = e.longitude) !== null && r !== void 0 ? r : this.pose.longitude), f = Math.max(-PI_2 + 1e-4, Math.min(PI_2 - 1e-4, (o = e.latitude) !== null && o !== void 0 ? o : this.pose.latitude)), d = (s = e.fov) !== null && s !== void 0 ? s : this.pose.fov, h = (u = e.distance) !== null && u !== void 0 ? u : this.pose.distance, v = (l = e.offset) !== null && l !== void 0 ? l : this.pose.offset, A = coordinatesToVector({ longitude: c, latitude: f }).normalize();
      return this.position.set(0, 0, 0), this.lookAt(A), this.position.add(v).sub(A.clone().setLength(h)), this.fov !== d && (this.fov = d, this.updateProjectionMatrix()), this.updateMatrixWorld(true), this.pose.longitude = c, this.pose.latitude = f, this.pose.fov = d, this.pose.distance = h, this.pose.offset.copy(v), this.needsRender = true, this;
    }, t.prototype.copyPose = function() {
      return {
        longitude: this.pose.longitude,
        latitude: this.pose.latitude,
        fov: this.pose.fov,
        distance: this.pose.distance,
        offset: this.pose.offset.clone()
      };
    }, t.prototype.computeProjectionMatrix = function() {
      matrixLerp(this.orthographicCamera.projectionMatrix, this.perspectiveCamera.projectionMatrix, 1 - this.perspToOrtho.x, this.projectionMatrix), this.projectionMatrixInverse.getInverse(this.projectionMatrix), this.needsRender = true;
    }, t.prototype.setViewOffset = function(e, r, o, s, u, l) {
      this.perspectiveCamera.setViewOffset(e, r, o, s, u, l), this.orthographicCamera.setViewOffset(e, r, o, s, u, l), this.computeProjectionMatrix();
    }, t.prototype.clearViewOffset = function() {
      this.perspectiveCamera.clearViewOffset(), this.orthographicCamera.clearViewOffset(), this.computeProjectionMatrix();
    }, t.prototype.updateProjectionMatrix = function() {
      this.perspectiveCamera.updateProjectionMatrix(), this.orthographicCamera.updateProjectionMatrix(), this.computeProjectionMatrix();
    }, Object.defineProperty(t.prototype, "perspectiveProjectionMatrix", {
      get: function() {
        return this.perspectiveCamera.projectionMatrix;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "perspectiveProjectionMatrixInverse", {
      get: function() {
        return this.perspectiveCamera.projectionMatrixInverse;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "orthographicProjectionMatrix", {
      get: function() {
        return this.orthographicCamera.projectionMatrix;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "orthographicProjectionMatrixInverse", {
      get: function() {
        return this.orthographicCamera.projectionMatrixInverse;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.updateTime = function(e) {
      this.time = e;
      var r = false;
      if ((this.lastValues.fov !== this.fov || this.lastValues.near !== this.near || this.lastValues.far !== this.far || this.lastValues.aspect !== this.aspect) && (this.perspectiveCamera.fov = this.fov, this.perspectiveCamera.near = this.near, this.perspectiveCamera.far = this.far, this.perspectiveCamera.aspect = this.aspect, this.perspectiveCamera.updateProjectionMatrix(), r = true), !this.lastValues.position.equals(this.position) || !this.lastValues.quaternion.equals(this.quaternion) || !this.lastValues.scale.equals(this.scale) || !this.lastValues.perspToOrtho.equals(this.perspToOrtho) || this.lastValues.fov !== this.fov || this.lastValues.near !== this.near || this.lastValues.far !== this.far || this.lastValues.orthoDistance !== this.orthoDistance || this.lastValues.aspect !== this.aspect) {
        var o = Math.max(this.orthoDistance, 0.01) * Math.tan(0.5 * this.fov / 180 * Math.PI), s = -0.5 * this.aspect * 2 * o;
        this.orthographicCamera.left = s, this.orthographicCamera.right = -s, this.orthographicCamera.top = o, this.orthographicCamera.bottom = -o, this.orthographicCamera.near = this.near, this.orthographicCamera.far = this.far, this.orthographicCamera.updateProjectionMatrix(), r = true;
      }
      r && this.computeProjectionMatrix(), this.lastValues.position.copy(this.position), this.lastValues.quaternion.copy(this.quaternion), this.lastValues.scale.copy(this.scale), this.lastValues.fov = this.fov, this.lastValues.aspect = this.aspect, this.lastValues.near = this.near, this.lastValues.far = this.far, this.lastValues.orthoDistance = this.orthoDistance, this.lastValues.perspToOrtho.copy(this.perspToOrtho), this.type = this.perspToOrtho.x < 1 ? "PerspectiveCamera" : "OrthographicCamera";
    }, Object.defineProperty(t.prototype, "isPerspectiveCamera", {
      get: function() {
        return this.perspToOrtho.x < 1;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "isOrthographicCamera", {
      get: function() {
        return this.perspToOrtho.x >= 1;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.copy = function(e, r) {
      return n45.prototype.copy.call(this, e, r), this.fov = e.fov, this.aspect = e.aspect, this.near = e.near, this.far = e.far, this.perspToOrtho.copy(e.perspToOrtho), this.updateTime(now()), this;
    }, t;
  }(Camera)
);
var VolumePlaneIntersect;
(function(n45) {
  n45[n45.Outside = -1] = "Outside", n45[n45.Intersecting = 0] = "Intersecting", n45[n45.Inside = 1] = "Inside";
})(VolumePlaneIntersect || (VolumePlaneIntersect = {}));
var EPSILON$2 = 1e-6;
var scratchVector = new Vector3();
var scratchMatrix4$4 = new Matrix4();
var scratchXAxis = new Vector3();
var scratchYAxis = new Vector3();
var scratchZAxis = new Vector3();
var scratchSize = new Vector3();
var scratchBox3 = new Box3();
var scratchSphere$1 = new Sphere();
var scratchMatrix4Inverse$1 = new Matrix4();
var scratchRay$1 = new Ray();
var scratchObject3D = new Object3D();
var scratchFrustum = new Frustum();
function quaternionFromMatrix3(n45, t) {
  var e = n45.elements;
  return t.setFromRotationMatrix(scratchMatrix4$4.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1)), t;
}
var CullingVolume = (
  /** @class */
  function() {
    function n45(t) {
      t === void 0 && (t = []), this.planes = t;
    }
    return Object.defineProperty(n45, "MASK_OUTSIDE", {
      // outside the culling volume.
      get: function() {
        return 4294967295;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45, "MASK_INSIDE", {
      // inside the culling volume.
      get: function() {
        return 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45, "MASK_INDETERMINATE", {
      // represents the case where the object bounding volume (may) intersect all planes of the culling volume.
      get: function() {
        return 2147483647;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.setFromFrustum = function(t) {
      return this.planes = t.planes.map(function(e) {
        return e.clone();
      }), this;
    }, n45.prototype.setFromCamera = function(t) {
      return scratchMatrix4$4.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), scratchFrustum.setFromProjectionMatrix(scratchMatrix4$4), this.setFromFrustum(scratchFrustum), this;
    }, n45.prototype.applyMatrix4 = function(t) {
      for (var e = 0, r = this.planes; e < r.length; e++) {
        var o = r[e];
        o.applyMatrix4(t);
      }
    }, n45.prototype.copy = function(t) {
      return this.planes = t.planes.map(function(e) {
        return e.clone();
      }), this;
    }, n45.prototype.clone = function() {
      return new n45().copy(this);
    }, n45.prototype.computeVisibility = function(t) {
      for (var e = VolumePlaneIntersect.Inside, r = 0, o = this.planes; r < o.length; r++) {
        var s = o[r], u = t.intersectPlane(s);
        switch (u) {
          case VolumePlaneIntersect.Outside:
            return VolumePlaneIntersect.Outside;
          case VolumePlaneIntersect.Intersecting:
            e = VolumePlaneIntersect.Intersecting;
            break;
        }
      }
      return e;
    }, n45.prototype.computeVisibilityWithPlaneMask = function(t, e) {
      if (e === n45.MASK_OUTSIDE || e === n45.MASK_INSIDE)
        return e;
      for (var r = n45.MASK_INSIDE, o = Math.min(32, this.planes.length), s = 0; s < o; ++s) {
        var u = 1 << s;
        if (e & u) {
          var l = this.planes[s], c = t.intersectPlane(l);
          if (c === VolumePlaneIntersect.Outside)
            return n45.MASK_OUTSIDE;
          c === VolumePlaneIntersect.Intersecting && (r |= u);
        }
      }
      return r;
    }, n45;
  }()
);
var BoxBoundingVolume = (
  /** @class */
  function() {
    function n45() {
      this.type = "box", this.center = new Vector3(), this.halfSize = new Vector3(), this.rotation = new Matrix3();
    }
    return n45.prototype.fromJson = function(t) {
      var e = t.box;
      this.center.set(e[0], e[1], e[2]);
      var r = e[3], o = e[4], s = e[5], u = e[6], l = e[7], c = e[8], f = e[9], d = e[10], h = e[11], v = Math.max(Math.sqrt(r * r + o * o + s * s), 1e-3), A = Math.max(Math.sqrt(u * u + l * l + c * c), 1e-3), g = Math.max(Math.sqrt(f * f + d * d + h * h), 1e-3);
      this.halfSize.set(v, A, g);
      var p = this.halfSize.toArray().reduce(function(y, m) {
        return y + m;
      }, 0);
      return (isNaN(p) || p <= 0) && this.halfSize.setScalar(EPSILON$2), this.rotation.fromArray([
        r / v,
        o / v,
        s / v,
        u / A,
        l / A,
        c / A,
        f / g,
        d / g,
        h / g
      ]), isNaN(this.rotation.toArray().reduce(function(y, m) {
        return y + m;
      }, 0)) && this.rotation.identity(), this;
    }, n45.prototype.toJson = function() {
      return this.rotation.extractBasis(scratchXAxis, scratchYAxis, scratchZAxis), {
        box: __spreadArray(__spreadArray(__spreadArray(__spreadArray([], this.center.toArray(), true), scratchXAxis.multiplyScalar(this.halfSize.x).toArray(), true), scratchYAxis.multiplyScalar(this.halfSize.y).toArray(), true), scratchZAxis.multiplyScalar(this.halfSize.z).toArray(), true)
      };
    }, n45.prototype.copy = function(t) {
      return this.center.copy(t.center), this.halfSize.copy(t.halfSize), this.rotation.copy(t.rotation), this;
    }, n45.prototype.clone = function() {
      return new n45().copy(this);
    }, n45.prototype.applyMatrix4 = function(t) {
      return scratchObject3D.position.copy(this.center), quaternionFromMatrix3(this.rotation, scratchObject3D.quaternion), scratchObject3D.scale.copy(this.halfSize), scratchObject3D.matrix.compose(scratchObject3D.position, scratchObject3D.quaternion, scratchObject3D.scale), scratchObject3D.matrix.premultiply(t), scratchObject3D.matrix.decompose(scratchObject3D.position, scratchObject3D.quaternion, scratchObject3D.scale), this.center.copy(scratchObject3D.position), this.rotation.setFromMatrix4(scratchMatrix4$4.makeRotationFromQuaternion(scratchObject3D.quaternion)), this.halfSize.copy(scratchObject3D.scale), this;
    }, n45.prototype.getCenter = function(t) {
      return t.copy(this.center);
    }, n45.prototype.distanceSquaredToPoint = function(t) {
      var e = this.rotation.elements, r = t.x - this.center.x, o = t.y - this.center.y, s = t.z - this.center.z, u = 0, l;
      return l = r * e[0] + o * e[1] + s * e[2], l < 0 && (l = -l), l -= this.halfSize.x, l > 0 && (u += l * l), l = r * e[3] + o * e[4] + s * e[5], l < 0 && (l = -l), l -= this.halfSize.y, l > 0 && (u += l * l), l = r * e[6] + o * e[7] + s * e[8], l < 0 && (l = -l), l -= this.halfSize.z, l > 0 && (u += l * l), u;
    }, n45.prototype.distanceToPoint = function(t) {
      return Math.sqrt(this.distanceSquaredToPoint(t));
    }, n45.prototype.distanceToPlane = function(t) {
      var e = t.projectPoint(this.center, new Vector3());
      return this.distanceToPoint(e);
    }, n45.prototype.getBoundingBox = function(t) {
      return t.makeEmpty(), this.rotation.extractBasis(scratchXAxis, scratchYAxis, scratchZAxis), scratchXAxis.setLength(this.halfSize.x), scratchYAxis.setLength(this.halfSize.y), scratchZAxis.setLength(this.halfSize.z), t.expandByPoint(scratchVector.copy(this.center).add(scratchXAxis)), t.expandByPoint(scratchVector.copy(this.center).sub(scratchXAxis)), t.expandByPoint(scratchVector.copy(this.center).add(scratchYAxis)), t.expandByPoint(scratchVector.copy(this.center).sub(scratchYAxis)), t.expandByPoint(scratchVector.copy(this.center).add(scratchZAxis)), t.expandByPoint(scratchVector.copy(this.center).sub(scratchZAxis)), t;
    }, n45.prototype.toGeometry = function() {
      var t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), e = new Float32Array(8 * 3);
      scratchVector.set(this.halfSize.x, this.halfSize.y, this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 0), scratchVector.set(-this.halfSize.x, this.halfSize.y, this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 3), scratchVector.set(-this.halfSize.x, -this.halfSize.y, this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 6), scratchVector.set(this.halfSize.x, -this.halfSize.y, this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 9), scratchVector.set(this.halfSize.x, this.halfSize.y, -this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 12), scratchVector.set(-this.halfSize.x, this.halfSize.y, -this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 15), scratchVector.set(-this.halfSize.x, -this.halfSize.y, -this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 18), scratchVector.set(this.halfSize.x, -this.halfSize.y, -this.halfSize.z).applyMatrix3(this.rotation).add(this.center).toArray(e, 21);
      var r = new BufferGeometry();
      return r.setIndex(new BufferAttribute(t, 1)), r.setAttribute("position", new BufferAttribute(e, 3)), r.computeBoundingBox(), r.computeBoundingSphere(), r;
    }, n45.prototype.intersectPlane = function(t) {
      var e = this.center, r = t.normal, o = this.rotation.elements, s = this.halfSize, u = r.x, l = r.y, c = r.z, f = Math.abs(u * o[0] * s.x + l * o[1] * s.x + c * o[2] * s.x) + Math.abs(u * o[3] * s.y + l * o[4] * s.y + c * o[5] * s.y) + Math.abs(u * o[6] * s.z + l * o[7] * s.z + c * o[8] * s.z), d = r.dot(e) + t.constant;
      return d <= -f ? VolumePlaneIntersect.Outside : d >= f ? VolumePlaneIntersect.Inside : VolumePlaneIntersect.Intersecting;
    }, n45.prototype.intersectRay = function(t, e) {
      if (scratchSize.copy(this.halfSize).multiplyScalar(2), scratchBox3.setFromCenterAndSize(scratchVector.set(0, 0, 0), scratchSize), this.rotation.extractBasis(scratchXAxis, scratchYAxis, scratchZAxis), scratchMatrix4$4.makeBasis(scratchXAxis, scratchYAxis, scratchZAxis), scratchMatrix4$4.setPosition(this.center), scratchMatrix4Inverse$1.getInverse(scratchMatrix4$4), scratchRay$1.copy(t).applyMatrix4(scratchMatrix4Inverse$1), scratchBox3.containsPoint(scratchRay$1.origin))
        return true;
      var r = scratchRay$1.intersectBox(scratchBox3, scratchVector);
      return r ? e !== void 0 ? r.applyMatrix4(scratchMatrix4$4).distanceTo(t.origin) < e : true : false;
    }, n45;
  }()
);
var SphereBoundingVolume = (
  /** @class */
  function() {
    function n45() {
      this.type = "sphere", this.center = new Vector3(), this.radius = -1;
    }
    return n45.prototype.fromJson = function(t) {
      var e = t.sphere;
      return this.center.set(e[0], e[1], e[2]), this.radius = Math.max(e[3], EPSILON$2), this;
    }, n45.prototype.toJson = function() {
      return {
        sphere: __spreadArray(__spreadArray([], this.center.toArray(), true), [
          this.radius
        ], false)
      };
    }, n45.prototype.copy = function(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    }, n45.prototype.clone = function() {
      return new n45().copy(this);
    }, n45.prototype.getBoundingBox = function(t) {
      return t.setFromCenterAndSize(this.center, scratchSize.set(1, 1, 1).multiplyScalar(this.radius * 2)), t;
    }, n45.prototype.toGeometry = function() {
      for (var t = 32, e = new Float32Array(t * 3 * 2 * 2), r = 0; r <= t; r++) {
        var o = 0;
        o = r / t * Math.PI * 2, e[r * 6 + 0] = this.center.x + Math.cos(o) * this.radius, e[r * 6 + 1] = this.center.y + Math.sin(o) * this.radius, e[r * 6 + 2] = this.center.z + 0, o = (r + 1) / t * Math.PI * 2, e[r * 6 + 3] = this.center.x + Math.cos(o) * this.radius, e[r * 6 + 4] = this.center.y + Math.sin(o) * this.radius, e[r * 6 + 5] = this.center.z + 0;
      }
      for (var r = t; r <= t * 2; r++) {
        var o = 0;
        o = r / t * Math.PI * 2, e[r * 6 + 0] = this.center.x + Math.cos(o) * this.radius, e[r * 6 + 1] = this.center.y + 0, e[r * 6 + 2] = this.center.z + Math.sin(o) * this.radius, o = (r + 1) / t * Math.PI * 2, e[r * 6 + 3] = this.center.x + Math.cos(o) * this.radius, e[r * 6 + 4] = this.center.y + 0, e[r * 6 + 5] = this.center.z + Math.sin(o) * this.radius;
      }
      var s = new BufferGeometry();
      return s.setAttribute("position", new BufferAttribute(e, 3)), s.computeBoundingBox(), s.computeBoundingSphere(), s;
    }, n45.prototype.applyMatrix4 = function(t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }, n45.prototype.getCenter = function(t) {
      return t.copy(this.center);
    }, n45.prototype.distanceSquaredToPoint = function(t) {
      var e = this.distanceToPoint(t);
      return e * e;
    }, n45.prototype.distanceToPoint = function(t) {
      var e = this.center.distanceTo(t) - this.radius;
      return e <= 0 ? 0 : e;
    }, n45.prototype.distanceToPlane = function(t) {
      var e = Math.abs(t.distanceToPoint(this.center));
      return Math.max(0, e - this.radius);
    }, n45.prototype.intersectPlane = function(t) {
      var e = this.center, r = this.radius, o = t.normal, s = o.dot(e) + t.constant;
      return s < -r ? VolumePlaneIntersect.Outside : s < r ? VolumePlaneIntersect.Intersecting : VolumePlaneIntersect.Inside;
    }, n45.prototype.intersectRay = function(t, e) {
      if (scratchSphere$1.set(this.center, this.radius), scratchSphere$1.containsPoint(t.origin))
        return true;
      var r = t.intersectSphere(scratchSphere$1, scratchVector);
      return r ? e !== void 0 ? t.origin.distanceTo(r) < e : true : false;
    }, n45;
  }()
);
var RegionBoundingVolume = (
  /** @class */
  function() {
    function n45() {
      throw this.type = "regin", this.west = 0, this.south = 0, this.east = 0, this.north = 0, this.minHeight = 0, this.maxHeight = 0, new Error("Region bounding volume not supported.");
    }
    return n45.prototype.fromJson = function(t) {
      var e = t.region;
      return this.west = e[0], this.south = e[1], this.east = e[2], this.north = e[3], this.minHeight = e[4], this.maxHeight = e[5], this;
    }, n45.prototype.toJson = function() {
      return {
        region: [
          this.west,
          this.south,
          this.east,
          this.north,
          this.minHeight,
          this.maxHeight
        ]
      };
    }, n45.prototype.copy = function(t) {
      return this.west = t.west, this.south = t.south, this.east = t.east, this.north = t.north, this.minHeight = t.minHeight, this.maxHeight = t.maxHeight, this;
    }, n45.prototype.clone = function() {
      return new n45().copy(this);
    }, n45.prototype.getBoundingBox = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.toGeometry = function() {
      throw new Error("not implemented");
    }, n45.prototype.applyMatrix4 = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.getCenter = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.distanceToPoint = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.distanceSquaredToPoint = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.distanceToPlane = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.intersectPlane = function(t) {
      throw new Error("not implemented");
    }, n45.prototype.intersectRay = function(t) {
      throw new Error("not implemented");
    }, n45;
  }()
);
function isBoundingVolume(n45) {
  return n45 instanceof BoxBoundingVolume || n45 instanceof SphereBoundingVolume || n45 instanceof RegionBoundingVolume;
}
function makeBoundingVolume(n45) {
  if ("box" in n45)
    return new BoxBoundingVolume().fromJson(n45);
  if ("sphere" in n45)
    return new SphereBoundingVolume().fromJson(n45);
  if ("region" in n45)
    return new RegionBoundingVolume().fromJson(n45);
  throw new Error("BoundingVolume ".concat(JSON.stringify(n45), " never suppored."));
}
var debugMaterials = [
  4821759,
  8191922,
  16637280,
  16739958,
  5822969,
  376977,
  16747077,
  9259235,
  14514687
].map(function(n45) {
  return new LineBasicMaterial({
    color: n45,
    depthWrite: false,
    depthTest: false,
    transparent: true
  });
});
var debugBoxGeometry = function() {
  var n45 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), t = new Float32Array(8 * 3);
  scratchVector.set(1, 1, 1).toArray(t, 0), scratchVector.set(-1, 1, 1).toArray(t, 3), scratchVector.set(-1, -1, 1).toArray(t, 6), scratchVector.set(1, -1, 1).toArray(t, 9), scratchVector.set(1, 1, -1).toArray(t, 12), scratchVector.set(-1, 1, -1).toArray(t, 15), scratchVector.set(-1, -1, -1).toArray(t, 18), scratchVector.set(1, -1, -1).toArray(t, 21);
  var e = new BufferGeometry();
  return e.setIndex(new BufferAttribute(n45, 1)), e.setAttribute("position", new BufferAttribute(t, 3)), e.computeBoundingBox(), e.computeBoundingSphere(), e;
}();
var debugSphereGeometry = function() {
  for (var n45 = 32, t = new Float32Array(n45 * 3 * 2 * 2), e = 0; e <= n45; e++) {
    var r = 0;
    r = e / n45 * Math.PI * 2, t[e * 6 + 0] = Math.cos(r), t[e * 6 + 1] = Math.sin(r), t[e * 6 + 2] = 0, r = (e + 1) / n45 * Math.PI * 2, t[e * 6 + 3] = Math.cos(r), t[e * 6 + 4] = Math.sin(r), t[e * 6 + 5] = 0;
  }
  for (var e = n45; e <= n45 * 2; e++) {
    var r = 0;
    r = e / n45 * Math.PI * 2, t[e * 6 + 0] = Math.cos(r), t[e * 6 + 1] = 0, t[e * 6 + 2] = Math.sin(r), r = (e + 1) / n45 * Math.PI * 2, t[e * 6 + 3] = Math.cos(r), t[e * 6 + 4] = 0, t[e * 6 + 5] = Math.sin(r);
  }
  var o = new BufferGeometry();
  return o.setAttribute("position", new BufferAttribute(t, 3)), o.computeBoundingBox(), o.computeBoundingSphere(), o;
}();
function createDebugBoundingMesh(n45, t) {
  if (n45 instanceof BoxBoundingVolume) {
    var e = new LineSegments(debugBoxGeometry, debugMaterials[Math.min(t, debugMaterials.length - 1)]);
    return e.position.copy(n45.center), quaternionFromMatrix3(n45.rotation, e.quaternion), e.scale.set(n45.halfSize.x, n45.halfSize.y, n45.halfSize.z), e.matrix.compose(e.position, e.quaternion, e.scale), e;
  } else if (n45 instanceof SphereBoundingVolume) {
    var e = new LineSegments(debugSphereGeometry, debugMaterials[Math.min(t, debugMaterials.length - 1)]);
    return e.position.copy(n45.center), e.scale.set(n45.radius, n45.radius, n45.radius), e.matrix.compose(e.position, e.quaternion, e.scale), e;
  }
  throw new Error("never");
}
var scratchVector3$4 = new Vector3();
var Tile = (
  /** @class */
  function() {
    function n45(t, e, r, o) {
      var s = this, u, l, c, f;
      this.parent = null, this.contentParent = null, this.floor = 0, this.id = t, this.state = {
        visible: false,
        frameNumber: 0,
        selectedFrameNumber: 0,
        requestedFrameNumber: 0,
        touchedFrameNumber: 0,
        distanceToCamera: 0,
        centerZDepth: 0,
        centerScreenY: 0,
        screenSpaceError: 0,
        visibilityPlaneMask: 0,
        inRequestVolume: false,
        shouldRefine: false,
        stackLength: 0,
        finalResolution: true,
        selectionDepth: 0,
        shouldSelect: false,
        lastSelect: false,
        ancestorWithContent: null,
        ancestorWithContentAvailable: null
      }, this.parent = o != null ? o : null, this.contentParent = o ? o.hasRenderContent ? o : o.contentParent : null, this.level = this.parent ? this.parent.level + 1 : 0, this.tileset = r, this.refine = (u = e.refine) !== null && u !== void 0 ? u : this.parent ? this.parent.refine : "REPLACE", this.transform = new Matrix4(), e.transform && this.transform.fromArray(e.transform), this.parent && this.transform.premultiply(this.parent.transform), typeof e.geometricError == "number" ? this.geometricError = e.geometricError * this.transform.getMaxScaleOnAxis() : this.geometricError = (c = (l = this.parent) === null || l === void 0 ? void 0 : l.geometricError) !== null && c !== void 0 ? c : 0, e.content && e.content.uri ? (this.content = {
        uri: e.content.uri,
        loadState: "UNLOADED",
        loadStateUpdateTime: now(),
        loadfailRetryDelay: 0,
        byteLength: 0,
        memoryUsage: 0
      }, e.content.group !== void 0 && (this.content.group = e.content.group), e.content.boundingVolume && (this.content.boundingVolume = makeBoundingVolume(e.content.boundingVolume).applyMatrix4(this.transform)), /\.json$/.test(this.content.uri) ? this.type = "TILESET" : this.type = "SCENEGRAPH") : (this.content = null, this.type = "EMPTY"), this.levelOfContent = this.parent ? this.parent.levelOfContent : -1, this.type === "SCENEGRAPH" && (this.levelOfContent = this.levelOfContent + 1), e.boundingVolume && (this.boundingVolume = makeBoundingVolume(e.boundingVolume).applyMatrix4(this.transform)), e.viewerRequestVolume && (this.viewerRequestVolume = makeBoundingVolume(e.viewerRequestVolume).applyMatrix4(this.transform)), this.extras = (f = e.extras) !== null && f !== void 0 ? f : {}, typeof this.extras.floor != "number" && o && typeof o.extras.floor == "number" && (this.extras.floor = o.extras.floor), typeof this.extras.floor == "number" && (this.floor = this.extras.floor, this.tileset.floorLength = Math.max(this.tileset.floorLength, this.floor + 1)), this.boundingVolume && (this.boundingVolumeDebugObject = createDebugBoundingMesh(this.boundingVolume, this.levelOfContent)), e.children ? this.children = e.children.map(function(d, h) {
        return new n45("".concat(s.id, ".").concat(h), d, r, s);
      }) : this.children = [];
    }
    return n45.prototype.traverse = function(t) {
      t(this);
      for (var e = 0, r = this.children; e < r.length; e++) {
        var o = r[e];
        o.traverse(t);
      }
    }, n45.prototype.updateState = function(t) {
      this.state.frameNumber = t.frameNumber;
      var e = this.tileset.transformIsIdentity ? null : this.tileset.transform;
      if (this.boundingVolume) {
        var r = e ? this.boundingVolume.clone().applyMatrix4(e) : this.boundingVolume;
        if (t.camera.type === "OrthographicCamera") {
          var o = new Plane().setFromNormalAndCoplanarPoint(t.camera.direction, t.camera.position);
          this.state.distanceToCamera = r.distanceToPlane(o);
        } else
          this.state.distanceToCamera = r.distanceToPoint(t.camera.position);
        var s = r.getCenter(scratchVector3$4).sub(t.camera.position);
        this.state.centerZDepth = t.camera.direction.dot(s), this.state.centerScreenY = t.camera.up.dot(s);
        var u = this.parent ? this.parent.state.visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
        this.state.visibilityPlaneMask = t.cullingVolume.computeVisibilityWithPlaneMask(r, u), this.state.visible = this.state.visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
      } else
        this.state.distanceToCamera = 0, this.state.centerZDepth = 0, this.state.visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE, this.state.visible = true;
      if ((this.levelOfContent <= t.minLevelOfDetail || this.geometricError >= t.maxGeometricError) && (this.state.visible = true), this.viewerRequestVolume) {
        var l = e ? this.viewerRequestVolume.clone().applyMatrix4(e) : this.viewerRequestVolume;
        this.state.inRequestVolume = l.distanceSquaredToPoint(t.camera.position) <= 0;
      } else
        this.state.inRequestVolume = true;
      this.state.screenSpaceError = this.getScreenSpaceError(t, this.state.distanceToCamera, false);
    }, Object.defineProperty(n45.prototype, "selected", {
      get: function() {
        return this.state.selectedFrameNumber === this.tileset.frameNumber;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "hasChildren", {
      get: function() {
        return this.children.length > 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "siblingIndex", {
      get: function() {
        var t, e;
        return (e = (t = this.parent) === null || t === void 0 ? void 0 : t.children.indexOf(this)) !== null && e !== void 0 ? e : 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "hasTilesetContent", {
      get: function() {
        return this.children.length > 0 && this.type === "TILESET";
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "hasRenderContent", {
      get: function() {
        return this.type === "SCENEGRAPH";
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "contentAvailable", {
      get: function() {
        var t;
        return this.hasRenderContent && ((t = this.content) === null || t === void 0 ? void 0 : t.loadState) === "READY";
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "hasUnloadedContent", {
      get: function() {
        var t;
        return ((t = this.content) === null || t === void 0 ? void 0 : t.loadState) === "UNLOADED";
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "hasEmptyContent", {
      get: function() {
        return this.type === "EMPTY";
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "contentReady", {
      get: function() {
        var t;
        return ((t = this.content) === null || t === void 0 ? void 0 : t.loadState) === "READY" || this.hasEmptyContent;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "contentByteLength", {
      get: function() {
        return this.content ? this.content.byteLength : 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "contentMemoryUsage", {
      get: function() {
        return this.content ? this.content.memoryUsage : 0;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.getScreenSpaceError = function(t, e, r) {
      var o = this.tileset.transformIsIdentity ? 1 : this.tileset.transform.getMaxScaleOnAxis(), s = this.parent ? this.parent.geometricError : this.tileset.geometricError, u = o * (r ? s : this.geometricError);
      if (u === 0)
        return 0;
      var l = t.height, c = t.sseDenominator;
      if (t.camera.type === "OrthographicCamera") {
        var f = t.camera.projectionMatrix.elements, d = 1 / (f[5] / 2), h = 0.9, v = d / l * h, A = u / v;
        return A;
      } else {
        var g = Math.max(e, 1e-3), v = g * c / l, A = u / v;
        return A;
      }
    }, n45.prototype.getPriority = function() {
      var t = this.refine === "ADD" || this.tileset.skipLevelOfDetail;
      if (t && !this.state.visible || this.tileset.frameNumber - this.state.touchedFrameNumber >= 1)
        return -1;
      var e = this.parent, r = e && (!t || this.state.screenSpaceError === 0), o = r ? e.state.screenSpaceError : this.state.screenSpaceError, s = this.tileset.root ? this.tileset.root.state.screenSpaceError : 0, u = Math.max(s - o, 0);
      return u;
    }, n45;
  }()
);
var priorityCache = /* @__PURE__ */ new Map();
function getPriority(n45, t) {
  if (t && t.has(n45))
    return t.get(n45);
  var e = n45.refine === "ADD" || n45.tileset.skipLevelOfDetail, r = n45.parent, o = r && (!e || n45.state.screenSpaceError === 0), s = o ? r.state.screenSpaceError : n45.state.screenSpaceError, u = n45.tileset.root ? n45.tileset.root.state.screenSpaceError : 0, l = Math.max(u - s, 0);
  return t && t.set(n45, l), l;
}
var TileRequestScheduler = (
  /** @class */
  function() {
    function n45(t, e) {
      this.tileset = t, this.options = e, this.activeRequests = 0, this.requestQueue = [];
    }
    return n45.prototype.reset = function() {
      for (var t = 0, e = this.requestQueue; t < e.length; t++) {
        var r = e[t];
        this.options.onTileSkip && this.options.onTileSkip(r.tile);
      }
      this.requestQueue.length = 0;
    }, n45.prototype.update = function(t, e, r) {
      for (var o = this, s = r.time, u = this.requestQueue, l = new Set(t), c = 0; c < u.length; c++) {
        var f = u[c];
        if (l.has(f.tile)) {
          l.delete(f.tile);
          continue;
        }
        f.status === "WAITING" && (u.splice(c, 1), c--, this.options.onTileSkip && this.options.onTileSkip(f.tile));
      }
      l.size > 0 && (l.forEach(function(m) {
        u.push({
          tile: m,
          status: "WAITING",
          time: s,
          error: null
        });
      }), l.clear());
      for (var d = this.tileset.maxRequests, c = 0; c < u.length && d > 0; c++) {
        var f = u[c];
        if (f.status === "DONE")
          f.error !== null ? this.options.onTileError && this.options.onTileError(f.tile, f.error) : (d--, f.tile.content && (f.tile.content.loadState = "READY"), this.options.onTileLoad && this.options.onTileLoad(f.tile)), u.splice(c, 1), c--;
        else if (f.status === "PENDING" && s - f.time < 1e3)
          break;
      }
      switch (priorityCache.clear(), e) {
        case "SCREEN_SPACE_ERROR": {
          u.sort(function(m, E) {
            if (m.tile.state.requestedFrameNumber !== E.tile.state.requestedFrameNumber)
              return E.tile.state.requestedFrameNumber - m.tile.state.requestedFrameNumber;
            if (m.tile.state.requestedFrameNumber === r.frameNumber) {
              var b = getPriority(m.tile, priorityCache), T = getPriority(E.tile, priorityCache);
              return b - T;
            } else
              return m.tile.level !== E.tile.level ? m.tile.level - E.tile.level : m.tile.state.distanceToCamera - E.tile.state.distanceToCamera;
          });
          break;
        }
        case "SCREEN_VERTICAL": {
          u.sort(function(m, E) {
            return m.tile.state.requestedFrameNumber !== E.tile.state.requestedFrameNumber ? E.tile.state.requestedFrameNumber - m.tile.state.requestedFrameNumber : m.tile.state.requestedFrameNumber === r.frameNumber ? m.tile.state.centerScreenY !== E.tile.state.centerScreenY ? m.tile.state.centerScreenY - E.tile.state.centerScreenY : m.tile.state.centerZDepth !== E.tile.state.centerZDepth ? m.tile.state.centerZDepth - E.tile.state.centerZDepth : m.tile.level !== E.tile.level ? m.tile.level - E.tile.level : m.tile.state.distanceToCamera - E.tile.state.distanceToCamera : m.tile.level !== E.tile.level ? m.tile.level - E.tile.level : m.tile.state.distanceToCamera - E.tile.state.distanceToCamera;
          });
          break;
        }
        case "SCREEN_LEVEL_VERTICAL": {
          u.sort(function(m, E) {
            return m.tile.state.requestedFrameNumber !== E.tile.state.requestedFrameNumber ? E.tile.state.requestedFrameNumber - m.tile.state.requestedFrameNumber : m.tile.state.requestedFrameNumber === r.frameNumber ? m.tile.level !== E.tile.level ? m.tile.level - E.tile.level : m.tile.state.centerScreenY !== E.tile.state.centerScreenY ? m.tile.state.centerScreenY - E.tile.state.centerScreenY : m.tile.state.centerZDepth !== E.tile.state.centerZDepth ? m.tile.state.centerZDepth - E.tile.state.centerZDepth : m.tile.state.distanceToCamera - E.tile.state.distanceToCamera : m.tile.level !== E.tile.level ? m.tile.level - E.tile.level : m.tile.state.distanceToCamera - E.tile.state.distanceToCamera;
          });
          break;
        }
      }
      if (d = Math.max(this.tileset.maxRequests - this.activeRequests, 0), !this.tileset.skipLevelOfDetail)
        for (var h = 0, v = u.length, c = 0; c < v; c++) {
          var A = u[c].tile;
          if (A.hasTilesetContent || A.contentParent === null || A.contentParent.state.selectedFrameNumber === this.tileset.frameNumber) {
            var g = u.splice(c, 1);
            u.splice.apply(u, __spreadArray([h++, 0], g, false));
          }
        }
      for (var p = function(m) {
        var E = u[m];
        E.status === "WAITING" && (d--, E.status = "PENDING", E.time = s, y.activeRequests++, y.tileset.options.tileLoader(E.tile).catch(function(b) {
          E.error = b;
        }).then(function() {
          E.status = "DONE", E.tile.content && E.tile.content.loadState === "READY" && (E.tile.content.loadState = "LOADING"), o.activeRequests--;
        }));
      }, y = this, c = 0; c < u.length && d > 0; c++)
        p(c);
    }, n45;
  }()
);
var CacheNode = (
  /** @class */
  /* @__PURE__ */ function() {
    function n45(t, e, r) {
      this.item = t, this.previous = e, this.next = r;
    }
    return n45;
  }()
);
var CacheNodeList = (
  /** @class */
  function() {
    function n45() {
      this.head = null, this.tail = null, this._length = 0;
    }
    return Object.defineProperty(n45.prototype, "length", {
      get: function() {
        return this._length;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.add = function(t) {
      var e = new CacheNode(t, this.tail, null);
      return this.tail ? (this.tail.next = e, this.tail = e) : (this.head = e, this.tail = e), this._length++, e;
    }, n45.prototype.remove = function(t) {
      t.previous && t.next ? (t.previous.next = t.next, t.next.previous = t.previous) : t.previous ? (t.previous.next = null, this.tail = t.previous) : t.next ? (t.next.previous = null, this.head = t.next) : (this.head = null, this.tail = null), t.next = null, t.previous = null, this._length--;
    }, n45.prototype.splice = function(t, e) {
      t !== e && (this.remove(e), this.insert(t, e));
    }, n45.prototype.insert = function(t, e) {
      var r = t.next;
      t.next = e, this.tail === t ? this.tail = e : r.previous = e, e.next = r, e.previous = t, this._length++;
    }, n45.prototype.toArray = function() {
      for (var t = [], e = this.head; e; )
        t.push(e), e = e.next;
      return t;
    }, n45;
  }()
);
var TileCache = (
  /** @class */
  function() {
    function n45(t) {
      t === void 0 && (t = {}), this.options = t, this.cacheNodeMap = /* @__PURE__ */ new Map(), this.list = new CacheNodeList(), this.sentinel = this.list.add("sentinel");
    }
    return n45.prototype.reset = function() {
      this.list.tail && this.list.splice(this.list.tail, this.sentinel);
    }, n45.prototype.touchTile = function(t) {
      var e = this.cacheNodeMap.get(t);
      e && this.list.splice(this.sentinel, e);
    }, n45.prototype.loadTile = function(t) {
      if (!this.cacheNodeMap.has(t)) {
        var e = this.list.add(t);
        this.cacheNodeMap.set(t, e), this.options.onTileLoad && this.options.onTileLoad(t);
      }
    }, n45.prototype.unloadTile = function(t) {
      var e = this.cacheNodeMap.get(t);
      e && (this.list.remove(e), this.cacheNodeMap.delete(t), this.options.onTileUnload && this.options.onTileUnload(t));
    }, n45.prototype.unloadTiles = function(t) {
      for (var e = this.list.head; e !== this.sentinel && t(); ) {
        var r = e.item;
        e = e.next, this.unloadTile(r);
      }
    }, n45.prototype.toArray = function() {
      for (var t = [], e = 0, r = this.list.toArray(); e < r.length; e++) {
        var o = r[e];
        o.item !== "sentinel" && t.push(o.item);
      }
      return t;
    }, n45;
  }()
);
var ManagedArray = (
  /** @class */
  function() {
    function n45() {
      this.map = /* @__PURE__ */ new Map(), this.array = [], this._length = 0;
    }
    return Object.defineProperty(n45.prototype, "length", {
      /**
       * Gets or sets the length of the array.
       * If the set length is greater than the length of the internal array, the internal array is resized.
       * @type Number
       */
      get: function() {
        return this._length;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.get = function(t) {
      return this.array[t];
    }, n45.prototype.set = function(t, e) {
      t >= this.length && (this._length = t + 1), this.map.has(this.array[t]) && this.map.delete(this.array[t]), this.array[t] = e, this.map.set(e, t);
    }, n45.prototype.delete = function(t) {
      var e = this.map.get(t);
      e !== void 0 && e >= 0 && (this.array.splice(e, 1), this.map.delete(t), this._length--);
    }, n45.prototype.push = function(t) {
      if (!this.map.has(t)) {
        var e = this._length++;
        this.array[e] = t, this.map.set(t, e);
      }
    }, n45.prototype.pop = function() {
      var t = this.array[--this._length];
      return this.map.delete(t), this.array[this._length] = void 0, t;
    }, n45.prototype.reset = function() {
      this.array = [], this.map = /* @__PURE__ */ new Map(), this._length = 0;
    }, n45.prototype.find = function(t) {
      return this.map.has(t);
    }, n45.prototype.peek = function() {
      return this.array[this._length - 1];
    }, n45;
  }()
);
var TilesetBaseTraverser = (
  /** @class */
  function() {
    function n45(t) {
      this.tileset = t, this._canSelectTile = true, this._loadAllTilesTraversalStack = new ManagedArray(), this.root = null;
    }
    return n45.prototype.traverse = function(t, e, r) {
      this.root = t, this.reset();
    }, n45.prototype.reset = function() {
      this._loadAllTilesTraversalStack.reset(), this.tileset.hasMixedContent = false, this.tileset.needsRefinedTiles.clear(), this.tileset.requestedTiles.length = 0, this.tileset.selectedTiles.length = 0;
    }, n45.prototype.updateTile = function(t, e) {
      this.updateTileVisibility(t, e), t.state.shouldSelect = false, t.state.finalResolution = true;
    }, n45.prototype.selectTile = function(t, e) {
      var r = t.contentAvailable && this._canSelectTile;
      r && t.state.selectedFrameNumber < e.frameNumber && (t.state.selectedFrameNumber = e.frameNumber, this.tileset.selectedTiles.push(t), this.tileset.needsRefinedTiles.add(t));
    }, n45.prototype.loadTile = function(t, e) {
      t.state.requestedFrameNumber < e.frameNumber && (t.state.requestedFrameNumber = e.frameNumber, t.content && (t.content.loadState === "FAILED" && e.time - t.content.loadStateUpdateTime > t.content.loadfailRetryDelay && (t.content.loadState = "UNLOADED", t.content.loadStateUpdateTime = e.time), t.content.loadState === "UNLOADED" && this.tileset.requestedTiles.push(t))), this.tileset.needsRefinedTiles.add(t);
    }, n45.prototype.touchTile = function(t, e) {
      this.tileset.cache.touchTile(t), t.state.touchedFrameNumber = e.frameNumber;
    }, n45.prototype.canTraverse = function(t, e) {
      return !t.state.inRequestVolume || t.levelOfContent >= e.maxLevelOfDetail || t.levelOfContent >= 0 && t.geometricError <= e.minGeometricError || t.children.length === 0 ? false : t.levelOfContent <= e.minLevelOfDetail || t.geometricError >= e.maxGeometricError || t.hasTilesetContent ? true : t.state.screenSpaceError > this.tileset.currentMaxScreenSpaceError;
    }, n45.prototype.updateTileVisibility = function(t, e) {
      if (t.updateState(e), !(!t.state.visible || !t.state.inRequestVolume)) {
        var r = t.children.length > 0;
        if (t.hasTilesetContent && r) {
          var o = t.children[0];
          this.updateTileVisibility(o, e), t.state.visible = o.state.visible;
          return;
        }
        if (this.meetsScreenSpaceErrorEarly(t, e)) {
          t.state.visible = false;
          return;
        }
        var s = t.refine === "REPLACE";
        if (s && r && !this.anyChildrenVisible(t, e)) {
          t.state.visible = false;
          return;
        }
      }
    }, n45.prototype.anyChildrenVisible = function(t, e) {
      for (var r = false, o = t.children, s = 0, u = o; s < u.length; s++) {
        var l = u[s];
        l.updateState(e), r = r || l.state.visible;
      }
      return r;
    }, n45.prototype.meetsScreenSpaceErrorEarly = function(t, e) {
      var r = t.parent;
      return !r || r.refine !== "ADD" || r.levelOfContent < e.minLevelOfDetail || r.geometricError > e.maxGeometricError ? false : r.levelOfContent > e.maxLevelOfDetail || r.levelOfContent >= 0 && r.geometricError < e.minGeometricError ? true : t.getScreenSpaceError(e, t.state.distanceToCamera, true) < this.tileset.currentMaxScreenSpaceError;
    }, n45.prototype.sortTilesByDistanceToCamera = function(t) {
      t.sort(function(e, r) {
        return r.state.distanceToCamera === 0 && e.state.distanceToCamera === 0 ? r.state.centerZDepth - e.state.centerZDepth : r.state.distanceToCamera - e.state.distanceToCamera;
      });
    }, n45.prototype.loadAllTiles = function(t, e) {
      var r = this._loadAllTilesTraversalStack;
      for (r.push(t); r.length > 0; ) {
        var o = r.pop();
        o.content && o.content.loadState === "UNLOADED" && o.state.requestedFrameNumber < e.frameNumber && this.tileset.requestedTiles.push(o), this.touchTile(o, e);
        for (var s = 0, u = o.children; s < u.length; s++) {
          var l = u[s];
          r.push(l);
        }
      }
    }, n45;
  }()
);
var TilesetNormalTraverser = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, e) || this;
      return r.tileset = e, r._traversalStack = new ManagedArray(), r._emptyTraversalStack = new ManagedArray(), r;
    }
    return t.prototype.traverse = function(e, r, o) {
      o === void 0 && (o = []), n45.prototype.traverse.call(this, e, r, o);
      for (var s = 0, u = o; s < u.length; s++) {
        var l = u[s];
        this._traversalStack.reset(), this._emptyTraversalStack.reset(), l.camera.refine && (this._canSelectTile = l.camera.visible, this.updateTile(e, l), this.executeTraversal(e, l));
      }
      this._traversalStack.reset(), this._emptyTraversalStack.reset(), r.camera.refine && (this._canSelectTile = r.camera.visible, this.updateTile(e, r), this.executeTraversal(e, r)), this.tileset.loadAll && this.loadAllTiles(e, r);
    }, t.prototype.reset = function() {
      n45.prototype.reset.call(this), this._traversalStack.reset(), this._emptyTraversalStack.reset();
    }, t.prototype.executeTraversal = function(e, r) {
      var o = this._traversalStack;
      for (e.state.visible && e.state.inRequestVolume && o.push(e); o.length > 0; ) {
        var s = o.pop(), u = s.parent, l = !u || u.state.shouldRefine, c = false;
        this.canTraverse(s, r) && (c = this.updateAndPushChildren(s, r, o) && l);
        var f = !c && l;
        s.hasRenderContent ? s.refine === "ADD" ? (this.loadTile(s, r), this.selectDesiredTile(s, r)) : s.refine === "REPLACE" && (this.loadTile(s, r), f && this.selectDesiredTile(s, r)) : (this.loadTile(s, r), f && this.selectDesiredTile(s, r)), this.touchTile(s, r), s.state.shouldRefine = c;
      }
    }, t.prototype.updateAndPushChildren = function(e, r, o) {
      for (var s = e.children, u = 0, l = s; u < l.length; u++) {
        var c = l[u];
        this.updateTile(c, r);
      }
      this.sortTilesByDistanceToCamera(s);
      for (var f = e.refine === "REPLACE" && e.hasRenderContent, d = false, h = true, v = 0, A = s; v < A.length; v++) {
        var c = A[v];
        if (c.levelOfContent <= r.minLevelOfDetail || c.geometricError >= r.maxGeometricError || c.state.visible && c.state.inRequestVolume ? (o.find(c) && o.delete(c), o.push(c), d === false && (d = true)) : (f || this.tileset.loadSiblings) && (this.loadTile(c, r), this.touchTile(c, r)), f) {
          var g = void 0;
          c.state.inRequestVolume ? c.hasRenderContent ? g = c.contentAvailable : g = this.executeEmptyTraversal(c, r) : g = false, h = h && g;
        }
      }
      return d || (h = false), h;
    }, t.prototype.selectDesiredTile = function(e, r) {
      e.contentAvailable && n45.prototype.selectTile.call(this, e, r);
    }, t.prototype.executeEmptyTraversal = function(e, r) {
      var o = true, s = this._emptyTraversalStack;
      for (s.push(e); s.length > 0 && o; ) {
        var u = s.pop(), l = !u.hasRenderContent && this.canTraverse(u, r);
        if (!l && !u.contentAvailable && (o = false), this.updateTile(u, r), u.state.visible || (this.loadTile(u, r), this.touchTile(u, r)), l)
          for (var c = u.children, f = 0, d = c; f < d.length; f++) {
            var h = d[f];
            s.find(h) && s.delete(h), s.push(h);
          }
      }
      return o;
    }, t;
  }(TilesetBaseTraverser)
);
var TilesetSkipTraverser = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, e) || this;
      return r.tileset = e, r.baseScreenSpaceError = 1024, r.skipScreenSpaceErrorFactor = 16, r.skipLevels = 1, r._traversalStack = new ManagedArray(), r._descendantTraversalStack = new ManagedArray(), r._selectionTraversalStack = new ManagedArray(), r._selectionTraversalancestorStack = new ManagedArray(), r;
    }
    return t.prototype.traverse = function(e, r, o) {
      o === void 0 && (o = []), n45.prototype.traverse.call(this, e, r, o);
      for (var s = 0, u = o; s < u.length; s++) {
        var l = u[s];
        this._traversalStack.reset(), l.camera.refine && (this._canSelectTile = l.camera.visible, this.updateTile(e, l), this.executeTraversal(e, l), this.traverseAndSelect(e, l));
      }
      this.tileset.hasMixedContent = false, this._traversalStack.reset(), this._descendantTraversalStack.reset(), this._selectionTraversalStack.reset(), this._selectionTraversalancestorStack.reset(), r.camera.refine && (this._canSelectTile = r.camera.visible, this.updateTile(e, r), this.executeTraversal(e, r), this.traverseAndSelect(e, r)), this.tileset.loadAll && this.loadAllTiles(e, r);
    }, t.prototype.reset = function() {
      n45.prototype.reset.call(this), this._traversalStack.reset(), this._descendantTraversalStack.reset(), this._selectionTraversalStack.reset(), this._selectionTraversalancestorStack.reset();
    }, t.prototype.executeTraversal = function(e, r) {
      var o = this._traversalStack;
      for (e.state.visible && e.state.inRequestVolume && o.push(e); o.length > 0; ) {
        var s = o.pop();
        this.updateTileAncestorContentLinks(s, r);
        var u = s.parent, l = !u || u.state.shouldRefine, c = false;
        this.canTraverse(s, r) && (c = this.updateAndPushChildren(s, r, o) && l);
        var f = !c && l;
        s.hasRenderContent ? s.refine === "ADD" ? (this.loadTile(s, r), this.selectDesiredTile(s, r)) : s.refine === "REPLACE" && (this.inBaseTraversal(s, this.baseScreenSpaceError) ? (this.loadTile(s, r), f && this.selectDesiredTile(s, r)) : f ? (this.loadTile(s, r), this.selectDesiredTile(s, r)) : this.reachedSkippingThreshold(s) && this.loadTile(s, r)) : (this.loadTile(s, r), f && this.selectDesiredTile(s, r)), this.touchTile(s, r), s.state.shouldRefine = c;
      }
    }, t.prototype.updateAndPushChildren = function(e, r, o) {
      for (var s = e.children, u = 0, l = s; u < l.length; u++) {
        var c = l[u];
        this.updateTile(c, r);
      }
      this.sortTilesByDistanceToCamera(s);
      for (var f = false, d = 0, h = s; d < h.length; d++) {
        var c = h[d];
        c.levelOfContent <= r.minLevelOfDetail || c.geometricError >= r.maxGeometricError || c.state.visible && c.state.inRequestVolume ? (o.push(c), f === false && (f = true)) : this.tileset.loadSiblings && (this.loadTile(c, r), this.touchTile(c, r));
      }
      return f;
    }, t.prototype.selectDesiredTile = function(e, r) {
      var o = e.contentAvailable ? e : e.state.ancestorWithContentAvailable;
      o && (o.state.shouldSelect = true), e.contentAvailable || this.selectDescendants(e, r);
    }, t.prototype.selectDescendants = function(e, r) {
      var o = this._descendantTraversalStack;
      for (o.push(e); o.length > 0; )
        for (var s = o.pop(), u = s.children, l = 0, c = u; l < c.length; l++) {
          var f = c[l];
          f.state.visible && (f.contentAvailable ? (this.updateTile(f, r), this.touchTile(f, r), this.selectTile(f, r)) : o.push(f));
        }
    }, t.prototype.reachedSkippingThreshold = function(e) {
      var r = e.state.ancestorWithContent, o = r !== null && e.state.screenSpaceError < r.state.screenSpaceError / this.skipScreenSpaceErrorFactor && e.levelOfContent > r.levelOfContent + this.skipLevels;
      return o;
    }, t.prototype.updateTileAncestorContentLinks = function(e, r) {
      e.state.ancestorWithContent = null, e.state.ancestorWithContentAvailable = null;
      var o = e.parent;
      if (o) {
        var s = !(o.hasRenderContent && o.hasUnloadedContent) || o.state.requestedFrameNumber === r.frameNumber;
        e.state.ancestorWithContent = s ? o : o.state.ancestorWithContent, e.state.ancestorWithContentAvailable = o.contentAvailable ? o : o.state.ancestorWithContentAvailable;
      }
    }, t.prototype.inBaseTraversal = function(e, r) {
      return e.state.ancestorWithContent ? e.parent && e.state.screenSpaceError === 0 ? e.parent.state.screenSpaceError > r : e.state.screenSpaceError > r : true;
    }, t.prototype.traverseAndSelect = function(e, r) {
      var o = this._selectionTraversalStack, s = this._selectionTraversalancestorStack, u;
      for (o.push(e); o.length > 0 || s.length > 0; ) {
        if (s.length > 0) {
          var l = s.peek();
          if (l.state.stackLength === o.length) {
            s.pop(), l !== u && (l.state.finalResolution = false), this.selectTile(l, r);
            continue;
          }
        }
        var c = o.pop();
        if (c) {
          var f = this.canTraverse(c, r);
          if (c.state.shouldSelect)
            if (c.refine === "ADD")
              this.selectTile(c, r);
            else {
              if (c.state.selectionDepth = s.length, c.state.selectionDepth > 0 && (c.tileset.hasMixedContent = true), u = c, !f) {
                this.selectTile(c, r);
                continue;
              }
              s.push(c), c.state.stackLength = o.length;
            }
          if (f)
            for (var d = 0, h = c.children; d < h.length; d++) {
              var v = h[d];
              v.state.visible && o.push(v);
            }
        }
      }
    }, t;
  }(TilesetBaseTraverser)
);
var TilesetMostDetailTraverser = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, e) || this;
      return r.tileset = e, r._traversalStack = new ManagedArray(), r;
    }
    return t.prototype.canTraverse = function(e, r) {
      return !(!e.state.inRequestVolume || e.levelOfContent >= r.maxLevelOfDetail || e.levelOfContent >= 0 && e.geometricError <= r.minGeometricError || e.children.length === 0);
    }, t.prototype.traverse = function(e, r, o) {
      n45.prototype.traverse.call(this, e, r, []), this._traversalStack.reset(), e.updateState(r);
      for (var s = 0, u = o; s < u.length; s++) {
        var l = u[s];
        this._traversalStack.reset(), l.camera.refine && (this._canSelectTile = l.camera.visible, e.updateState(l), this.executeTraversal(e, l));
      }
      this._traversalStack.reset(), r.camera.refine && (this._canSelectTile = r.camera.visible, e.updateState(r), this.executeTraversal(e, r)), this.tileset.loadAll && this.loadAllTiles(e, r);
    }, t.prototype.reset = function() {
      n45.prototype.reset.call(this), this._traversalStack.reset();
    }, t.prototype.executeTraversal = function(e, r) {
      var o = this._traversalStack;
      for (o.push(e); o.length > 0; ) {
        var s = o.pop(), u = s.refine === "ADD", l = s.refine === "REPLACE", c = this.canTraverse(s, r);
        c && this.updateAndPushChildren(s, r, o), (u || l && !c) && (this.loadTile(s, r), this.touchTile(s, r), this.selectDesiredTile(s, r));
      }
    }, t.prototype.updateAndPushChildren = function(e, r, o) {
      for (var s = e.children, u = 0; u < s.length; ++u) {
        var l = s[u];
        l.updateState(r), l.state.visible && o.push(l);
      }
    }, t.prototype.selectDesiredTile = function(e, r) {
      e.contentAvailable && n45.prototype.selectTile.call(this, e, r);
    }, t;
  }(TilesetBaseTraverser)
);
var Trajectory = (
  /** @class */
  /* @__PURE__ */ function() {
    function n45(t, e, r) {
      this.index = t, this.name = e.name, this.visible = false, this.tileset = r, this.transform = new Matrix4(), e.transform && this.transform.fromArray(e.transform), this.transform.premultiply(this.tileset.root.transform), this.content = {
        uri: e.file,
        byteLength: 0,
        memoryUsage: 0,
        loadState: "UNLOADED",
        loadStateUpdateTime: now(),
        loadfailRetryDelay: 0,
        data: void 0
      };
    }
    return n45;
  }()
);
var identityMatrix4 = new Matrix4();
var Tileset = (
  /** @class */
  function() {
    function n45(t, e, r) {
      var o = this, s, u, l, c, f, d, h, v, A;
      if (this.id = t, this.transform = new Matrix4(), this.transformIsIdentity = true, this.hasMixedContent = false, this.url = (s = r.url) !== null && s !== void 0 ? s : "", this.referer = (u = r.referer) !== null && u !== void 0 ? u : "", this.asset = {
        version: e.asset.version,
        tilesetVersion: e.asset.tilesetVersion || "",
        gltfUpAxis: (l = e.asset.gltfUpAxis) !== null && l !== void 0 ? l : "Y",
        overview: e.asset.overview,
        trajectories: (f = (c = e.asset.trajectories) === null || c === void 0 ? void 0 : c.list) !== null && f !== void 0 ? f : [],
        extras: e.asset.extras
      }, this.rootMeta = (d = e.rootMeta) !== null && d !== void 0 ? d : {}, this.pointLength = (h = this.rootMeta.numTotalPoints) !== null && h !== void 0 ? h : 1 / 0, this.floorLength = (v = this.rootMeta.numFloors) !== null && v !== void 0 ? v : 1, this.properties = (A = e.properties) !== null && A !== void 0 ? A : {}, this.options = r, this.memoryOverflow = n45.DEFAULT_MEMORY_OVERFLOW, this.maxMemoryUsage = n45.DEFAULT_MAX_MEMORY_USAGE, this.memoryAdjustedScreenSpaceError = n45.DEFAULT_MEMORY_ADJUSTED_SCREEN_SPACE_ERROR, this.maxScreenSpaceError = n45.DEFAULT_MAX_SCREEN_SPACE_ERROR, this.skipLevelOfDetail = n45.DEFAULT_SKIP_LEVEL_OF_DETAIL, this.mostDetail = n45.DEFAULT_MOST_DETAIL, this.loadSiblings = n45.DEFAULT_LOAD_SIBLINGS, this.loadAll = n45.DEFAULT_LOAD_ALL, this.maxRequests = n45.DEFAULT_MAX_REQUESTS, this.tileRequestOrder = n45.DEFAULT_REQUEST_ORDER, this.requestedTiles = [], this.selectedTiles = [], this.unloadTiles = [], this.needsRefinedTiles = /* @__PURE__ */ new Set(), this.selectedTrajectories = [], this.normalTraverser = new TilesetNormalTraverser(this), this.skipTraverser = new TilesetSkipTraverser(this), this.mostDetailTraverser = new TilesetMostDetailTraverser(this), this.cache = new TileCache({
        onTileLoad: function(y) {
          o.cacheMemoryUsageInBytes += y.contentMemoryUsage;
        },
        onTileUnload: function(y) {
          o.cacheMemoryUsageInBytes -= y.contentMemoryUsage, o.unloadTiles.push(y);
        }
      }), this.requestScheduler = new TileRequestScheduler(this, {
        onTileSkip: function(y) {
        },
        onTileLoad: function(y) {
          var m;
          !((m = y.content) === null || m === void 0) && m.data && (o.loadedTiles.add(y), o.cache.loadTile(y)), o.options.onTileLoad(y);
        },
        onTileError: function(y, m) {
          o.options.onTileError(y, m);
        }
      }), this.frameNumber = 0, this.maxLevelOfDetail = 0, this.minLevelOfDetail = 0, this.minGeometricError = 0, this.maxGeometricError = 0, this.loadedTiles = /* @__PURE__ */ new Set(), this.cacheMemoryUsageInBytes = 0, this.currentMaxScreenSpaceError = this.maxScreenSpaceError, this.root = new Tile("".concat(this.id, ".0"), e.root, this), this.geometricError = e.geometricError, this.trajectories = [], this.asset.trajectories)
        for (var g = 0; g < this.asset.trajectories.length; g++) {
          var p = new Trajectory(g, this.asset.trajectories[g], this);
          this.trajectories.push(p);
        }
    }
    return n45.prototype.adjustScreenSpaceError = function() {
      if (this.memoryAdjustedScreenSpaceError) {
        var t = 0;
        this.needsRefinedTiles.forEach(function(o) {
          o.content && (t += o.content.memoryUsage);
        });
        var e = (this.maxMemoryUsage - this.memoryOverflow) * 1024 * 1024, r = this.maxMemoryUsage * 1024 * 1024;
        t < e ? this.currentMaxScreenSpaceError = Math.max(this.currentMaxScreenSpaceError / 1.02, this.maxScreenSpaceError) : t > r && this.selectedTiles.length > 0 && (this.currentMaxScreenSpaceError *= 1.02);
      } else
        this.currentMaxScreenSpaceError = this.maxScreenSpaceError;
    }, Object.defineProperty(n45.prototype, "traverser", {
      get: function() {
        return this.mostDetail ? this.mostDetailTraverser : this.skipLevelOfDetail ? this.skipTraverser : this.normalTraverser;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.reset = function() {
      for (var t = this, e = [this.root], r; r = e.pop(); ) {
        for (var o = 0, s = r.children.length; o < s; o++)
          e.push(r.children[o]);
        this.cache.unloadTile(r);
      }
      for (var u = function() {
        var d = l.unloadTiles.pop();
        d && (l.loadedTiles.delete(d), l.cacheMemoryUsageInBytes -= d.contentMemoryUsage, l.options.tileUnloader(d).catch(function() {
        }).then(function() {
          t.options.onTileUnload && t.options.onTileUnload(d);
        }));
      }, l = this; this.unloadTiles.length; )
        u();
      this.cache.reset(), this.traverser.reset(), this.requestScheduler.reset(), this.loadedTiles.clear();
      for (var c = function() {
        var d = f.trajectories.pop();
        d && f.options.trajectoryUnloader(d).catch(function() {
        }).then(function() {
          t.options.onTrajectoryUnload && t.options.onTrajectoryUnload(d);
        });
      }, f = this; this.trajectories.length; )
        c();
    }, n45.prototype.update = function(t, e) {
      var r = this, o;
      e === void 0 && (e = []), this.frameNumber = t.frameNumber, this.minLevelOfDetail = t.minLevelOfDetail, this.maxLevelOfDetail = t.maxLevelOfDetail, this.minGeometricError = t.minGeometricError, this.maxGeometricError = t.maxGeometricError, this.adjustScreenSpaceError(), this.transformIsIdentity = this.transform.equals(identityMatrix4), this.traverser.traverse(this.root, t, e), this.cache.unloadTiles(function() {
        var v = r.cacheMemoryUsageInBytes > r.maxMemoryUsage * 1024 * 1024;
        return v;
      }), this.requestScheduler.update(this.requestedTiles, this.tileRequestOrder, t);
      for (var s = function() {
        var v = u.unloadTiles.pop();
        v && (u.loadedTiles.delete(v), u.options.tileUnloader(v).catch(function() {
        }).then(function() {
          r.options.onTileUnload && r.options.onTileUnload(v);
        }));
      }, u = this; this.unloadTiles.length; )
        s();
      this.selectedTrajectories.length = 0;
      for (var l = function(v) {
        v.visible === true && v.content.loadState === "READY" && (!((o = v.content.data) === null || o === void 0) && o.object) ? c.selectedTrajectories.push(v) : v.visible === true && (v.content.loadState === "FAILED" && t.time - v.content.loadStateUpdateTime > v.content.loadfailRetryDelay && (v.content.loadState = "UNLOADED", v.content.loadStateUpdateTime = t.time), v.content.loadState === "UNLOADED" && c.options.trajectoryLoader(v).then(function() {
          r.options.onTrajectoryLoad(v);
        }).catch(function(A) {
          r.options.onTrajectoryError(v, A);
        }));
      }, c = this, f = 0, d = this.trajectories; f < d.length; f++) {
        var h = d[f];
        l(h);
      }
    }, n45.DEFAULT_MAX_MEMORY_USAGE = 16, n45.DEFAULT_MEMORY_OVERFLOW = 4, n45.DEFAULT_MEMORY_ADJUSTED_SCREEN_SPACE_ERROR = false, n45.DEFAULT_MAX_SCREEN_SPACE_ERROR = 4, n45.DEFAULT_SKIP_LEVEL_OF_DETAIL = false, n45.DEFAULT_MOST_DETAIL = false, n45.DEFAULT_LOAD_SIBLINGS = false, n45.DEFAULT_LOAD_ALL = false, n45.DEFAULT_MAX_REQUESTS = 6, n45.DEFAULT_REQUEST_ORDER = "SCREEN_SPACE_ERROR", n45;
  }()
);
var BVHObject = (
  /** @class */
  function() {
    function n45(t, e) {
      this.position = t, this.indices = e;
    }
    return n45.prototype.getPositionCount = function() {
      var t, e, r = this.indices, o = this.position;
      return r ? r.array.length / ((t = r.stride) !== null && t !== void 0 ? t : 1) : o.array.length / ((e = o.stride) !== null && e !== void 0 ? e : 3);
    }, n45.prototype.getPositionByIndex = function(t, e) {
      var r, o, s, u, l = this.indices, c = this.position, f = t;
      if (l) {
        var d = l.array, h = (r = l.stride) !== null && r !== void 0 ? r : 1, v = (o = l.offset) !== null && o !== void 0 ? o : 0;
        f = d[t * h + v];
      }
      var A = c.array, g = (s = c.stride) !== null && s !== void 0 ? s : 3, p = (u = c.offset) !== null && u !== void 0 ? u : 0;
      return f = f * g + p, e.x = A[f], e.y = A[f + 1], e.z = A[f + 2], e;
    }, n45.prototype.createTree = function(t, e, r) {
      throw new Error("not implemented");
    }, n45.prototype.trianglesInSphere = function(t, e) {
      throw new Error("not implemented");
    }, n45.prototype.intersectRay = function(t, e, r, o) {
      throw new Error("not implemented");
    }, n45;
  }()
);
var BVHNode = (
  /** @class */
  /* @__PURE__ */ function() {
    function n45(t, e, r, o, s) {
      this.id = t, this.extents = e, this.startIndex = r, this.endIndex = o, this.deepth = s;
    }
    return n45;
  }()
);
var BYTES_PER_NODE = 6 * 4 + 4 + 4 + 2 + 2;
function packBVHNode(n45, t) {
  for (var e = new ArrayBuffer(t * BYTES_PER_NODE), r = new Float32Array(e), o = new Uint32Array(e), s = new Uint16Array(e), u = [n45], l, c; l = u.pop(); )
    c = l.id * BYTES_PER_NODE / 4, r[c] = l.extents[0], r[c + 1] = l.extents[1], r[c + 2] = l.extents[2], r[c + 3] = l.extents[3], r[c + 4] = l.extents[4], r[c + 5] = l.extents[5], o[c + 6] = l.startIndex, o[c + 7] = l.endIndex, c = l.id * BYTES_PER_NODE / 2, l.node0 && (s[c + 16] = l.node0.id, u.push(l.node0)), l.node1 && (s[c + 17] = l.node1.id, u.push(l.node1));
  return e;
}
function intersectNodeBox(n45, t, e, r, o, s, u, l, c) {
  c === void 0 && (c = 0), e = e - c, r = r - c, o = o - c, s = s + c, u = u + c, l = l + c;
  var f = 0, d = 0, h = 0, v = 0, A = 0, g = 0;
  return t.x >= 0 ? (f = (e - n45.x) * t.x, d = (s - n45.x) * t.x) : (f = (s - n45.x) * t.x, d = (e - n45.x) * t.x), t.y >= 0 ? (h = (r - n45.y) * t.y, v = (u - n45.y) * t.y) : (h = (u - n45.y) * t.y, v = (r - n45.y) * t.y), !(f > v || h > d || (h > f && (f = h), v < d && (d = v), t.z >= 0 ? (A = (o - n45.z) * t.z, g = (l - n45.z) * t.z) : (A = (l - n45.z) * t.z, g = (o - n45.z) * t.z), f > g || A > d) || (A > f && (f = A), g < d && (d = g), d < 0));
}
var BVHVector3 = (
  /** @class */
  function() {
    function n45(t, e, r) {
      this.x = t, this.y = e, this.z = r;
    }
    return n45.prototype.copy = function(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }, n45.prototype.set = function(t, e, r) {
      return this.x = t, this.y = e, this.z = r, this;
    }, n45.prototype.fromArray = function(t, e) {
      return e === void 0 && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    }, n45.prototype.toArray = function(t, e) {
      return t === void 0 && (t = []), e === void 0 && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    }, n45.prototype.add = function(t) {
      return this.x += t.x, this.y += t.y, this.z += t.z, this;
    }, n45.prototype.multiplyScalar = function(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    }, n45.prototype.subVectors = function(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    }, n45.prototype.addScaledVector = function(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    }, n45.prototype.dot = function(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }, n45.prototype.cross = function(t) {
      var e = this.x, r = this.y, o = this.z;
      return this.x = r * t.z - o * t.y, this.y = o * t.x - e * t.z, this.z = e * t.y - r * t.x, this;
    }, n45.prototype.crossVectors = function(t, e) {
      var r = t.x, o = t.y, s = t.z, u = e.x, l = e.y, c = e.z;
      return this.x = o * c - s * l, this.y = s * u - r * c, this.z = r * l - o * u, this;
    }, n45.prototype.distanceTo = function(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }, n45.prototype.distanceToSquared = function(t) {
      var e = this.x - t.x, r = this.y - t.y, o = this.z - t.z;
      return e * e + r * r + o * o;
    }, n45.prototype.clone = function() {
      return new n45(this.x, this.y, this.z);
    }, n45;
  }()
);
var BVHIntersect = (
  /** @class */
  /* @__PURE__ */ function() {
    function n45(t, e, r) {
      this.triangle = t, this.intersectionPoint = e, this.index = r;
    }
    return n45;
  }()
);
var EPSILON$1 = 1e-6;
var scratchVector3$3 = new BVHVector3(0, 0, 0);
var scratchVector3A = new BVHVector3(0, 0, 0);
var scratchVector3B = new BVHVector3(0, 0, 0);
var scratchVector3C = new BVHVector3(0, 0, 0);
var BVHMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.createTree = function(e, r, o) {
      r = Math.min(r, 16);
      var s = this.getPositionCount() / 3, u = s > 65535 ? new Uint32Array(s) : new Uint16Array(s), l = new Float32Array(s * 6), c = [], f = 0, d = -1;
      if (o)
        for (var h = 0, v = 0, A = 0, g = void 0, p = void 0, y = void 0, m = void 0, E = void 0, b = void 0, T = void 0; h < s; h += 1, v += 3, A += 6)
          u[h] = h, this.getPositionByIndex(v, scratchVector3A), this.getPositionByIndex(v + 1, scratchVector3B), this.getPositionByIndex(v + 2, scratchVector3C), g = m = scratchVector3A.x, T = scratchVector3B.x, T < g && (g = T), T > m && (m = T), T = scratchVector3C.x, T < g && (g = T), T > m && (m = T), p = E = scratchVector3A.y, T = scratchVector3B.y, T < p && (p = T), T > E && (E = T), T = scratchVector3C.y, T < p && (p = T), T > E && (E = T), y = b = scratchVector3A.z, T = scratchVector3B.z, T < y && (y = T), T > b && (b = T), T = scratchVector3C.z, T < y && (y = T), T > b && (b = T), l[A] = g, l[A + 1] = p, l[A + 2] = y, l[A + 3] = m, l[A + 4] = E, l[A + 5] = b;
      else {
        for (var R = 1 / 0, S = 1 / 0, M = 1 / 0, w = -1 / 0, H = -1 / 0, L = -1 / 0, h = 0, v = 0, A = 0, g = void 0, p = void 0, y = void 0, m = void 0, E = void 0, b = void 0, T = void 0; h < s; h += 1, v += 3, A += 6)
          u[h] = h, this.getPositionByIndex(v, scratchVector3A), this.getPositionByIndex(v + 1, scratchVector3B), this.getPositionByIndex(v + 2, scratchVector3C), g = m = scratchVector3A.x, T = scratchVector3B.x, T < g && (g = T), T > m && (m = T), T = scratchVector3C.x, T < g && (g = T), T > m && (m = T), p = E = scratchVector3A.y, T = scratchVector3B.y, T < p && (p = T), T > E && (E = T), T = scratchVector3C.y, T < p && (p = T), T > E && (E = T), y = b = scratchVector3A.z, T = scratchVector3B.z, T < y && (y = T), T > b && (b = T), T = scratchVector3C.z, T < y && (y = T), T > b && (b = T), l[A] = g, l[A + 1] = p, l[A + 2] = y, l[A + 3] = m, l[A + 4] = E, l[A + 5] = b, g < R && (R = g), m > w && (w = m), p < S && (S = p), E > H && (H = E), y < M && (M = y), b > L && (L = b);
        o = [R, S, M, w, H, L];
      }
      var C = new BVHNode(++d, o, 0, s, 0);
      c[f++] = C;
      var I = [], _ = [0, 1, 2], O = function(N, k) {
        return I[k] - I[N];
      };
      function P(N) {
        var k = N.startIndex, U = N.endIndex, D = N.extents;
        I[0] = D[3] - D[0], I[1] = D[4] - D[1], I[2] = D[5] - D[2], _.sort(O);
        for (var q = 0; q < 3; q++) {
          for (var z = _[q], Q = D[z] + D[z + 3], G = k, X = U - 1, $ = -1, W = void 0; G <= X; )
            $ === -1 ? (W = u[G], l[W * 6 + z] + l[W * 6 + z + 3] < Q ? G++ : $ = W) : (W = u[X], l[W * 6 + z] + l[W * 6 + z + 3] >= Q || (u[G] = W, u[X] = $, $ = -1, G++), X--);
          if (G > k && G < U) {
            var oe = new BVHNode(++d, calcExtents(u, l, k, G, EPSILON$1), k, G, N.deepth + 1);
            oe.deepth < r && oe.endIndex - oe.startIndex > e && (c[f++] = oe);
            var ie = new BVHNode(++d, calcExtents(u, l, G, U, EPSILON$1), G, U, N.deepth + 1);
            ie.deepth < r && ie.endIndex - ie.startIndex > e && (c[f++] = ie), N.node0 = oe, N.node1 = ie, N.startIndex = 0, N.endIndex = 0;
            break;
          }
        }
      }
      for (; f; )
        P(c[--f]);
      return this.offsetArray = u, this.rootNodePacked = packBVHNode(C, d + 1), c.length = 0, this;
    }, t.prototype.trianglesInSphere = function(e, r) {
      for (var o = this.offsetArray, s = this.rootNodePacked, u = new Float32Array(s), l = new Uint32Array(s), c = new Uint16Array(s), f = [0], d = [], h, v, A, g; (h = f.pop()) !== void 0; ) {
        g = h * BYTES_PER_NODE / 4;
        var p = clamp(e.x, u[g], u[g + 3]) - e.x, y = clamp(e.y, u[g + 1], u[g + 4]) - e.y, m = clamp(e.z, u[g + 2], u[g + 5]) - e.z;
        if (p * p + y * y + m * m <= r * r) {
          for (var E = l[g + 6]; E < l[g + 7]; E++)
            d.push(o[E]);
          g = h * BYTES_PER_NODE / 2, v = c[g + 16], A = c[g + 17], v && f.push(v), A && f.push(A);
        }
      }
      for (var b = d.length, T = new Float32Array(b * 9), E = 0; E < b; E++) {
        var R = d[E];
        this.getPositionByIndex(R, scratchVector3$3), T[E * 9] = scratchVector3$3.x, T[E * 9 + 1] = scratchVector3$3.y, T[E * 9 + 2] = scratchVector3$3.z, this.getPositionByIndex(R + 1, scratchVector3$3), T[E * 9 + 3] = scratchVector3$3.x, T[E * 9 + 4] = scratchVector3$3.y, T[E * 9 + 5] = scratchVector3$3.z, this.getPositionByIndex(R + 2, scratchVector3$3), T[E * 9 + 6] = scratchVector3$3.x, T[E * 9 + 7] = scratchVector3$3.y, T[E * 9 + 8] = scratchVector3$3.z;
      }
      return T;
    }, t.prototype.intersectRay = function(e, r, o, s) {
      for (var u = this.offsetArray, l = this.rootNodePacked, c = new Float32Array(l), f = new Uint32Array(l), d = new Uint16Array(l), h = new BVHVector3(1 / r.x, 1 / r.y, 1 / r.z), v = [0], A, g, p, y; (A = v.pop()) !== void 0; )
        if (y = A * BYTES_PER_NODE / 4, intersectNodeBox(e, h, c[y], c[y + 1], c[y + 2], c[y + 3], c[y + 4], c[y + 5])) {
          for (var m = f[y + 6], E = f[y + 7], b = void 0, T = void 0, R = void 0, S = e.x, M = e.y, w = e.z, H = r.x, L = r.y, C = r.z, I = void 0, _ = void 0, O = void 0, P = void 0, N = void 0, k = void 0, U = void 0, D = void 0, q = void 0, z = void 0, Q = void 0, G = void 0, X = void 0, $ = void 0, W = void 0, oe = void 0, ie = void 0, re = void 0, j = void 0, se = void 0, ae = void 0, ue = void 0, fe = void 0, ne = void 0, Te = void 0, Re = void 0, ve = void 0; m < E; m++) {
            if (b = u[m], T = b * 3, this.getPositionByIndex(T, scratchVector3$3), I = scratchVector3$3.x, _ = scratchVector3$3.y, O = scratchVector3$3.z, this.getPositionByIndex(T + 1, scratchVector3$3), P = scratchVector3$3.x, N = scratchVector3$3.y, k = scratchVector3$3.z, this.getPositionByIndex(T + 2, scratchVector3$3), U = scratchVector3$3.x, D = scratchVector3$3.y, q = scratchVector3$3.z, z = P - I, Q = N - _, G = k - O, X = U - I, $ = D - _, W = q - O, oe = Q * W - G * $, ie = G * X - z * W, re = z * $ - Q * X, fe = H * oe + L * ie + C * re, fe > 0)
              ue = 1;
            else if (fe < 0)
              ue = -1, fe = -fe;
            else
              continue;
            j = S - I, se = M - _, ae = w - O, ne = ue * (H * (se * W - ae * $) + L * (ae * X - j * W) + C * (j * $ - se * X)), !(ne < 0) && (Te = ue * (H * (Q * ae - G * se) + L * (G * j - z * ae) + C * (z * se - Q * j)), !(Te < 0) && (ne + Te > fe || (Re = -ue * (j * oe + se * ie + ae * re), !(Re < 0) && (ve = Re / fe, s.push(new BVHIntersect([I, _, O, P, N, k, U, D, q], [S + H * ve, M + L * ve, w + C * ve], b))))));
          }
          y = A * BYTES_PER_NODE / 2, g = d[y + 16], p = d[y + 17], g && v.push(g), p && v.push(p);
        }
      return s;
    }, t;
  }(BVHObject)
);
function clamp(n45, t, e) {
  return n45 < t ? t : n45 > e ? e : n45;
}
function calcExtents(n45, t, e, r, o) {
  if (e >= r)
    return [0, 0, 0, 0, 0, 0];
  for (var s = 1 / 0, u = 1 / 0, l = 1 / 0, c = -1 / 0, f = -1 / 0, d = -1 / 0, h = e, v = void 0, A = void 0; h < r; h++)
    v = n45[h] * 6, A = t[v], A < s && (s = A), A = t[v + 1], A < u && (u = A), A = t[v + 2], A < l && (l = A), A = t[v + 3], A > c && (c = A), A = t[v + 4], A > f && (f = A), A = t[v + 5], A > d && (d = A);
  return [
    s - o,
    u - o,
    l - o,
    c + o,
    f + o,
    d + o
  ];
}
var EPSILON = 1e-6;
var ORDER_AXISES = ["x", "y", "z"];
var scratchVector3$2 = new BVHVector3(0, 0, 0);
var BVHPoints = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.createTree = function(e, r, o) {
      r = Math.min(r, 16);
      var s = this.getPositionByIndex.bind(this), u = this.getPositionCount(), l = u > 65535 ? new Uint32Array(u) : new Uint16Array(u), c = [], f = 0, d = -1;
      if (o)
        for (var h = 0; h < u; h += 1)
          l[h] = h;
      else {
        s(0, scratchVector3$2);
        for (var v = scratchVector3$2.x, A = scratchVector3$2.y, g = scratchVector3$2.z, p = v, y = A, m = g, h = 0, E = void 0, b = void 0, T = void 0; h < u; h += 1)
          l[h] = h, s(h, scratchVector3$2), E = scratchVector3$2.x, b = scratchVector3$2.y, T = scratchVector3$2.z, E < v ? v = E : E > p && (p = E), b < A ? A = b : b > y && (y = b), T < g ? g = T : T > m && (m = T);
        o = [v, A, g, p, y, m];
      }
      var R = new BVHNode(++d, o, 0, u, 0);
      c[f++] = R;
      var S = [], M = [0, 1, 2], w = function(L, C) {
        return S[C] - S[L];
      };
      function H(L) {
        var C = L.startIndex, I = L.endIndex, _ = L.extents;
        S[0] = _[3] - _[0], S[1] = _[4] - _[1], S[2] = _[5] - _[2];
        for (var O = M.sort(w)[0], P = ORDER_AXISES[O], N = (_[O] + _[O + 3]) / 2, k = C, U = I - 1, D = -1, q; k <= U; )
          D === -1 ? (q = l[k], s(q, scratchVector3$2), scratchVector3$2[P] < N ? k++ : D = q) : (q = l[U], s(q, scratchVector3$2), scratchVector3$2[P] >= N || (l[k] = q, l[U] = D, D = -1, k++), U--);
        if (k > C) {
          var z = _.slice();
          z[O + 3] = N + EPSILON;
          var Q = new BVHNode(++d, z, C, k, L.deepth + 1);
          Q.deepth < r && Q.endIndex - Q.startIndex > e && (c[f++] = Q), L.node0 = Q;
        }
        if (I > k) {
          var G = _.slice();
          G[O] = N - EPSILON;
          var X = new BVHNode(++d, G, k, I, L.deepth + 1);
          X.deepth < r && X.endIndex - X.startIndex > e && (c[f++] = X), L.node1 = X;
        }
        L.startIndex = 0, L.endIndex = 0;
      }
      for (; f; )
        H(c[--f]);
      return this.offsetArray = l, this.rootNodePacked = packBVHNode(R, d + 1), c.length = 0, this;
    }, t.prototype.intersectRay = function(e, r, o, s) {
      for (var u = this.offsetArray, l = this.rootNodePacked, c = new Float32Array(l), f = new Uint32Array(l), d = new Uint16Array(l), h = o * o, v = new BVHVector3(1 / r.x, 1 / r.y, 1 / r.z), A = [0], g, p, y, m; (g = A.pop()) !== void 0; )
        if (m = g * BYTES_PER_NODE / 4, intersectNodeBox(e, v, c[m], c[m + 1], c[m + 2], c[m + 3], c[m + 4], c[m + 5], o)) {
          for (var E = f[m + 6], b = f[m + 7], T = void 0, R = void 0, S = void 0, M = void 0, w = void 0, H = void 0, L = void 0, C = void 0, I = void 0, _ = void 0, O = void 0, P = void 0; E < b; E++)
            T = u[E], this.getPositionByIndex(T, scratchVector3$2), R = scratchVector3$2.x, S = scratchVector3$2.y, M = scratchVector3$2.z, w = e.x, H = e.y, L = e.z, C = r.x, I = r.y, _ = r.z, O = C * (R - w) + I * (S - H) + _ * (M - L), O > 0 && (w += C * O, H += I * O, L += _ * O), C = R - w, I = S - H, _ = M - L, O = C * C + I * I + _ * _, O <= h && s.push(new BVHIntersect([R, S, M, R, S, M, R, S, M], [w, H, L], T));
          m = g * BYTES_PER_NODE / 2, p = d[m + 16], y = d[m + 17], p && A.push(p), y && A.push(y);
        }
      return s;
    }, t;
  }(BVHObject)
);
var encodedJs$1 = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBlcj1mdW5jdGlvbihlLHIpe3JldHVybiBlcj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxvKXt0Ll9fcHJvdG9fXz1vfXx8ZnVuY3Rpb24odCxvKXtmb3IodmFyIGYgaW4gbylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxmKSYmKHRbZl09b1tmXSl9LGVyKGUscil9O2Z1bmN0aW9uIGhyKGUscil7aWYodHlwZW9mIHIhPSJmdW5jdGlvbiImJnIhPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoIkNsYXNzIGV4dGVuZHMgdmFsdWUgIitTdHJpbmcocikrIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsIik7ZXIoZSxyKTtmdW5jdGlvbiB0KCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfWUucHJvdG90eXBlPXI9PT1udWxsP09iamVjdC5jcmVhdGUocik6KHQucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyB0KX10eXBlb2YgU3VwcHJlc3NlZEVycm9yPT0iZnVuY3Rpb24iJiZTdXBwcmVzc2VkRXJyb3I7dmFyIGRyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyLHQpe3RoaXMucG9zaXRpb249cix0aGlzLmluZGljZXM9dH1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0UG9zaXRpb25Db3VudD1mdW5jdGlvbigpe3ZhciByLHQsbz10aGlzLmluZGljZXMsZj10aGlzLnBvc2l0aW9uO3JldHVybiBvP28uYXJyYXkubGVuZ3RoLygocj1vLnN0cmlkZSkhPT1udWxsJiZyIT09dm9pZCAwP3I6MSk6Zi5hcnJheS5sZW5ndGgvKCh0PWYuc3RyaWRlKSE9PW51bGwmJnQhPT12b2lkIDA/dDozKX0sZS5wcm90b3R5cGUuZ2V0UG9zaXRpb25CeUluZGV4PWZ1bmN0aW9uKHIsdCl7dmFyIG8sZixkLHYsbj10aGlzLmluZGljZXMscz10aGlzLnBvc2l0aW9uLHU9cjtpZihuKXt2YXIgdz1uLmFycmF5LHk9KG89bi5zdHJpZGUpIT09bnVsbCYmbyE9PXZvaWQgMD9vOjEscD0oZj1uLm9mZnNldCkhPT1udWxsJiZmIT09dm9pZCAwP2Y6MDt1PXdbcip5K3BdfXZhciBhPXMuYXJyYXksaD0oZD1zLnN0cmlkZSkhPT1udWxsJiZkIT09dm9pZCAwP2Q6MyxBPSh2PXMub2Zmc2V0KSE9PW51bGwmJnYhPT12b2lkIDA/djowO3JldHVybiB1PXUqaCtBLHQueD1hW3VdLHQueT1hW3UrMV0sdC56PWFbdSsyXSx0fSxlLnByb3RvdHlwZS5jcmVhdGVUcmVlPWZ1bmN0aW9uKHIsdCxvKXt0aHJvdyBuZXcgRXJyb3IoIm5vdCBpbXBsZW1lbnRlZCIpfSxlLnByb3RvdHlwZS50cmlhbmdsZXNJblNwaGVyZT1mdW5jdGlvbihyLHQpe3Rocm93IG5ldyBFcnJvcigibm90IGltcGxlbWVudGVkIil9LGUucHJvdG90eXBlLmludGVyc2VjdFJheT1mdW5jdGlvbihyLHQsbyxmKXt0aHJvdyBuZXcgRXJyb3IoIm5vdCBpbXBsZW1lbnRlZCIpfSxlfSgpLG09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIsdCxvLGYsZCl7dGhpcy5pZD1yLHRoaXMuZXh0ZW50cz10LHRoaXMuc3RhcnRJbmRleD1vLHRoaXMuZW5kSW5kZXg9Zix0aGlzLmRlZXB0aD1kfXJldHVybiBlfSgpLFE9Nio0KzQrNCsyKzI7ZnVuY3Rpb24geXIoZSxyKXtmb3IodmFyIHQ9bmV3IEFycmF5QnVmZmVyKHIqUSksbz1uZXcgRmxvYXQzMkFycmF5KHQpLGY9bmV3IFVpbnQzMkFycmF5KHQpLGQ9bmV3IFVpbnQxNkFycmF5KHQpLHY9W2VdLG4scztuPXYucG9wKCk7KXM9bi5pZCpRLzQsb1tzXT1uLmV4dGVudHNbMF0sb1tzKzFdPW4uZXh0ZW50c1sxXSxvW3MrMl09bi5leHRlbnRzWzJdLG9bcyszXT1uLmV4dGVudHNbM10sb1tzKzRdPW4uZXh0ZW50c1s0XSxvW3MrNV09bi5leHRlbnRzWzVdLGZbcys2XT1uLnN0YXJ0SW5kZXgsZltzKzddPW4uZW5kSW5kZXgscz1uLmlkKlEvMixuLm5vZGUwJiYoZFtzKzE2XT1uLm5vZGUwLmlkLHYucHVzaChuLm5vZGUwKSksbi5ub2RlMSYmKGRbcysxN109bi5ub2RlMS5pZCx2LnB1c2gobi5ub2RlMSkpO3JldHVybiB0fWZ1bmN0aW9uIGNyKGUscix0LG8sZixkLHYsbixzKXtzPT09dm9pZCAwJiYocz0wKSx0PXQtcyxvPW8tcyxmPWYtcyxkPWQrcyx2PXYrcyxuPW4rczt2YXIgdT0wLHc9MCx5PTAscD0wLGE9MCxoPTA7cmV0dXJuIHIueD49MD8odT0odC1lLngpKnIueCx3PShkLWUueCkqci54KToodT0oZC1lLngpKnIueCx3PSh0LWUueCkqci54KSxyLnk+PTA/KHk9KG8tZS55KSpyLnkscD0odi1lLnkpKnIueSk6KHk9KHYtZS55KSpyLnkscD0oby1lLnkpKnIueSksISh1PnB8fHk+d3x8KHk+dSYmKHU9eSkscDx3JiYodz1wKSxyLno+PTA/KGE9KGYtZS56KSpyLnosaD0obi1lLnopKnIueik6KGE9KG4tZS56KSpyLnosaD0oZi1lLnopKnIueiksdT5ofHxhPncpfHwoYT51JiYodT1hKSxoPHcmJih3PWgpLHc8MCkpfXZhciBZPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyLHQsbyl7dGhpcy54PXIsdGhpcy55PXQsdGhpcy56PW99cmV0dXJuIGUucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMueD1yLngsdGhpcy55PXIueSx0aGlzLno9ci56LHRoaXN9LGUucHJvdG90eXBlLnNldD1mdW5jdGlvbihyLHQsbyl7cmV0dXJuIHRoaXMueD1yLHRoaXMueT10LHRoaXMuej1vLHRoaXN9LGUucHJvdG90eXBlLmZyb21BcnJheT1mdW5jdGlvbihyLHQpe3JldHVybiB0PT09dm9pZCAwJiYodD0wKSx0aGlzLng9clt0XSx0aGlzLnk9clt0KzFdLHRoaXMuej1yW3QrMl0sdGhpc30sZS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihyLHQpe3JldHVybiByPT09dm9pZCAwJiYocj1bXSksdD09PXZvaWQgMCYmKHQ9MCksclt0XT10aGlzLngsclt0KzFdPXRoaXMueSxyW3QrMl09dGhpcy56LHJ9LGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy54Kz1yLngsdGhpcy55Kz1yLnksdGhpcy56Kz1yLnosdGhpc30sZS5wcm90b3R5cGUubXVsdGlwbHlTY2FsYXI9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMueCo9cix0aGlzLnkqPXIsdGhpcy56Kj1yLHRoaXN9LGUucHJvdG90eXBlLnN1YlZlY3RvcnM9ZnVuY3Rpb24ocix0KXtyZXR1cm4gdGhpcy54PXIueC10LngsdGhpcy55PXIueS10LnksdGhpcy56PXIuei10LnosdGhpc30sZS5wcm90b3R5cGUuYWRkU2NhbGVkVmVjdG9yPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHRoaXMueCs9ci54KnQsdGhpcy55Kz1yLnkqdCx0aGlzLnorPXIueip0LHRoaXN9LGUucHJvdG90eXBlLmRvdD1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy54KnIueCt0aGlzLnkqci55K3RoaXMueipyLnp9LGUucHJvdG90eXBlLmNyb3NzPWZ1bmN0aW9uKHIpe3ZhciB0PXRoaXMueCxvPXRoaXMueSxmPXRoaXMuejtyZXR1cm4gdGhpcy54PW8qci56LWYqci55LHRoaXMueT1mKnIueC10KnIueix0aGlzLno9dCpyLnktbypyLngsdGhpc30sZS5wcm90b3R5cGUuY3Jvc3NWZWN0b3JzPWZ1bmN0aW9uKHIsdCl7dmFyIG89ci54LGY9ci55LGQ9ci56LHY9dC54LG49dC55LHM9dC56O3JldHVybiB0aGlzLng9ZipzLWQqbix0aGlzLnk9ZCp2LW8qcyx0aGlzLno9bypuLWYqdix0aGlzfSxlLnByb3RvdHlwZS5kaXN0YW5jZVRvPWZ1bmN0aW9uKHIpe3JldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZChyKSl9LGUucHJvdG90eXBlLmRpc3RhbmNlVG9TcXVhcmVkPWZ1bmN0aW9uKHIpe3ZhciB0PXRoaXMueC1yLngsbz10aGlzLnktci55LGY9dGhpcy56LXIuejtyZXR1cm4gdCp0K28qbytmKmZ9LGUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlKHRoaXMueCx0aGlzLnksdGhpcy56KX0sZX0oKSxwcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUocix0LG8pe3RoaXMudHJpYW5nbGU9cix0aGlzLmludGVyc2VjdGlvblBvaW50PXQsdGhpcy5pbmRleD1vfXJldHVybiBlfSgpLGxyPTFlLTYsUz1uZXcgWSgwLDAsMCksRD1uZXcgWSgwLDAsMCksZz1uZXcgWSgwLDAsMCksWD1uZXcgWSgwLDAsMCksQXI9ZnVuY3Rpb24oZSl7aHIocixlKTtmdW5jdGlvbiByKCl7cmV0dXJuIGUhPT1udWxsJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gci5wcm90b3R5cGUuY3JlYXRlVHJlZT1mdW5jdGlvbih0LG8sZil7bz1NYXRoLm1pbihvLDE2KTt2YXIgZD10aGlzLmdldFBvc2l0aW9uQ291bnQoKS8zLHY9ZD42NTUzNT9uZXcgVWludDMyQXJyYXkoZCk6bmV3IFVpbnQxNkFycmF5KGQpLG49bmV3IEZsb2F0MzJBcnJheShkKjYpLHM9W10sdT0wLHc9LTE7aWYoZilmb3IodmFyIHk9MCxwPTAsYT0wLGg9dm9pZCAwLEE9dm9pZCAwLGw9dm9pZCAwLEk9dm9pZCAwLGM9dm9pZCAwLHo9dm9pZCAwLGk9dm9pZCAwO3k8ZDt5Kz0xLHArPTMsYSs9Nil2W3ldPXksdGhpcy5nZXRQb3NpdGlvbkJ5SW5kZXgocCxEKSx0aGlzLmdldFBvc2l0aW9uQnlJbmRleChwKzEsZyksdGhpcy5nZXRQb3NpdGlvbkJ5SW5kZXgocCsyLFgpLGg9ST1ELngsaT1nLngsaTxoJiYoaD1pKSxpPkkmJihJPWkpLGk9WC54LGk8aCYmKGg9aSksaT5JJiYoST1pKSxBPWM9RC55LGk9Zy55LGk8QSYmKEE9aSksaT5jJiYoYz1pKSxpPVgueSxpPEEmJihBPWkpLGk+YyYmKGM9aSksbD16PUQueixpPWcueixpPGwmJihsPWkpLGk+eiYmKHo9aSksaT1YLnosaTxsJiYobD1pKSxpPnomJih6PWkpLG5bYV09aCxuW2ErMV09QSxuW2ErMl09bCxuW2ErM109SSxuW2ErNF09YyxuW2ErNV09ejtlbHNle2Zvcih2YXIgaz0xLzAsSD0xLzAsaj0xLzAscT0tMS8wLE09LTEvMCxQPS0xLzAseT0wLHA9MCxhPTAsaD12b2lkIDAsQT12b2lkIDAsbD12b2lkIDAsST12b2lkIDAsYz12b2lkIDAsej12b2lkIDAsaT12b2lkIDA7eTxkO3krPTEscCs9MyxhKz02KXZbeV09eSx0aGlzLmdldFBvc2l0aW9uQnlJbmRleChwLEQpLHRoaXMuZ2V0UG9zaXRpb25CeUluZGV4KHArMSxnKSx0aGlzLmdldFBvc2l0aW9uQnlJbmRleChwKzIsWCksaD1JPUQueCxpPWcueCxpPGgmJihoPWkpLGk+SSYmKEk9aSksaT1YLngsaTxoJiYoaD1pKSxpPkkmJihJPWkpLEE9Yz1ELnksaT1nLnksaTxBJiYoQT1pKSxpPmMmJihjPWkpLGk9WC55LGk8QSYmKEE9aSksaT5jJiYoYz1pKSxsPXo9RC56LGk9Zy56LGk8bCYmKGw9aSksaT56JiYoej1pKSxpPVgueixpPGwmJihsPWkpLGk+eiYmKHo9aSksblthXT1oLG5bYSsxXT1BLG5bYSsyXT1sLG5bYSszXT1JLG5bYSs0XT1jLG5bYSs1XT16LGg8ayYmKGs9aCksST5xJiYocT1JKSxBPEgmJihIPUEpLGM+TSYmKE09YyksbDxqJiYoaj1sKSx6PlAmJihQPXopO2Y9W2ssSCxqLHEsTSxQXX12YXIgVD1uZXcgbSgrK3csZiwwLGQsMCk7c1t1KytdPVQ7dmFyIE49W10sQj1bMCwxLDJdLFY9ZnVuY3Rpb24oVSxfKXtyZXR1cm4gTltfXS1OW1VdfTtmdW5jdGlvbiBSKFUpe3ZhciBfPVUuc3RhcnRJbmRleCwkPVUuZW5kSW5kZXgsRj1VLmV4dGVudHM7TlswXT1GWzNdLUZbMF0sTlsxXT1GWzRdLUZbMV0sTlsyXT1GWzVdLUZbMl0sQi5zb3J0KFYpO2Zvcih2YXIgVz0wO1c8MztXKyspe2Zvcih2YXIgTD1CW1ddLEc9RltMXStGW0wrM10seD1fLEM9JC0xLEs9LTEsSj12b2lkIDA7eDw9QzspSz09PS0xPyhKPXZbeF0sbltKKjYrTF0rbltKKjYrTCszXTxHP3grKzpLPUopOihKPXZbQ10sbltKKjYrTF0rbltKKjYrTCszXT49R3x8KHZbeF09Six2W0NdPUssSz0tMSx4KyspLEMtLSk7aWYoeD5fJiZ4PCQpe3ZhciBiPW5ldyBtKCsrdyxJcih2LG4sXyx4LGxyKSxfLHgsVS5kZWVwdGgrMSk7Yi5kZWVwdGg8byYmYi5lbmRJbmRleC1iLnN0YXJ0SW5kZXg+dCYmKHNbdSsrXT1iKTt2YXIgTz1uZXcgbSgrK3csSXIodixuLHgsJCxscikseCwkLFUuZGVlcHRoKzEpO08uZGVlcHRoPG8mJk8uZW5kSW5kZXgtTy5zdGFydEluZGV4PnQmJihzW3UrK109TyksVS5ub2RlMD1iLFUubm9kZTE9TyxVLnN0YXJ0SW5kZXg9MCxVLmVuZEluZGV4PTA7YnJlYWt9fX1mb3IoO3U7KVIoc1stLXVdKTtyZXR1cm4gdGhpcy5vZmZzZXRBcnJheT12LHRoaXMucm9vdE5vZGVQYWNrZWQ9eXIoVCx3KzEpLHMubGVuZ3RoPTAsdGhpc30sci5wcm90b3R5cGUudHJpYW5nbGVzSW5TcGhlcmU9ZnVuY3Rpb24odCxvKXtmb3IodmFyIGY9dGhpcy5vZmZzZXRBcnJheSxkPXRoaXMucm9vdE5vZGVQYWNrZWQsdj1uZXcgRmxvYXQzMkFycmF5KGQpLG49bmV3IFVpbnQzMkFycmF5KGQpLHM9bmV3IFVpbnQxNkFycmF5KGQpLHU9WzBdLHc9W10seSxwLGEsaDsoeT11LnBvcCgpKSE9PXZvaWQgMDspe2g9eSpRLzQ7dmFyIEE9c3IodC54LHZbaF0sdltoKzNdKS10LngsbD1zcih0LnksdltoKzFdLHZbaCs0XSktdC55LEk9c3IodC56LHZbaCsyXSx2W2grNV0pLXQuejtpZihBKkErbCpsK0kqSTw9bypvKXtmb3IodmFyIGM9bltoKzZdO2M8bltoKzddO2MrKyl3LnB1c2goZltjXSk7aD15KlEvMixwPXNbaCsxNl0sYT1zW2grMTddLHAmJnUucHVzaChwKSxhJiZ1LnB1c2goYSl9fWZvcih2YXIgej13Lmxlbmd0aCxpPW5ldyBGbG9hdDMyQXJyYXkoeio5KSxjPTA7Yzx6O2MrKyl7dmFyIGs9d1tjXTt0aGlzLmdldFBvc2l0aW9uQnlJbmRleChrLFMpLGlbYyo5XT1TLngsaVtjKjkrMV09Uy55LGlbYyo5KzJdPVMueix0aGlzLmdldFBvc2l0aW9uQnlJbmRleChrKzEsUyksaVtjKjkrM109Uy54LGlbYyo5KzRdPVMueSxpW2MqOSs1XT1TLnosdGhpcy5nZXRQb3NpdGlvbkJ5SW5kZXgoaysyLFMpLGlbYyo5KzZdPVMueCxpW2MqOSs3XT1TLnksaVtjKjkrOF09Uy56fXJldHVybiBpfSxyLnByb3RvdHlwZS5pbnRlcnNlY3RSYXk9ZnVuY3Rpb24odCxvLGYsZCl7Zm9yKHZhciB2PXRoaXMub2Zmc2V0QXJyYXksbj10aGlzLnJvb3ROb2RlUGFja2VkLHM9bmV3IEZsb2F0MzJBcnJheShuKSx1PW5ldyBVaW50MzJBcnJheShuKSx3PW5ldyBVaW50MTZBcnJheShuKSx5PW5ldyBZKDEvby54LDEvby55LDEvby56KSxwPVswXSxhLGgsQSxsOyhhPXAucG9wKCkpIT09dm9pZCAwOylpZihsPWEqUS80LGNyKHQseSxzW2xdLHNbbCsxXSxzW2wrMl0sc1tsKzNdLHNbbCs0XSxzW2wrNV0pKXtmb3IodmFyIEk9dVtsKzZdLGM9dVtsKzddLHo9dm9pZCAwLGk9dm9pZCAwLGs9dm9pZCAwLEg9dC54LGo9dC55LHE9dC56LE09by54LFA9by55LFQ9by56LE49dm9pZCAwLEI9dm9pZCAwLFY9dm9pZCAwLFI9dm9pZCAwLFU9dm9pZCAwLF89dm9pZCAwLCQ9dm9pZCAwLEY9dm9pZCAwLFc9dm9pZCAwLEw9dm9pZCAwLEc9dm9pZCAwLHg9dm9pZCAwLEM9dm9pZCAwLEs9dm9pZCAwLEo9dm9pZCAwLGI9dm9pZCAwLE89dm9pZCAwLGFyPXZvaWQgMCxycj12b2lkIDAsdHI9dm9pZCAwLG9yPXZvaWQgMCxpcj12b2lkIDAsWj12b2lkIDAsdnI9dm9pZCAwLGZyPXZvaWQgMCx1cj12b2lkIDAsbnI9dm9pZCAwO0k8YztJKyspe2lmKHo9dltJXSxpPXoqMyx0aGlzLmdldFBvc2l0aW9uQnlJbmRleChpLFMpLE49Uy54LEI9Uy55LFY9Uy56LHRoaXMuZ2V0UG9zaXRpb25CeUluZGV4KGkrMSxTKSxSPVMueCxVPVMueSxfPVMueix0aGlzLmdldFBvc2l0aW9uQnlJbmRleChpKzIsUyksJD1TLngsRj1TLnksVz1TLnosTD1SLU4sRz1VLUIseD1fLVYsQz0kLU4sSz1GLUIsSj1XLVYsYj1HKkoteCpLLE89eCpDLUwqSixhcj1MKkstRypDLFo9TSpiK1AqTytUKmFyLFo+MClpcj0xO2Vsc2UgaWYoWjwwKWlyPS0xLFo9LVo7ZWxzZSBjb250aW51ZTtycj1ILU4sdHI9ai1CLG9yPXEtVix2cj1pciooTSoodHIqSi1vcipLKStQKihvcipDLXJyKkopK1QqKHJyKkstdHIqQykpLCEodnI8MCkmJihmcj1pciooTSooRypvci14KnRyKStQKih4KnJyLUwqb3IpK1QqKEwqdHItRypycikpLCEoZnI8MCkmJih2citmcj5afHwodXI9LWlyKihycipiK3RyKk8rb3IqYXIpLCEodXI8MCkmJihucj11ci9aLGQucHVzaChuZXcgcHIoW04sQixWLFIsVSxfLCQsRixXXSxbSCtNKm5yLGorUCpucixxK1QqbnJdLHopKSkpKSl9bD1hKlEvMixoPXdbbCsxNl0sQT13W2wrMTddLGgmJnAucHVzaChoKSxBJiZwLnB1c2goQSl9cmV0dXJuIGR9LHJ9KGRyKTtmdW5jdGlvbiBzcihlLHIsdCl7cmV0dXJuIGU8cj9yOmU+dD90OmV9ZnVuY3Rpb24gSXIoZSxyLHQsbyxmKXtpZih0Pj1vKXJldHVyblswLDAsMCwwLDAsMF07Zm9yKHZhciBkPTEvMCx2PTEvMCxuPTEvMCxzPS0xLzAsdT0tMS8wLHc9LTEvMCx5PXQscD12b2lkIDAsYT12b2lkIDA7eTxvO3krKylwPWVbeV0qNixhPXJbcF0sYTxkJiYoZD1hKSxhPXJbcCsxXSxhPHYmJih2PWEpLGE9cltwKzJdLGE8biYmKG49YSksYT1yW3ArM10sYT5zJiYocz1hKSxhPXJbcCs0XSxhPnUmJih1PWEpLGE9cltwKzVdLGE+dyYmKHc9YSk7cmV0dXJuW2QtZix2LWYsbi1mLHMrZix1K2YsdytmXX12YXIgd3I9MWUtNix6cj1bIngiLCJ5IiwieiJdLEU9bmV3IFkoMCwwLDApLFByPWZ1bmN0aW9uKGUpe2hyKHIsZSk7ZnVuY3Rpb24gcigpe3JldHVybiBlIT09bnVsbCYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIHIucHJvdG90eXBlLmNyZWF0ZVRyZWU9ZnVuY3Rpb24odCxvLGYpe289TWF0aC5taW4obywxNik7dmFyIGQ9dGhpcy5nZXRQb3NpdGlvbkJ5SW5kZXguYmluZCh0aGlzKSx2PXRoaXMuZ2V0UG9zaXRpb25Db3VudCgpLG49dj42NTUzNT9uZXcgVWludDMyQXJyYXkodik6bmV3IFVpbnQxNkFycmF5KHYpLHM9W10sdT0wLHc9LTE7aWYoZilmb3IodmFyIHk9MDt5PHY7eSs9MSluW3ldPXk7ZWxzZXtkKDAsRSk7Zm9yKHZhciBwPUUueCxhPUUueSxoPUUueixBPXAsbD1hLEk9aCx5PTAsYz12b2lkIDAsej12b2lkIDAsaT12b2lkIDA7eTx2O3krPTEpblt5XT15LGQoeSxFKSxjPUUueCx6PUUueSxpPUUueixjPHA/cD1jOmM+QSYmKEE9YyksejxhP2E9ejp6PmwmJihsPXopLGk8aD9oPWk6aT5JJiYoST1pKTtmPVtwLGEsaCxBLGwsSV19dmFyIGs9bmV3IG0oKyt3LGYsMCx2LDApO3NbdSsrXT1rO3ZhciBIPVtdLGo9WzAsMSwyXSxxPWZ1bmN0aW9uKFAsVCl7cmV0dXJuIEhbVF0tSFtQXX07ZnVuY3Rpb24gTShQKXt2YXIgVD1QLnN0YXJ0SW5kZXgsTj1QLmVuZEluZGV4LEI9UC5leHRlbnRzO0hbMF09QlszXS1CWzBdLEhbMV09Qls0XS1CWzFdLEhbMl09Qls1XS1CWzJdO2Zvcih2YXIgVj1qLnNvcnQocSlbMF0sUj16cltWXSxVPShCW1ZdK0JbViszXSkvMixfPVQsJD1OLTEsRj0tMSxXO188PSQ7KUY9PT0tMT8oVz1uW19dLGQoVyxFKSxFW1JdPFU/XysrOkY9Vyk6KFc9blskXSxkKFcsRSksRVtSXT49VXx8KG5bX109VyxuWyRdPUYsRj0tMSxfKyspLCQtLSk7aWYoXz5UKXt2YXIgTD1CLnNsaWNlKCk7TFtWKzNdPVUrd3I7dmFyIEc9bmV3IG0oKyt3LEwsVCxfLFAuZGVlcHRoKzEpO0cuZGVlcHRoPG8mJkcuZW5kSW5kZXgtRy5zdGFydEluZGV4PnQmJihzW3UrK109RyksUC5ub2RlMD1HfWlmKE4+Xyl7dmFyIHg9Qi5zbGljZSgpO3hbVl09VS13cjt2YXIgQz1uZXcgbSgrK3cseCxfLE4sUC5kZWVwdGgrMSk7Qy5kZWVwdGg8byYmQy5lbmRJbmRleC1DLnN0YXJ0SW5kZXg+dCYmKHNbdSsrXT1DKSxQLm5vZGUxPUN9UC5zdGFydEluZGV4PTAsUC5lbmRJbmRleD0wfWZvcig7dTspTShzWy0tdV0pO3JldHVybiB0aGlzLm9mZnNldEFycmF5PW4sdGhpcy5yb290Tm9kZVBhY2tlZD15cihrLHcrMSkscy5sZW5ndGg9MCx0aGlzfSxyLnByb3RvdHlwZS5pbnRlcnNlY3RSYXk9ZnVuY3Rpb24odCxvLGYsZCl7Zm9yKHZhciB2PXRoaXMub2Zmc2V0QXJyYXksbj10aGlzLnJvb3ROb2RlUGFja2VkLHM9bmV3IEZsb2F0MzJBcnJheShuKSx1PW5ldyBVaW50MzJBcnJheShuKSx3PW5ldyBVaW50MTZBcnJheShuKSx5PWYqZixwPW5ldyBZKDEvby54LDEvby55LDEvby56KSxhPVswXSxoLEEsbCxJOyhoPWEucG9wKCkpIT09dm9pZCAwOylpZihJPWgqUS80LGNyKHQscCxzW0ldLHNbSSsxXSxzW0krMl0sc1tJKzNdLHNbSSs0XSxzW0krNV0sZikpe2Zvcih2YXIgYz11W0krNl0sej11W0krN10saT12b2lkIDAsaz12b2lkIDAsSD12b2lkIDAsaj12b2lkIDAscT12b2lkIDAsTT12b2lkIDAsUD12b2lkIDAsVD12b2lkIDAsTj12b2lkIDAsQj12b2lkIDAsVj12b2lkIDAsUj12b2lkIDA7Yzx6O2MrKylpPXZbY10sdGhpcy5nZXRQb3NpdGlvbkJ5SW5kZXgoaSxFKSxrPUUueCxIPUUueSxqPUUueixxPXQueCxNPXQueSxQPXQueixUPW8ueCxOPW8ueSxCPW8ueixWPVQqKGstcSkrTiooSC1NKStCKihqLVApLFY+MCYmKHErPVQqVixNKz1OKlYsUCs9QipWKSxUPWstcSxOPUgtTSxCPWotUCxWPVQqVCtOKk4rQipCLFY8PXkmJmQucHVzaChuZXcgcHIoW2ssSCxqLGssSCxqLGssSCxqXSxbcSxNLFBdLGkpKTtJPWgqUS8yLEE9d1tJKzE2XSxsPXdbSSsxN10sQSYmYS5wdXNoKEEpLGwmJmEucHVzaChsKX1yZXR1cm4gZH0scn0oZHIpO2Z1bmN0aW9uIEJyKGUpe29ubWVzc2FnZT1mdW5jdGlvbihyKXtQcm9taXNlLnJlc29sdmUoci5kYXRhKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSkudGhlbihmdW5jdGlvbih0KXt2YXIgbz10Lm91dHB1dCxmPXQudHJhbnNmZXI7cmV0dXJuIHBvc3RNZXNzYWdlKG8sZil9KS5jYXRjaChmdW5jdGlvbih0KXtyZXR1cm4gcG9zdE1lc3NhZ2UoeyQkZXJyb3I6dH0pfSl9fUJyKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoZSkudGhlbihmdW5jdGlvbihyKXtmb3IodmFyIHQ9W10sbz1uZXcgU2V0LGY9MCxkPXI7ZjxkLmxlbmd0aDtmKyspe3ZhciB2PWRbZl0sbj12b2lkIDA7aWYodi50eXBlPT09Im1lc2giKW49bmV3IEFyKHYuYXR0cmlidXRlcy5wb3NpdGlvbix2LmluZGljZXMpO2Vsc2UgaWYodi50eXBlPT09InBvaW50cyIpbj1uZXcgUHIodi5hdHRyaWJ1dGVzLnBvc2l0aW9uLHYuaW5kaWNlcyk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgVHlwZSIpO24uY3JlYXRlVHJlZSh2Lm1heEl0ZW1QZXJOb2RlLHYubWF4VHJlZURlcHRoLHYuZXh0ZW50cyk7dmFyIHM9e3R5cGU6di50eXBlLGF0dHJpYnV0ZXM6di5hdHRyaWJ1dGVzLGluZGljZXM6di5pbmRpY2VzLG9mZnNldEFycmF5Om4ub2Zmc2V0QXJyYXkscm9vdE5vZGVQYWNrZWQ6bi5yb290Tm9kZVBhY2tlZH07dC5wdXNoKHMpO3ZhciB1PXZvaWQgMDtmb3IodmFyIHcgaW4gcy5hdHRyaWJ1dGVzKXt2YXIgeT1zLmF0dHJpYnV0ZXNbd107eSYmeS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmby5hZGQoeS5idWZmZXIpfXU9cy5pbmRpY2VzLHUmJnUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJm8uYWRkKHUuYnVmZmVyKSx1PXMub2Zmc2V0QXJyYXksdSYmdS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmby5hZGQodS5idWZmZXIpLG8uYWRkKHMucm9vdE5vZGVQYWNrZWQpfXJldHVybntvdXRwdXQ6dCx0cmFuc2ZlcjpBcnJheS5mcm9tKG8pfX0pfSl9KSgpOwo=";
var decodeBase64$1 = (n45) => Uint8Array.from(atob(n45), (t) => t.charCodeAt(0));
var blob$2 = typeof self != "undefined" && self.Blob && new Blob([decodeBase64$1(encodedJs$1)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper$1(n45) {
  let t;
  try {
    if (t = blob$2 && (self.URL || self.webkitURL).createObjectURL(blob$2), !t) throw "";
    const e = new Worker(t, {
      name: n45 == null ? void 0 : n45.name
    });
    return e.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), e;
  } catch (e) {
    return new Worker(
      "data:text/javascript;base64," + encodedJs$1,
      {
        name: n45 == null ? void 0 : n45.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
var WorkerPool$1 = (
  /** @class */
  function() {
    function n45(t, e) {
      this.pool = e, this.workerCreator = t, this.queue = [], this.workers = [], this.workersResolver = [], this.workerStatus = 0;
    }
    return n45.prototype.initWorker = function(t) {
      if (this.workerCreator && !this.workers[t]) {
        var e = this.workerCreator();
        e.addEventListener("message", this.onMessage.bind(this, t)), this.workers[t] = e;
      }
    }, n45.prototype.getIdleWorker = function() {
      for (var t = 0; t < this.pool; t++)
        if (!(this.workerStatus & 1 << t))
          return t;
      return -1;
    }, n45.prototype.onMessage = function(t, e) {
      var r = this.workersResolver[t], o = r.resolve, s = r.reject;
      if (e.data && "$$error" in e.data ? s(e.data.$$error) : o(e.data), this.queue.length) {
        var u = this.queue.shift(), l = u.resolve, c = u.reject, f = u.input, d = u.transfer;
        this.workersResolver[t] = { resolve: l, reject: c }, this.workers[t].postMessage(f, d);
      } else
        this.workerStatus ^= 1 << t;
    }, n45.prototype.postMessage = function(t, e) {
      var r = this;
      return e === void 0 && (e = []), new Promise(function(o, s) {
        var u = r.getIdleWorker();
        u !== -1 ? (r.initWorker(u), r.workerStatus |= 1 << u, r.workersResolver[u] = { resolve: o, reject: s }, r.workers[u].postMessage(t, e)) : r.queue.push({ resolve: o, reject: s, input: t, transfer: e });
      });
    }, n45.prototype.dispose = function() {
      this.workers.forEach(function(t) {
        return t.terminate();
      }), this.workersResolver.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }, n45;
  }()
);
var bvhWorkerPool = new WorkerPool$1(function() {
  return new WorkerWrapper$1();
}, 4);
var bvhMeshMap = /* @__PURE__ */ new Map();
var scratchRay = new Ray();
var scratchNormalMatrix = new Matrix3();
var scratchInverseMatrix = new Matrix4();
var scratchIntersectionFaceA = new Vector3();
var scratchIntersectionFaceB = new Vector3();
var scratchIntersectionFaceC = new Vector3();
var scratchIntersectionTriangle = new Triangle();
function raycastMesh(n45, t, e, r) {
  var o, s = n45.matrixWorld;
  scratchInverseMatrix.getInverse(s), scratchRay.copy(e.ray).applyMatrix4(scratchInverseMatrix);
  for (var u = t.intersectRay(scratchRay.origin, scratchRay.direction, 0, []), l = n45.geometry, c = n45.material, f = l.groups, d = l.index, h = 0, v = u.length; h < v; h++) {
    var A = u[h], g = A.triangle, p = A.index, y = A.intersectionPoint, m = new Vector3(y[0], y[1], y[2]).applyMatrix4(s), E = e.ray.origin.distanceTo(m);
    if (!(E < e.near || E > e.far)) {
      var b = void 0;
      if (Array.isArray(c)) {
        if (f)
          for (var T = p * 3, R = 0, S = f; R < S.length; R++) {
            var M = S[R];
            if (T >= M.start && T - M.start < M.count) {
              b = c[(o = M.materialIndex) !== null && o !== void 0 ? o : 0];
              break;
            }
          }
      } else
        b = c;
      if (b) {
        var w = scratchIntersectionTriangle.set(scratchIntersectionFaceA.set(g[0], g[1], g[2]).applyMatrix4(s), scratchIntersectionFaceB.set(g[3], g[4], g[5]).applyMatrix4(s), scratchIntersectionFaceC.set(g[6], g[7], g[8]).applyMatrix4(s)).getNormal(new Vector3()), H = p * 3, L = new Face3(d ? d.array[H] : H, d ? d.array[H + 1] : H + 1, d ? d.array[H + 2] : H + 2, w), C = e.ray.direction.dot(w);
        b.side === FrontSide && C >= 0 || b.side === BackSide && C <= 0 || r.push({
          distance: E,
          object: n45,
          face: L,
          point: m,
          distanceToRay: 0,
          faceIndex: p
        });
      }
    }
  }
}
function raycastPoints(n45, t, e, r) {
  var o, s, u = n45.matrixWorld;
  scratchNormalMatrix.getNormalMatrix(u), scratchInverseMatrix.getInverse(u);
  var l = ((s = (o = e.params.Points) === null || o === void 0 ? void 0 : o.threshold) !== null && s !== void 0 ? s : 1) * scratchInverseMatrix.getMaxScaleOnAxis();
  scratchRay.copy(e.ray).applyMatrix4(scratchInverseMatrix);
  for (var c = t.intersectRay(scratchRay.origin, scratchRay.direction, l, []), f = n45.geometry, d = f.index, h = f.getAttribute("normal"), v = 0, A = c.length; v < A; v++) {
    var g = c[v], p = g.triangle, y = g.index, m = g.intersectionPoint, E = new Vector3(m[0], m[1], m[2]).applyMatrix4(u), b = e.ray.origin.distanceTo(E);
    if (!(b < e.near || b > e.far)) {
      var T = scratchIntersectionFaceA.set(p[0], p[1], p[2]).applyMatrix4(u), R = d ? d.array[y] : y, S = void 0;
      if (h instanceof BufferAttribute) {
        var M = new Vector3().fromBufferAttribute(h, R).applyNormalMatrix(scratchNormalMatrix);
        S = new Face3(R, R, R, M);
      }
      r.push({
        distance: b,
        object: n45,
        face: S,
        point: E,
        distanceToRay: E.distanceTo(T),
        index: y
      });
    }
  }
}
var BVH_MESH_PROP = "__bvh_mesh__";
var originMeshRaycast = Mesh.prototype.raycast;
function overrideMeshRaycast(n45, t) {
  var e = getBvhTreeForMesh(this);
  e ? raycastMesh(this, e, n45, t) : originMeshRaycast.call(this, n45, t);
}
function getBvhTreeForMesh(n45) {
  var t = n45[BVH_MESH_PROP];
  return t instanceof BVHMesh, t;
}
function bindBvhTreeForMesh(n45, t) {
  var e;
  Object.assign(n45, (e = {}, e[BVH_MESH_PROP] = t, e.raycast = overrideMeshRaycast, e));
}
var BVH_POINTS_PROP = "__bvh_points__";
var originPointsRaycast = Points.prototype.raycast;
function overridePointsRaycast(n45, t) {
  var e = getBvhTreeForPoints(this);
  e ? raycastPoints(this, e, n45, t) : originPointsRaycast.call(this, n45, t);
}
function getBvhTreeForPoints(n45) {
  var t = n45[BVH_POINTS_PROP];
  return t instanceof BVHPoints, t;
}
function bindBvhTreeForPoints(n45, t) {
  var e;
  Object.assign(n45, (e = {}, e[BVH_POINTS_PROP] = t, e.raycast = overridePointsRaycast, e));
}
function generateBvhTree(n45, t, e, r) {
  var o = [];
  return n45.traverse(function(s) {
    (s instanceof Mesh || s instanceof Points) && s.geometry instanceof BufferGeometry && o.push(s);
  }), Promise.resolve().then(function() {
    for (var s = [], u = /* @__PURE__ */ new Set(), l = null, c = 0; c < o.length; c++) {
      var f = o[c], d = f.geometry;
      if (d instanceof BufferGeometry) {
        var h = void 0;
        if (f instanceof Mesh ? h = "mesh" : f instanceof Points && (h = "points"), !!h) {
          var v = d.boundingBox, A = v ? [v.min.x, v.min.y, v.min.z, v.max.x, v.max.y, v.max.z] : void 0, g = {};
          for (var p in d.attributes) {
            var y = d.attributes[p];
            y instanceof InterleavedBufferAttribute ? (g[p] = {
              array: y.data.array,
              stride: y.data.stride,
              offset: y.offset
            }, l = y.data.array, l && l.buffer instanceof ArrayBuffer && u.add(l.buffer)) : (g[p] = {
              array: y.array
            }, l = y.array, l && l.buffer instanceof ArrayBuffer && u.add(l.buffer));
          }
          var m = void 0, E = d.getIndex();
          E && (E instanceof InterleavedBufferAttribute ? (m = {
            array: E.data.array,
            stride: E.data.stride,
            offset: E.offset
          }, l = E.data.array, l && l.buffer instanceof ArrayBuffer && u.add(l.buffer)) : (m = {
            array: E.array
          }, l = E.array, l && l.buffer instanceof ArrayBuffer && u.add(l.buffer)));
          var b = {
            type: h,
            attributes: g,
            indices: m,
            maxItemPerNode: e,
            maxTreeDepth: r,
            extents: A
          };
          s.push(b);
        }
      }
    }
    return bvhWorkerPool.postMessage(s, Array.from(u));
  }).then(function(s) {
    for (var u = 0; u < o.length; u++) {
      var l = o[u], c = l.geometry, f = s[u];
      if (c instanceof BufferGeometry) {
        for (var d in f.attributes) {
          var h = f.attributes[d].array, v = c.attributes[d];
          v instanceof InterleavedBufferAttribute ? v.data.array = h : v.array = h;
        }
        var A = c.getIndex();
        if (A && f.indices) {
          var h = f.indices.array;
          A instanceof InterleavedBufferAttribute ? A.data.array = h : A.array = h;
        }
        if (l instanceof Mesh) {
          var g = new BVHMesh(f.attributes.position, f.indices);
          g.offsetArray = f.offsetArray, g.rootNodePacked = f.rootNodePacked, bindBvhTreeForMesh(l, g);
        } else if (l instanceof Points) {
          var g = new BVHPoints(f.attributes.position, f.indices);
          g.offsetArray = f.offsetArray, g.rootNodePacked = f.rootNodePacked, bindBvhTreeForPoints(l, g);
        }
      }
    }
    return n45;
  });
}
var TileNode = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      o === void 0 && (o = noop$1);
      var s = n45.call(this) || this;
      return s.contentObject = r, s.name = e, s.materials = [], s.pbmObjects = [], s.disposers = [o], s.add(r), r.traverse(function(u) {
        var l;
        if (u instanceof Mesh || u instanceof Points) {
          var c = u.material;
          Array.isArray(c) ? (l = s.materials).push.apply(l, c) : s.materials.push(c);
        }
        (u instanceof PBMMesh || u instanceof PBMSkinnedMesh || u instanceof PBMPointCloud) && s.pbmObjects.push(u);
      }), s;
    }
    return t.prototype.generateBvhTree = function() {
      return generateBvhTree(this, true, 200, 10);
    }, t.prototype.intersectRaycaster = function(e, r, o) {
      r === void 0 && (r = true), o === void 0 && (o = []);
      for (var s = this.children.slice(), u, l = []; u = s.pop(); )
        if (u.visible) {
          u.raycast(e, l);
          for (var c = 0, f = u.children.length; c < f; c++)
            s.push(u.children[c]);
        }
      return l.forEach(function(d) {
        var h = 0;
        if ((d.object instanceof PBMMesh || d.object instanceof PBMSkinnedMesh || d.object instanceof PBMPointCloud) && d.face) {
          var v = Array.isArray(d.object.material) ? d.object.material[d.face.materialIndex] : d.object.material;
          v && (h = v.floorIndex);
        }
        d.floor = h;
      }), r && l.sort(function(d, h) {
        return d.distance - h.distance;
      }), o.push.apply(o, l), o;
    }, t.prototype.update = function(e, r, o, s) {
      for (var u = 0, l = this.pbmObjects; u < l.length; u++) {
        var c = l[u];
        c.update(e, r, o, s);
      }
    }, t.prototype.dispose = function() {
      for (var e = 0, r = this.disposers; e < r.length; e++) {
        var o = r[e];
        o();
      }
      this.disposers.length = 0, this.pbmObjects.length = 0;
    }, t.prototype.clone = function() {
      return new t(this.name, this.contentObject.clone());
    }, t;
  }(Object3D)
);
function pathJoin() {
  for (var n45 = [], t = 0; t < arguments.length; t++)
    n45[t] = arguments[t];
  var e = [];
  n45 = n45.map(function(l) {
    return (l != null ? l : "").trim();
  }).filter(function(l) {
    return l.length > 0 && !/^\/+$/.test(l);
  });
  for (var r = 0; r < n45.length; r++) {
    var o = r === 0, s = r === n45.length - 1, u = n45[r];
    o || (u = u.replace(/^\.\//, "").replace(/^\/+/, "")), s || (u = u.replace(/\/+$/, "")), e.push(u);
  }
  return e.join("/");
}
function normalizeURL(n45) {
  var t, e = /^(http\:|https\:|file\:)?\/\/[^/]/.exec(n45);
  if (!e)
    return n45;
  var r = e[1] || "", o = n45.slice(r.length + 2), s = o.indexOf("#");
  s >= 0 && (n45.slice(s), o = n45.slice(0, s));
  var u = o.indexOf("?");
  u >= 0 && (n45.slice(u), o = n45.slice(0, u));
  for (var l = o.split("/"), c = l.shift(), f = (t = l.pop()) !== null && t !== void 0 ? t : "", d = [], h = 0, v = l; h < v.length; h++) {
    var A = v[h];
    if (!(A === "" || A === ".")) {
      if (A === "..") {
        d.pop();
        continue;
      }
      d.push(A);
    }
  }
  return r + "//" + c + "/" + d.join("/") + "/" + f;
}
function isAbsoluteURL(n45) {
  return n45.indexOf("//") === 0 || /^[0-9a-z]+\:/i.test(n45);
}
function normalizeTileHeader(n45, t, e) {
  var r;
  if (n45.content) {
    var o = (r = n45.content.uri) !== null && r !== void 0 ? r : n45.content.url;
    typeof o == "string" && !isAbsoluteURL(o) && (n45.content.uri = normalizeURL(pathJoin(t, o)));
  }
  if (n45.transform) {
    for (var s = false, u = 0; u < 16; u++) {
      var l = n45.transform[u];
      if (typeof l != "number" || isNaN(l) || !isFinite(l)) {
        s = true;
        break;
      }
    }
    if (n45.transform[15] === 0 && (s = true), s)
      throw new Error("Invalid Tile Transform: " + JSON.stringify(n45.transform));
  }
  if (n45.children)
    for (var c = 0, f = n45.children; c < f.length; c++) {
      var d = f[c];
      normalizeTileHeader(d, t);
    }
  return n45;
}
function normalizeTilesetHeader(n45, t) {
  if (n45.asset || (n45.asset = {}), n45.rootMeta || (n45.rootMeta = {}), n45.rootMeta.taskParameters || (n45.rootMeta.taskParameters = {}), n45.asset.overview) {
    var e = n45.asset.overview;
    isAbsoluteURL(e.imageFile) || (e.imageFile = normalizeURL(pathJoin(t, e.imageFile))), isAbsoluteURL(e.worldFile) || (e.worldFile = normalizeURL(pathJoin(t, e.worldFile)));
  }
  if (n45.asset.trajectories)
    for (var r = 0; r < n45.asset.trajectories.list.length; r++) {
      var o = n45.asset.trajectories.list[r];
      o.file = normalizeURL(pathJoin(t, o.file));
    }
  return normalizeTileHeader(n45.root, t), n45;
}
function initTextures(n45, t, e) {
  for (var r, o, s = Promise.resolve(), u = n45.slice(), l = function() {
    for (var c = [], f = 0, d = void 0; d = u.shift(); ) {
      c.push(d);
      var h = ((r = d.image) === null || r === void 0 ? void 0 : r.width) * ((o = d.image) === null || o === void 0 ? void 0 : o.height);
      if (!isNaN(h) && isFinite(h) && (f += h), f >= e)
        break;
    }
    s = s.then(function() {
      return new Promise(function(v) {
        AnimationFrameLoop.shared.add(function() {
          for (var A = 0, g = c; A < g.length; A++) {
            var p = g[A];
            t.initTexture(p);
          }
          v();
        }, true);
      });
    }).catch(function() {
    });
  }; u.length > 0; )
    l();
  return s;
}
function appendSearch(n45, t) {
  if (t === void 0 && (t = ""), (t[0] === "?" || t[0] === "&") && (t = t.slice(1)), !t)
    return n45;
  var e = n45.indexOf("#"), r = "";
  return e >= 0 && (r = n45.slice(e), n45 = n45.slice(0, e)), (n45[n45.length - 1] === "?" || n45[n45.length - 1] === "&") && (n45 = n45.slice(0, -1)), n45.indexOf("?") >= 0 ? "".concat(n45, "&").concat(t).concat(r) : "".concat(n45, "?").concat(t).concat(r);
}
var SIZEOF_UINT32$1 = 4;
function parseHeader$1(n45, t, e) {
  var r = new DataView(t);
  if (n45.magic = r.getUint32(e, true), e += SIZEOF_UINT32$1, n45.version = r.getUint32(e, true), e += SIZEOF_UINT32$1, n45.byteLength = r.getUint32(e, true), e += SIZEOF_UINT32$1, n45.version !== 1)
    throw new Error("3D Tile Version ".concat(n45.version, " not supported"));
  return e;
}
var _a$4;
var GL_TYPE;
(function(n45) {
  n45[n45.BYTE = 5120] = "BYTE", n45[n45.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n45[n45.SHORT = 5122] = "SHORT", n45[n45.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n45[n45.INT = 5124] = "INT", n45[n45.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n45[n45.FLOAT = 5126] = "FLOAT", n45[n45.DOUBLE = 5130] = "DOUBLE";
})(GL_TYPE || (GL_TYPE = {}));
var GL_TYPE_TO_ARRAY_TYPE = (_a$4 = {}, _a$4[GL_TYPE.DOUBLE] = Float64Array, _a$4[GL_TYPE.FLOAT] = Float32Array, _a$4[GL_TYPE.UNSIGNED_SHORT] = Uint16Array, _a$4[GL_TYPE.UNSIGNED_INT] = Uint32Array, _a$4[GL_TYPE.UNSIGNED_BYTE] = Uint8Array, _a$4[GL_TYPE.BYTE] = Int8Array, _a$4[GL_TYPE.SHORT] = Int16Array, _a$4[GL_TYPE.INT] = Int32Array, _a$4);
var NAME_TO_GL_TYPE = {
  DOUBLE: GL_TYPE.DOUBLE,
  FLOAT: GL_TYPE.FLOAT,
  UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
  UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
  UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
  BYTE: GL_TYPE.BYTE,
  SHORT: GL_TYPE.SHORT,
  INT: GL_TYPE.INT
};
function getArrayType(n45) {
  var t = GL_TYPE_TO_ARRAY_TYPE[n45];
  if (!t)
    throw new Error("Failed to convert GL type");
  return t;
}
function getByteSize(n45) {
  var t = getArrayType(n45);
  return t.BYTES_PER_ELEMENT;
}
function createTypedArray(n45, t, e, r) {
  e === void 0 && (e = 0);
  var o = getArrayType(n45);
  if (e % getByteSize(n45) !== 0) {
    var s = r ? t.slice(e, e + r * getByteSize(n45)) : t.slice(e);
    return new o(s);
  } else
    return new o(t, e, r != null ? r : (t.byteLength - e) / getByteSize(n45));
}
function glTypeFromName(n45) {
  var t = NAME_TO_GL_TYPE[n45];
  if (!t)
    throw new Error("Failed to convert GL type");
  return t;
}
var FeatureTable = (
  /** @class */
  function() {
    function n45(t, e) {
      this.featuresLength = 0, this.cachedTypedArrays = {}, this.json = t, this.buffer = e;
      var r = this.getGlobalProperty("POINTS_LENGTH", GL_TYPE.UNSIGNED_INT, 1);
      r && r.length && (this.featuresLength = r[0]);
    }
    return n45.prototype.getExtension = function(t) {
      return this.json.extensions && this.json.extensions[t];
    }, n45.prototype.hasProperty = function(t) {
      return !!this.json[t];
    }, n45.prototype.getGlobalProperty = function(t, e, r) {
      var o = this.json[t];
      if (typeof o == "number") {
        var s = getArrayType(e);
        return new s([o]);
      } else if (Array.isArray(o)) {
        var s = getArrayType(e);
        return new s(o);
      } else if (o && Number.isFinite(o.byteOffset))
        return this.getTypedArrayFromBinary(t, e, r, 1, o.byteOffset);
      return null;
    }, n45.prototype.getPropertyArray = function(t, e, r) {
      var o = this.json[t];
      return o && Number.isFinite(o.byteOffset) ? ("componentType" in o && (e = glTypeFromName(o.componentType)), this.getTypedArrayFromBinary(t, e, r, this.featuresLength, o.byteOffset)) : this.getTypedArrayFromArray(t, e, o);
    }, n45.prototype.getProperty = function(t, e, r, o, s) {
      var u = this.json[t];
      if (!u)
        return null;
      var l = this.getPropertyArray(t, e, r);
      if (r === 1)
        return s[0] = l[o], s;
      for (var c = 0; c < r; ++c)
        s[c] = l[r * o + c];
      return s;
    }, n45.prototype.getTypedArrayFromBinary = function(t, e, r, o, s) {
      var u = this.cachedTypedArrays, l = u[t];
      return l || (l = createTypedArray(e, this.buffer.buffer, this.buffer.byteOffset + s, o * r), u[t] = l), l;
    }, n45.prototype.getTypedArrayFromArray = function(t, e, r) {
      var o = this.cachedTypedArrays, s = o[t];
      return s || (s = createTypedArray(e, r), o[t] = s), s;
    }, n45;
  }()
);
var SIZEOF_UINT32 = 4;
var DEPRECATION_WARNING = "b3dm tile in legacy format.";
function getStringFromArrayBuffer(n45, t, e) {
  var r = new TextDecoder("utf8"), o = new Uint8Array(n45, t, e), s = r.decode(o);
  return s;
}
function parseTable(n45, t, e) {
  return e = parseTablesHeader(n45, t, e), e = parseFeatureTable(n45, t, e), e = parseBatchTable(n45, t, e), e;
}
function parseTablesHeader(n45, t, e) {
  var r = new DataView(t), o = 0;
  n45.header = n45.header || {};
  var s = r.getUint32(e, true);
  e += SIZEOF_UINT32;
  var u = r.getUint32(e, true);
  e += SIZEOF_UINT32;
  var l = r.getUint32(e, true);
  e += SIZEOF_UINT32;
  var c = r.getUint32(e, true);
  return e += SIZEOF_UINT32, l >= 570425344 ? (e -= SIZEOF_UINT32 * 2, o = s, l = u, c = 0, s = 0, u = 0, console.warn(DEPRECATION_WARNING)) : c >= 570425344 && (e -= SIZEOF_UINT32, o = l, l = s, c = u, s = 0, u = 0, console.warn(DEPRECATION_WARNING)), n45.header.featureTableJsonByteLength = s, n45.header.featureTableBinaryByteLength = u, n45.header.batchTableJsonByteLength = l, n45.header.batchTableBinaryByteLength = c, n45.header.batchLength = o, e;
}
function parseFeatureTable(n45, t, e) {
  var r = n45.header || {}, o = r.featureTableJsonByteLength, s = r.featureTableBinaryByteLength, u = r.batchLength;
  if (n45.featureTableJson = {
    BATCH_LENGTH: u || 0
  }, o && o > 0) {
    var l = getStringFromArrayBuffer(t, e, o);
    n45.featureTableJson = JSON.parse(l);
  }
  e += o || 0, n45.featureTableBinary = new Uint8Array(t, e, s), e += s || 0, n45.rtcCenter = [0, 0, 0];
  var c = new FeatureTable(n45.featureTableJson, n45.featureTableBinary);
  if (Array.isArray(c.json.RTC_CENTER)) {
    var f = c.json.RTC_CENTER;
    n45.rtcCenter[0] = f[0], n45.rtcCenter[1] = f[1], n45.rtcCenter[2] = f[2];
  } else {
    var f = c.getGlobalProperty("RTC_CENTER", GL_TYPE.FLOAT, 3);
    f && (n45.rtcCenter[0] = f[0], n45.rtcCenter[1] = f[1], n45.rtcCenter[2] = f[2]);
  }
  return e;
}
function parseBatchTable(n45, t, e) {
  var r = n45.header || {}, o = r.batchTableJsonByteLength, s = r.batchTableBinaryByteLength;
  if (o && o > 0) {
    var u = getStringFromArrayBuffer(t, e, o);
    n45.batchTableJson = JSON.parse(u), e += o, s && s > 0 && (n45.batchTableBinary = new Uint8Array(t, e, s), n45.batchTableBinary = new Uint8Array(n45.batchTableBinary), e += s);
  }
  return e;
}
function sliceArrayBuffer(n45, t, e) {
  var r = e !== void 0 ? new Uint8Array(n45).subarray(t, t + e) : new Uint8Array(n45).subarray(t), o = new Uint8Array(r);
  return o.buffer;
}
function parseGlTFArrayBuffer(n45, t, e) {
  var r = n45.byteLength - e;
  if (r === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return e % 4 !== 0 && console.warn("".concat(n45.type, ": embedded glb is not aligned to a 4-byte boundary.")), n45.gltfArrayBuffer = sliceArrayBuffer(t, e, r), n45.byteLength;
}
function decodeText(n45) {
  if (typeof TextDecoder != "undefined")
    return new TextDecoder().decode(n45);
  for (var t = "", e = 0, r = n45.length; e < r; e++)
    t += String.fromCharCode(n45[e]);
  try {
    return decodeURIComponent(escape(t));
  } catch (o) {
    return t;
  }
}
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function values(n45) {
  var t = [];
  for (var e in n45)
    t.push(n45[e]);
  return t;
}
function composeDsiposeSet(n45) {
  var t = Array.from(n45);
  return function() {
    for (var e = 0, r = t; e < r.length; e++) {
      var o = r[e];
      typeof o.dispose == "function" && o.dispose(), typeof o.close == "function" && o.close();
    }
  };
}
var Parser = (
  /** @class */
  function() {
    function n45(t, e, r) {
      this.json = t, this.extensions = e, this.options = r, this.cache = /* @__PURE__ */ new Map(), this.disposeSet = /* @__PURE__ */ new Set(), this.textureSet = /* @__PURE__ */ new Set(), this.nodeNamesUsed = {};
    }
    return n45.prototype.dispose = function() {
      this.cache.clear(), this.disposeSet.forEach(function(t) {
        typeof t.dispose == "function" && t.dispose(), typeof t.close == "function" && t.close();
      }), this.disposeSet.clear(), this.textureSet.clear(), this.extensions = {}, this.json = {
        asset: {
          version: "unknown"
        }
      };
    }, n45.prototype.markDefs = function() {
      for (var t = this.json.nodes || [], e = this.json.skins || [], r = this.json.meshes || [], o = 0, s = e.length; o < s; o++)
        for (var u = e[o].joints, l = 0, c = u.length; l < c; l++)
          t[u[l]].isBone = true;
      for (var f = 0, d = t.length; f < d; f++) {
        var h = t[f];
        h.mesh !== void 0 && h.skin !== void 0 && (r[h.mesh].isSkinnedMesh = true);
      }
    }, n45.prototype.parse = function() {
      var t = this, e = this.json, r = this.extensions;
      this.markDefs();
      for (var o = 0, s = values(r); o < s.length; o++) {
        var u = s[o];
        u.markDefs(this);
      }
      return Promise.all(values(r).map(function(l) {
        return l.prepare(t);
      })).then(function() {
        var l, c, f;
        return Promise.all([
          Promise.all(((l = e.scenes) !== null && l !== void 0 ? l : []).map(function(d, h) {
            return t.loadScene(h);
          })),
          Promise.all(((c = e.animations) !== null && c !== void 0 ? c : []).map(function(d, h) {
            return t.loadAnimation(h);
          })),
          Promise.all(((f = e.cameras) !== null && f !== void 0 ? f : []).map(function(d, h) {
            return t.loadCamera(h);
          }))
        ]);
      }).then(function(l) {
        var c = l[0], f = l[1], d = l[2], h = {
          json: e,
          scene: c[e.scene || 0],
          scenes: c,
          animations: f,
          cameras: d,
          textures: [],
          dispose: noop$1
        };
        return h;
      }).then(function(l) {
        return Promise.all(values(r).map(function(c) {
          return c.emitResult(l, t);
        })).then(function() {
          return l;
        });
      }).then(function(l) {
        var c = Array.from(t.textureSet), f = composeDsiposeSet(t.disposeSet);
        return Object.assign(l, {
          textures: c,
          dispose: f
        }), t.textureSet.clear(), t.disposeSet.clear(), t.dispose(), l;
      });
    }, n45.prototype.loadCamera = function(t) {
      var e = "camera:" + t, r = this.cache.get(e);
      if (r)
        return r;
      for (var o = null, s = 0, u = values(this.extensions); s < u.length; s++) {
        var l = u[s];
        if (o = l.loadCamera(t, this), o)
          break;
      }
      if (!o) {
        var c = void 0, f = this.json.cameras[t], d = f[f.type];
        d ? f.type === "perspective" ? c = new PerspectiveCamera(MathUtils.radToDeg(d.yfov), d.aspectRatio || 1, d.znear || 1, d.zfar || 2e6) : f.type === "orthographic" ? c = new OrthographicCamera(-d.xmag, d.xmag, d.ymag, -d.ymag, d.znear, d.zfar) : (console.warn("glTF: Invalid camera type ".concat(f.type, ".")), c = new Camera()) : (console.warn("glTF: Missing camera parameters."), c = new Camera()), f.name && (c.name = this.createUniqueName(f.name)), o = Promise.resolve(c);
      }
      return this.cache.set(e, o), o;
    }, n45.prototype.loadSkin = function(t) {
      var e = "skin:" + t, r = this.cache.get(e);
      if (r)
        return r;
      var o, s = this.json.skins[t], u = {
        joints: s.joints
      };
      return s.inverseBindMatrices === void 0 ? o = Promise.resolve(u) : o = this.loadAccessor(s.inverseBindMatrices).then(function(l) {
        return l && (u.inverseBindMatrices = l), u;
      }), this.cache.set(e, o), o;
    }, n45.prototype.loadAnimation = function(t) {
      var e = "animation:" + t, r = this.cache.get(e);
      if (r)
        return r;
      for (var o = null, s = 0, u = values(this.extensions); s < u.length; s++) {
        var l = u[s];
        if (o = l.loadAnimation(t, this), o)
          break;
      }
      if (!o) {
        for (var c = this.json, f = c.animations[t], d = [], h = [], v = [], A = [], g = [], p = 0, y = f.channels.length; p < y; p++) {
          var m = f.channels[p], E = f.samplers[m.sampler], b = m.target, T = b.node !== void 0 ? b.node : b.id, R = f.parameters !== void 0 ? f.parameters[E.input] : E.input, S = f.parameters !== void 0 ? f.parameters[E.output] : E.output;
          d.push(this.loadNode(T)), h.push(this.loadAccessor(R)), v.push(this.loadAccessor(S)), A.push(E), g.push(b);
        }
        o = Promise.all([
          Promise.all(d),
          Promise.all(h),
          Promise.all(v),
          Promise.all(A),
          Promise.all(g)
        ]).then(function(M) {
          for (var w = M[0], H = M[1], L = M[2], C = M[3], I = M[4], _ = [], O = function(U, D) {
            var q = w[U], z = H[U], Q = L[U], G = C[U], X = I[U];
            if (q === void 0)
              return "continue";
            q.updateMatrix(), q.matrixAutoUpdate = true;
            var $ = void 0;
            switch (PATH_PROPERTIES[X.path]) {
              case PATH_PROPERTIES.weights:
                $ = NumberKeyframeTrack;
                break;
              case PATH_PROPERTIES.rotation:
                $ = QuaternionKeyframeTrack;
                break;
              case PATH_PROPERTIES.position:
              case PATH_PROPERTIES.scale:
              default:
                $ = VectorKeyframeTrack;
                break;
            }
            var W = q.name ? q.name : q.uuid, oe = G.interpolation !== void 0 ? INTERPOLATION[G.interpolation] : InterpolateLinear, ie = [];
            PATH_PROPERTIES[X.path] === PATH_PROPERTIES.weights ? q.traverse(function(ne) {
              ne.morphTargetInfluences && ie.push(ne.name ? ne.name : ne.uuid);
            }) : ie.push(W);
            var re = Q.array;
            if (Q.normalized) {
              for (var j = getNormalizedComponentScale(re.constructor), se = new Float32Array(re.length), ae = 0, ue = re.length; ae < ue; ae++)
                se[ae] = re[ae] * j;
              re = se;
            }
            for (var ae = 0, ue = ie.length; ae < ue; ae++) {
              var fe = new $(ie[ae] + "." + PATH_PROPERTIES[X.path], z.array, re, oe);
              _.push(fe);
            }
          }, P = 0, N = w.length; P < N; P++)
            O(P);
          var k = f.name ? f.name : "animation_" + t;
          return new AnimationClip(k, void 0, _);
        });
      }
      return this.cache.set(e, o), o;
    }, n45.prototype.loadBuffer = function(t) {
      var e = this.json.buffers[t];
      if (e.type && e.type !== "arraybuffer")
        throw new Error("glTF: " + e.type + " buffer type is not supported.");
      var r = "buffer:" + t, o = this.cache.get(r);
      if (o)
        return o;
      for (var s = null, u = 0, l = values(this.extensions); u < l.length; u++) {
        var c = l[u];
        if (s = c.loadBuffer(t, this), s)
          break;
      }
      if (!s) {
        var f = this.json.buffers[t];
        s = this.options.fetcher.ajax(this.resolveResouce(f.uri), {
          responseType: "arraybuffer"
        }).then(function(d) {
          return d.body;
        });
      }
      return this.cache.set(r, s), s;
    }, n45.prototype.loadBufferView = function(t) {
      var e = "bufferView:" + t, r = this.cache.get(e);
      if (r)
        return r;
      for (var o = null, s = 0, u = values(this.extensions); s < u.length; s++) {
        var l = u[s];
        if (o = l.loadBufferView(t, this), o)
          break;
      }
      if (!o) {
        var c = this.json.bufferViews[t];
        o = this.loadBuffer(c.buffer).then(function(f) {
          var d = c.byteLength || 0, h = c.byteOffset || 0;
          return f.slice(h, h + d);
        });
      }
      return this.cache.set(e, o), o;
    }, n45.prototype.loadAccessor = function(t) {
      var e = this, r = "accessor:" + t, o = this.cache.get(r);
      if (o)
        return o;
      var s = null;
      if (!s) {
        var u = this.json.accessors[t];
        if (u.bufferView === void 0 && u.sparse === void 0)
          s = Promise.resolve(null);
        else {
          var l = [];
          u.bufferView !== void 0 ? l.push(this.loadBufferView(u.bufferView)) : l.push(Promise.resolve(null)), u.sparse !== void 0 && (l.push(this.loadBufferView(u.sparse.indices.bufferView)), l.push(this.loadBufferView(u.sparse.values.bufferView))), s = Promise.all(l).then(function(c) {
            var f = c[0], d = WEBGL_TYPE_SIZES[u.type], h = WEBGL_COMPONENT_TYPES[u.componentType], v = h.BYTES_PER_ELEMENT, A = v * d, g = u.byteOffset || 0, p = u.bufferView !== void 0 ? e.json.bufferViews[u.bufferView].byteStride : void 0, y = u.normalized === true, m, E;
            if (p && p !== A) {
              var b = Math.floor(g / p), T = "InterleavedBuffer:" + u.bufferView + ":" + u.componentType + ":" + b + ":" + u.count, R = e.cache.get(T);
              R || (m = new h(f, b * p, u.count * p / v), R = new InterleavedBuffer(m, p / v), e.cache.set(T, R)), E = new InterleavedBufferAttribute(R, d, g % p / v, y);
            } else
              f === null ? m = new h(u.count * d) : m = new h(f, g, u.count * d), E = new BufferAttribute(m, d, y);
            if (u.sparse !== void 0) {
              var S = WEBGL_TYPE_SIZES.SCALAR, M = WEBGL_COMPONENT_TYPES[u.sparse.indices.componentType], w = u.sparse.indices.byteOffset || 0, H = u.sparse.values.byteOffset || 0, L = new M(c[1], w, u.sparse.count * S), C = new h(c[2], H, u.sparse.count * d);
              f !== null && (E = new BufferAttribute(E.array.slice(), E.itemSize, E.normalized));
              for (var I = 0, _ = L.length; I < _; I++) {
                var O = L[I];
                if (E.setX(O, C[I * d]), d >= 2 && E.setY(O, C[I * d + 1]), d >= 3 && E.setZ(O, C[I * d + 2]), d >= 4 && E.setW(O, C[I * d + 3]), d >= 5)
                  throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
            }
            return E;
          });
        }
      }
      return this.cache.set(r, s), s;
    }, n45.prototype.createPrimitiveKey = function(t) {
      for (var e = 0, r = values(this.extensions); e < r.length; e++) {
        var o = r[e], s = o.createPrimitiveKey(t, this);
        if (s)
          return s;
      }
      for (var u = "", l = Object.keys(t.attributes).sort(), c = 0, f = l.length; c < f; c++)
        u += l[c] + ":" + t.attributes[l[c]] + ";";
      return t.indices + ":" + u + ":" + t.mode;
    }, n45.prototype.loadGeometry = function(t) {
      for (var e = this, r = null, o = 0, s = values(this.extensions); o < s.length; o++) {
        var u = s[o];
        if (r = u.loadGeometry(t, this), r)
          break;
      }
      return r || (r = this.addGeometryPrimitiveAttributes(new BufferGeometry(), t)), r = r.then(function(l) {
        return e.disposeSet.add(l), l;
      }), r;
    }, n45.prototype.loadImage = function(t) {
      for (var e = this, r = null, o = 0, s = values(this.extensions); o < s.length; o++) {
        var u = s[o];
        if (r = u.loadImage(t, this), r)
          break;
      }
      if (!r) {
        var l = this.json.images[t];
        if (l.bufferView !== void 0) {
          var c = this.json.bufferViews[l.bufferView];
          r = this.loadBuffer(c.buffer).then(function(d) {
            var h = c.byteOffset || 0, v = c.byteLength || 0, A = new Uint8Array(d, h, v), g = new Blob([A], { type: l.mimeType });
            return createImageBitmapLike(g);
          });
        } else if (l.uri) {
          var f = this.resolveResouce(l.uri);
          r = this.options.fetcher.loadImage(f, {}, void 0, void 0, void 0, createImageBitmapLikeImage()).then(function(d) {
            return d.body;
          });
        } else
          throw new Error("glTF: Invalid image defs.");
      }
      return r = r.then(function(d) {
        return e.disposeSet.add(d), d;
      }), r;
    }, n45.prototype.loadMaterialAsMeshStandardMaterial = function(t) {
      var e = this, r = [], o = new MeshStandardMaterial();
      o.color = new Color(1, 1, 1), o.opacity = 1;
      var s = {};
      for (var u in t.attributes) {
        var l = ATTRIBUTES[u] || u.toLowerCase();
        s[l] = u;
      }
      if ("color" in s && (o.vertexColors = true), "normal" in s || (o.flatShading = true), "tangent" in s ? o.vertexTangents = true : (o.normalScale && (o.normalScale.y *= -1), o.clearcoatNormalScale && (o.clearcoatNormalScale.y *= -1)), t.material !== void 0) {
        var c = this.json.materials[t.material];
        c.name && (o.name = c.name);
        var f = c.pbrMetallicRoughness || {};
        if (Array.isArray(f.baseColorFactor)) {
          var d = f.baseColorFactor;
          o.color.fromArray(d), o.opacity = d[3];
        }
        f.baseColorTexture !== void 0 && r.push(this.createMaterialTexture(f.baseColorTexture).then(function(A) {
          A.encoding = sRGBEncoding, o.map = A, e.disposeSet.add(A);
        })), o.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, o.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && r.push(this.createMaterialTexture(f.metallicRoughnessTexture).then(function(A) {
          o.metalnessMap = A, o.roughnessMap = A, e.disposeSet.add(A);
        })), c.doubleSided === true && (o.side = DoubleSide);
        var h = c.alphaMode || ALPHA_MODES.OPAQUE;
        if (h === ALPHA_MODES.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, h === ALPHA_MODES.MASK && (o.alphaTest = c.alphaCutoff !== void 0 ? c.alphaCutoff : 0.5)), c.normalTexture !== void 0 && (r.push(this.createMaterialTexture(c.normalTexture).then(function(A) {
          o.normalMap = A, e.disposeSet.add(A);
        })), o.normalScale = new Vector2(1, 1), c.normalTexture.scale !== void 0)) {
          var v = c.normalTexture.scale;
          o.normalScale.set(v, v);
        }
        c.occlusionTexture !== void 0 && (r.push(this.createMaterialTexture(c.occlusionTexture).then(function(A) {
          o.aoMap = A, e.disposeSet.add(A);
        })), c.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = c.occlusionTexture.strength)), c.emissiveFactor !== void 0 && (o.emissive = new Color().fromArray(c.emissiveFactor)), c.emissiveTexture !== void 0 && r.push(this.createMaterialTexture(c.emissiveTexture).then(function(A) {
          o.emissiveMap = A, e.disposeSet.add(A);
        }));
      }
      return this.disposeSet.add(o), Promise.all(r).then(function() {
        return o;
      });
    }, n45.prototype.loadMaterialAsMeshBasicMaterial = function(t) {
      var e = this, r = [], o = new MeshBasicMaterial();
      o.color = new Color(1, 1, 1), o.opacity = 1;
      var s = {};
      for (var u in t.attributes) {
        var l = ATTRIBUTES[u] || u.toLowerCase();
        s[l] = u;
      }
      if ("color" in s && (o.vertexColors = true), "normal" in s || (o.flatShading = true), t.material !== void 0) {
        var c = this.json.materials[t.material];
        c.name && (o.name = c.name);
        var f = c.pbrMetallicRoughness || {};
        if (Array.isArray(f.baseColorFactor)) {
          var d = f.baseColorFactor;
          o.color.fromArray(d), o.opacity = d[3];
        }
        f.baseColorTexture !== void 0 && r.push(this.createMaterialTexture(f.baseColorTexture).then(function(v) {
          o.map = v, e.disposeSet.add(v);
        })), c.doubleSided === true && (o.side = DoubleSide);
        var h = c.alphaMode || ALPHA_MODES.OPAQUE;
        h === ALPHA_MODES.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, h === ALPHA_MODES.MASK && (o.alphaTest = c.alphaCutoff !== void 0 ? c.alphaCutoff : 0.5)), c.occlusionTexture !== void 0 && (r.push(this.createMaterialTexture(c.occlusionTexture).then(function(v) {
          o.aoMap = v, e.disposeSet.add(v);
        })), c.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = c.occlusionTexture.strength));
      }
      return this.disposeSet.add(o), Promise.all(r).then(function() {
        return o;
      });
    }, n45.prototype.loadMaterialAsLineBasicMaterial = function(t) {
      var e = [], r = new LineBasicMaterial();
      if (r.color = new Color(1, 1, 1), r.opacity = 1, Object.keys(t.attributes).filter(function(c) {
        return ATTRIBUTES[c] === "color";
      }).length > 0 && (r.vertexColors = true), Object.keys(t.attributes).filter(function(c) {
        return ATTRIBUTES[c] === "tangent";
      }).length === 0 && (r.normalScale && (r.normalScale.y *= -1), r.clearcoatNormalScale && (r.clearcoatNormalScale.y *= -1)), t.material !== void 0) {
        var o = this.json.materials[t.material];
        o.name && (r.name = o.name);
        var s = o.pbrMetallicRoughness || {};
        if (Array.isArray(s.baseColorFactor)) {
          var u = s.baseColorFactor;
          r.color.fromArray(u), r.opacity = u[3];
        }
        o.doubleSided === true && (r.side = DoubleSide);
        var l = o.alphaMode || ALPHA_MODES.OPAQUE;
        l === ALPHA_MODES.BLEND ? (r.transparent = true, r.depthWrite = false) : (r.transparent = false, l === ALPHA_MODES.MASK && (r.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : 0.5));
      }
      return this.disposeSet.add(r), Promise.all(e).then(function() {
        return r;
      });
    }, n45.prototype.loadMaterialAsPointsMaterial = function(t) {
      var e = this, r = [], o = new PointsMaterial();
      if (o.color = new Color(1, 1, 1), o.opacity = 1, o.sizeAttenuation = false, Object.keys(t.attributes).filter(function(f) {
        return ATTRIBUTES[f] === "color";
      }).length > 0 && (o.vertexColors = true), Object.keys(t.attributes).filter(function(f) {
        return ATTRIBUTES[f] === "tangent";
      }).length === 0 && (o.normalScale && (o.normalScale.y *= -1), o.clearcoatNormalScale && (o.clearcoatNormalScale.y *= -1)), t.material !== void 0) {
        var s = this.json.materials[t.material];
        s.name && (o.name = s.name);
        var u = s.pbrMetallicRoughness || {};
        if (Array.isArray(u.baseColorFactor)) {
          var l = u.baseColorFactor;
          o.color.fromArray(l), o.opacity = l[3];
        }
        u.baseColorTexture !== void 0 && r.push(this.createMaterialTexture(u.baseColorTexture).then(function(f) {
          f.encoding = sRGBEncoding, o.map = f, e.disposeSet.add(f);
        })), s.doubleSided === true && (o.side = DoubleSide);
        var c = s.alphaMode || ALPHA_MODES.OPAQUE;
        c === ALPHA_MODES.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, c === ALPHA_MODES.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5));
      }
      return this.disposeSet.add(o), Promise.all(r).then(function() {
        return o;
      });
    }, n45.prototype.loadMaterial = function(t) {
      var e = this, r, o = (r = t.mode) !== null && r !== void 0 ? r : WEBGL_CONSTANTS.TRIANGLES, s = "material:" + this.createPrimitiveKey(t), u = this.cache.get(s);
      if (u)
        return u;
      for (var l = null, c = 0, f = values(this.extensions); c < f.length; c++) {
        var d = f[c];
        if (l = d.loadMaterial(t, this), l)
          break;
      }
      if (!l)
        if (o === WEBGL_CONSTANTS.TRIANGLES || o === WEBGL_CONSTANTS.TRIANGLE_STRIP || o === WEBGL_CONSTANTS.TRIANGLE_FAN)
          this.extensions.KHR_materials_unlit ? l = this.loadMaterialAsMeshBasicMaterial(t) : l = this.loadMaterialAsMeshStandardMaterial(t);
        else if (o === WEBGL_CONSTANTS.LINES || o === WEBGL_CONSTANTS.LINE_STRIP || o === WEBGL_CONSTANTS.LINE_LOOP)
          l = this.loadMaterialAsLineBasicMaterial(t);
        else if (o === WEBGL_CONSTANTS.POINTS)
          l = this.loadMaterialAsPointsMaterial(t);
        else
          throw new Error("glTF: Primitive mode unsupported: " + o);
      return l = l.then(function(h) {
        return Promise.all(values(e.extensions).map(function(v) {
          return v.extendMaterial(h, t, e);
        })).then(function() {
          return h;
        });
      }), this.cache.set(s, l), l;
    }, n45.prototype.loadTexture = function(t) {
      var e = this, r = "texture:" + t, o = this.cache.get(r);
      if (o)
        return o;
      for (var s = null, u = 0, l = values(this.extensions); u < l.length; u++) {
        var c = l[u];
        if (s = c.loadTexture(t, this), s)
          break;
      }
      if (!s) {
        var f = this.json.textures[t];
        s = this.loadImage(f.source).then(function(d) {
          var h = new Texture(d);
          h.needsUpdate = true, h.flipY = false, f.name && (h.name = f.name);
          var v = e.json.samplers || {}, A = v[f.sampler] || {};
          return h.magFilter = WEBGL_FILTERS[A.magFilter] || LinearFilter, h.minFilter = WEBGL_FILTERS[A.minFilter] || LinearMipmapLinearFilter, h.wrapS = WEBGL_WRAPPINGS[A.wrapS] || RepeatWrapping, h.wrapT = WEBGL_WRAPPINGS[A.wrapT] || RepeatWrapping, h.onUpdate = function() {
            d.close();
          }, h;
        });
      }
      return s = s.then(function(d) {
        return e.disposeSet.add(d), d;
      }), this.cache.set(r, s), s;
    }, n45.prototype.loadMesh = function(t) {
      for (var e = this, r = null, o = 0, s = values(this.extensions); o < s.length; o++) {
        var u = s[o];
        if (r = u.loadMesh(t, this), r)
          break;
      }
      if (!r) {
        var l = this.json.meshes[t], c = l.primitives, f = Promise.all(c.map(function(h) {
          return e.loadGeometry(h);
        })), d = Promise.all(c.map(function(h) {
          return e.loadMaterial(h);
        }));
        r = Promise.all([f, d]).then(function(h) {
          for (var v = h[0], A = h[1], g = [], p = 0; p < c.length; p++) {
            var y = c[p], m = v[p], E = A[p], b = y.mode || WEBGL_CONSTANTS.TRIANGLES, T = void 0;
            if (b === WEBGL_CONSTANTS.TRIANGLES || b === WEBGL_CONSTANTS.TRIANGLE_STRIP || b === WEBGL_CONSTANTS.TRIANGLE_FAN)
              if (b === WEBGL_CONSTANTS.TRIANGLE_STRIP ? m = e.toGeometryTrianglesDrawMode(m, TriangleStripDrawMode) : b === WEBGL_CONSTANTS.TRIANGLE_FAN && (m = e.toGeometryTrianglesDrawMode(m, TriangleFanDrawMode)), e.disposeSet.add(m), l.isSkinnedMesh) {
                var R = new SkinnedMesh(m, E);
                m.attributes.skinWeight.normalized || R.normalizeSkinWeights(), T = R;
              } else
                T = new Mesh(m, E);
            else if (b === WEBGL_CONSTANTS.POINTS)
              T = new Points(m, E);
            else if (b === WEBGL_CONSTANTS.LINES)
              T = new LineSegments(m, E);
            else if (b === WEBGL_CONSTANTS.LINE_STRIP)
              T = new Line(m, E);
            else if (b === WEBGL_CONSTANTS.LINE_LOOP)
              T = new LineLoop(m, E);
            else
              throw new Error("glTF: Primitive mode unsupported: " + b);
            if (Object.keys(m.morphAttributes).length > 0) {
              if (l.weights !== void 0)
                for (var S = 0, M = l.weights.length; S < M; S++)
                  T.morphTargetInfluences[S] = l.weights[S];
              if (l.extras && Array.isArray(l.extras.targetNames)) {
                var w = l.extras.targetNames;
                if (T.morphTargetInfluences.length === w.length) {
                  T.morphTargetDictionary = {};
                  for (var S = 0, M = w.length; S < M; S++)
                    T.morphTargetDictionary[w[S]] = S;
                } else
                  console.warn("glTF: Invalid extras.targetNames length. Ignoring names.");
              }
            }
            T.name = e.createUniqueName(l.name || "mesh_" + t), g.push(T);
          }
          if (g.length === 1)
            return g[0];
          for (var H = new Group(), L = 0, C = g; L < C.length; L++) {
            var T = C[L];
            H.add(T);
          }
          return H;
        });
      }
      return r;
    }, n45.prototype.loadNodeAttachments = function(t) {
      for (var e = [], r = 0, o = values(this.extensions); r < o.length; r++) {
        var s = o[r], u = s.loadNodeAttachments(t, this);
        u && e.push(u);
      }
      return e;
    }, n45.prototype.loadNode = function(t) {
      var e = "node:" + t, r = this.cache.get(e);
      if (r)
        return r;
      var o = this.json, s = o.nodes[t], u = s.name ? this.createUniqueName(s.name) : "", l = [];
      s.mesh !== void 0 && l.push(this.loadMesh(s.mesh).then(function(v) {
        if (s.weights !== void 0) {
          var A = s.weights;
          v.traverse(function(g) {
            if (g instanceof Mesh || g instanceof Line || g instanceof Points)
              for (var p = 0, y = A.length; p < y; p++)
                g.morphTargetInfluences[p] = A[p];
          });
        }
        return v;
      })), s.camera !== void 0 && l.push(this.loadCamera(s.camera));
      for (var c = this.loadNodeAttachments(t), f = 0, d = c; f < d.length; f++) {
        var h = d[f];
        l.push(h);
      }
      return Promise.all(l).then(function(v) {
        var A;
        if (s.isBone === true ? A = new Bone() : v.length > 1 ? A = new Group() : v.length === 1 ? A = v[0] : A = new Object3D(), A !== v[0])
          for (var g = 0, p = v.length; g < p; g++)
            A.add(v[g]);
        if (s.name && (A.name = u), s.matrix !== void 0) {
          var y = new Matrix4();
          y.fromArray(s.matrix), A.applyMatrix4(y);
        } else
          s.translation !== void 0 && A.position.fromArray(s.translation), s.rotation !== void 0 && A.quaternion.fromArray(s.rotation), s.scale !== void 0 && A.scale.fromArray(s.scale);
        return A;
      });
    }, n45.prototype.loadScene = function(t) {
      var e = this.json, r = e.scenes[t], o = new Group();
      r.name && (o.name = this.createUniqueName(r.name));
      for (var s = r.nodes || [], u = [], l = 0, c = s.length; l < c; l++)
        u.push(this.buildNodeHierarchy(s[l], o));
      return Promise.all(u).then(function() {
        return o;
      });
    }, n45.prototype.createMaterialTexture = function(t) {
      var e = this;
      return this.loadTexture(t.index).then(function(r) {
        for (var o = 0, s = values(e.extensions); o < s.length; o++) {
          var u = s[o], l = u.extendTexture(r, t, e);
          l && (r = l);
        }
        return e.textureSet.add(r), e.disposeSet.add(r), r;
      });
    }, n45.prototype.addGeometryPrimitiveAttributes = function(t, e) {
      var r = this, o = e.attributes, s = [], u = function(R) {
        var S = ATTRIBUTES[R] || R.toLowerCase();
        if (S in t.attributes)
          return "continue";
        s.push(l.loadAccessor(o[R]).then(function(M) {
          M && t.setAttribute(S, M);
        }));
      }, l = this;
      for (var c in o)
        u(c);
      e.indices !== void 0 && !t.index && s.push(this.loadAccessor(e.indices).then(function(R) {
        R && t.setIndex(R);
      }));
      var f = new Box3();
      if (o.POSITION !== void 0) {
        var d = this.json.accessors[o.POSITION], h = d.min, v = d.max;
        if (h !== void 0 && v !== void 0) {
          if (f.set(new Vector3(h[0], h[1], h[2]), new Vector3(v[0], v[1], v[2])), d.normalized) {
            var A = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[d.componentType]);
            f.min.multiplyScalar(A), f.max.multiplyScalar(A);
          }
        } else
          console.warn("glTF: Missing min/max properties for accessor POSITION.");
      }
      var g = e.targets;
      if (g !== void 0) {
        for (var p = new Vector3(), y = new Vector3(), m = 0, E = g.length; m < E; m++) {
          var b = g[m];
          if (b.POSITION !== void 0) {
            var d = this.json.accessors[b.POSITION], h = d.min, v = d.max;
            if (h !== void 0 && v !== void 0) {
              if (y.setX(Math.max(Math.abs(h[0]), Math.abs(v[0]))), y.setY(Math.max(Math.abs(h[1]), Math.abs(v[1]))), y.setZ(Math.max(Math.abs(h[2]), Math.abs(v[2]))), d.normalized) {
                var A = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[d.componentType]);
                y.multiplyScalar(A);
              }
              p.max(y);
            } else
              console.warn("glTF: Missing min/max properties for accessor POSITION.");
          }
        }
        f.expandByVector(p);
      }
      t.boundingBox = f;
      var T = new Sphere();
      return f.getCenter(T.center), T.radius = f.min.distanceTo(f.max) / 2, t.boundingSphere = T, Promise.all(s).then(function() {
        if (t.attributes.uv && !t.attributes.uv2 && r.options.copyUV2 && t.setAttribute("uv2", t.attributes.uv), e.targets) {
          for (var R = false, S = false, M = 0, w = e.targets.length; M < w; M++) {
            var H = e.targets[M];
            if (H.POSITION !== void 0 && (R = true), H.NORMAL !== void 0 && (S = true), R && S)
              break;
          }
          if (!R && !S)
            return t;
          var L = [];
          t.morphTargetsRelative = true;
          for (var C = function(I, _) {
            var O = e.targets[I];
            R ? L.push(r.loadAccessor(O.POSITION).then(function(P) {
              P && (t.morphAttributes.position = t.morphAttributes.position || [], t.morphAttributes.position[I] = P);
            })) : t.attributes.position && (t.morphAttributes.position = t.morphAttributes.position || [], t.morphAttributes.position[I] = t.attributes.position), S ? L.push(r.loadAccessor(O.NORMAL).then(function(P) {
              P && (t.morphAttributes.normal = t.morphAttributes.normal || [], t.morphAttributes.normal[I] = P);
            })) : t.attributes.normal && (t.morphAttributes.normal = t.morphAttributes.normal || [], t.morphAttributes.normal[I] = t.attributes.normal);
          }, M = 0, w = e.targets.length; M < w; M++)
            C(M, w);
          return Promise.all(L).then(function() {
            return t;
          });
        } else
          return t;
      });
    }, n45.prototype.buildNodeHierarchy = function(t, e) {
      var r = this, o = this.json.nodes[t];
      return this.loadNode(t).then(function(s) {
        if (o.skin === void 0)
          return s;
        var u;
        return r.loadSkin(o.skin).then(function(l) {
          u = l;
          for (var c = [], f = 0, d = u.joints.length; f < d; f++)
            c.push(r.loadNode(u.joints[f]));
          return Promise.all(c);
        }).then(function(l) {
          return s.traverse(function(c) {
            if (c instanceof SkinnedMesh) {
              for (var f = [], d = [], h = 0, v = l.length; h < v; h++) {
                var A = l[h];
                if (A instanceof Bone) {
                  f.push(A);
                  var g = new Matrix4();
                  u.inverseBindMatrices !== void 0 && g.fromArray(u.inverseBindMatrices.array, h * 16), d.push(g);
                } else
                  console.warn('glTF: Joint "%s" could not be found.', u.joints[h]);
              }
              c.bind(new Skeleton(f, d), c.matrixWorld);
            }
          }), s;
        });
      }).then(function(s) {
        e.add(s);
        var u = [];
        if (o.children)
          for (var l = o.children, c = 0, f = l.length; c < f; c++) {
            var d = l[c];
            u.push(r.buildNodeHierarchy(d, s));
          }
        return Promise.all(u).then(function() {
          return s;
        });
      });
    }, n45.prototype.createUniqueName = function(t) {
      for (var e = PropertyBinding.sanitizeNodeName(t || ""), r = e, o = 1; this.nodeNamesUsed[r]; ++o)
        r = e + "_" + o;
      return this.nodeNamesUsed[r] = true, r;
    }, n45.prototype.resolveResouce = function(t) {
      return /^[a-z]{0,8}\:/i.test(t) ? t : pathJoin(this.options.resourcePath, appendSearch(t, this.options.search));
    }, n45.prototype.toGeometryTrianglesDrawMode = function(t, e) {
      var r = t.getIndex();
      if (r === null) {
        var o = [], s = t.getAttribute("position");
        if (s !== void 0) {
          for (var u = 0; u < s.count; u++)
            o.push(u);
          t.setIndex(o), r = t.getIndex();
        }
      }
      if (r === null)
        return console.error("glTF: Undefined position attribute. Processing not possible."), t;
      var l = r.count - 2, c = [];
      if (e === TriangleFanDrawMode)
        for (var u = 1; u <= l; u++)
          c.push(r.getX(0)), c.push(r.getX(u)), c.push(r.getX(u + 1));
      else
        for (var u = 0; u < l; u++)
          u % 2 === 0 ? (c.push(r.getX(u)), c.push(r.getX(u + 1)), c.push(r.getX(u + 2))) : (c.push(r.getX(u + 2)), c.push(r.getX(u + 1)), c.push(r.getX(u)));
      c.length / 3 !== l && console.error("glTF: Unable to generate correct amount of triangles.");
      var f = t.clone();
      return f.setIndex(c), this.disposeSet.add(f), f;
    }, n45;
  }()
);
function getNormalizedComponentScale(n45) {
  switch (n45) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("glTF: Unsupported normalized accessor component type.");
  }
}
var BaseExtension = (
  /** @class */
  function() {
    function n45() {
    }
    return n45.prototype.markDefs = function(t) {
    }, n45.prototype.prepare = function(t) {
    }, n45.prototype.emitResult = function(t, e) {
    }, n45.prototype.createPrimitiveKey = function(t, e) {
    }, n45.prototype.extendTexture = function(t, e, r) {
      return null;
    }, n45.prototype.loadBuffer = function(t, e) {
      return null;
    }, n45.prototype.loadBufferView = function(t, e) {
      return null;
    }, n45.prototype.loadImage = function(t, e) {
      return null;
    }, n45.prototype.loadTexture = function(t, e) {
      return null;
    }, n45.prototype.loadGeometry = function(t, e) {
      return null;
    }, n45.prototype.loadMaterial = function(t, e) {
      return null;
    }, n45.prototype.extendMaterial = function(t, e, r) {
      return Promise.resolve();
    }, n45.prototype.loadMesh = function(t, e) {
      return null;
    }, n45.prototype.loadNodeAttachments = function(t, e) {
      return null;
    }, n45.prototype.loadCamera = function(t, e) {
      return null;
    }, n45.prototype.loadAnimation = function(t, e) {
      return null;
    }, n45;
  }()
);
var KHR_binary_glTF = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      return e.header = {
        magic: "",
        version: 0,
        length: 0
      }, e.content = "", e.body = null, e;
    }
    return t.getMagic = function(e) {
      return decodeText(new Uint8Array(e.slice(0, 4)));
    }, t.prototype.loadGlbBinary = function(e) {
      var r = new DataView(e, 0, t.HEADER_LENGTH);
      if (this.header = {
        magic: t.getMagic(e),
        version: r.getUint32(4, true),
        length: r.getUint32(8, true)
      }, this.header.magic !== t.HEADER_MAGIC)
        throw new Error("glTF:KHR_binary_glTF: Unsupported.");
      if (this.header.version < 2)
        throw new Error("glTF:KHR_binary_glTF: Legacy binary file detected.");
      for (var o = new DataView(e, t.HEADER_LENGTH), s = 0, u = null, l = null; s < o.byteLength; ) {
        var c = o.getUint32(s, true);
        if (s += 4, c !== 0) {
          var f = o.getUint32(s, true);
          if (s += 4, f === t.CHUNK_TYPES.JSON) {
            var d = new Uint8Array(e, t.HEADER_LENGTH + s, c);
            u = decodeText(d);
          } else if (f === t.CHUNK_TYPES.BIN) {
            var h = t.HEADER_LENGTH + s;
            l = e.slice(h, h + c);
          }
          s += c;
        }
      }
      if (u === null)
        throw new Error("glTF:KHR_binary_glTF: JSON content not found.");
      this.content = u, this.body = l;
    }, t.prototype.loadBuffer = function(e, r) {
      var o = r.json.buffers[e];
      return o.uri === void 0 && e === 0 && this.body ? Promise.resolve(this.body) : null;
    }, t.prototype.clear = function() {
      this.body = null, this.content = "";
    }, t.HEADER_MAGIC = "glTF", t.HEADER_LENGTH = 12, t.CHUNK_TYPES = {
      JSON: 1313821514,
      BIN: 5130562
    }, t;
  }(BaseExtension)
);
var defaultDecoderPath = "https://vr-public.realsee-cdn.cn/release/static/image/release/five/resource/draco/1.5.6/";
var defaultAttributeIDs = {
  position: "POSITION",
  normal: "NORMAL",
  color: "COLOR",
  uv: "TEX_COORD"
};
var defaultAttributeTypes = {
  position: "Float32Array",
  normal: "Float32Array",
  color: "Float32Array",
  uv: "Float32Array"
};
var Draco = (
  /** @class */
  function() {
    function n45() {
      this.decoderPath = defaultDecoderPath, this.decoderConfig = {}, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "";
    }
    return n45.prototype.setDecoderPath = function(t) {
      this.decoderPath = t;
    }, n45.prototype.setDecoderConfig = function(t) {
      return this.decoderConfig = t, this;
    }, n45.prototype.setWorkerLimit = function(t) {
      return this.workerLimit = t, this;
    }, n45.prototype.decodeDracoFile = function(t, e, r, o) {
      var s = {
        attributeIDs: r || defaultAttributeIDs,
        attributeTypes: o || defaultAttributeTypes,
        useUniqueIDs: !!r
      };
      this.decodeGeometry(t, s).then(e);
    }, n45.prototype.decodeGeometry = function(t, e) {
      var r = this;
      e === void 0 && (e = {
        attributeIDs: defaultAttributeIDs,
        attributeTypes: defaultAttributeTypes,
        useUniqueIDs: false
      });
      for (var o in e.attributeTypes) {
        var s = e.attributeTypes[o];
        s.BYTES_PER_ELEMENT !== void 0 && (e.attributeTypes[o] = s.name);
      }
      var u, l = this.workerNextTaskID++, c = t.byteLength, f = this._getWorker(l, c).then(function(d) {
        return u = d, new Promise(function(h, v) {
          u._callbacks[l] = { resolve: h, reject: v }, u.postMessage({ type: "decode", id: l, taskConfig: e, buffer: t }, [t]);
        });
      }).then(function(d) {
        return r._createGeometry(d.geometry);
      });
      return f.catch(function() {
        return true;
      }).then(function() {
        u && l && r._releaseTask(u, l);
      }), f;
    }, n45.prototype._createGeometry = function(t) {
      var e = new BufferGeometry();
      t.index && e.setIndex(new BufferAttribute(t.index.array, 1));
      for (var r = 0; r < t.attributes.length; r++) {
        var o = t.attributes[r], s = o.name, u = o.array, l = o.itemSize, c = !(u instanceof Float32Array || u instanceof Float64Array);
        e.setAttribute(s, new BufferAttribute(u, l, c));
      }
      return e;
    }, n45.prototype._initDecoder = function() {
      var t = this;
      if (this.decoderPending)
        return this.decoderPending;
      var e = typeof WebAssembly != "object" || this.decoderConfig.type === "js";
      if (e) {
        var r = ajax(this.decoderPath + "draco_decoder.js", {
          responseType: "text"
        }).then(function(s) {
          return s.body;
        });
        this.decoderPending = r.then(function(s) {
          var u = [
            "/* draco decoder */",
            s,
            "",
            "/* worker */",
            DRACOWorker
          ].join(`
`);
          t.workerSourceURL = URL.createObjectURL(new Blob([u]));
        });
      } else {
        var r = ajax(this.decoderPath + "draco_wasm_wrapper.js", {
          responseType: "text"
        }).then(function(u) {
          return u.body;
        }), o = ajax(this.decoderPath + "draco_decoder.wasm", {
          responseType: "arraybuffer"
        }).then(function(u) {
          return u.body;
        });
        this.decoderPending = Promise.all([r, o]).then(function(u) {
          var l = u[0], c = u[1];
          t.decoderConfig.wasmBinary = c;
          var f = [
            "/* draco decoder */",
            l,
            "",
            "/* worker */",
            DRACOWorker
          ].join(`
`);
          t.workerSourceURL = URL.createObjectURL(new Blob([f]));
        });
      }
      return this.decoderPending;
    }, n45.prototype._getWorker = function(t, e) {
      var r = this;
      return this._initDecoder().then(function() {
        if (r.workerPool.length < r.workerLimit) {
          var o = new Worker(r.workerSourceURL);
          o._callbacks = {}, o._taskCosts = {}, o._taskLoad = 0, o.postMessage({ type: "init", decoderConfig: r.decoderConfig }), o.onmessage = function(u) {
            var l = u.data;
            switch (l.type) {
              case "decode":
                o._callbacks[l.id].resolve(l);
                break;
              case "error":
                o._callbacks[l.id].reject(l);
                break;
              default:
                console.error('DRACO: Unexpected message, "' + l.type + '"');
            }
          }, r.workerPool.push(o);
        } else
          r.workerPool.sort(function(u, l) {
            return u._taskLoad > l._taskLoad ? -1 : 1;
          });
        var s = r.workerPool[r.workerPool.length - 1];
        return s._taskCosts[t] = e, s._taskLoad += e, s;
      });
    }, n45.prototype._releaseTask = function(t, e) {
      t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e];
    }, n45.prototype.dispose = function() {
      for (var t = 0; t < this.workerPool.length; ++t)
        this.workerPool[t].terminate();
      return this.workerPool.length = 0, this;
    }, n45;
  }()
);
var draco = new Draco();
var DRACOWorker = `
  let decoderConfig;
  let decoderPending;

  onmessage = function ( e ) {

    const message = e.data;

    switch ( message.type ) {

      case 'init':
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise( function ( resolve/*, reject*/ ) {

          decoderConfig.onModuleLoaded = function ( draco ) {

            // Module is Promise-like. Wrap before resolving to avoid loop.
            resolve( { draco: draco } );

          };

          DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

        } );
        break;

      case 'decode':
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then( ( module ) => {

          const draco = module.draco;
          const decoder = new draco.Decoder();
          const decoderBuffer = new draco.DecoderBuffer();
          decoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );

          try {

            const geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );

            const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

            if ( geometry.index ) buffers.push( geometry.index.array.buffer );

            self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

          } catch ( error ) {

            console.error( error );

            self.postMessage( { type: 'error', id: message.id, error: error.message } );

          } finally {

            draco.destroy( decoderBuffer );
            draco.destroy( decoder );

          }

        } );
        break;

    }

  };

  function decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {

    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;

    let dracoGeometry;
    let decodingStatus;

    const geometryType = decoder.GetEncodedGeometryType( decoderBuffer );

    if ( geometryType === draco.TRIANGULAR_MESH ) {

      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );

    } else if ( geometryType === draco.POINT_CLOUD ) {

      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );

    } else {

      throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

    }

    if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

      throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

    }

    const geometry = { index: null, attributes: [] };

    // Gather all vertex attributes.
    for ( const attributeName in attributeIDs ) {

      const attributeType = self[ attributeTypes[ attributeName ] ];

      let attribute;
      let attributeID;

      // A Draco file may be created with default vertex attributes, whose attribute IDs
      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
      // a Draco file may contain a custom set of attributes, identified by known unique
      // IDs. glTF files always do the latter, and .drc files typically do the former.
      if ( taskConfig.useUniqueIDs ) {

        attributeID = attributeIDs[ attributeName ];
        attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

      } else {

        attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

        if ( attributeID === - 1 ) continue;

        attribute = decoder.GetAttribute( dracoGeometry, attributeID );

      }

      geometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );

    }

    // Add index.
    if ( geometryType === draco.TRIANGULAR_MESH ) {

      geometry.index = decodeIndex( draco, decoder, dracoGeometry );

    }

    draco.destroy( dracoGeometry );

    return geometry;

  }

  function decodeIndex( draco, decoder, dracoGeometry ) {

    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;

    const ptr = draco._malloc( byteLength );
    decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
    const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
    draco._free( ptr );

    return { array: index, itemSize: 1 };

  }

  function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType( draco, attributeType );

    const ptr = draco._malloc( byteLength );
    decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
    const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
    draco._free( ptr );

    return {
      name: attributeName,
      array: array,
      itemSize: numComponents
    };

  }

  function getDracoDataType( draco, attributeType ) {

    switch ( attributeType ) {

      case Float32Array: return draco.DT_FLOAT32;
      case Int8Array: return draco.DT_INT8;
      case Int16Array: return draco.DT_INT16;
      case Int32Array: return draco.DT_INT32;
      case Uint8Array: return draco.DT_UINT8;
      case Uint16Array: return draco.DT_UINT16;
      case Uint32Array: return draco.DT_UINT32;

    }

  }
`;
var EXTENSION_NAME$6 = "KHR_draco_mesh_compression";
var KHR_draco_mesh_compression = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.loadGeometry = function(e, r) {
      return e.extensions && e.extensions[EXTENSION_NAME$6] ? this.decodePrimitive(e, r).then(function(o) {
        return r.addGeometryPrimitiveAttributes(o, e);
      }) : null;
    }, t.prototype.decodePrimitive = function(e, r) {
      var o = r.json, s = e.extensions[EXTENSION_NAME$6].bufferView, u = e.extensions[EXTENSION_NAME$6].attributes, l = {}, c = {}, f = {};
      for (var d in u) {
        var h = ATTRIBUTES[d] || d.toLowerCase();
        l[h] = u[d];
      }
      for (var d in e.attributes) {
        var h = ATTRIBUTES[d] || d.toLowerCase();
        if (u[d] !== void 0) {
          var v = o.accessors[e.attributes[d]], A = WEBGL_COMPONENT_TYPES[v.componentType];
          f[h] = A, c[h] = v.normalized === true;
        }
      }
      return r.loadBufferView(s).then(function(g) {
        return new Promise(function(p) {
          draco.decodeDracoFile(g, function(y) {
            for (var m in y.attributes) {
              var E = y.attributes[m], b = c[m];
              b !== void 0 && (E.normalized = b);
            }
            p(y);
          }, l, f);
        });
      });
    }, t;
  }(BaseExtension)
);
var defaultTranscoderPath = "https://vr-public.realsee-cdn.cn/release/static/image/release/five/resource/basis/1.16/";
var KTX2TransferSRGB = 2;
var KTX2_ALPHA_PREMULTIPLIED = 1;
var WorkerPool = (
  /** @class */
  function() {
    function n45(t) {
      this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0, this.workerCreator = null;
    }
    return n45.prototype._initWorker = function(t) {
      if (this.workerCreator && !this.workers[t]) {
        var e = this.workerCreator();
        e.addEventListener("message", this._onMessage.bind(this, t)), this.workers[t] = e;
      }
    }, n45.prototype._getIdleWorker = function() {
      for (var t = 0; t < this.pool; t++)
        if (!(this.workerStatus & 1 << t))
          return t;
      return -1;
    }, n45.prototype._onMessage = function(t, e) {
      var r = this.workersResolve[t];
      if (r && r(e), this.queue.length) {
        var o = this.queue.shift(), s = o.resolve, u = o.msg, l = o.transfer;
        this.workersResolve[t] = s, this.workers[t].postMessage(u, l);
      } else
        this.workerStatus ^= 1 << t;
    }, n45.prototype.setWorkerCreator = function(t) {
      this.workerCreator = t;
    }, n45.prototype.setWorkerLimit = function(t) {
      this.pool = t;
    }, n45.prototype.postMessage = function(t, e) {
      var r = this;
      return new Promise(function(o) {
        var s = r._getIdleWorker();
        s !== -1 ? (r._initWorker(s), r.workerStatus |= 1 << s, r.workersResolve[s] = o, r.workers[s].postMessage(t, e)) : r.queue.push({ resolve: o, msg: t, transfer: e });
      });
    }, n45.prototype.dispose = function() {
      this.workers.forEach(function(t) {
        return t.terminate();
      }), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }, n45;
  }()
);
var KTX2 = (
  /** @class */
  function() {
    function n45() {
      this.transcoderPath = defaultTranscoderPath, this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new WorkerPool(4), this.workerSourceURL = "", this.workerConfig = null;
    }
    return n45.prototype.setTranscoderPath = function(t) {
      this.transcoderPath = t;
    }, n45.prototype.detectSupport = function(t) {
      if (!this.workerConfig) {
        var e = console.warn;
        console.warn = function() {
        }, this.workerConfig = {
          astcSupported: !!t.extensions.get("WEBGL_compressed_texture_astc"),
          etc1Supported: !!t.extensions.get("WEBGL_compressed_texture_etc1"),
          etc2Supported: !!t.extensions.get("WEBGL_compressed_texture_etc"),
          dxtSupported: !!t.extensions.get("WEBGL_compressed_texture_s3tc"),
          bptcSupported: !!t.extensions.get("EXT_texture_compression_bptc"),
          pvrtcSupported: !!t.extensions.get("WEBGL_compressed_texture_pvrtc") || !!t.extensions.get("WEBKIT_WEBGL_compressed_texture_pvrtc")
        }, console.warn = e;
      }
      return this;
    }, n45.prototype.init = function() {
      var t = this;
      if (!this.transcoderPending) {
        var e = ajax(this.transcoderPath + "basis_transcoder.js", {
          responseType: "text"
        }).then(function(o) {
          return o.body;
        }), r = ajax(this.transcoderPath + "basis_transcoder.wasm", {
          responseType: "arraybuffer"
        }).then(function(o) {
          return o.body;
        });
        this.transcoderPending = Promise.all([e, r]).then(function(o) {
          var s = o[0], u = o[1], l = [
            "/* constants */",
            "let _EngineFormat = " + JSON.stringify(EngineFormat),
            "let _TranscoderFormat = " + JSON.stringify(TranscoderFormat),
            "let _BasisFormat = " + JSON.stringify(BasisFormat),
            "/* basis_transcoder.js */",
            s,
            "/* worker */",
            BasisWorker
          ].join(`
`);
          t.workerSourceURL = URL.createObjectURL(new Blob([l])), t.transcoderBinary = u, t.workerPool.setWorkerCreator(function() {
            var c = new Worker(t.workerSourceURL), f = t.transcoderBinary.slice(0);
            return c.postMessage({ type: "init", config: t.workerConfig, transcoderBinary: f }, [f]), c;
          });
        });
      }
      return this.transcoderPending;
    }, n45.prototype.parse = function(t) {
      return this._createTexture([t]);
    }, n45.prototype._createTextureFrom = function(t) {
      var e = t.mipmaps, r = t.width, o = t.height, s = t.format, u = t.type, l = t.error, c = t.dfdTransferFn, f = t.dfdFlags;
      if (u === "error")
        return Promise.reject(l);
      var d = new CompressedTexture(e, r, o, s, UnsignedByteType);
      return d.minFilter = e.length === 1 ? LinearFilter : LinearMipmapLinearFilter, d.magFilter = LinearFilter, d.generateMipmaps = false, d.needsUpdate = true, d.encoding = c === KTX2TransferSRGB ? sRGBEncoding : LinearEncoding, d.premultiplyAlpha = !!(f & KTX2_ALPHA_PREMULTIPLIED), Promise.resolve(d);
    }, n45.prototype._createTexture = function(t) {
      var e = this, r = this.init().then(function() {
        return e.workerPool.postMessage({ type: "transcode", buffers: t }, t);
      }).then(function(o) {
        return e._createTextureFrom(o.data);
      });
      return r;
    }, n45.prototype.dispose = function() {
      return URL.revokeObjectURL(this.workerSourceURL), this.workerPool.dispose(), this;
    }, n45;
  }()
);
var ktx2 = new KTX2();
var BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
var TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
var EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
var BasisWorker = `

  let config;
  let transcoderPending;
  let BasisModule;

  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef
  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef
  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef

  self.addEventListener( 'message', function ( e ) {

    const message = e.data;

    switch ( message.type ) {

      case 'init':
        config = message.config;
        init( message.transcoderBinary );
        break;

      case 'transcode':
        transcoderPending.then( () => {

          try {

            const { width, height, hasAlpha, mipmaps, format, dfdTransferFn, dfdFlags } = transcode( message.buffers[ 0 ] );

            const buffers = [];

            for ( let i = 0; i < mipmaps.length; ++ i ) {

              buffers.push( mipmaps[ i ].data.buffer );

            }

            self.postMessage( { type: 'transcode', id: message.id, width, height, hasAlpha, mipmaps, format, dfdTransferFn, dfdFlags }, buffers );

          } catch ( error ) {

            console.error( error );

            self.postMessage( { type: 'error', id: message.id, error: error.message } );

          }

        } );
        break;

    }

  } );

  function init( wasmBinary ) {

    transcoderPending = new Promise( ( resolve ) => {

      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS( BasisModule ); // eslint-disable-line no-undef

    } ).then( () => {

      BasisModule.initializeBasis();

      if ( BasisModule.KTX2File === undefined ) {

        console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );

      }

    } );

  }

  function transcode( buffer ) {

    const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );

    function cleanup() {

      ktx2File.close();
      ktx2File.delete();

    }

    if ( ! ktx2File.isValid() ) {

      cleanup();
      throw new Error( 'THREE.KTX2Loader:	Invalid or unsupported .ktx2 file' );

    }

    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const levels = ktx2File.getLevels();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();

    const { transcoderFormat, engineFormat } = getTranscoderFormat( basisFormat, width, height, hasAlpha );

    if ( ! width || ! height || ! levels ) {

      cleanup();
      throw new Error( 'THREE.KTX2Loader:	Invalid texture' );

    }

    if ( ! ktx2File.startTranscoding() ) {

      cleanup();
      throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );

    }

    const mipmaps = [];

    for ( let mip = 0; mip < levels; mip ++ ) {

      const levelInfo = ktx2File.getImageLevelInfo( mip, 0, 0 );
      const mipWidth = levelInfo.origWidth;
      const mipHeight = levelInfo.origHeight;
      const dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, 0, 0, transcoderFormat ) );

      const status = ktx2File.transcodeImage(
        dst,
        mip,
        0,
        0,
        transcoderFormat,
        0,
        - 1,
        - 1,
      );

      if ( ! status ) {

        cleanup();
        throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );

      }

      mipmaps.push( { data: dst, width: mipWidth, height: mipHeight } );

    }

    cleanup();

    return { width, height, hasAlpha, mipmaps, format: engineFormat, dfdTransferFn, dfdFlags };

  }

  //

  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),
  // device capabilities, and texture dimensions. The list below ranks the formats separately
  // for ETC1S and UASTC.
  //
  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at
  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently
  // chooses RGBA32 only as a last resort and does not expose that option to the caller.
  const FORMAT_OPTIONS = [
    {
      if: 'astcSupported',
      basisFormat: [ BasisFormat.UASTC_4x4 ],
      transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],
      engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false,
    },
    {
      if: 'bptcSupported',
      basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
      transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],
      engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false,
    },
    {
      if: 'dxtSupported',
      basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
      transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],
      engineFormat: [ EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false,
    },
    {
      if: 'etc2Supported',
      basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
      transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],
      engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false,
    },
    {
      if: 'etc1Supported',
      basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
      transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC1 ],
      engineFormat: [ EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format ],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false,
    },
    {
      if: 'pvrtcSupported',
      basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
      transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],
      engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true,
    },
  ];

  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {

    return a.priorityETC1S - b.priorityETC1S;

  } );
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {

    return a.priorityUASTC - b.priorityUASTC;

  } );

  function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {

    let transcoderFormat;
    let engineFormat;

    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;

    for ( let i = 0; i < options.length; i ++ ) {

      const opt = options[ i ];

      if ( ! config[ opt.if ] ) continue;
      if ( ! opt.basisFormat.includes( basisFormat ) ) continue;
      if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;

      transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];
      engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];

      return { transcoderFormat, engineFormat };

    }

    console.warn( 'KTX2: No suitable compressed texture format found. Decoding to RGBA32.' );

    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;

    return { transcoderFormat, engineFormat };

  }

  function isPowerOfTwo( value ) {

    if ( value <= 2 ) return true;

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }
`;
var EXTENSION_NAME$5 = "KHR_texture_basisu";
var KHR_texture_basisu = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.loadTexture = function(e, r) {
      var o = r.json.textures[e];
      if (!o.extensions || !o.extensions[EXTENSION_NAME$5])
        return null;
      var s = o.extensions[EXTENSION_NAME$5], u = r.json.images[s.source], l = null;
      if (u.bufferView !== void 0)
        l = r.loadBufferView(u.bufferView).then(function(d) {
          return ktx2.parse(d);
        });
      else if (u.uri)
        l = r.options.fetcher.ajax(r.resolveResouce(u.uri), {
          responseType: "arraybuffer"
        }).then(function(d) {
          return ktx2.parse(d.body);
        });
      else
        throw new Error("glTF: Invalid image defs.");
      var c = r.json.samplers || {}, f = c[o.sampler] || {};
      return l = l.then(function(d) {
        return d.magFilter = LinearFilter, d.minFilter = LinearFilter, d.wrapS = WEBGL_WRAPPINGS[f.wrapS] || RepeatWrapping, d.wrapT = WEBGL_WRAPPINGS[f.wrapT] || RepeatWrapping, d;
      }), l;
    }, t;
  }(BaseExtension)
);
var EXTENSION_NAME$4 = "KHR_texture_transform";
var KHR_texture_transform = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.extendTexture = function(e, r, o) {
      var s = r.extensions !== void 0 ? r.extensions[EXTENSION_NAME$4] : void 0;
      return s ? (s.texCoord !== void 0 && console.warn('glTF: Custom UV sets in "' + EXTENSION_NAME$4 + '" extension not yet supported.'), s.offset === void 0 && s.rotation === void 0 && s.scale === void 0 || (e = e.clone(), e.needsUpdate = true, s.offset !== void 0 && e.offset.fromArray(s.offset), s.rotation !== void 0 && (e.rotation = s.rotation), s.scale !== void 0 && e.repeat.fromArray(s.scale)), e) : null;
    }, t;
  }(BaseExtension)
);
var KHR_mesh_quantization = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t;
  }(BaseExtension)
);
var KHR_materials_unlit = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t;
  }(BaseExtension)
);
var meshoptDecoder = function() {
  var n45 = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:78Yqdbk:qzezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhlaicefhodnadTmbalc;WFbGglcjdalcjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfglcl4cifcd4hxdndndndnalc9WGgmTmbcbhPcehsawcjdfhzaohHinaraH9Rax6midnaraHaxfgo9RcK6mbczhlinalgic9Wfglawcj;cbffhOdndndndndnaHalco4fRbbalci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOaoRblaoRbbgAco4glalciSgCE86bbawcj;cbfaifglcGfaoclfaCfgORbbaAcl4ciGgCaCciSgCE86bbalcVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbalc7faOaCfgORbbaAciGgAaAciSgAE86bbalctfaOaAfgARbbaoRbegOco4gCaCciSgCE86bbalc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc93faAaCfgARbbaOciGgOaOciSgOE86bbalc94faAaOfgARbbaoRbdgOco4gCaCciSgCE86bbalc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc97faAaCfgARbbaOciGgOaOciSgOE86bbalc98faAaOfgORbbaoRbigoco4gAaAciSgAE86bbalc99faOaAfgORbbaocl4ciGgAaAciSgAE86bbalc9:faOaAfgORbbaocd4ciGgAaAciSgAE86bbalcufaOaAfglRbbaociGgoaociSgoE86bbalaofhoxdkaOaoRbwaoRbbgAcl4glalcsSgCE86bbawcj;cbfaifglcGfaocwfaCfgORbbaAcsGgAaAcsSgAE86bbalcVfaOaAfgORbbaoRbegAcl4gCaCcsSgCE86bbalc7faOaCfgORbbaAcsGgAaAcsSgAE86bbalctfaOaAfgORbbaoRbdgAcl4gCaCcsSgCE86bbalc91faOaCfgORbbaAcsGgAaAcsSgAE86bbalc4faOaAfgORbbaoRbigAcl4gCaCcsSgCE86bbalc93faOaCfgORbbaAcsGgAaAcsSgAE86bbalc94faOaAfgORbbaoRblgAcl4gCaCcsSgCE86bbalc95faOaCfgORbbaAcsGgAaAcsSgAE86bbalc96faOaAfgORbbaoRbvgAcl4gCaCcsSgCE86bbalc97faOaCfgORbbaAcsGgAaAcsSgAE86bbalc98faOaAfgORbbaoRbogAcl4gCaCcsSgCE86bbalc99faOaCfgORbbaAcsGgAaAcsSgAE86bbalc9:faOaAfgORbbaoRbrgocl4gAaAcsSgAE86bbalcufaOaAfglRbbaocsGgoaocsSgoE86bbalaofhoxekaOao8Pbb83bbaOcwfaocwf8Pbb83bbaoczfhokdnaiam9pmbaiczfhlarao9RcL0mekkaiam6miaoTmidnakTmbawaPfRbbhOawcj;cbfhlazhiakhHinaialRbbgAce4cbaAceG9R7aOfgO86bbaiadfhialcefhlaHcufgHmbkkazcefhzaPcefgPad6hsaohHaPad9hmexvkkcbhoasceGmdxikaoaxad2fhPdnakTmbcbhmcehsawcjdfhCinarao9Rax6miaoTmdaoaxfhoawamfRbbhOawcj;cbfhlaChiakhHinaialRbbgAce4cbaAceG9R7aOfgO86bbaiadfhialcefhlaHcufgHmbkaCcefhCamcefgmad6hsamad9hmbkaPhoxikcbhlcehsinarao9Rax6mdaoTmeaoaxfhoalcefglad6hsadal9hmbkaPhoxdkcbhoasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqaombkc9:hoxekcbc99arao9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;xzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhrcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgDc;Ve0mbavc;abfalaDcu7gPcl4fcsGcitfgsydlhzasydbhHdnaDcsGgDak9pmbavaiaPfcsGcdtfydbaxaDEhsaDThDdndnadcd9hmbabarcetfgPaH87ebaPcdfaz87ebaPclfas87ebxekabarcdtfgPaHBdbaPclfazBdbaPcwfasBdbkaxaDfhxavc;abfalcitfgPasBdbaPazBdlavaicdtfasBdbavc;abfalcefcsGglcitfgPaHBdbaPasBdlaiaDfhialcefhlxdkdndnaDcsSmbamaDfaDc987fcefhmxekaocefhDao8SbbgscFeGhPdndnascu9mmbaDhoxekaocvfhoaPcFbGhPcrhsdninaD8SbbgOcFbGastaPVhPaOcu9kmeaDcefhDascrfgsc8J9hmbxdkkaDcefhokaPce4cbaPceG9R7amfhmkdndnadcd9hmbabarcetfgDaH87ebaDcdfaz87ebaDclfam87ebxekabarcdtfgDaHBdbaDclfazBdbaDcwfamBdbkavc;abfalcitfgDamBdbaDazBdlavaicdtfamBdbavc;abfalcefcsGglcitfgDaHBdbaDamBdlaicefhialcefhlxekdnaDcpe0mbaxcefgOavaiaqaDcsGfRbbgscl49RcsGcdtfydbascz6gPEhDavaias9RcsGcdtfydbaOaPfgzascsGgOEhsaOThOdndnadcd9hmbabarcetfgHax87ebaHcdfaD87ebaHclfas87ebxekabarcdtfgHaxBdbaHclfaDBdbaHcwfasBdbkavaicdtfaxBdbavc;abfalcitfgHaDBdbaHaxBdlavaicefgicsGcdtfaDBdbavc;abfalcefcsGcitfgHasBdbaHaDBdlavaiaPfcsGgicdtfasBdbavc;abfalcdfcsGglcitfgDaxBdbaDasBdlalcefhlaiaOfhiazaOfhxxekaxcbaoRbbgHEgAaDc;:eSgDfhzaHcsGhCaHcl4hXdndnaHcs0mbazcefhOxekazhOavaiaX9RcsGcdtfydbhzkdndnaCmbaOcefhxxekaOhxavaiaH9RcsGcdtfydbhOkdndnaDTmbaocefhDxekaocdfhDao8SbegPcFeGhsdnaPcu9kmbaocofhAascFbGhscrhodninaD8SbbgPcFbGaotasVhsaPcu9kmeaDcefhDaocrfgoc8J9hmbkaAhDxekaDcefhDkasce4cbasceG9R7amfgmhAkdndnaXcsSmbaDhsxekaDcefhsaD8SbbgocFeGhPdnaocu9kmbaDcvfhzaPcFbGhPcrhodninas8SbbgDcFbGaotaPVhPaDcu9kmeascefhsaocrfgoc8J9hmbkazhsxekascefhskaPce4cbaPceG9R7amfgmhzkdndnaCcsSmbashoxekascefhoas8SbbgDcFeGhPdnaDcu9kmbascvfhOaPcFbGhPcrhDdninao8SbbgscFbGaDtaPVhPascu9kmeaocefhoaDcrfgDc8J9hmbkaOhoxekaocefhokaPce4cbaPceG9R7amfgmhOkdndnadcd9hmbabarcetfgDaA87ebaDcdfaz87ebaDclfaO87ebxekabarcdtfgDaABdbaDclfazBdbaDcwfaOBdbkavc;abfalcitfgDazBdbaDaABdlavaicdtfaABdbavc;abfalcefcsGcitfgDaOBdbaDazBdlavaicefgicsGcdtfazBdbavc;abfalcdfcsGcitfgDaABdbaDaOBdlavaiaHcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiarcifgrae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2gdTmbinababydbgecwtcw91:Yaece91cjjj;8ifcjjj98G::NUdbabclfhbadcufgdmbkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", t = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;a9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;d8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgAclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;tzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhrcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgDc;Ve0mbavc;abfalaDcu7gPcl4fcsGcitfgsydlhzasydbhHdnaDcsGgDak9pmbavaiaPfcsGcdtfydbaxaDEhsaDThDdndnadcd9hmbabarcetfgPaH87ebaPcdfaz87ebaPclfas87ebxekabarcdtfgPaHBdbaPclfazBdbaPcwfasBdbkaxaDfhxavc;abfalcitfgPasBdbaPazBdlavaicdtfasBdbavc;abfalcefcsGglcitfgPaHBdbaPasBdlaiaDfhialcefhlxdkdndnaDcsSmbamaDfaDc987fcefhmxekaocefhDao8SbbgscFeGhPdndnascu9mmbaDhoxekaocvfhoaPcFbGhPcrhsdninaD8SbbgOcFbGastaPVhPaOcu9kmeaDcefhDascrfgsc8J9hmbxdkkaDcefhokaPce4cbaPceG9R7amfhmkdndnadcd9hmbabarcetfgDaH87ebaDcdfaz87ebaDclfam87ebxekabarcdtfgDaHBdbaDclfazBdbaDcwfamBdbkavc;abfalcitfgDamBdbaDazBdlavaicdtfamBdbavc;abfalcefcsGglcitfgDaHBdbaDamBdlaicefhialcefhlxekdnaDcpe0mbaxcefgOavaiaqaDcsGfRbbgscl49RcsGcdtfydbascz6gPEhDavaias9RcsGcdtfydbaOaPfgzascsGgOEhsaOThOdndnadcd9hmbabarcetfgHax87ebaHcdfaD87ebaHclfas87ebxekabarcdtfgHaxBdbaHclfaDBdbaHcwfasBdbkavaicdtfaxBdbavc;abfalcitfgHaDBdbaHaxBdlavaicefgicsGcdtfaDBdbavc;abfalcefcsGcitfgHasBdbaHaDBdlavaiaPfcsGgicdtfasBdbavc;abfalcdfcsGglcitfgDaxBdbaDasBdlalcefhlaiaOfhiazaOfhxxekaxcbaoRbbgHEgAaDc;:eSgDfhzaHcsGhCaHcl4hXdndnaHcs0mbazcefhOxekazhOavaiaX9RcsGcdtfydbhzkdndnaCmbaOcefhxxekaOhxavaiaH9RcsGcdtfydbhOkdndnaDTmbaocefhDxekaocdfhDao8SbegPcFeGhsdnaPcu9kmbaocofhAascFbGhscrhodninaD8SbbgPcFbGaotasVhsaPcu9kmeaDcefhDaocrfgoc8J9hmbkaAhDxekaDcefhDkasce4cbasceG9R7amfgmhAkdndnaXcsSmbaDhsxekaDcefhsaD8SbbgocFeGhPdnaocu9kmbaDcvfhzaPcFbGhPcrhodninas8SbbgDcFbGaotaPVhPaDcu9kmeascefhsaocrfgoc8J9hmbkazhsxekascefhskaPce4cbaPceG9R7amfgmhzkdndnaCcsSmbashoxekascefhoas8SbbgDcFeGhPdnaDcu9kmbascvfhOaPcFbGhPcrhDdninao8SbbgscFbGaDtaPVhPascu9kmeaocefhoaDcrfgDc8J9hmbkaOhoxekaocefhokaPce4cbaPceG9R7amfgmhOkdndnadcd9hmbabarcetfgDaA87ebaDcdfaz87ebaDclfaO87ebxekabarcdtfgDaABdbaDclfazBdbaDcwfaOBdbkavc;abfalcitfgDazBdbaDaABdlavaicdtfaABdbavc;abfalcefcsGcitfgDaOBdbaDazBdlavaicefgicsGcdtfazBdbavc;abfalcdfcsGcitfgDaABdbaDaOBdlavaiaHcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiarcifgrae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:wPliuo97eue978Jjjjjbca9Rhiaec98Ghldndnadcl9hmbdnalTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaipxbbbbbbbbbbbbbbbbgqpklbaiabalcdtfgdaeciGglcdtgv;8qbbdnalTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDaqp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkadaiav;8qbbskdnalTmbcbhvabhdinadczfgxaxpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgval6mbkkalae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabalcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbheabhdinadadpbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbadczfhdaeclfgeav6mbkkdnaval9pmbaialciGgecdtgdVcbc;abad9R;8kbaiabavcdtfgvad;8qbbdnaeTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiad;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), r = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: false
    };
  var o = WebAssembly.validate(e) ? t : n45, s, u = WebAssembly.instantiate(l(o), {}).then(function(m) {
    s = m.instance, s.exports.__wasm_call_ctors();
  });
  function l(m) {
    for (var E = new Uint8Array(m.length), b = 0; b < m.length; ++b) {
      var T = m.charCodeAt(b);
      E[b] = T > 96 ? T - 97 : T > 64 ? T - 39 : T + 4;
    }
    for (var R = 0, b = 0; b < m.length; ++b)
      E[R++] = E[b] < 60 ? r[E[b]] : (E[b] - 60) * 64 + E[++b];
    return E.buffer.slice(0, R);
  }
  function c(m, E, b, T, R, S) {
    var M = s.exports.sbrk, w = b + 3 & -4, H = M(w * T), L = M(R.length), C = new Uint8Array(s.exports.memory.buffer);
    C.set(R, L);
    var I = m(H, b, T, L, R.length);
    if (I == 0 && S && S(H, w, T), E.set(C.subarray(H, H + b * T)), M(H - M(0)), I != 0)
      throw new Error("Malformed buffer data: " + I);
  }
  var f = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, d = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, h = [], v = 0;
  function A(m) {
    var E = {
      object: new Worker(m),
      pending: 0,
      requests: {}
    };
    return E.object.onmessage = function(b) {
      var T = b.data;
      E.pending -= T.count, E.requests[T.id][T.action](T.value), delete E.requests[T.id];
    }, E;
  }
  function g(m) {
    for (var E = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(l(o)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + c.toString() + y.toString(), b = new Blob([E], { type: "text/javascript" }), T = URL.createObjectURL(b), R = 0; R < m; ++R)
      h[R] = A(T);
    URL.revokeObjectURL(T);
  }
  function p(m, E, b, T, R) {
    for (var S = h[0], M = 1; M < h.length; ++M)
      h[M].pending < S.pending && (S = h[M]);
    return new Promise(function(w, H) {
      var L = new Uint8Array(b), C = v++;
      S.pending += m, S.requests[C] = { resolve: w, reject: H }, S.object.postMessage({ id: C, count: m, size: E, source: L, mode: T, filter: R }, [L.buffer]);
    });
  }
  function y(m) {
    u.then(function() {
      var E = m.data;
      try {
        var b = new Uint8Array(E.count * E.size);
        c(s.exports[E.mode], b, E.count, E.size, E.source, s.exports[E.filter]), self.postMessage({ id: E.id, count: E.count, action: "resolve", value: b }, [b.buffer]);
      } catch (T) {
        self.postMessage({ id: E.id, count: E.count, action: "reject", value: T });
      }
    });
  }
  return {
    ready: u,
    supported: true,
    useWorkers: function(m) {
      g(m);
    },
    decodeVertexBuffer: function(m, E, b, T, R) {
      c(s.exports.meshopt_decodeVertexBuffer, m, E, b, T, s.exports[f[R]]);
    },
    decodeIndexBuffer: function(m, E, b, T) {
      c(s.exports.meshopt_decodeIndexBuffer, m, E, b, T);
    },
    decodeIndexSequence: function(m, E, b, T) {
      c(s.exports.meshopt_decodeIndexSequence, m, E, b, T);
    },
    decodeGltfBuffer: function(m, E, b, T, R, S) {
      c(s.exports[d[R]], m, E, b, T, s.exports[f[S]]);
    },
    decodeGltfBufferAsync: function(m, E, b, T, R) {
      return h.length > 0 ? p(m, E, b, d[T], f[R]) : u.then(function() {
        var S = new Uint8Array(m * E);
        return c(s.exports[d[T]], S, m, E, b, s.exports[f[R]]), S;
      });
    }
  };
}();
var EXTENSION_NAME$3 = "EXT_meshopt_compression";
var EXT_meshopt_compression = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.loadBufferView = function(e, r) {
      var o = r.json, s = o.bufferViews[e];
      if (s.extensions && s.extensions[EXTENSION_NAME$3]) {
        var u = s.extensions[EXTENSION_NAME$3], l = r.loadBuffer(u.buffer);
        if (!meshoptDecoder.supported) {
          if (o.extensionsRequired && o.extensionsRequired.indexOf(EXTENSION_NAME$3) >= 0)
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return Promise.all([l, meshoptDecoder.ready]).then(function(c) {
          var f = c[0], d = u.byteOffset || 0, h = u.byteLength || 0, v = u.count, A = u.byteStride, g = new ArrayBuffer(v * A), p = new Uint8Array(f, d, h);
          return meshoptDecoder.decodeGltfBuffer(new Uint8Array(g), v, A, p, u.mode, u.filter), g;
        });
      } else
        return null;
    }, t;
  }(BaseExtension)
);
var EXTENSION_NAME$2 = "EXT_texture_webp";
var EXT_texture_webp = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45 !== null && n45.apply(this, arguments) || this;
      return e.supportsWep = false, e;
    }
    return t.prototype.prepare = function(e) {
      var r = this;
      return imageSupport().then(function(o) {
        r.supportsWep = o.webp;
      });
    }, t.prototype.loadTexture = function(e, r) {
      var o = r.json, s = o.textures[e];
      if (!s.extensions || !s.extensions[EXTENSION_NAME$2] || !this.supportsWep)
        return null;
      var u = s.extensions[EXTENSION_NAME$2];
      return r.loadImage(u.source).then(function(l) {
        var c = new Texture(l);
        c.needsUpdate = true, c.flipY = false, s.name && (c.name = s.name);
        var f = r.json.samplers || {}, d = f[s.sampler] || {};
        return c.magFilter = WEBGL_FILTERS[d.magFilter] || LinearFilter, c.minFilter = WEBGL_FILTERS[d.minFilter] || LinearMipmapLinearFilter, c.wrapS = WEBGL_WRAPPINGS[d.wrapS] || RepeatWrapping, c.wrapT = WEBGL_WRAPPINGS[d.wrapT] || RepeatWrapping, c.onUpdate = function() {
          l.close();
        }, c;
      });
    }, t;
  }(BaseExtension)
);
var EXTENSION_NAME$1 = "CESIUM_RTC";
var CESIUM_RTC = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.emitResult = function(e, r) {
      if (r.json.extensions[EXTENSION_NAME$1] && r.json.extensions[EXTENSION_NAME$1].center) {
        var o = r.json.extensions[EXTENSION_NAME$1].center;
        e.CESIUM_RTC = {
          center: new Vector3().fromArray(o)
        };
      }
    }, t;
  }(BaseExtension)
);
var PBM_mesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.loadMesh = function(e, r) {
      var o = this, s = r.json.meshes[e], u = s.primitives, l = Promise.all(u.map(function(d) {
        return r.loadGeometry(d);
      })), c = Promise.all(u.map(function(d) {
        return o.loadPBMMaterial(d, r);
      })), f = Promise.all([l, c]).then(function(d) {
        for (var h = d[0], v = d[1], A = [], g = 0; g < u.length; g++) {
          var p = u[g], y = h[g], m = v[g], E = p.mode || WEBGL_CONSTANTS.TRIANGLES, b = void 0;
          if (E === WEBGL_CONSTANTS.TRIANGLES || E === WEBGL_CONSTANTS.TRIANGLE_STRIP || E === WEBGL_CONSTANTS.TRIANGLE_FAN)
            if (E === WEBGL_CONSTANTS.TRIANGLE_STRIP ? y = r.toGeometryTrianglesDrawMode(y, TriangleStripDrawMode) : E === WEBGL_CONSTANTS.TRIANGLE_FAN && (y = r.toGeometryTrianglesDrawMode(y, TriangleFanDrawMode)), y.clearGroups(), y.addGroup(0, y.index ? y.index.count : y.attributes.position.count, 0), r.disposeSet.add(y), s.isSkinnedMesh) {
              var T = new PBMSkinnedMesh(y, [m]);
              y.attributes.skinWeight.normalized || T.normalizeSkinWeights(), b = T;
            } else
              b = new PBMMesh(y, [m]);
          else if (E === WEBGL_CONSTANTS.POINTS)
            b = new PBMPointCloud(y, m);
          else
            throw new Error("glTF: Primitive mode unsupported: " + E);
          if (Object.keys(y.morphAttributes).length > 0) {
            if (s.weights !== void 0)
              for (var R = 0, S = s.weights.length; R < S; R++)
                b.morphTargetInfluences[R] = s.weights[R];
            if (s.extras && Array.isArray(s.extras.targetNames)) {
              var M = s.extras.targetNames;
              if (b.morphTargetInfluences.length === M.length) {
                b.morphTargetDictionary = {};
                for (var R = 0, S = M.length; R < S; R++)
                  b.morphTargetDictionary[M[R]] = R;
              } else
                console.warn("glTF: Invalid extras.targetNames length. Ignoring names.");
            }
          }
          b.name = r.createUniqueName(s.name || "mesh_" + e), A.push(b);
        }
        if (A.length === 1)
          return A[0];
        for (var w = new Group(), H = 0, L = A; H < L.length; H++) {
          var b = L[H];
          w.add(b);
        }
        return w;
      });
      return f;
    }, t.prototype.loadPBMMaterial = function(e, r) {
      var o, s = (o = e.mode) !== null && o !== void 0 ? o : WEBGL_CONSTANTS.TRIANGLES, u = null;
      if (s === WEBGL_CONSTANTS.TRIANGLES || s === WEBGL_CONSTANTS.TRIANGLE_STRIP || s === WEBGL_CONSTANTS.TRIANGLE_FAN)
        u = this.loadPBMMeshMaterial(e, r);
      else if (s === WEBGL_CONSTANTS.POINTS)
        u = this.loadPBMPointCloudMaterial(e, r);
      else
        throw new Error("glTF: Primitive mode unsupported: " + s);
      return u = u.then(function(l) {
        return Promise.all(values(r.extensions).map(function(c) {
          return c.extendMaterial(l, e, r);
        })).then(function() {
          return l;
        });
      }), u;
    }, t.prototype.extendTexture = function(e, r, o) {
      return e.minFilter = LinearFilter, e.magFilter = LinearFilter, e.generateMipmaps = false, e;
    }, t.prototype.loadPBMPointCloudMaterial = function(e, r) {
      var o = new PBMPointCloudMaterial();
      return Object.keys(e.attributes).filter(function(s) {
        return ATTRIBUTES[s] === "normal";
      }).length > 0 && (o.defines.USE_POINT_NORMAL = true), r.disposeSet.add(o), Promise.resolve(o);
    }, t.prototype.loadPBMMeshMaterial = function(e, r) {
      var o = [], s = r.extensions.KHR_materials_unlit ? "basic" : "standard", u = new PBMMeshMaterial(s);
      u.color = new Color(1, 1, 1);
      var l = {};
      for (var c in e.attributes) {
        var f = ATTRIBUTES[c] || c.toLowerCase();
        l[f] = c;
      }
      if ("color" in l && (u.vertexColors = true), "normal" in l || (u.flatShading = true), "tangent" in l ? u.vertexTangents = true : (u.normalScale && (u.normalScale.y *= -1), u.clearcoatNormalScale && (u.clearcoatNormalScale.y *= -1)), "_feature_id_rsmask" in l && (u.defines.USE_VERTEX_MARK = true), e.material !== void 0) {
        var d = r.json.materials[e.material];
        d.name && (u.name = d.name);
        var h = d.pbrMetallicRoughness || {};
        if (Array.isArray(h.baseColorFactor)) {
          var v = h.baseColorFactor;
          u.color = new Color().fromArray(v), u.colorAlpha = v[3];
        }
        h.baseColorTexture !== void 0 && o.push(r.createMaterialTexture(h.baseColorTexture).then(function(p) {
          r.disposeSet.add(p), p.encoding = sRGBEncoding, u.map = p;
        })), typeof h.roughnessFactor == "number" && (u.roughness = h.roughnessFactor), typeof h.metallicFactor == "number" && (u.metalness = h.metallicFactor), h.metallicRoughnessTexture !== void 0 && o.push(r.createMaterialTexture(h.metallicRoughnessTexture).then(function(p) {
          r.disposeSet.add(p), p.encoding = sRGBEncoding, u.roughnessMap = p, u.metalnessMap = p;
        })), d.doubleSided === true && (u.side = DoubleSide);
        var A = d.alphaMode || ALPHA_MODES.OPAQUE;
        if (u.alphaMode = "OPAQUE", A === ALPHA_MODES.BLEND ? (u.alphaMode = "BLEND", u.transparent = true, u.depthWrite = false) : (u.transparent = false, A === ALPHA_MODES.MASK && (u.alphaMode = "MASK", u.alphaTest = d.alphaCutoff !== void 0 ? d.alphaCutoff : 0.5)), d.normalTexture !== void 0 && (o.push(r.createMaterialTexture(d.normalTexture).then(function(p) {
          r.disposeSet.add(p), u.normalMap = p;
        })), u.normalScale = new Vector2(1, 1), d.normalTexture.scale !== void 0)) {
          var g = d.normalTexture.scale;
          u.normalScale.set(g, g);
        }
      }
      return r.disposeSet.add(u), Promise.all(o).then(function() {
        return u.refreshUniforms(), u;
      });
    }, t;
  }(BaseExtension)
);
var EXTENSION_NAME = "REALSEE_materials_lightmap";
var REALSEE_materials_lightmap = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      return n45 !== null && n45.apply(this, arguments) || this;
    }
    return t.prototype.extendMaterial = function(e, r, o) {
      var s = [];
      if (o.json.materials && r.material !== void 0) {
        var u = o.json.materials[r.material], l = u.extensions[EXTENSION_NAME];
        l && (l.lightMapTexture !== void 0 && s.push(o.createMaterialTexture(l.lightMapTexture).then(function(c) {
          e.lightMap = c;
        })), l.lightMapIntensity !== void 0 && (e.lightMapIntensity = l.lightMapIntensity));
      }
      return Promise.all(s).then(function() {
      });
    }, t;
  }(BaseExtension)
);
var EXTENSIONS = {
  KHR_binary_glTF,
  KHR_draco_mesh_compression,
  KHR_texture_basisu,
  KHR_texture_transform,
  KHR_mesh_quantization,
  KHR_materials_unlit,
  EXT_meshopt_compression,
  EXT_texture_webp,
  CESIUM_RTC,
  REALSEE_materials_lightmap,
  PBM_mesh
};
function parseGltf(n45, t) {
  var e, r, o, s = {}, u, l;
  if (typeof n45 == "string")
    l = n45;
  else {
    var c = EXTENSIONS.KHR_binary_glTF.getMagic(n45);
    if (c === EXTENSIONS.KHR_binary_glTF.HEADER_MAGIC) {
      u = new EXTENSIONS.KHR_binary_glTF();
      try {
        u.loadGlbBinary(n45);
      } catch (g) {
        return Promise.reject(g);
      }
      s.KHR_binary_glTF = u, l = u.content;
    } else
      l = decodeText(new Uint8Array(n45));
  }
  var f = JSON.parse(l);
  if (t.jsonModify && (f = t.jsonModify(f)), f.asset === void 0 || Number(f.asset.version[0]) < 2)
    return Promise.reject(new Error("glTF: Unsupported asset. glTF versions >=2.0 are supported."));
  if (f.extensionsUsed)
    for (var d = f.extensionsRequired || [], h = 0; h < f.extensionsUsed.length; h++) {
      var v = f.extensionsUsed[h];
      s[v] || (EXTENSIONS[v] ? s[v] = new EXTENSIONS[v]() : d.indexOf(v) >= 0 && console.warn('glTF: Unknown extension "' + v + '".'));
    }
  var A = new Parser(f, s, {
    copyUV2: (e = t.copyUV2) !== null && e !== void 0 ? e : true,
    resourcePath: (r = t.resourcePath) !== null && r !== void 0 ? r : "",
    search: (o = t.search) !== null && o !== void 0 ? o : "",
    fetcher: t.fetcher
  });
  return A.parse().then(function(g) {
    return u && u.clear(), g;
  });
}
function fixNumber(n45) {
  return isNaN(n45) || !isFinite(n45) ? 0 : n45;
}
function getGeometryMemoryUsed(n45) {
  var t = 0;
  if (n45 instanceof BufferGeometry) {
    for (var e in n45.attributes) {
      var r = n45.getAttribute(e), o = 4;
      "BYTES_PER_ELEMENT" in r.array && typeof r.array.BYTES_PER_ELEMENT == "number" && (o = r.array.BYTES_PER_ELEMENT), t += fixNumber(r.count * r.itemSize * o);
    }
    var s = n45.getIndex();
    if (s) {
      var o = 4;
      "BYTES_PER_ELEMENT" in s.array && typeof s.array.BYTES_PER_ELEMENT == "number" && (o = s.array.BYTES_PER_ELEMENT), t += fixNumber(s.count * s.itemSize * o);
    }
  } else n45 instanceof Geometry && (t += fixNumber(n45.faces.length * 3 * 3 * 4), t += fixNumber(n45.faceVertexUvs.length * 3 * 2 * 4));
  return t;
}
function makeComputeBlockRectSizeFunction(n45, t, e) {
  return function(r, o, s) {
    var u = (r + n45 - 1) / n45 | 0, l = (o + t - 1) / t | 0;
    return u * l * e * s;
  };
}
function makeComputePaddedRectSizeFunction(n45, t, e) {
  return function(r, o, s) {
    return (Math.max(r, n45) * Math.max(o, t) / e | 0) * s;
  };
}
var compressedTextureFunctions = /* @__PURE__ */ new Map([
  [RGB_S3TC_DXT1_Format, makeComputeBlockRectSizeFunction(4, 4, 8)],
  [RGBA_S3TC_DXT1_Format, makeComputeBlockRectSizeFunction(4, 4, 8)],
  [RGBA_S3TC_DXT3_Format, makeComputeBlockRectSizeFunction(4, 4, 16)],
  [RGBA_S3TC_DXT5_Format, makeComputeBlockRectSizeFunction(4, 4, 16)],
  [RGB_ETC1_Format, makeComputeBlockRectSizeFunction(4, 4, 8)],
  [RGB_PVRTC_4BPPV1_Format, makeComputePaddedRectSizeFunction(8, 8, 2)],
  [RGBA_PVRTC_4BPPV1_Format, makeComputePaddedRectSizeFunction(8, 8, 2)],
  [RGB_PVRTC_2BPPV1_Format, makeComputePaddedRectSizeFunction(16, 8, 4)],
  [RGBA_PVRTC_2BPPV1_Format, makeComputePaddedRectSizeFunction(16, 8, 4)],
  // [ /*COMPRESSED_R11_EAC*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  // [ /*COMPRESSED_SIGNED_R11_EAC*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  [RGB_ETC2_Format, makeComputeBlockRectSizeFunction(4, 4, 8)],
  // [ /*COMPRESSED_SRGB8_ETC2*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  // [ /*COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  // [ /*COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  // [ /*COMPRESSED_RG11_EAC*/, makeComputeBlockRectSizeFunction(4, 4, 16) ],
  // [ /*COMPRESSED_SIGNED_RG11_EAC*/, makeComputeBlockRectSizeFunction(4, 4, 16) ],
  [RGBA_ETC2_EAC_Format, makeComputeBlockRectSizeFunction(4, 4, 16)],
  // [ /*COMPRESSED_SRGB8_ALPHA8_ETC2_EAC*/, makeComputeBlockRectSizeFunction(4, 4, 16) ],
  [RGBA_ASTC_4x4_Format, makeComputeBlockRectSizeFunction(4, 4, 16)],
  [SRGB8_ALPHA8_ASTC_4x4_Format, makeComputeBlockRectSizeFunction(4, 4, 16)],
  [RGBA_ASTC_5x4_Format, makeComputeBlockRectSizeFunction(5, 4, 16)],
  [SRGB8_ALPHA8_ASTC_5x4_Format, makeComputeBlockRectSizeFunction(5, 4, 16)],
  [RGBA_ASTC_5x5_Format, makeComputeBlockRectSizeFunction(5, 5, 16)],
  [SRGB8_ALPHA8_ASTC_5x5_Format, makeComputeBlockRectSizeFunction(5, 5, 16)],
  [RGBA_ASTC_6x5_Format, makeComputeBlockRectSizeFunction(6, 5, 16)],
  [SRGB8_ALPHA8_ASTC_6x5_Format, makeComputeBlockRectSizeFunction(6, 5, 16)],
  [RGBA_ASTC_6x6_Format, makeComputeBlockRectSizeFunction(6, 6, 16)],
  [SRGB8_ALPHA8_ASTC_6x6_Format, makeComputeBlockRectSizeFunction(6, 6, 16)],
  [RGBA_ASTC_8x5_Format, makeComputeBlockRectSizeFunction(8, 5, 16)],
  [SRGB8_ALPHA8_ASTC_8x5_Format, makeComputeBlockRectSizeFunction(8, 5, 16)],
  [RGBA_ASTC_8x6_Format, makeComputeBlockRectSizeFunction(8, 6, 16)],
  [SRGB8_ALPHA8_ASTC_8x6_Format, makeComputeBlockRectSizeFunction(8, 6, 16)],
  [RGBA_ASTC_8x8_Format, makeComputeBlockRectSizeFunction(8, 8, 16)],
  [SRGB8_ALPHA8_ASTC_8x8_Format, makeComputeBlockRectSizeFunction(8, 8, 16)],
  [RGBA_ASTC_10x5_Format, makeComputeBlockRectSizeFunction(10, 5, 16)],
  [SRGB8_ALPHA8_ASTC_10x5_Format, makeComputeBlockRectSizeFunction(10, 5, 16)],
  [RGBA_ASTC_10x6_Format, makeComputeBlockRectSizeFunction(10, 6, 16)],
  [SRGB8_ALPHA8_ASTC_10x6_Format, makeComputeBlockRectSizeFunction(10, 6, 16)],
  [RGBA_ASTC_10x8_Format, makeComputeBlockRectSizeFunction(10, 8, 16)],
  [SRGB8_ALPHA8_ASTC_10x8_Format, makeComputeBlockRectSizeFunction(10, 8, 16)],
  [RGBA_ASTC_10x10_Format, makeComputeBlockRectSizeFunction(10, 10, 16)],
  [SRGB8_ALPHA8_ASTC_10x10_Format, makeComputeBlockRectSizeFunction(10, 10, 16)],
  [RGBA_ASTC_12x10_Format, makeComputeBlockRectSizeFunction(12, 10, 16)],
  [SRGB8_ALPHA8_ASTC_12x10_Format, makeComputeBlockRectSizeFunction(12, 10, 16)],
  [RGBA_ASTC_12x12_Format, makeComputeBlockRectSizeFunction(12, 12, 16)],
  [SRGB8_ALPHA8_ASTC_12x12_Format, makeComputeBlockRectSizeFunction(12, 12, 16)],
  // [ /*COMPRESSED_SRGB_S3TC_DXT1_EXT*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  // [ /*COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT*/, makeComputeBlockRectSizeFunction(4, 4, 8) ],
  // [ /*COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT*/, makeComputeBlockRectSizeFunction(4, 4, 16) ],
  // [ /*COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT*/, makeComputeBlockRectSizeFunction(4, 4, 16) ],
  [RGBA_BPTC_Format, makeComputeBlockRectSizeFunction(4, 4, 16)]
  // [ /*COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  // [ /*COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  // [ /*COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  // [ /*COMPRESSED_RED_RGTC1_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
  // [ /*COMPRESSED_SIGNED_RED_RGTC1_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
  // [ /*COMPRESSED_RED_GREEN_RGTC2_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  // [ /*COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT*/, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
]);
function getTextureMemoryUsed(n45) {
  var t = 0, e = 1;
  (n45.generateMipmaps === true || n45.mipmaps && n45.mipmaps.length > 1) && (e = 1.33);
  for (var r = n45 instanceof CompressedTexture, o = r ? compressedTextureFunctions.get(n45.format) : void 0, s = [].concat(n45.image), u = 0, l = s; u < l.length; u++) {
    var c = l[u];
    if (c instanceof Texture)
      t += getTextureMemoryUsed(c);
    else {
      var f = c.width, d = f === void 0 ? 1 : f, h = c.height, v = h === void 0 ? 1 : h, A = c.depth, g = A === void 0 ? 1 : A;
      o ? t += fixNumber(o(d, v, g) * e) : t += fixNumber(d * v * g * 4 * e);
    }
  }
  return t;
}
var textureSet = /* @__PURE__ */ new Set();
var textureNames = [
  "map",
  "alphaMap",
  "bumpMap",
  "normalMap",
  "displacementMap",
  "emissiveMap",
  "specularMap",
  "envMap",
  "flipEnvMap",
  "lightMap",
  "aoMap",
  "gradientMap",
  "metalnessMap",
  "roughnessMap",
  "sheenColorMap",
  "sheenRoughnessMap",
  "clearcoatMap",
  "clearcoatRoughnessMap",
  "clearcoatNormalMap",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "transmissionMap",
  "thicknessMap",
  "anisotropyMap",
  "specularColorMap",
  "specularIntensityMap"
];
function getMaterialMemoryUsed(n45) {
  var t = 0;
  if (textureSet.clear(), n45 instanceof ShaderMaterial)
    for (var e in n45.uniforms) {
      var r = n45.uniforms[e], o = r && r.value && r.value instanceof Texture ? r.value : void 0;
      o instanceof Texture && (textureSet.has(o) || (t = getTextureMemoryUsed(o), textureSet.add(o)));
    }
  else
    for (var s = 0, u = textureNames; s < u.length; s++) {
      var l = u[s], o = n45[l];
      o instanceof Texture && (textureSet.has(o) || (t = getTextureMemoryUsed(o), textureSet.add(o)));
    }
  return textureSet.clear(), t;
}
var sceneSet = /* @__PURE__ */ new Set();
function getMemoryUsage(n45) {
  var t = 0;
  return sceneSet.clear(), n45.traverse(function(e) {
    if (e instanceof Mesh || e instanceof Line || e instanceof Points) {
      var r = e.geometry;
      (r instanceof BufferGeometry || r instanceof Geometry) && (sceneSet.has(r) || (t += getGeometryMemoryUsed(r), sceneSet.add(r)));
      for (var o = [].concat(e.material), s = 0, u = o; s < u.length; s++) {
        var l = u[s];
        l instanceof Material && (sceneSet.has(l) || (t += getMaterialMemoryUsed(l), sceneSet.add(l)));
      }
    }
  }), sceneSet.clear(), t;
}
var ROTATE_X_MATRIX$6 = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
function loadB3dm(n45, t) {
  var e, r;
  t === void 0 && (t = {});
  var o = (e = t.upAxis) !== null && e !== void 0 ? e : "Y", s = (r = t.fetcher) !== null && r !== void 0 ? r : new Fetcher({ allowHosts: ["*"] }), u = {
    uri: n45,
    gltfUpAxis: o
  };
  return Promise.resolve().then(function() {
    return s.ajax(n45, {
      responseType: "arraybuffer"
    }).then(function(l) {
      return l.body;
    });
  }).then(function(l) {
    return Promise.resolve(0).then(function(c) {
      return parseHeader$1(u, l, c);
    }).then(function(c) {
      return parseTable(u, l, c);
    }).then(function(c) {
      return parseGlTFArrayBuffer(u, l, c);
    });
  }).then(function() {
    var l;
    return parseGltf(u.gltfArrayBuffer, {
      copyUV2: false,
      resourcePath: n45.slice(0, n45.lastIndexOf("/") + 1),
      search: (l = n45.split("?")[1]) !== null && l !== void 0 ? l : "",
      jsonModify: function(c) {
        var f;
        if (c.extensionsUsed = (f = c.extensionsUsed) !== null && f !== void 0 ? f : [], typeof t.light == "boolean") {
          var d = "KHR_materials_unlit";
          if (t.light) {
            var h = c.extensionsUsed.indexOf(d);
            h >= 0 && c.extensionsUsed.splice(h, 1);
          } else {
            var h = c.extensionsUsed.indexOf(d);
            h === -1 && c.extensionsUsed.push(d);
          }
        }
        {
          var d = "PBM_mesh", h = c.extensionsUsed.indexOf(d);
          h === -1 && c.extensionsUsed.push(d);
        }
        return c;
      },
      fetcher: s
    }).then(function(c) {
      var f = new Matrix4();
      o === "Y" && f.premultiply(ROTATE_X_MATRIX$6);
      var d = new Matrix4().setPosition(u.rtcCenter[0], u.rtcCenter[1], u.rtcCenter[2]);
      if (f.premultiply(d), c.CESIUM_RTC) {
        var h = new Matrix4().setPosition(c.CESIUM_RTC.center);
        f.premultiply(h);
      }
      var v = c.scene;
      return v.applyMatrix4(f), delete u.featureTableBinary, delete u.batchTableBinary, delete u.gltfArrayBuffer, {
        type: "b3dm",
        upAxis: "Z",
        uri: u.uri,
        byteLength: u.byteLength,
        memoryUsage: getMemoryUsage(v),
        scene: v,
        textures: c.textures,
        dispose: function() {
          return c.dispose();
        }
      };
    });
  });
}
var encodedJs = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIEIoYSl7b25tZXNzYWdlPWZ1bmN0aW9uKHIpe1Byb21pc2UucmVzb2x2ZShyLmRhdGEpLnRoZW4oZnVuY3Rpb24obil7cmV0dXJuIGEobil9KS50aGVuKGZ1bmN0aW9uKG4pe3ZhciBlPW4ub3V0cHV0LHQ9bi50cmFuc2ZlcjtyZXR1cm4gcG9zdE1lc3NhZ2UoZSx0KX0pLmNhdGNoKGZ1bmN0aW9uKG4pe3JldHVybiBwb3N0TWVzc2FnZSh7JCRlcnJvcjpufSl9KX19dmFyIHUseTsoZnVuY3Rpb24oYSl7YVthLkJZVEU9NTEyMF09IkJZVEUiLGFbYS5VTlNJR05FRF9CWVRFPTUxMjFdPSJVTlNJR05FRF9CWVRFIixhW2EuU0hPUlQ9NTEyMl09IlNIT1JUIixhW2EuVU5TSUdORURfU0hPUlQ9NTEyM109IlVOU0lHTkVEX1NIT1JUIixhW2EuSU5UPTUxMjRdPSJJTlQiLGFbYS5VTlNJR05FRF9JTlQ9NTEyNV09IlVOU0lHTkVEX0lOVCIsYVthLkZMT0FUPTUxMjZdPSJGTE9BVCIsYVthLkRPVUJMRT01MTMwXT0iRE9VQkxFIn0pKHl8fCh5PXt9KSk7dmFyIGM9KHU9e30sdVt5LkRPVUJMRV09RmxvYXQ2NEFycmF5LHVbeS5GTE9BVF09RmxvYXQzMkFycmF5LHVbeS5VTlNJR05FRF9TSE9SVF09VWludDE2QXJyYXksdVt5LlVOU0lHTkVEX0lOVF09VWludDMyQXJyYXksdVt5LlVOU0lHTkVEX0JZVEVdPVVpbnQ4QXJyYXksdVt5LkJZVEVdPUludDhBcnJheSx1W3kuU0hPUlRdPUludDE2QXJyYXksdVt5LklOVF09SW50MzJBcnJheSx1KSxGPXtET1VCTEU6eS5ET1VCTEUsRkxPQVQ6eS5GTE9BVCxVTlNJR05FRF9TSE9SVDp5LlVOU0lHTkVEX1NIT1JULFVOU0lHTkVEX0lOVDp5LlVOU0lHTkVEX0lOVCxVTlNJR05FRF9CWVRFOnkuVU5TSUdORURfQllURSxCWVRFOnkuQllURSxTSE9SVDp5LlNIT1JULElOVDp5LklOVH07ZnVuY3Rpb24gTyhhKXt2YXIgcj1jW2FdO2lmKCFyKXRocm93IG5ldyBFcnJvcigiRmFpbGVkIHRvIGNvbnZlcnQgR0wgdHlwZSIpO3JldHVybiByfWZ1bmN0aW9uIHAoYSl7dmFyIHI9TyhhKTtyZXR1cm4gci5CWVRFU19QRVJfRUxFTUVOVH1mdW5jdGlvbiBfKGEscixuLGUpe249PT12b2lkIDAmJihuPTApO3ZhciB0PU8oYSk7aWYobiVwKGEpIT09MCl7dmFyIGk9ZT9yLnNsaWNlKG4sbitlKnAoYSkpOnIuc2xpY2Uobik7cmV0dXJuIG5ldyB0KGkpfWVsc2UgcmV0dXJuIG5ldyB0KHIsbixlIT1udWxsP2U6KHIuYnl0ZUxlbmd0aC1uKS9wKGEpKX1mdW5jdGlvbiBsKGEpe3ZhciByPUZbYV07aWYoIXIpdGhyb3cgbmV3IEVycm9yKCJGYWlsZWQgdG8gY29udmVydCBHTCB0eXBlIik7cmV0dXJuIHJ9dmFyIFI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKHIsbil7dGhpcy5mZWF0dXJlc0xlbmd0aD0wLHRoaXMuY2FjaGVkVHlwZWRBcnJheXM9e30sdGhpcy5qc29uPXIsdGhpcy5idWZmZXI9bjt2YXIgZT10aGlzLmdldEdsb2JhbFByb3BlcnR5KCJQT0lOVFNfTEVOR1RIIix5LlVOU0lHTkVEX0lOVCwxKTtlJiZlLmxlbmd0aCYmKHRoaXMuZmVhdHVyZXNMZW5ndGg9ZVswXSl9cmV0dXJuIGEucHJvdG90eXBlLmdldEV4dGVuc2lvbj1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5qc29uLmV4dGVuc2lvbnMmJnRoaXMuanNvbi5leHRlbnNpb25zW3JdfSxhLnByb3RvdHlwZS5oYXNQcm9wZXJ0eT1mdW5jdGlvbihyKXtyZXR1cm4hIXRoaXMuanNvbltyXX0sYS5wcm90b3R5cGUuZ2V0R2xvYmFsUHJvcGVydHk9ZnVuY3Rpb24ocixuLGUpe3ZhciB0PXRoaXMuanNvbltyXTtpZih0eXBlb2YgdD09Im51bWJlciIpe3ZhciBpPU8obik7cmV0dXJuIG5ldyBpKFt0XSl9ZWxzZSBpZihBcnJheS5pc0FycmF5KHQpKXt2YXIgaT1PKG4pO3JldHVybiBuZXcgaSh0KX1lbHNlIGlmKHQmJk51bWJlci5pc0Zpbml0ZSh0LmJ5dGVPZmZzZXQpKXJldHVybiB0aGlzLmdldFR5cGVkQXJyYXlGcm9tQmluYXJ5KHIsbixlLDEsdC5ieXRlT2Zmc2V0KTtyZXR1cm4gbnVsbH0sYS5wcm90b3R5cGUuZ2V0UHJvcGVydHlBcnJheT1mdW5jdGlvbihyLG4sZSl7dmFyIHQ9dGhpcy5qc29uW3JdO3JldHVybiB0JiZOdW1iZXIuaXNGaW5pdGUodC5ieXRlT2Zmc2V0KT8oImNvbXBvbmVudFR5cGUiaW4gdCYmKG49bCh0LmNvbXBvbmVudFR5cGUpKSx0aGlzLmdldFR5cGVkQXJyYXlGcm9tQmluYXJ5KHIsbixlLHRoaXMuZmVhdHVyZXNMZW5ndGgsdC5ieXRlT2Zmc2V0KSk6dGhpcy5nZXRUeXBlZEFycmF5RnJvbUFycmF5KHIsbix0KX0sYS5wcm90b3R5cGUuZ2V0UHJvcGVydHk9ZnVuY3Rpb24ocixuLGUsdCxpKXt2YXIgbz10aGlzLmpzb25bcl07aWYoIW8pcmV0dXJuIG51bGw7dmFyIHY9dGhpcy5nZXRQcm9wZXJ0eUFycmF5KHIsbixlKTtpZihlPT09MSlyZXR1cm4gaVswXT12W3RdLGk7Zm9yKHZhciBBPTA7QTxlOysrQSlpW0FdPXZbZSp0K0FdO3JldHVybiBpfSxhLnByb3RvdHlwZS5nZXRUeXBlZEFycmF5RnJvbUJpbmFyeT1mdW5jdGlvbihyLG4sZSx0LGkpe3ZhciBvPXRoaXMuY2FjaGVkVHlwZWRBcnJheXMsdj1vW3JdO3JldHVybiB2fHwodj1fKG4sdGhpcy5idWZmZXIuYnVmZmVyLHRoaXMuYnVmZmVyLmJ5dGVPZmZzZXQraSx0KmUpLG9bcl09diksdn0sYS5wcm90b3R5cGUuZ2V0VHlwZWRBcnJheUZyb21BcnJheT1mdW5jdGlvbihyLG4sZSl7dmFyIHQ9dGhpcy5jYWNoZWRUeXBlZEFycmF5cyxpPXRbcl07cmV0dXJuIGl8fChpPV8obixlKSx0W3JdPWkpLGl9LGF9KCk7QihmdW5jdGlvbihhKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oZnVuY3Rpb24ocil7dmFyIG49bmV3IFIoci5mZWF0dXJlVGFibGVKc29uLHIuZmVhdHVyZVRhYmxlQmluYXJ5KSxlPWQobiksdD1nKG4pLGk9UChuKSxvPVtdO3JldHVybiBlJiZvLnB1c2goZS5hcnJheS5idWZmZXIpLHQmJm8ucHVzaCh0LmFycmF5LmJ1ZmZlciksaSYmby5wdXNoKGkuYXJyYXkuYnVmZmVyKSx7b3V0cHV0Ontwb3NpdGlvbjplLGNvbG9yOnQsbm9ybWFsOml9LHRyYW5zZmVyOm99fSl9KTt2YXIgVT02NTUzNTtmdW5jdGlvbiBkKGEpe2lmKGEuaGFzUHJvcGVydHkoIlBPU0lUSU9OIikpe3ZhciByPWEuZ2V0UHJvcGVydHlBcnJheSgiUE9TSVRJT04iLHkuRkxPQVQsMyk7cmV0dXJue2FycmF5OnIsaXRlbVNpemU6Myxub3JtYWxpemVkOiExfX1lbHNlIGlmKGEuaGFzUHJvcGVydHkoIlBPU0lUSU9OX1FVQU5USVpFRCIpKXt2YXIgbj1hLmdldFByb3BlcnR5QXJyYXkoIlBPU0lUSU9OX1FVQU5USVpFRCIseS5VTlNJR05FRF9TSE9SVCwzKSxlPWEuZ2V0R2xvYmFsUHJvcGVydHkoIlFVQU5USVpFRF9WT0xVTUVfU0NBTEUiLHkuRkxPQVQsMyksdD1hLmdldEdsb2JhbFByb3BlcnR5KCJRVUFOVElaRURfVk9MVU1FX09GRlNFVCIseS5GTE9BVCwzKTtpZighZXx8IXQpdGhyb3cgbmV3IEVycm9yKCJRVUFOVElaRURfVk9MVU1FX1NDQUxFIG9yIFFVQU5USVpFRF9WT0xVTUVfT0ZGU0VUIG5ldmVyIGZvdW5kLiIpO2Zvcih2YXIgaT1uZXcgRmxvYXQzMkFycmF5KG4ubGVuZ3RoKSxvPW4ubGVuZ3RoLzMsdj1lWzBdL1UsQT1lWzFdL1UsTj1lWzJdL1UsRT10WzBdLFM9dFsxXSxzPXRbMl0sVD0wLEk9dm9pZCAwO1Q8bztUKyspST1UKjMsaVtJXT1uW0ldKnYrRSxpWysrSV09bltJXSpBK1MsaVsrK0ldPW5bSV0qTitzO3JldHVybnthcnJheTppLGl0ZW1TaXplOjMsbm9ybWFsaXplZDohMX19cmV0dXJuIG51bGx9ZnVuY3Rpb24gZyhhKXtpZihhLmhhc1Byb3BlcnR5KCJSR0IiKSl7Zm9yKHZhciByPWEuZ2V0UHJvcGVydHlBcnJheSgiUkdCIix5LlVOU0lHTkVEX0JZVEUsMyksbj1yLmxlbmd0aC8zLGU9bmV3IFVpbnQ4QXJyYXkobio0KSx0PTAsaT12b2lkIDAsbz12b2lkIDA7dDxuO3QrKylvPXQqNCxpPXQqMyxlW29dPXJbaV0sZVsrK29dPXJbKytpXSxlWysrb109clsrK2ldO3JldHVybnthcnJheTplLGl0ZW1TaXplOjQsbm9ybWFsaXplZDohMH19ZWxzZSBpZihhLmhhc1Byb3BlcnR5KCJSR0JBIikpe3ZhciByPWEuZ2V0UHJvcGVydHlBcnJheSgiUkdCQSIseS5VTlNJR05FRF9CWVRFLDQpO3JldHVybnthcnJheTpyLGl0ZW1TaXplOjQsbm9ybWFsaXplZDohMH19ZWxzZSBpZihhLmhhc1Byb3BlcnR5KCJSR0I1NjUiKSl7Zm9yKHZhciByPWEuZ2V0UHJvcGVydHlBcnJheSgiUkdCNTY1Iix5LlVOU0lHTkVEX1NIT1JULDEpLG49ci5sZW5ndGgsZT1uZXcgVWludDhBcnJheShuKjQpLHQ9MCx2PXZvaWQgMCxBPXZvaWQgMDt0PG47dCsrKUE9clt0XSx2PXQqNCxlW3ZdPShBPj4xMSYzMSk8PDMsZVsrK3ZdPShBPj41JjYzKTw8MixlWysrdl09KEEmMzEpPDwzO3JldHVybnthcnJheTplLGl0ZW1TaXplOjQsbm9ybWFsaXplZDohMH19cmV0dXJuIG51bGx9dmFyIEc9MjU1LGg9MTI3LEQ9Mi9HO2Z1bmN0aW9uIFAoYSl7aWYoYS5oYXNQcm9wZXJ0eSgiTk9STUFMIikpe2Zvcih2YXIgcj1hLmdldFByb3BlcnR5QXJyYXkoIk5PUk1BTCIseS5GTE9BVCwzKSxuPXIubGVuZ3RoLzMsZT1uZXcgSW50OEFycmF5KG4qNCksdD0wLGk9dm9pZCAwLG89dm9pZCAwO3Q8bjt0Kyspbz10KjQsaT10KjMsZVtvXT1yW2ldKmgsZVsrK29dPXJbKytpXSpoLGVbKytvXT1yWysraV0qaDtyZXR1cm57YXJyYXk6ZSxpdGVtU2l6ZTo0LG5vcm1hbGl6ZWQ6ITB9fWVsc2UgaWYoYS5oYXNQcm9wZXJ0eSgiTk9STUFMX09DVDE2UCIpKXtmb3IodmFyIHI9YS5nZXRQcm9wZXJ0eUFycmF5KCJOT1JNQUxfT0NUMTZQIix5LlVOU0lHTkVEX0JZVEUsMiksbj1yLmxlbmd0aC8yLGU9bmV3IEludDhBcnJheShuKjQpLHQ9MCx2PXZvaWQgMCxBPXZvaWQgMCxOPXZvaWQgMCxFPXZvaWQgMCxTPXZvaWQgMCxzPXZvaWQgMCxUPXZvaWQgMDt0PG47dCsrKXY9dCoyLEE9clt2XSpELTEsTj1yWysrdl0qRC0xLFM9QTwwPy1BOkEscz1OPDA/LU46TixFPTEtKFMrcyksRTwwJiYoQT0oMS1zKSooQTwwPy0xOjEpLE49KDEtUykqKE48MD8tMToxKSksVD1NYXRoLnNxcnQoQSpBK04qTitFKkUpLHY9dCo0LGVbdl09QS9UKmgsZVsrK3ZdPU4vVCpoLGVbKyt2XT1FL1QqaDtyZXR1cm57YXJyYXk6ZSxpdGVtU2l6ZTo0LG5vcm1hbGl6ZWQ6ITB9fXJldHVybiBudWxsfX0pKCk7Cg==";
var decodeBase64 = (n45) => Uint8Array.from(atob(n45), (t) => t.charCodeAt(0));
var blob$1 = typeof self != "undefined" && self.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(n45) {
  let t;
  try {
    if (t = blob$1 && (self.URL || self.webkitURL).createObjectURL(blob$1), !t) throw "";
    const e = new Worker(t, {
      name: n45 == null ? void 0 : n45.name
    });
    return e.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), e;
  } catch (e) {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        name: n45 == null ? void 0 : n45.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
var attributeWorkerPool = new WorkerPool$1(function() {
  return new WorkerWrapper();
}, 2);
function parsePointCloud(n45, t, e) {
  var r = new FeatureTable(n45.featureTableJson, n45.featureTableBinary);
  return Promise.resolve().then(function() {
    var o = r.getExtension("3DTILES_draco_point_compression");
    return o ? parseDraco(o, r) : attributeWorkerPool.postMessage({
      featureTableBinary: r.buffer,
      featureTableJson: r.json
    }, [r.buffer.buffer]);
  }).then(function(o) {
    return n45.attributes = o, e;
  });
}
function parseDraco(n45, t) {
  return __awaiter(this, void 0, void 0, function() {
    var e, r, o, s, u, l;
    return __generator(this, function(c) {
      if (e = n45.properties || {}, r = n45.byteOffset, o = n45.byteLength, !e || !Number.isFinite(r) || !o)
        throw new Error("Draco properties, byteOffset, and byteLength must be defined");
      return s = t.buffer.slice(r, r + o), u = n45.properties, l = {
        POSITION: "Float32Array",
        NORMAL: "Float32Array",
        RGB: "Uint8Array",
        RGBA: "Uint8Array"
      }, [2, draco.decodeGeometry(s.buffer, {
        attributeIDs: u,
        attributeTypes: l,
        useUniqueIDs: true
      }).then(function(f) {
        var d = f.getAttribute("POSITION"), h = f.getAttribute("RGB"), v = f.getAttribute("RGBA"), A = f.getAttribute("NORMAL"), g;
        if (v)
          g = v;
        else if (h) {
          for (var p = h.count, y = h.array, m = new Uint8Array(p * 4), E = 0, b = void 0, T = void 0; E < p; E++)
            T = E * 4, b = E * 3, m[T] = y[b], m[++T] = y[++b], m[++T] = y[++b];
          g = new BufferAttribute(m, 4, h.normalized);
        }
        return {
          position: d ? { array: d.array, itemSize: d.itemSize, normalized: d.normalized } : null,
          color: g ? { array: g.array, itemSize: g.itemSize, normalized: g.normalized } : null,
          normal: A ? { array: A.array, itemSize: A.itemSize, normalized: A.normalized } : null
        };
      })];
    });
  });
}
function loadPnts(n45, t) {
  var e;
  t === void 0 && (t = {});
  var r = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), o = {
    uri: n45
  };
  return Promise.resolve().then(function() {
    return r.ajax(n45, {
      responseType: "arraybuffer"
    }).then(function(s) {
      return s.body;
    });
  }).then(function(s) {
    return Promise.resolve(0).then(function(u) {
      return parseHeader$1(o, s, u);
    }).then(function(u) {
      return parseTable(o, s, u);
    }).then(function(u) {
      return parsePointCloud(o, s, u);
    });
  }).then(function() {
    var s;
    return createPoints(o.attributes, {
      computeBoundingBox: (s = t.computeBoundingBox) !== null && s !== void 0 ? s : true
    });
  }).then(function(s) {
    var u = new Matrix4(), l = new Matrix4().setPosition(o.rtcCenter[0], o.rtcCenter[1], o.rtcCenter[2]);
    return u.premultiply(l), s.object.applyMatrix4(u), delete o.gltfArrayBuffer, delete o.featureTableBinary, delete o.batchTableBinary, {
      type: "pnts",
      upAxis: "Z",
      uri: o.uri,
      byteLength: o.byteLength,
      memoryUsage: getMemoryUsage(s.object),
      scene: s.object,
      textures: [],
      dispose: function() {
        return s.dispose();
      }
    };
  });
}
function createPoints(n45, t) {
  var e = /* @__PURE__ */ new Set(), r = new BufferGeometry();
  e.add(r);
  var o = new PBMPointCloudMaterial();
  e.add(o), n45.position && r.setAttribute("position", new BufferAttribute(n45.position.array, n45.position.itemSize, n45.position.normalized)), n45.color && r.setAttribute("color", new BufferAttribute(n45.color.array, n45.color.itemSize, n45.color.normalized)), n45.normal && (r.setAttribute("normal", new BufferAttribute(n45.normal.array, n45.normal.itemSize, n45.normal.normalized)), o.defines.USE_POINT_NORMAL = true), t.computeBoundingBox && r.computeBoundingBox();
  var s = new PBMPointCloud(r, o);
  return s.matrix.compose(s.position, s.quaternion, s.scale), s.matrixAutoUpdate = false, s.frustumCulled = false, Promise.resolve({
    object: s,
    dispose: function() {
      e.forEach(function(u) {
        u.dispose();
      }), e.clear();
    }
  });
}
function createLZMA() {
  var n45 = {};
  return n45.OutWindow = function() {
    this._windowSize = 0;
  }, n45.OutWindow.prototype.create = function(t) {
    (!this._buffer || this._windowSize !== t) && (this._buffer = []), this._windowSize = t, this._pos = 0, this._streamPos = 0;
  }, n45.OutWindow.prototype.flush = function() {
    var t = this._pos - this._streamPos;
    if (t !== 0) {
      for (; t--; )
        this._stream.writeByte(this._buffer[this._streamPos++]);
      this._pos >= this._windowSize && (this._pos = 0), this._streamPos = this._pos;
    }
  }, n45.OutWindow.prototype.releaseStream = function() {
    this.flush(), this._stream = null;
  }, n45.OutWindow.prototype.setStream = function(t) {
    this.releaseStream(), this._stream = t;
  }, n45.OutWindow.prototype.init = function(t) {
    t || (this._streamPos = 0, this._pos = 0);
  }, n45.OutWindow.prototype.copyBlock = function(t, e) {
    var r = this._pos - t - 1;
    for (r < 0 && (r += this._windowSize); e--; )
      r >= this._windowSize && (r = 0), this._buffer[this._pos++] = this._buffer[r++], this._pos >= this._windowSize && this.flush();
  }, n45.OutWindow.prototype.putByte = function(t) {
    this._buffer[this._pos++] = t, this._pos >= this._windowSize && this.flush();
  }, n45.OutWindow.prototype.getByte = function(t) {
    var e = this._pos - t - 1;
    return e < 0 && (e += this._windowSize), this._buffer[e];
  }, n45.RangeDecoder = function() {
  }, n45.RangeDecoder.prototype.setStream = function(t) {
    this._stream = t;
  }, n45.RangeDecoder.prototype.releaseStream = function() {
    this._stream = null;
  }, n45.RangeDecoder.prototype.init = function() {
    var t = 5;
    for (this._code = 0, this._range = -1; t--; )
      this._code = this._code << 8 | this._stream.readByte();
  }, n45.RangeDecoder.prototype.decodeDirectBits = function(t) {
    for (var e = 0, r = t, o; r--; )
      this._range >>>= 1, o = this._code - this._range >>> 31, this._code -= this._range & o - 1, e = e << 1 | 1 - o, this._range & 4278190080 || (this._code = this._code << 8 | this._stream.readByte(), this._range <<= 8);
    return e;
  }, n45.RangeDecoder.prototype.decodeBit = function(t, e) {
    var r = t[e], o = (this._range >>> 11) * r;
    return (this._code ^ 2147483648) < (o ^ 2147483648) ? (this._range = o, t[e] += 2048 - r >>> 5, this._range & 4278190080 || (this._code = this._code << 8 | this._stream.readByte(), this._range <<= 8), 0) : (this._range -= o, this._code -= o, t[e] -= r >>> 5, this._range & 4278190080 || (this._code = this._code << 8 | this._stream.readByte(), this._range <<= 8), 1);
  }, n45.initBitModels = function(t, e) {
    for (; e--; )
      t[e] = 1024;
  }, n45.BitTreeDecoder = function(t) {
    this._models = [], this._numBitLevels = t;
  }, n45.BitTreeDecoder.prototype.init = function() {
    n45.initBitModels(this._models, 1 << this._numBitLevels);
  }, n45.BitTreeDecoder.prototype.decode = function(t) {
    for (var e = 1, r = this._numBitLevels; r--; )
      e = e << 1 | t.decodeBit(this._models, e);
    return e - (1 << this._numBitLevels);
  }, n45.BitTreeDecoder.prototype.reverseDecode = function(t) {
    for (var e = 1, r = 0, o = 0, s; o < this._numBitLevels; ++o)
      s = t.decodeBit(this._models, e), e = e << 1 | s, r |= s << o;
    return r;
  }, n45.reverseDecode2 = function(t, e, r, o) {
    for (var s = 1, u = 0, l = 0, c; l < o; ++l)
      c = r.decodeBit(t, e + s), s = s << 1 | c, u |= c << l;
    return u;
  }, n45.LenDecoder = function() {
    this._choice = [], this._lowCoder = [], this._midCoder = [], this._highCoder = new n45.BitTreeDecoder(8), this._numPosStates = 0;
  }, n45.LenDecoder.prototype.create = function(t) {
    for (; this._numPosStates < t; ++this._numPosStates)
      this._lowCoder[this._numPosStates] = new n45.BitTreeDecoder(3), this._midCoder[this._numPosStates] = new n45.BitTreeDecoder(3);
  }, n45.LenDecoder.prototype.init = function() {
    var t = this._numPosStates;
    for (n45.initBitModels(this._choice, 2); t--; )
      this._lowCoder[t].init(), this._midCoder[t].init();
    this._highCoder.init();
  }, n45.LenDecoder.prototype.decode = function(t, e) {
    return t.decodeBit(this._choice, 0) === 0 ? this._lowCoder[e].decode(t) : t.decodeBit(this._choice, 1) === 0 ? 8 + this._midCoder[e].decode(t) : 16 + this._highCoder.decode(t);
  }, n45.Decoder2 = function() {
    this._decoders = [];
  }, n45.Decoder2.prototype.init = function() {
    n45.initBitModels(this._decoders, 768);
  }, n45.Decoder2.prototype.decodeNormal = function(t) {
    var e = 1;
    do
      e = e << 1 | t.decodeBit(this._decoders, e);
    while (e < 256);
    return e & 255;
  }, n45.Decoder2.prototype.decodeWithMatchByte = function(t, e) {
    var r = 1, o, s;
    do
      if (o = e >> 7 & 1, e <<= 1, s = t.decodeBit(this._decoders, (1 + o << 8) + r), r = r << 1 | s, o !== s) {
        for (; r < 256; )
          r = r << 1 | t.decodeBit(this._decoders, r);
        break;
      }
    while (r < 256);
    return r & 255;
  }, n45.LiteralDecoder = function() {
  }, n45.LiteralDecoder.prototype.create = function(t, e) {
    var r;
    if (!(this._coders && this._numPrevBits === e && this._numPosBits === t))
      for (this._numPosBits = t, this._posMask = (1 << t) - 1, this._numPrevBits = e, this._coders = [], r = 1 << this._numPrevBits + this._numPosBits; r--; )
        this._coders[r] = new n45.Decoder2();
  }, n45.LiteralDecoder.prototype.init = function() {
    for (var t = 1 << this._numPrevBits + this._numPosBits; t--; )
      this._coders[t].init();
  }, n45.LiteralDecoder.prototype.getDecoder = function(t, e) {
    return this._coders[((t & this._posMask) << this._numPrevBits) + ((e & 255) >>> 8 - this._numPrevBits)];
  }, n45.Decoder = function() {
    this._outWindow = new n45.OutWindow(), this._rangeDecoder = new n45.RangeDecoder(), this._isMatchDecoders = [], this._isRepDecoders = [], this._isRepG0Decoders = [], this._isRepG1Decoders = [], this._isRepG2Decoders = [], this._isRep0LongDecoders = [], this._posSlotDecoder = [], this._posDecoders = [], this._posAlignDecoder = new n45.BitTreeDecoder(4), this._lenDecoder = new n45.LenDecoder(), this._repLenDecoder = new n45.LenDecoder(), this._literalDecoder = new n45.LiteralDecoder(), this._dictionarySize = -1, this._dictionarySizeCheck = -1, this._posSlotDecoder[0] = new n45.BitTreeDecoder(6), this._posSlotDecoder[1] = new n45.BitTreeDecoder(6), this._posSlotDecoder[2] = new n45.BitTreeDecoder(6), this._posSlotDecoder[3] = new n45.BitTreeDecoder(6);
  }, n45.Decoder.prototype.setDictionarySize = function(t) {
    return t < 0 ? false : (this._dictionarySize !== t && (this._dictionarySize = t, this._dictionarySizeCheck = Math.max(this._dictionarySize, 1), this._outWindow.create(Math.max(this._dictionarySizeCheck, 4096))), true);
  }, n45.Decoder.prototype.setLcLpPb = function(t, e, r) {
    var o = 1 << r;
    return t > 8 || e > 4 || r > 4 ? false : (this._literalDecoder.create(e, t), this._lenDecoder.create(o), this._repLenDecoder.create(o), this._posStateMask = o - 1, true);
  }, n45.Decoder.prototype.init = function() {
    var t = 4;
    for (this._outWindow.init(false), n45.initBitModels(this._isMatchDecoders, 192), n45.initBitModels(this._isRep0LongDecoders, 192), n45.initBitModels(this._isRepDecoders, 12), n45.initBitModels(this._isRepG0Decoders, 12), n45.initBitModels(this._isRepG1Decoders, 12), n45.initBitModels(this._isRepG2Decoders, 12), n45.initBitModels(this._posDecoders, 114), this._literalDecoder.init(); t--; )
      this._posSlotDecoder[t].init();
    this._lenDecoder.init(), this._repLenDecoder.init(), this._posAlignDecoder.init(), this._rangeDecoder.init();
  }, n45.Decoder.prototype.decode = function(t, e, r) {
    var o = 0, s = 0, u = 0, l = 0, c = 0, f = 0, d = 0, h, v, A, g, p, y;
    for (this._rangeDecoder.setStream(t), this._outWindow.setStream(e), this.init(); r < 0 || f < r; )
      if (h = f & this._posStateMask, this._rangeDecoder.decodeBit(this._isMatchDecoders, (o << 4) + h) === 0)
        v = this._literalDecoder.getDecoder(f++, d), o >= 7 ? d = v.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(s)) : d = v.decodeNormal(this._rangeDecoder), this._outWindow.putByte(d), o = o < 4 ? 0 : o - (o < 10 ? 3 : 6);
      else {
        if (this._rangeDecoder.decodeBit(this._isRepDecoders, o) === 1)
          A = 0, this._rangeDecoder.decodeBit(this._isRepG0Decoders, o) === 0 ? this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (o << 4) + h) === 0 && (o = o < 7 ? 9 : 11, A = 1) : (this._rangeDecoder.decodeBit(this._isRepG1Decoders, o) === 0 ? g = u : (this._rangeDecoder.decodeBit(this._isRepG2Decoders, o) === 0 ? g = l : (g = c, c = l), l = u), u = s, s = g), A === 0 && (A = 2 + this._repLenDecoder.decode(this._rangeDecoder, h), o = o < 7 ? 8 : 11);
        else if (c = l, l = u, u = s, A = 2 + this._lenDecoder.decode(this._rangeDecoder, h), o = o < 7 ? 7 : 10, p = this._posSlotDecoder[A <= 5 ? A - 2 : 3].decode(this._rangeDecoder), p >= 4) {
          if (y = (p >> 1) - 1, s = (2 | p & 1) << y, p < 14)
            s += n45.reverseDecode2(this._posDecoders, s - p - 1, this._rangeDecoder, y);
          else if (s += this._rangeDecoder.decodeDirectBits(y - 4) << 4, s += this._posAlignDecoder.reverseDecode(this._rangeDecoder), s < 0) {
            if (s === -1)
              break;
            return false;
          }
        } else
          s = p;
        if (s >= f || s >= this._dictionarySizeCheck)
          return false;
        this._outWindow.copyBlock(s, A), f += A, d = this._outWindow.getByte(0);
      }
    return this._outWindow.flush(), this._outWindow.releaseStream(), this._rangeDecoder.releaseStream(), true;
  }, n45.Decoder.prototype.setDecoderProperties = function(t) {
    var e, r, o, s, u;
    return t.size < 5 || (e = t.readByte(), r = e % 9, e = ~~(e / 9), o = e % 5, s = ~~(e / 5), !this.setLcLpPb(r, o, s)) ? false : (u = t.readByte(), u |= t.readByte() << 8, u |= t.readByte() << 16, u += t.readByte() * 16777216, this.setDictionarySize(u));
  }, n45.decompress = function(t, e, r, o) {
    var s = new n45.Decoder();
    if (!s.setDecoderProperties(t))
      throw "Incorrect stream properties";
    if (!s.decode(e, r, o))
      throw "Error in data stream";
    return true;
  }, n45.decompressFile = function(t, e) {
    var r = new n45.Decoder(), o;
    if (!r.setDecoderProperties(t))
      throw "Incorrect stream properties";
    if (o = t.readByte(), o |= t.readByte() << 8, o |= t.readByte() << 16, o += t.readByte() * 16777216, t.readByte(), t.readByte(), t.readByte(), t.readByte(), !r.decode(t, e, o))
      throw "Error in data stream";
    return true;
  }, n45;
}
var LZMA = createLZMA();
function createWASM() {
  function n45(e) {
    for (var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = new Uint8Array(256), s = 0; s < r.length; s++)
      o[r.charCodeAt(s)] = s;
    var u = e.length * 0.75, l = e.length, c, f = 0, d, h, v, A;
    e[e.length - 1] === "=" && (u--, e[e.length - 2] === "=" && u--);
    var g = new ArrayBuffer(u), p = new Uint8Array(g);
    for (c = 0; c < l; c += 4)
      d = o[e.charCodeAt(c)], h = o[e.charCodeAt(c + 1)], v = o[e.charCodeAt(c + 2)], A = o[e.charCodeAt(c + 3)], p[f++] = d << 2 | h >> 4, p[f++] = (h & 15) << 4 | v >> 2, p[f++] = (v & 3) << 6 | A & 63;
    return g;
  }
  var t = "AGFzbQEAAAABSg1gAABgAX8Bf2ACf38Bf2AEf39/fwBgA39/fwBgAX8AYAJ/fwBgA39/fwF/YAR/f39/AX9gAn9/AGABfwF/YAABf2AEf39/fwF/AhsCA2VudgVhYm9ydAADA2VudgZtZW1vcnkCAAEDJiUBAQkKAgoKCwsLCwsAAgoBAgQKAQYFCAoFBQQEBwgCBwwCAQAABAQBcAABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwc9BgZtZW1vcnkCAAV0YWJsZQEABXJlc2V0AA0KbmV3VThBcnJheQAQCnVucGFja1NpemUAFAZkZWNvZGUAIwgBJAkHAQBBAAsBJQqAViVoAQN/IABBgICAgARLBEAACyMBIgEgAEEBIABBAUsbakEHakF4cSICPwAiA0EQdEsEQCADIAIgAWtB//8DakGAgHxxQRB2IgAgAyAAShtAAEEASARAIABAAEEASARAAAsLCyACJAEgAQsbAQF/QQFBICAAQQdqZ2t0EAEiASAANgIAIAELkQMBAX8gAUUEQA8LIABBADoAACAAIAFqQQFrQQA6AAAgAUECTQRADwsgAEEBakEAOgAAIABBAmpBADoAACAAIAFqIgJBAmtBADoAACACQQNrQQA6AAAgAUEGTQRADwsgAEEDakEAOgAAIAAgAWpBBGtBADoAACABQQhNBEAPC0EAIABrQQNxIgIgAGoiAEEANgIAIAEgAmtBfHEiASAAakEEa0EANgIAIAFBCE0EQA8LIABBBGpBADYCACAAQQhqQQA2AgAgACABaiICQQxrQQA2AgAgAkEIa0EANgIAIAFBGE0EQA8LIABBDGpBADYCACAAQRBqQQA2AgAgAEEUakEANgIAIABBGGpBADYCACAAIAFqIgJBHGtBADYCACACQRhrQQA2AgAgAkEUa0EANgIAIAJBEGtBADYCACAAQQRxQRhqIgIgAGohACABIAJrIQEDQCABQSBPBEAgAEIANwMAIABBCGpCADcDACAAQRBqQgA3AwAgAEEYakIANwMAIAFBIGshASAAQSBqIQAMAQsLC1EBA38gAEH+////AEsEQEEAQSBBLUEnEAAACyAAQQJ0IgMQAiECQQgQASIBQQA2AgAgAUEANgIEIAEgAjYCACABIAA2AgQgAkEIaiADEAMgAQtmAQF/IAFB/P///wFLBEBBAEHAAEEXQSIQAAALIAFBAXQiARACIgJBCGogARADIABFBEBBDBABIQALIABBADYCACAAQQA2AgQgAEEANgIIIAAgAjYCACAAQQA2AgQgACABNgIIIAALCgBBDBABIAAQBQsuAQF/QQgQASIBQQA2AgAgAUEANgIEIAEgADYCBCABQQEgASgCBHQQBjYCACABC6EBAQR/QRAQASIBQQA2AgAgAUEANgIEIAFBADYCCCABQQA2AgxBEBAEIQIDQCAAQRBIBEBBAxAHIQMgAigCACAAQQJ0aiADNgIIIABBAWohAAwBCwsgASACNgIEQRAQBCECQQAhAANAIABBEEgEQEEDEAchAyACKAIAIABBAnRqIAM2AgggAEEBaiEADAELCyABIAI2AgggAUEIEAc2AgwgAQs0AQF/QRQQASIAQQA2AgAgAEEAOgAEIABBADYCCCAAQQA2AgwgAEEANgIQIABBDTYCCCAAC0IBAX9BGRABIgBBADYCACAAQQA2AgQgAEEANgIIIABBADYCDCAAQQA2AhAgAEEANgIUIABBADoAGCAAQQA2AhAgAAu1AgEEf0HQABABIgBBADoAACAAQQA2AgQgAEEANgIIIABBADYCDCAAQQA2AhAgAEEAOgAUIABBADYCGCAAQQA2AhwgAEEANgIgIABBADYCJCAAQQA2AiggAEEANgIsIABBADYCMCAAQQA2AjQgAEEANgI4IABBADYCPCAAQQA2AkAgAEEANgJEIABBADYCSCAAQQA2AkxBBBAEIQIDQCABQQRIBEBBBhAHIQMgAigCACABQQJ0aiADNgIIIAFBAWohAQwBCwsgACACNgIkIABBBBAHNgIoIABB8wAQBjYCLCAAQcABEAY2AjAgAEEMEAY2AjQgAEEMEAY2AjggAEEMEAY2AjwgAEEMEAY2AkAgAEHAARAGNgJEIAAQCDYCSCAAEAg2AkwgABAJNgIEIAAQCjYCCCAACx8BAX9BCBABIgBBADYCACAAQQA2AgQgABALNgIAIAALCgAjACQBEAwkAwthAQF/IAFB+P///wNLBEBBAEHAAEEXQSIQAAALIAEQAiICQQhqIAEQAyAARQRAQQwQASEACyAAQQA2AgAgAEEANgIEIABBADYCCCAAIAI2AgAgAEEANgIEIAAgATYCCCAACwoAQQwQASAAEA4LBgAgABAPCyoAIAEgACgCCE8EQEEAQcAAQSdBPxAAAAsgACgCBCABIAAoAgBqai0ACAssACABIAAoAghPBEBBAEHAAEEyQT8QAAALIAAoAgQgASAAKAIAamogAjoACAtkAQJ/QQ0QDyECA0AgAUENSARAIAIgASAAIAEQEUH/AXEQEiABQQFqIQEMAQsLQQAhAEEAIQEDQCABQQhIBEAgAiABQQVqEBFB/wFxIAFBA3R0IAByIQAgAUEBaiEBDAELCyAACwYAIAAQEwsnACAAIAEQDzYCCCAAQQA2AgwgACABNgIUIABBADoAGCAAQQA2AgALJAAgACgCCCAAKAIYEBUgAEGABiAAKAIMIAAtABRqdBAGNgIgC5UBAQR/IAEhBSAAIgYoAgAhASAAKAIEIQcgACgCCEEBdiEEIAJBAEgEfyACIARqIgBBACAAQQBKGwUgAiIAIAQgACAESBsLIQIgA0EASAR/IAMgBGoiAEEAIABBAEobBSADIgAgBCAAIARIGwshAwNAIAIgA05FBEAgAkEBdCABaiAHaiAFOwEIIAJBAWohAgwBCwsgBgssAQF/AkACQAJAIwRBAWsOAwEBAgALAAtB/////wchAQsgAEGACEEAIAEQFwvBAQECfyAAQQIQBjYCACAAKAIAIgEoAgAgASgCBGpBgAg7AQggACgCACICKAIAIQEgAigCBCABQQJqakGACDsBCCAAKAIMKAIAQQEkBBAYGkEAIQIDQCACQRBIBEAgAiAAKAIEKAIAIgEoAgBBAnZJBH8gAkECdCABaigCCAUACygCAEEBJAQQGBogAiAAKAIIKAIAIgEoAgBBAnZJBH8gAkECdCABaigCCAUACygCAEEBJAQQGBogAkEBaiECDAELCwuHAgEFfyAAIQJBgAYgACgCDCAALQAUanQhAQNAIAMgAUgEQCACKAIgIgQoAgAhBSAEKAIEIANBAXQgBWpqQYAIOwEIIANBAWohAwwBCwsgAiEBQQAhAgNAIAJBBEkEQCACIAEoAiQoAgAiAygCAEECdkkEfyACQQJ0IANqKAIIBQALKAIAQQEkBBAYGiACQQFqIQIMAQsLIAEoAigoAgBBASQEEBgaIAEoAixBASQEEBgaIAAoAjBBASQEEBgaIAAoAjRBASQEEBgaIAAoAjhBASQEEBgaIAAoAjxBASQEEBgaIAAoAkBBASQEEBgaIAAoAkRBASQEEBgaIAAoAkgQGSAAKAJMEBkLyAwBA38DQCABQQNxIAIgAhsEQCAAIgRBAWohACABIgNBAWohASAEIAMtAAA6AAAgAkEBayECDAELCyAAQQNxRQRAA0AgAkEQTwRAIAAgASgCADYCACAAQQRqIAFBBGooAgA2AgAgAEEIaiABQQhqKAIANgIAIABBDGogAUEMaigCADYCACABQRBqIQEgAEEQaiEAIAJBEGshAgwBCwsgAkEIcQRAIAAgASgCADYCACAAQQRqIAFBBGooAgA2AgAgAUEIaiEBIABBCGohAAsgAkEEcQRAIAAgASgCADYCACABQQRqIQEgAEEEaiEACyACQQJxBEAgACABLwEAOwEAIAFBAmohASAAQQJqIQALIAJBAXEEQCAAIAEtAAA6AAALDwsgAkEgTwRAAkACQAJAIABBA3EiA0EBRwRAIANBAkYNASADQQNGDQIMAwsgASgCACEFIAAgASIDLQAAOgAAIABBAWoiASABIANBAWoiAS0AADoAAEEBaiIEQQFqIQAgAUEBaiIDQQFqIQEgBCADLQAAOgAAIAJBA2shAgNAIAJBEU8EQCAAIAFBAWooAgAiA0EIdCAFQRh2cjYCACAAQQRqIAFBBWooAgAiBUEIdCADQRh2cjYCACAAQQhqIAFBCWooAgAiA0EIdCAFQRh2cjYCACAAQQxqIAFBDWooAgAiBUEIdCADQRh2cjYCACABQRBqIQEgAEEQaiEAIAJBEGshAgwBCwsMAgsgASgCACEFIAAgAS0AADoAACAAQQFqIgRBAWohACABQQFqIgNBAWohASAEIAMtAAA6AAAgAkECayECA0AgAkESTwRAIAAgAUECaigCACIDQRB0IAVBEHZyNgIAIABBBGogAUEGaigCACIFQRB0IANBEHZyNgIAIABBCGogAUEKaigCACIDQRB0IAVBEHZyNgIAIABBDGogAUEOaigCACIFQRB0IANBEHZyNgIAIAFBEGohASAAQRBqIQAgAkEQayECDAELCwwBCyABKAIAIQUgACIEQQFqIQAgASIDQQFqIQEgBCADLQAAOgAAIAJBAWshAgNAIAJBE08EQCAAIAFBA2ooAgAiA0EYdCAFQQh2cjYCACAAQQRqIAFBB2ooAgAiBUEYdCADQQh2cjYCACAAQQhqIAFBC2ooAgAiA0EYdCAFQQh2cjYCACAAQQxqIAFBD2ooAgAiBUEYdCADQQh2cjYCACABQRBqIQEgAEEQaiEAIAJBEGshAgwBCwsLCyACQRBxBEAgACABIgMtAAA6AAAgAEEBaiIBIAEgA0EBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiAyADIAFBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiAyADIAFBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiAyADIAFBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiAyADIAFBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiBEEBaiEAIAFBAWoiA0EBaiEBIAQgAy0AADoAAAsgAkEIcQRAIAAgASIDLQAAOgAAIABBAWoiASABIANBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiAyADIAFBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgMgAyABQQFqIgEtAAA6AABBAWoiBEEBaiEAIAFBAWoiA0EBaiEBIAQgAy0AADoAAAsgAkEEcQRAIAAgASIDLQAAOgAAIABBAWoiASABIANBAWoiAS0AADoAAEEBaiIDIAMgAUEBaiIBLQAAOgAAQQFqIgRBAWohACABQQFqIgNBAWohASAEIAMtAAA6AAALIAJBAnEEQCAAIAEtAAA6AAAgAEEBaiIEQQFqIQAgAUEBaiIDQQFqIQEgBCADLQAAOgAACyACQQFxBEAgACABLQAAOgAACwvVAgECfyAAIAFGBEAPCyABIAJqIABNIgNFBEAgACACaiABTSEDCyADBEAgACABIAIQGw8LIAAgAUkEQCABQQdxIABBB3FGBEADQCAAQQdxBEAgAkUEQA8LIAJBAWshAiAAIgRBAWohACABIgNBAWohASAEIAMtAAA6AAAMAQsLA0AgAkEITwRAIAAgASkDADcDACACQQhrIQIgAEEIaiEAIAFBCGohAQwBCwsLA0AgAgRAIAAiBEEBaiEAIAEiA0EBaiEBIAQgAy0AADoAACACQQFrIQIMAQsLBSABQQdxIABBB3FGBEADQCAAIAJqQQdxBEAgAkUEQA8LIAJBAWsiAiAAaiABIAJqLQAAOgAADAELCwNAIAJBCE8EQCACQQhrIgIgAGogASACaikDADcDAAwBCwsLA0AgAgRAIAJBAWsiAiAAaiABIAJqLQAAOgAADAELCwsL4AoBCH8gACgCACIGIgQoAgAgBCgCBGovAQgiCCABIgcoAgxBC3ZsIQQgBygCECAESQR/QYAQIAhrQf//A3FBBXYgCGohCCAHIAQ2AgxBAAUgCCAIQf//A3FBBXZrIQggByAHKAIQIARrNgIQIAcgBygCDCAEazYCDEEBCyAGKAIEIAYoAgBqIAg7AQggByIFKAIMIwJJBEAgBSAFKAIMQQh0NgIMIAUoAhBBCHQhByAFKAIAIQYgBSAFKAIIIglBAWo2AgggBSAGIAkQEUH/AXEgB3I2AhALQf//A3FFBEAgAiAAKAIEKAIAIgAoAgBBAnZJBH8gAkECdCAAaigCCAUACyEDIAEhBEEBIQgDQCAKIAMoAgRJBEAgAygCACIHKAIAIQEgBCgCECAHKAIEIAgiBUEBdCIIIAFqai8BCCIGIAQoAgxBC3ZsIglJBH9BgBAgBmtB//8DcUEFdiAGaiEGIAQgCTYCDEEABSAGIAZB//8DcUEFdmshBiAEIAQoAhAgCWs2AhAgBCAEKAIMIAlrNgIMQQELIAcoAgQgBygCACAFQQF0amogBjsBCCAEKAIMIwJJBEAgBCAEKAIMQQh0NgIMIAQoAhBBCHQhACAEKAIAIQUgBCAEKAIIIgFBAWo2AgggBCAFIAEQEUH/AXEgAHI2AhALQf//A3EgCGohCCAKQQFqIQoMAQsLIAhBASADKAIEdGsPCyAAKAIAIgooAgAhCCAFKAIQIAooAgQgCEECamovAQgiBCABKAIMQQt2bCIDSQR/IAUgAzYCDEEAIQlBgBAgBGtB//8DcUEFdiAEagUgBSAFKAIQIANrNgIQIAUgBSgCDCADazYCDEEBIQkgBCAEQf//A3FBBXZrCyEEIAoiBygCBCAHKAIAQQJqaiAEOwEIIAUiBigCDCMCSQRAIAYgBigCDEEIdDYCDCAGKAIQQQh0IQUgBigCACEHIAYgBigCCCIIQQFqNgIIIAYgByAIEBFB/wFxIAVyNgIQCyAJQf//A3FFBEAgAiAAKAIIKAIAIgAoAgBBAnZJBH8gAkECdCAAaigCCAUACyEJIAEhA0EBIQRBACECA0AgAiAJKAIESQRAIAMoAhAgCSgCACIFKAIEIAQiBkEBdCIEIAUoAgBqai8BCCIHIAMoAgxBC3ZsIghJBH9BgBAgB2tB//8DcUEFdiAHaiEHIAMgCDYCDEEABSAHIAdB//8DcUEFdmshByADIAMoAhAgCGs2AhAgAyADKAIMIAhrNgIMQQELIAUoAgQgBSgCACAGQQF0amogBzsBCCADKAIMIwJJBEAgAyADKAIMQQh0NgIMIAMoAhBBCHQhBSADKAIAIQcgAyADKAIIIgZBAWo2AgggAyAHIAYQEUH/AXEgBXI2AhALQf//A3EgBGohBCACQQFqIQIMAQsLIARBASAJKAIEdGtBCGoPCyAAKAIMIQQgASEDQQEhCUEAIQIDQCACIAQoAgRJBEAgBCgCACIIKAIAIQogAygCECAIKAIEIAogCSIHQQF0IgFqai8BCCIFIAMoAgxBC3ZsIgZJBH8gAyAGNgIMQQAhBkGAECAFa0H//wNxQQV2IAVqBSADIAMoAhAgBms2AhAgAyADKAIMIAZrNgIMQQEhBiAFIAVB//8DcUEFdmsLIQUgCCgCBCAIKAIAIAdBAXRqaiAFOwEIIAMoAgwjAkkEQCADIAMoAgxBCHQ2AgwgAygCEEEIdCEAIAMoAgAhBSADIAMoAggiCkEBajYCCCADIAUgChARQf8BcSAAcjYCEAsgBkH//wNxIAFqIQkgAkEBaiECDAELCyAJQQEgBCgCBHRrQRBqC5YCAQh/QQEhBwNAAkAgBiABTg0AIAIoAhAgACgCBCAAKAIAIAMgB2oiCUEBdGpqLwEIIgQgAigCDEELdmwiBUkEfyACIAU2AgxBACEFQYAQIARrQf//A3FBBXYgBGoFIAIgAigCECAFazYCECACIAIoAgwgBWs2AgxBASEFIAQgBEH//wNxQQV2awshBCAAKAIEIAAoAgAgCUEBdGpqIAQ7AQggAiIEKAIMIwJJBEAgBCAEKAIMQQh0NgIMIAQoAhBBCHQhCiAEKAIAIQsgBCAEKAIIIglBAWo2AgggBCALIAkQEUH/AXEgCnI2AhALIAVB//8DcSIEIAdBAXRqIQcgBCAGdCAIciEIIAZBAWohBgwBCwsgCAvwBAEIf0EDIAEgAUEDSxsiAiAAKAIkKAIAIgEoAgBBAnZJBH8gAkECdCABaigCCAUACyEEIAAoAgQhAkEBIQEDQCAHIAQoAgRJBEAgBCgCACIFKAIAIQMgAigCECAFKAIEIAFBAXQiCSADamovAQgiAyACKAIMQQt2bCIGSQR/IAIgBjYCDEEAIQhBgBAgA2tB//8DcUEFdiADagUgAiACKAIQIAZrNgIQIAIgAigCDCAGazYCDEEBIQggAyADQf//A3FBBXZrCyEDIAUoAgQgBSgCACABQQF0amogAzsBCCACKAIMIwJJBEAgAiACKAIMQQh0NgIMIAIoAhBBCHQhBiACKAIAIQUgAiACKAIIIgNBAWo2AgggAiAFIAMQEUH/AXEgBnI2AhALIAhB//8DcSAJaiEBIAdBAWohBwwBCwsgAUEBIAQoAgR0ayIBQQRJBEAgAQ8LIAFBAXFBAnIgAUEBdkEBayICdCEDIAFBDkkEfyAAKAIsIAIgACgCBCADIAFrEB4gA2oFIAAoAgQhASACQQRrIQJBACEEA0AgASABKAIMQQF2NgIMIAEgASgCECABKAIMazYCECABIAEoAhBBACABKAIQQR92ayIHIAEoAgxxajYCECABKAIQIAEoAgxGBEAgAUEBOgAECyABKAIMIwJJBEAgASABKAIMQQh0NgIMIAEoAhBBCHQhBSABKAIAIQggASABKAIIIgZBAWo2AgggASAIIAYQEUH/AXEgBXI2AhALIAdBAWogBEEBdGohBCACQQFrIgINAAsgBEEEdCADaiAAKAIoIgQoAgAgBCgCBCAAKAIEQQAQHmoLC9AcAQ9/IAAQGiAAKAIEIgdBADoABCAHKAIAIAcgBygCCCIDQQFqNgIIIAMQEUH/AXEEQCAHQQE6AAQLIAdBfzYCDCAHQQA2AhBBACEDA0AgA0EESARAIAcoAhBBCHQhBSAHKAIAIQwgByAHKAIIIghBAWo2AgggByAMIAgQEUH/AXEgBXI2AhAgA0EBaiEDDAELCyAHKAIQIAcoAgxGBEAgB0EBOgAECyABBEAgACgCCCACEA82AgQFIAAoAghBBBAPNgIEC0EAIQwDQAJAIAJFIAEgARsiBwR/IAAtAABFBSAHCwRAIAAoAgQoAhBFBEBBAw8LCyAAKAIwIgUoAgAhByAFKAIEIAAoAggoAgBBASAAKAIQdEEBa3EiCyAMQQR0Qf8BcWoiBkEBdCAHamovAQghAyAGIQcgACgCBCIEKAIMQQt2IANsIQggBCgCECAISQR/IAQgCDYCDEEAIQlBgBAgA2tB//8DcUEFdiADagUgBCAEKAIQIAhrNgIQIAQgBCgCDCAIazYCDEEBIQkgAyADQf//A3FBBXZrCyEIIAUiAygCBCADKAIAIAdBAXRqaiAIOwEIIAQiBigCDCMCSQRAIAYgBigCDEEIdDYCDCAGKAIQQQh0IQggBigCACEDIAYgBigCCCIHQQFqNgIIIAYgAyAHEBFB/wFxIAhyNgIQCyAJQf//A3FFBEAgAkUgASABGw0BIAwhCEEAIQYgACgCCCIFKAIMRSIEBH8gBS0AGEUFIAQLRQRAIAAoAggiBSgCCCIGKAIEQQEgBSgCDEwEfyAFKAIMQQFrBSAFKAIMIAUoAhRBAWtqCyAGKAIAamotAAghBgtBASEEIAAoAggoAgBBASAALQAUdEEBa3EgACgCDHQgBkEIIAAoAgxrdmpBgAZsIQcgCEEHTwRAIAAoAggiBigCCCIJKAIEIA5BAWoiDSAGKAIMTAR/IAYoAgwgDWsFIAYoAgwgBigCFCANa2oLIAkoAgBqai0ACCENA0ACQCANQf8BcUEHdiEGIA1BAXQhDSAAKAIgIgkoAgAhCyAJKAIEIAZBAWpBCHQgB2ogBGoiDEEBdCALamovAQgiCyAAKAIEIgMoAgxBC3ZsIQogAygCECAKSQR/QYAQIAtrQf//A3FBBXYgC2ohCyADIAo2AgxBAAUgCyALQf//A3FBBXZrIQsgAyADKAIQIAprNgIQIAMgAygCDCAKazYCDEEBCyEFIAkoAgQgCSgCACAMQQF0amogCzsBCCADIgooAgwjAkkEQCAKIAooAgxBCHQ2AgwgCigCEEEIdCEDIAooAgAhDCAKIAooAggiC0EBajYCCCAKIAwgCxARQf8BcSADcjYCEAsgBEEBdCAFciEEIAVB//8DcSAGRw0AIARB//8DcUGAAkkNAQsLCwNAIARBgAJJBEAgBEEBdCEJIAAoAiAiBSgCACEMIAUoAgQgBCAHaiIGQQF0IAxqai8BCCILIAAoAgQiDSgCDEELdmwhCiANKAIQIApJBH9BgBAgC2tB//8DcUEFdiALaiELIA0gCjYCDEEABSALIAtB//8DcUEFdmshCyANIA0oAhAgCms2AhAgDSANKAIMIAprNgIMQQELIAUoAgQgBSgCACAGQQF0amogCzsBCCANIgooAgwjAkkEQCAKIAooAgxBCHQ2AgwgCigCEEEIdCEGIAooAgAhBSAKIAooAggiDEEBajYCCCAKIAUgDBARQf8BcSAGcjYCEAsgCXIhBAwBCwsgACgCCCIDIAMoAgBBAWo2AgAgAygCCCELIAMgAygCDCIGQQFqNgIMIAsoAgQgCygCACAGamogBEGAAmsiCjoACCADKAIMIAMoAhRGBEAgA0EANgIMIANBAToAGAsgAygCBCgCCCADKAIQRgRAIAMgAygCBCIGKAIIQQF0EA82AgQgAygCBCgCACADKAIEKAIEakEIaiAGKAIAIAYoAgRqQQhqIAYoAggQHCAGKAIAGgsgAygCBCEJIAMgAygCECIMQQFqNgIQIAkoAgQgCSgCACAMamogCjoACCAIIgVBBEkEf0EABSAFQQNrIAVBBmsgBUEKSRsLIQwgAkEBayECDAILIAAoAjQiBigCACEFIAYoAgQgDCIDQQF0IAVqai8BCCIHIAAoAgQiCigCDEELdmwhBCAKKAIQIARJBH9BgBAgB2tB//8DcUEFdiAHaiEHIAogBDYCDEEABSAHIAdB//8DcUEFdmshByAKIAooAhAgBGs2AhAgCiAKKAIMIARrNgIMQQELIAMhBSAGIgMoAgAhDSADKAIEIAVBAXQgDWpqIAc7AQggCiIJKAIMIwJJBEAgCSAJKAIMQQh0NgIMIAkoAhBBCHQhBiAJKAIAIQMgCSAJKAIIIgVBAWo2AgggCSADIAUQEUH/AXEgBnI2AhALQf//A3EEQCACRSABIAEbDQEgACgCCCIIKAIMRSIEBH8gCC0AGEUFIAQLDQEgACgCOCIDKAIAIQggAygCBCAMQQF0IAhqai8BCCIEIAAoAgQiBSgCDEELdmwhByAFKAIQIAdJBH9BgBAgBGtB//8DcUEFdiAEaiEEIAUgBzYCDEEABSAEIARB//8DcUEFdmshBCAFIAUoAhAgB2s2AhAgBSAFKAIMIAdrNgIMQQELIAMoAgQgAygCACAMQQF0amogBDsBCCAFIgkoAgwjAkkEQCAJIAkoAgxBCHQ2AgwgCSgCEEEIdCEFIAkoAgAhAyAJIAkoAggiCEEBajYCCCAJIAMgCBARQf8BcSAFcjYCEAtB//8DcQRAIAAoAjwiCCgCACEHIAgoAgQgDEEBdCAHamovAQgiBCAAKAIEIgUoAgxBC3ZsIQYgBSgCECAGSQR/QYAQIARrQf//A3FBBXYgBGohBCAFIAY2AgxBAAUgBCAEQf//A3FBBXZrIQQgBSAFKAIQIAZrNgIQIAUgBSgCDCAGazYCDEEBCyAIIgMoAgQgAygCACAMQQF0amogBDsBCCAFIgkoAgwjAkkEQCAJIAkoAgxBCHQ2AgwgCSgCEEEIdCEIIAkoAgAhAyAJIAkoAggiB0EBajYCCCAJIAMgBxARQf8BcSAIcjYCEAtB//8DcQRAIAAoAkAiAygCACEKIAMoAgQgDEEBdCAKamovAQgiBiAAKAIEIgcoAgxBC3ZsIQQgBygCECAESQR/QYAQIAZrQf//A3FBBXYgBmohBiAHIAQ2AgxBAAUgBiAGQf//A3FBBXZrIQYgByAHKAIQIARrNgIQIAcgBygCDCAEazYCDEEBCyADKAIEIAMoAgAgDEEBdGpqIAY7AQggByIJKAIMIwJJBEAgCSAJKAIMQQh0NgIMIAkoAhBBCHQhCCAJKAIAIQMgCSAJKAIIIgpBAWo2AgggCSADIAoQEUH/AXEgCHI2AhALQf//A3EEQCARIQMgDyERBSAPIQMLIBAhDwUgECEDCyAOIRAgAyEOBSAAKAJEIgYoAgAhCiAGKAIEIAxBBHRB/wFxIAtqIgNBAXQgCmpqLwEIIgcgACgCBCIIKAIMQQt2bCEEIAgoAhAgBEkEf0GAECAHa0H//wNxQQV2IAdqIQcgCCAENgIMQQAFIAcgB0H//wNxQQV2ayEHIAggCCgCECAEazYCECAIIAgoAgwgBGs2AgxBAQsgAyEKIAYiAygCACENIAMoAgQgCkEBdCANamogBzsBCCAIIgkoAgwjAkkEQCAJIAkoAgxBCHQ2AgwgCSgCEEEIdCEIIAkoAgAhAyAJIAkoAggiCkEBajYCCCAJIAMgChARQf8BcSAIcjYCEAtB//8DcUUEQEEJQQsgDEEHSRshDCAAKAIIIQQgACgCCCIFKAIIIgMoAgQgDkEBaiIHIAUoAgxMBH8gBSgCDCAHawUgBSgCDCAFKAIUIAdragsgAygCAGpqLQAIIQcgBCAEKAIAQQFqNgIAIAQoAgghBSAEIAQoAgwiBkEBajYCDCAFKAIEIAUoAgAgBmpqIAc6AAggBCgCDCAEKAIURgRAIARBADYCDCAEQQE6ABgLIAQoAgQoAgggBCgCEEYEQCAEIAQoAgQiBigCCEEBdBAPNgIEIAQoAgQoAgAgBCgCBCgCBGpBCGogBigCACAGKAIEakEIaiAGKAIIEBwgBigCABoLIAQoAgQhAyAEIAQoAhAiCEEBajYCECADKAIEIAMoAgAgCGpqIAc6AAggAkEBayECDAQLCyAAKAJMIAAoAgQgCxAdIQtBCEELIAxBB0kbIQwFIA8hESAQIQ8gDiEQQQdBCiAMQQdJGyEMIAAgACgCSCAAKAIEIAsQHSILEB8iDkF/RgRAIAAoAgQoAhAEf0EBBUECCw8LIAJFIAEgARsNASAOIAAoAhhPIgUEfyAFBSAOIAAoAggiBCgCDEwiBgR/IAYFIAQtABgLRQsNAQtBACENIAAoAgghBSAOQQFqIQQgAiALQQJqIgtIIAEgARsEQEEBIQ0gAiELCyALIQYDQCAGQQBKBEAgBSIIKAIIIgkoAgQgBCAFKAIMTAR/IAUoAgwgBGsFIAUoAgwgBSgCFCAEa2oLIAkoAgBqai0ACCEHIAggCCgCAEEBajYCACAIKAIIIQMgCCAIKAIMIgpBAWo2AgwgAygCBCADKAIAIApqaiAHOgAIIAgoAgwgCCgCFEYEQCAIQQA2AgwgCEEBOgAYCyAIKAIEKAIIIAgoAhBGBEAgCCAIKAIEIgMoAghBAXQQDzYCBCAIKAIEKAIAIAgoAgQoAgRqQQhqIAMoAgAgAygCBGpBCGogAygCCBAcIAMoAgAaCyAIKAIEIQkgCCAIKAIQIgNBAWo2AhAgCSgCBCAJKAIAIANqaiAHOgAIIAZBAWshBgwBCwsgAiALayECIA1FDQELC0EBCyYBAX9BEBABIgQgADYCACAEIAE2AgQgBCACNgIIIAQgAzYCDCAEC7YEAQZ/IAAgATYCBEENEA8hAgNAAkAgA0ENTg0AIAIgAyABIAMQEUH/AXEQEiADQQFqIQMMAQsLIAAoAgAhBCACIQZBBBAPIgIoAgQgAigCAGogBigCBCAGKAIAai0ACCIDOgAIIANB/wFxQeEBTwRAQQBBgAFBoQFBDBAAAAsgAigCBCACKAIAQQFqaiADQf8BcUEJcCIHOgAIIAIoAgQgAigCAGogA0H/AXFBCW4iAzoACCADQQVwIQUgAigCBCACKAIAQQJqaiADQQVuIgM6AAggAigCBCACKAIAQQNqaiAFOgAIIAQgBzYCDCAEIAM2AhAgBCAFOgAUIARBADYCHEEAIQIDQAJAIAJBBE8NACAEIAQoAhwgBigCBCAGKAIAIAJBAWpqai0ACCACQQN0dHI2AhwgAkEBaiECDAELCyAEIAQoAhw2AhggBCgCGEGAIEkEQCAEQYAgNgIYC0EAIQJBACEFQQAhAwNAAkAgA0EITg0AIAYgA0EFahARQf8BcSIEQf8BRwRAQQEhBQsgBCADQQN0dCACciECIANBAWohAwwBCwsgACgCACAFRToAACAAKAIAKAIEIAE2AgAgACgCABAWAkAgACgCACAFIAIQICIBQQFGDQAgAUEDRwRAIAFBAkYEQCAFBEAgACgCACgCCCgCECACRw0DCwUMAgsLIAAoAgAoAgQtAAQaQQFBACAAKAIAKAIIKAIQIAAoAgAoAggoAgQQIQ8LQQBBAUEAQQAQIQsIACMDIAAQIgsWAEG4ASQAIwAkAUGAgIAIJAIQDCQDCwMAAQsLtwEEAEEICxcKAAAAdQBzAGUAIABzAHQAcgBpAGMAdABBIAsdDQAAAH4AbABpAGIALwBhAHIAcgBhAHkALgB0AHMAQcAACzkbAAAAfgBsAGkAYgAvAGkAbgB0AGUAcgBuAGEAbAAvAHQAeQBwAGUAZABhAHIAcgBhAHkALgB0AHMAQYABCzMYAAAAcwByAGMALwBsAHoAbQBhAC8AbAB6AG0AYQAtAGQAZQBjAG8AZABlAHIALgB0AHM=";
  return n45(t);
}
function decodeLZMA(n45, t, e) {
  try {
    var r = {
      data: t,
      offset: 0,
      readByte: function() {
        return this.data[this.offset++];
      }
    }, o = r.data.length, s = {
      data: [],
      offset: 0,
      writeByte: function(c) {
        var f = Math.floor(this.offset / o);
        this.data[f] || (this.data[f] = new Uint8Array(o)), this.data[f][this.offset % o] = c, this.offset++;
      }
    };
    n45.decompressFile(r, s);
    for (var u = new Uint8Array(s.offset), l = 0; l < s.offset; l++)
      u[l] = s.data[Math.floor(l / o)][l % o];
    e(null, u);
  } catch (c) {
    e(c);
  }
}
function decodeLZMAWithWASM(n45, t, e) {
  var r = 24;
  try {
    var o = new WebAssembly.Memory({ initial: 16 }), s = new WebAssembly.Module(n45), u = new WebAssembly.Instance(s, {
      env: {
        memory: o,
        abort: function() {
          e(new Error("webAssembly abort"));
        }
      }
    }), l = u.exports, c = l.newU8Array(t.length), f = new Uint8Array(o.buffer, c + r, t.length);
    f.set(t);
    var d = l.decode(c), h = new Uint32Array(o.buffer, d, 4), v = h[0], A = h[2], g = h[3];
    v ? e(null, new Uint8Array(o.buffer, g + r, A).slice(0, A)) : e(new Error("lzma deocder error"));
  } catch (p) {
    e(p);
  }
}
var lzmaWorkerSource = `
var decodeLZMA = (function() {
  var LZMA = (`.concat(createLZMA.toString(), `)();
  return function(data, callback) {
    return (`).concat(decodeLZMA.toString(), `)(LZMA, data, callback);
  }
})();

var decodeLZMAWithWASM = (function() {
  var LZMA_WASM = (`).concat(createWASM.toString(), `)();
  return function(data, callback) {
    return (`).concat(decodeLZMAWithWASM.toString(), `)(LZMA_WASM, data, callback);
  }
})();

self.onmessage = function(event) {
  var packet = event.data;
  if (!packet.id) {
    postMessage({ id: packet.id, error: "No incoming id." });
    return;
  }
  if (!packet.data) {
    postMessage({ id: packet.id, error: "No input data." });
    return;
  }
  if (packet.type == "decompress") {
    if (packet.data.constructor !== Uint8Array) {
      postMessage({ id: packet.id, error: "Input data is not Uint8Array." });
    }
    const callback = function(error, result) {
      if (error) {
        postMessage({ id: packet.id, error: error.toString() });
      } else {
        postMessage({ id: packet.id, result: result, error: null }, [ result.buffer ]);
      }
    }
    if (typeof WebAssembly !== "undefined" && WebAssembly.instantiate) {
      decodeLZMAWithWASM(packet.data, callback);
    } else {
      decodeLZMA(packet.data, callback);
    }
    return;
  }
  postMessage({ id: packet.id, error: "type never matched." });
};
`);
var support = typeof Worker != "undefined" && typeof Blob != "undefined";
var lzmaWorkerURL = "";
if (support)
  try {
    blob = new Blob([lzmaWorkerSource], { type: "text/javascript" });
    lzmaWorkerURL = URL.createObjectURL(blob);
  } catch (n45) {
  }
var blob;
var LZMAWorker = (
  /** @class */
  function() {
    function n45() {
      var t = this;
      if (!support)
        throw new Error("LZMAWorker cannot work in this broswer.");
      this.callCounter = 0, this.requests = {};
      var e = this.worker = new Worker(lzmaWorkerURL);
      e.onmessage = function(r) {
        var o = r.data, s = o.id, u = o.result, l = o.error, c = t.getKey(s);
        t.requests[c] && (l ? t.requests[c](new Error(l)) : t.requests[c](null, u), delete t.requests[c]);
      }, e.onerror = function(r) {
        return console.error(r);
      };
    }
    return n45.prototype.getKey = function(t) {
      return "key_" + String(t);
    }, n45.prototype.decompress = function(t, e) {
      var r = ++this.callCounter;
      this.requests[this.getKey(r)] = e, this.worker.postMessage({ type: "decompress", id: r, data: t }, [t.buffer]);
    }, n45.prototype.terminate = function() {
      this.worker.terminate();
    }, n45.support = support, n45;
  }()
);
function readUint32(n45) {
  return Array.prototype.reduce.call(n45, function(t, e, r) {
    return t | e << r * 8;
  }, 0);
}
function binaryArrays(n45) {
  for (var t = [], e = n45.length, r = function(u) {
    var l = {
      data: n45[u],
      offset: 0,
      readByte: function() {
        return this.data[this.offset++];
      }
    }, c = l.data.length, f = {
      data: [],
      offset: 0,
      writeByte: function(h) {
        var v = Math.floor(this.offset / c);
        this.data[v] || (this.data[v] = new Uint8Array(c)), this.data[v][this.offset % c] = h, this.offset++;
      }
    };
    LZMA.decompressFile(l, f), o = new Uint8Array(f.offset);
    for (var d = 0; d < f.offset; d++)
      o[d] = f.data[Math.floor(d / c)][d % c];
    t.push(o);
  }, o, s = 0; s < e; s++)
    r(s);
  return t;
}
function binaryArraysWithWorker(n45) {
  for (var t = [], e = n45.length, r = function(s) {
    t.push(new Promise(function(u, l) {
      var c = new LZMAWorker();
      c.decompress(n45[s], function(f, d) {
        if (c.terminate(), f)
          return l(f);
        u(d);
      });
    }));
  }, o = 0; o < e; o++)
    r(o);
  return Promise.all(t);
}
function lzma(n45) {
  var t = new Uint8Array(n45), e = readUint32(t.slice(0, 4));
  if (e > 10)
    return Promise.reject(new Error("LZMA got too many sub chunks."));
  for (var r = [], o = [], s = 4 + e * 4, u = 0; u < e; u++)
    o[u] = readUint32(t.slice(4 + u * 4, 8 + u * 4)), u === e - 1 ? r[u] = t.subarray(s, s + o[u]) : r[u] = t.slice(s, s + o[u]), s += o[u];
  return LZMAWorker.support ? binaryArraysWithWorker(r) : Promise.resolve(binaryArrays(r));
}
var dequeuing = false;
var queue = [];
function dequeue(n45) {
  if (n45 === void 0 && (n45 = false), !(!n45 && dequeuing)) {
    dequeuing = true;
    var t = queue.shift();
    if (t) {
      try {
        t();
      } catch (e) {
      }
      AnimationFrameLoop.shared.add(function() {
        return dequeue(true);
      }, true, 2, -100);
    } else
      dequeuing = false;
  }
}
function delay(n45) {
  return new Promise(function(t, e) {
    var r = function() {
      try {
        t(n45());
      } catch (o) {
        e(o);
      }
    };
    queue.push(r), AnimationFrameLoop.shared.add(function() {
      return dequeue();
    }, true, 2, -100);
  });
}
var commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
var indexMinimal = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(n45, t) {
  for (var e = new Array(arguments.length - 1), r = 0, o = 2, s = true; o < arguments.length; )
    e[r++] = arguments[o++];
  return new Promise(function(l, c) {
    e[r] = function(d) {
      if (s)
        if (s = false, d)
          c(d);
        else {
          for (var h = new Array(arguments.length - 1), v = 0; v < h.length; )
            h[v++] = arguments[v];
          l.apply(null, h);
        }
    };
    try {
      n45.apply(t || null, e);
    } catch (f) {
      s && (s = false, c(f));
    }
  });
}
var base64$1 = {};
(function(n45) {
  var t = n45;
  t.length = function(l) {
    var c = l.length;
    if (!c)
      return 0;
    for (var f = 0; --c % 4 > 1 && l.charAt(c) === "="; )
      ++f;
    return Math.ceil(l.length * 3) / 4 - f;
  };
  for (var e = new Array(64), r = new Array(123), o = 0; o < 64; )
    r[e[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
  t.encode = function(l, c, f) {
    for (var d = null, h = [], v = 0, A = 0, g; c < f; ) {
      var p = l[c++];
      switch (A) {
        case 0:
          h[v++] = e[p >> 2], g = (p & 3) << 4, A = 1;
          break;
        case 1:
          h[v++] = e[g | p >> 4], g = (p & 15) << 2, A = 2;
          break;
        case 2:
          h[v++] = e[g | p >> 6], h[v++] = e[p & 63], A = 0;
          break;
      }
      v > 8191 && ((d || (d = [])).push(String.fromCharCode.apply(String, h)), v = 0);
    }
    return A && (h[v++] = e[g], h[v++] = 61, A === 1 && (h[v++] = 61)), d ? (v && d.push(String.fromCharCode.apply(String, h.slice(0, v))), d.join("")) : String.fromCharCode.apply(String, h.slice(0, v));
  };
  var s = "invalid encoding";
  t.decode = function(l, c, f) {
    for (var d = f, h = 0, v, A = 0; A < l.length; ) {
      var g = l.charCodeAt(A++);
      if (g === 61 && h > 1)
        break;
      if ((g = r[g]) === void 0)
        throw Error(s);
      switch (h) {
        case 0:
          v = g, h = 1;
          break;
        case 1:
          c[f++] = v << 2 | (g & 48) >> 4, v = g, h = 2;
          break;
        case 2:
          c[f++] = (v & 15) << 4 | (g & 60) >> 2, v = g, h = 3;
          break;
        case 3:
          c[f++] = (v & 3) << 6 | g, h = 0;
          break;
      }
    }
    if (h === 1)
      throw Error(s);
    return f - d;
  }, t.test = function(l) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(l);
  };
})(base64$1);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function(t, e, r) {
  return (this._listeners[t] || (this._listeners[t] = [])).push({
    fn: e,
    ctx: r || this
  }), this;
};
EventEmitter.prototype.off = function(t, e) {
  if (t === void 0)
    this._listeners = {};
  else if (e === void 0)
    this._listeners[t] = [];
  else
    for (var r = this._listeners[t], o = 0; o < r.length; )
      r[o].fn === e ? r.splice(o, 1) : ++o;
  return this;
};
EventEmitter.prototype.emit = function(t) {
  var e = this._listeners[t];
  if (e) {
    for (var r = [], o = 1; o < arguments.length; )
      r.push(arguments[o++]);
    for (o = 0; o < e.length; )
      e[o].fn.apply(e[o++].ctx, r);
  }
  return this;
};
var float = factory(factory);
function factory(n45) {
  return typeof Float32Array != "undefined" ? function() {
    var t = new Float32Array([-0]), e = new Uint8Array(t.buffer), r = e[3] === 128;
    function o(c, f, d) {
      t[0] = c, f[d] = e[0], f[d + 1] = e[1], f[d + 2] = e[2], f[d + 3] = e[3];
    }
    function s(c, f, d) {
      t[0] = c, f[d] = e[3], f[d + 1] = e[2], f[d + 2] = e[1], f[d + 3] = e[0];
    }
    n45.writeFloatLE = r ? o : s, n45.writeFloatBE = r ? s : o;
    function u(c, f) {
      return e[0] = c[f], e[1] = c[f + 1], e[2] = c[f + 2], e[3] = c[f + 3], t[0];
    }
    function l(c, f) {
      return e[3] = c[f], e[2] = c[f + 1], e[1] = c[f + 2], e[0] = c[f + 3], t[0];
    }
    n45.readFloatLE = r ? u : l, n45.readFloatBE = r ? l : u;
  }() : function() {
    function t(r, o, s, u) {
      var l = o < 0 ? 1 : 0;
      if (l && (o = -o), o === 0)
        r(1 / o > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), s, u);
      else if (isNaN(o))
        r(2143289344, s, u);
      else if (o > 34028234663852886e22)
        r((l << 31 | 2139095040) >>> 0, s, u);
      else if (o < 11754943508222875e-54)
        r((l << 31 | Math.round(o / 1401298464324817e-60)) >>> 0, s, u);
      else {
        var c = Math.floor(Math.log(o) / Math.LN2), f = Math.round(o * Math.pow(2, -c) * 8388608) & 8388607;
        r((l << 31 | c + 127 << 23 | f) >>> 0, s, u);
      }
    }
    n45.writeFloatLE = t.bind(null, writeUintLE), n45.writeFloatBE = t.bind(null, writeUintBE);
    function e(r, o, s) {
      var u = r(o, s), l = (u >> 31) * 2 + 1, c = u >>> 23 & 255, f = u & 8388607;
      return c === 255 ? f ? NaN : l * (1 / 0) : c === 0 ? l * 1401298464324817e-60 * f : l * Math.pow(2, c - 150) * (f + 8388608);
    }
    n45.readFloatLE = e.bind(null, readUintLE), n45.readFloatBE = e.bind(null, readUintBE);
  }(), typeof Float64Array != "undefined" ? function() {
    var t = new Float64Array([-0]), e = new Uint8Array(t.buffer), r = e[7] === 128;
    function o(c, f, d) {
      t[0] = c, f[d] = e[0], f[d + 1] = e[1], f[d + 2] = e[2], f[d + 3] = e[3], f[d + 4] = e[4], f[d + 5] = e[5], f[d + 6] = e[6], f[d + 7] = e[7];
    }
    function s(c, f, d) {
      t[0] = c, f[d] = e[7], f[d + 1] = e[6], f[d + 2] = e[5], f[d + 3] = e[4], f[d + 4] = e[3], f[d + 5] = e[2], f[d + 6] = e[1], f[d + 7] = e[0];
    }
    n45.writeDoubleLE = r ? o : s, n45.writeDoubleBE = r ? s : o;
    function u(c, f) {
      return e[0] = c[f], e[1] = c[f + 1], e[2] = c[f + 2], e[3] = c[f + 3], e[4] = c[f + 4], e[5] = c[f + 5], e[6] = c[f + 6], e[7] = c[f + 7], t[0];
    }
    function l(c, f) {
      return e[7] = c[f], e[6] = c[f + 1], e[5] = c[f + 2], e[4] = c[f + 3], e[3] = c[f + 4], e[2] = c[f + 5], e[1] = c[f + 6], e[0] = c[f + 7], t[0];
    }
    n45.readDoubleLE = r ? u : l, n45.readDoubleBE = r ? l : u;
  }() : function() {
    function t(r, o, s, u, l, c) {
      var f = u < 0 ? 1 : 0;
      if (f && (u = -u), u === 0)
        r(0, l, c + o), r(1 / u > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), l, c + s);
      else if (isNaN(u))
        r(0, l, c + o), r(2146959360, l, c + s);
      else if (u > 17976931348623157e292)
        r(0, l, c + o), r((f << 31 | 2146435072) >>> 0, l, c + s);
      else {
        var d;
        if (u < 22250738585072014e-324)
          d = u / 5e-324, r(d >>> 0, l, c + o), r((f << 31 | d / 4294967296) >>> 0, l, c + s);
        else {
          var h = Math.floor(Math.log(u) / Math.LN2);
          h === 1024 && (h = 1023), d = u * Math.pow(2, -h), r(d * 4503599627370496 >>> 0, l, c + o), r((f << 31 | h + 1023 << 20 | d * 1048576 & 1048575) >>> 0, l, c + s);
        }
      }
    }
    n45.writeDoubleLE = t.bind(null, writeUintLE, 0, 4), n45.writeDoubleBE = t.bind(null, writeUintBE, 4, 0);
    function e(r, o, s, u, l) {
      var c = r(u, l + o), f = r(u, l + s), d = (f >> 31) * 2 + 1, h = f >>> 20 & 2047, v = 4294967296 * (f & 1048575) + c;
      return h === 2047 ? v ? NaN : d * (1 / 0) : h === 0 ? d * 5e-324 * v : d * Math.pow(2, h - 1075) * (v + 4503599627370496);
    }
    n45.readDoubleLE = e.bind(null, readUintLE, 0, 4), n45.readDoubleBE = e.bind(null, readUintBE, 4, 0);
  }(), n45;
}
function writeUintLE(n45, t, e) {
  t[e] = n45 & 255, t[e + 1] = n45 >>> 8 & 255, t[e + 2] = n45 >>> 16 & 255, t[e + 3] = n45 >>> 24;
}
function writeUintBE(n45, t, e) {
  t[e] = n45 >>> 24, t[e + 1] = n45 >>> 16 & 255, t[e + 2] = n45 >>> 8 & 255, t[e + 3] = n45 & 255;
}
function readUintLE(n45, t) {
  return (n45[t] | n45[t + 1] << 8 | n45[t + 2] << 16 | n45[t + 3] << 24) >>> 0;
}
function readUintBE(n45, t) {
  return (n45[t] << 24 | n45[t + 1] << 16 | n45[t + 2] << 8 | n45[t + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (n45) {
  }
  return null;
}
var utf8$2 = {};
(function(n45) {
  var t = n45;
  t.length = function(r) {
    for (var o = 0, s = 0, u = 0; u < r.length; ++u)
      s = r.charCodeAt(u), s < 128 ? o += 1 : s < 2048 ? o += 2 : (s & 64512) === 55296 && (r.charCodeAt(u + 1) & 64512) === 56320 ? (++u, o += 4) : o += 3;
    return o;
  }, t.read = function(r, o, s) {
    var u = s - o;
    if (u < 1)
      return "";
    for (var l = null, c = [], f = 0, d; o < s; )
      d = r[o++], d < 128 ? c[f++] = d : d > 191 && d < 224 ? c[f++] = (d & 31) << 6 | r[o++] & 63 : d > 239 && d < 365 ? (d = ((d & 7) << 18 | (r[o++] & 63) << 12 | (r[o++] & 63) << 6 | r[o++] & 63) - 65536, c[f++] = 55296 + (d >> 10), c[f++] = 56320 + (d & 1023)) : c[f++] = (d & 15) << 12 | (r[o++] & 63) << 6 | r[o++] & 63, f > 8191 && ((l || (l = [])).push(String.fromCharCode.apply(String, c)), f = 0);
    return l ? (f && l.push(String.fromCharCode.apply(String, c.slice(0, f))), l.join("")) : String.fromCharCode.apply(String, c.slice(0, f));
  }, t.write = function(r, o, s) {
    for (var u = s, l, c, f = 0; f < r.length; ++f)
      l = r.charCodeAt(f), l < 128 ? o[s++] = l : l < 2048 ? (o[s++] = l >> 6 | 192, o[s++] = l & 63 | 128) : (l & 64512) === 55296 && ((c = r.charCodeAt(f + 1)) & 64512) === 56320 ? (l = 65536 + ((l & 1023) << 10) + (c & 1023), ++f, o[s++] = l >> 18 | 240, o[s++] = l >> 12 & 63 | 128, o[s++] = l >> 6 & 63 | 128, o[s++] = l & 63 | 128) : (o[s++] = l >> 12 | 224, o[s++] = l >> 6 & 63 | 128, o[s++] = l & 63 | 128);
    return s - u;
  };
})(utf8$2);
var pool_1 = pool;
function pool(n45, t, e) {
  var r = e || 8192, o = r >>> 1, s = null, u = r;
  return function(c) {
    if (c < 1 || c > o)
      return n45(c);
    u + c > r && (s = n45(r), u = 0);
    var f = t.call(s, u, u += c);
    return u & 7 && (u = (u | 7) + 1), f;
  };
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits) return longbits;
  hasRequiredLongbits = 1, longbits = t;
  var n45 = requireMinimal();
  function t(s, u) {
    this.lo = s >>> 0, this.hi = u >>> 0;
  }
  var e = t.zero = new t(0, 0);
  e.toNumber = function() {
    return 0;
  }, e.zzEncode = e.zzDecode = function() {
    return this;
  }, e.length = function() {
    return 1;
  };
  var r = t.zeroHash = "\0\0\0\0\0\0\0\0";
  t.fromNumber = function(u) {
    if (u === 0)
      return e;
    var l = u < 0;
    l && (u = -u);
    var c = u >>> 0, f = (u - c) / 4294967296 >>> 0;
    return l && (f = ~f >>> 0, c = ~c >>> 0, ++c > 4294967295 && (c = 0, ++f > 4294967295 && (f = 0))), new t(c, f);
  }, t.from = function(u) {
    if (typeof u == "number")
      return t.fromNumber(u);
    if (n45.isString(u))
      if (n45.Long)
        u = n45.Long.fromString(u);
      else
        return t.fromNumber(parseInt(u, 10));
    return u.low || u.high ? new t(u.low >>> 0, u.high >>> 0) : e;
  }, t.prototype.toNumber = function(u) {
    if (!u && this.hi >>> 31) {
      var l = ~this.lo + 1 >>> 0, c = ~this.hi >>> 0;
      return l || (c = c + 1 >>> 0), -(l + c * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, t.prototype.toLong = function(u) {
    return n45.Long ? new n45.Long(this.lo | 0, this.hi | 0, !!u) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!u };
  };
  var o = String.prototype.charCodeAt;
  return t.fromHash = function(u) {
    return u === r ? e : new t(
      (o.call(u, 0) | o.call(u, 1) << 8 | o.call(u, 2) << 16 | o.call(u, 3) << 24) >>> 0,
      (o.call(u, 4) | o.call(u, 5) << 8 | o.call(u, 6) << 16 | o.call(u, 7) << 24) >>> 0
    );
  }, t.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, t.prototype.zzEncode = function() {
    var u = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ u) >>> 0, this.lo = (this.lo << 1 ^ u) >>> 0, this;
  }, t.prototype.zzDecode = function() {
    var u = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ u) >>> 0, this.hi = (this.hi >>> 1 ^ u) >>> 0, this;
  }, t.prototype.length = function() {
    var u = this.lo, l = (this.lo >>> 28 | this.hi << 4) >>> 0, c = this.hi >>> 24;
    return c === 0 ? l === 0 ? u < 16384 ? u < 128 ? 1 : 2 : u < 2097152 ? 3 : 4 : l < 16384 ? l < 128 ? 5 : 6 : l < 2097152 ? 7 : 8 : c < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(n45) {
    var t = n45;
    t.asPromise = aspromise, t.base64 = base64$1, t.EventEmitter = eventemitter, t.float = float, t.inquire = inquire_1, t.utf8 = utf8$2, t.pool = pool_1, t.LongBits = requireLongbits(), t.isNode = !!(typeof commonjsGlobal != "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), t.global = t.isNode && commonjsGlobal || typeof window != "undefined" && window || typeof self != "undefined" && self || commonjsGlobal, t.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), t.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), t.isInteger = Number.isInteger || /* istanbul ignore next */
    function(s) {
      return typeof s == "number" && isFinite(s) && Math.floor(s) === s;
    }, t.isString = function(s) {
      return typeof s == "string" || s instanceof String;
    }, t.isObject = function(s) {
      return s && typeof s == "object";
    }, t.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    t.isSet = function(s, u) {
      var l = s[u];
      return l != null && s.hasOwnProperty(u) ? typeof l != "object" || (Array.isArray(l) ? l.length : Object.keys(l).length) > 0 : false;
    }, t.Buffer = function() {
      try {
        var o = t.inquire("buffer").Buffer;
        return o.prototype.utf8Write ? o : (
          /* istanbul ignore next */
          null
        );
      } catch (s) {
        return null;
      }
    }(), t._Buffer_from = null, t._Buffer_allocUnsafe = null, t.newBuffer = function(s) {
      return typeof s == "number" ? t.Buffer ? t._Buffer_allocUnsafe(s) : new t.Array(s) : t.Buffer ? t._Buffer_from(s) : typeof Uint8Array == "undefined" ? s : new Uint8Array(s);
    }, t.Array = typeof Uint8Array != "undefined" ? Uint8Array : Array, t.Long = /* istanbul ignore next */
    t.global.dcodeIO && /* istanbul ignore next */
    t.global.dcodeIO.Long || /* istanbul ignore next */
    t.global.Long || t.inquire("long"), t.key2Re = /^true|false|0|1$/, t.key32Re = /^-?(?:0|[1-9][0-9]*)$/, t.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, t.longToHash = function(s) {
      return s ? t.LongBits.from(s).toHash() : t.LongBits.zeroHash;
    }, t.longFromHash = function(s, u) {
      var l = t.LongBits.fromHash(s);
      return t.Long ? t.Long.fromBits(l.lo, l.hi, u) : l.toNumber(!!u);
    };
    function e(o, s, u) {
      for (var l = Object.keys(s), c = 0; c < l.length; ++c)
        (o[l[c]] === void 0 || !u) && (o[l[c]] = s[l[c]]);
      return o;
    }
    t.merge = e, t.lcFirst = function(s) {
      return s.charAt(0).toLowerCase() + s.substring(1);
    };
    function r(o) {
      function s(u, l) {
        if (!(this instanceof s))
          return new s(u, l);
        Object.defineProperty(this, "message", { get: function() {
          return u;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, s) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), l && e(this, l);
      }
      return s.prototype = Object.create(Error.prototype, {
        constructor: {
          value: s,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function() {
            return o;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      }), s;
    }
    t.newError = r, t.ProtocolError = r("ProtocolError"), t.oneOfGetter = function(s) {
      for (var u = {}, l = 0; l < s.length; ++l)
        u[s[l]] = 1;
      return function() {
        for (var c = Object.keys(this), f = c.length - 1; f > -1; --f)
          if (u[c[f]] === 1 && this[c[f]] !== void 0 && this[c[f]] !== null)
            return c[f];
      };
    }, t.oneOfSetter = function(s) {
      return function(u) {
        for (var l = 0; l < s.length; ++l)
          s[l] !== u && delete this[s[l]];
      };
    }, t.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    }, t._configure = function() {
      var o = t.Buffer;
      if (!o) {
        t._Buffer_from = t._Buffer_allocUnsafe = null;
        return;
      }
      t._Buffer_from = o.from !== Uint8Array.from && o.from || /* istanbul ignore next */
      function(u, l) {
        return new o(u, l);
      }, t._Buffer_allocUnsafe = o.allocUnsafe || /* istanbul ignore next */
      function(u) {
        return new o(u);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer = Writer$1;
var util$4 = requireMinimal();
var BufferWriter$1;
var LongBits$1 = util$4.LongBits;
var base64 = util$4.base64;
var utf8$1 = util$4.utf8;
function Op(n45, t, e) {
  this.fn = n45, this.len = t, this.next = void 0, this.val = e;
}
function noop() {
}
function State(n45) {
  this.head = n45.head, this.tail = n45.tail, this.len = n45.len, this.next = n45.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;
}
var create$1 = function n() {
  return util$4.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$1();
Writer$1.alloc = function n2(t) {
  return new util$4.Array(t);
};
util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray));
Writer$1.prototype._push = function n3(t, e, r) {
  return this.tail = this.tail.next = new Op(t, e, r), this.len += e, this;
};
function writeByte(n45, t, e) {
  t[e] = n45 & 255;
}
function writeVarint32(n45, t, e) {
  for (; n45 > 127; )
    t[e++] = n45 & 127 | 128, n45 >>>= 7;
  t[e] = n45;
}
function VarintOp(n45, t) {
  this.len = n45, this.next = void 0, this.val = t;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function n4(t) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (t = t >>> 0) < 128 ? 1 : t < 16384 ? 2 : t < 2097152 ? 3 : t < 268435456 ? 4 : 5,
    t
  )).len, this;
};
Writer$1.prototype.int32 = function n5(t) {
  return t < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(t)) : this.uint32(t);
};
Writer$1.prototype.sint32 = function n6(t) {
  return this.uint32((t << 1 ^ t >> 31) >>> 0);
};
function writeVarint64(n45, t, e) {
  for (; n45.hi; )
    t[e++] = n45.lo & 127 | 128, n45.lo = (n45.lo >>> 7 | n45.hi << 25) >>> 0, n45.hi >>>= 7;
  for (; n45.lo > 127; )
    t[e++] = n45.lo & 127 | 128, n45.lo = n45.lo >>> 7;
  t[e++] = n45.lo;
}
Writer$1.prototype.uint64 = function n7(t) {
  var e = LongBits$1.from(t);
  return this._push(writeVarint64, e.length(), e);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function n8(t) {
  var e = LongBits$1.from(t).zzEncode();
  return this._push(writeVarint64, e.length(), e);
};
Writer$1.prototype.bool = function n9(t) {
  return this._push(writeByte, 1, t ? 1 : 0);
};
function writeFixed32(n45, t, e) {
  t[e] = n45 & 255, t[e + 1] = n45 >>> 8 & 255, t[e + 2] = n45 >>> 16 & 255, t[e + 3] = n45 >>> 24;
}
Writer$1.prototype.fixed32 = function n10(t) {
  return this._push(writeFixed32, 4, t >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function n11(t) {
  var e = LongBits$1.from(t);
  return this._push(writeFixed32, 4, e.lo)._push(writeFixed32, 4, e.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function n12(t) {
  return this._push(util$4.float.writeFloatLE, 4, t);
};
Writer$1.prototype.double = function n13(t) {
  return this._push(util$4.float.writeDoubleLE, 8, t);
};
var writeBytes = util$4.Array.prototype.set ? function n14(t, e, r) {
  e.set(t, r);
} : function n15(t, e, r) {
  for (var o = 0; o < t.length; ++o)
    e[r + o] = t[o];
};
Writer$1.prototype.bytes = function n16(t) {
  var e = t.length >>> 0;
  if (!e)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(t)) {
    var r = Writer$1.alloc(e = base64.length(t));
    base64.decode(t, r, 0), t = r;
  }
  return this.uint32(e)._push(writeBytes, e, t);
};
Writer$1.prototype.string = function n17(t) {
  var e = utf8$1.length(t);
  return e ? this.uint32(e)._push(utf8$1.write, e, t) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function n18() {
  return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function n19() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function n20() {
  var t = this.head, e = this.tail, r = this.len;
  return this.reset().uint32(r), r && (this.tail.next = t.next, this.tail = e, this.len += r), this;
};
Writer$1.prototype.finish = function n21() {
  for (var t = this.head.next, e = this.constructor.alloc(this.len), r = 0; t; )
    t.fn(t.val, e, r), r += t.len, t = t.next;
  return e;
};
Writer$1._configure = function(n45) {
  BufferWriter$1 = n45, Writer$1.create = create$1(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function(t, e, r) {
    e.set(t, r);
  } : function(t, e, r) {
    if (t.copy)
      t.copy(e, r, 0, t.length);
    else for (var o = 0; o < t.length; )
      e[r++] = t[o++];
  };
};
BufferWriter.prototype.bytes = function n22(t) {
  util$3.isString(t) && (t = util$3._Buffer_from(t, "base64"));
  var e = t.length >>> 0;
  return this.uint32(e), e && this._push(BufferWriter.writeBytesBuffer, e, t), this;
};
function writeStringBuffer(n45, t, e) {
  n45.length < 40 ? util$3.utf8.write(n45, t, e) : t.utf8Write ? t.utf8Write(n45, e) : t.write(n45, e);
}
BufferWriter.prototype.string = function n23(t) {
  var e = util$3.Buffer.byteLength(t);
  return this.uint32(e), e && this._push(writeStringBuffer, e, t), this;
};
BufferWriter._configure();
var reader = Reader$1;
var util$2 = requireMinimal();
var BufferReader$1;
var LongBits = util$2.LongBits;
var utf8 = util$2.utf8;
function indexOutOfRange(n45, t) {
  return RangeError("index out of range: " + n45.pos + " + " + (t || 1) + " > " + n45.len);
}
function Reader$1(n45) {
  this.buf = n45, this.pos = 0, this.len = n45.length;
}
var create_array = typeof Uint8Array != "undefined" ? function n24(t) {
  if (t instanceof Uint8Array || Array.isArray(t))
    return new Reader$1(t);
  throw Error("illegal buffer");
} : function n25(t) {
  if (Array.isArray(t))
    return new Reader$1(t);
  throw Error("illegal buffer");
};
var create = function n26() {
  return util$2.Buffer ? function(e) {
    return (Reader$1.create = function(o) {
      return util$2.Buffer.isBuffer(o) ? new BufferReader$1(o) : create_array(o);
    })(e);
  } : create_array;
};
Reader$1.create = create();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */
util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function n27() {
  var t = 4294967295;
  return function() {
    if (t = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (t = (t | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (t = (t | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (t = (t | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (t = (t | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return t;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return t;
  };
}();
Reader$1.prototype.int32 = function n28() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function n29() {
  var t = this.uint32();
  return t >>> 1 ^ -(t & 1) | 0;
};
function readLongVarint() {
  var n45 = new LongBits(0, 0), t = 0;
  if (this.len - this.pos > 4) {
    for (; t < 4; ++t)
      if (n45.lo = (n45.lo | (this.buf[this.pos] & 127) << t * 7) >>> 0, this.buf[this.pos++] < 128)
        return n45;
    if (n45.lo = (n45.lo | (this.buf[this.pos] & 127) << 28) >>> 0, n45.hi = (n45.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return n45;
    t = 0;
  } else {
    for (; t < 3; ++t) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (n45.lo = (n45.lo | (this.buf[this.pos] & 127) << t * 7) >>> 0, this.buf[this.pos++] < 128)
        return n45;
    }
    return n45.lo = (n45.lo | (this.buf[this.pos++] & 127) << t * 7) >>> 0, n45;
  }
  if (this.len - this.pos > 4) {
    for (; t < 5; ++t)
      if (n45.hi = (n45.hi | (this.buf[this.pos] & 127) << t * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return n45;
  } else
    for (; t < 5; ++t) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (n45.hi = (n45.hi | (this.buf[this.pos] & 127) << t * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return n45;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function n30() {
  return this.uint32() !== 0;
};
function readFixed32_end(n45, t) {
  return (n45[t - 4] | n45[t - 3] << 8 | n45[t - 2] << 16 | n45[t - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function n31() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function n32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function n33() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var t = util$2.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, t;
};
Reader$1.prototype.double = function n34() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var t = util$2.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, t;
};
Reader$1.prototype.bytes = function n35() {
  var t = this.uint32(), e = this.pos, r = this.pos + t;
  if (r > this.len)
    throw indexOutOfRange(this, t);
  if (this.pos += t, Array.isArray(this.buf))
    return this.buf.slice(e, r);
  if (e === r) {
    var o = util$2.Buffer;
    return o ? o.alloc(0) : new this.buf.constructor(0);
  }
  return this._slice.call(this.buf, e, r);
};
Reader$1.prototype.string = function n36() {
  var t = this.bytes();
  return utf8.read(t, 0, t.length);
};
Reader$1.prototype.skip = function n37(t) {
  if (typeof t == "number") {
    if (this.pos + t > this.len)
      throw indexOutOfRange(this, t);
    this.pos += t;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(n45) {
  switch (n45) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (n45 = this.uint32() & 7) !== 4; )
        this.skipType(n45);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + n45 + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(n45) {
  BufferReader$1 = n45, Reader$1.create = create(), BufferReader$1._configure();
  var t = util$2.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$2.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[t](false);
    },
    uint64: function() {
      return readLongVarint.call(this)[t](true);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[t](false);
    },
    fixed64: function() {
      return readFixed64.call(this)[t](true);
    },
    sfixed64: function() {
      return readFixed64.call(this)[t](false);
    }
  });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(n45) {
  Reader.call(this, n45);
}
BufferReader._configure = function() {
  util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice);
};
BufferReader.prototype.string = function n38() {
  var t = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t, this.len));
};
BufferReader._configure();
var rpc = {};
var service = Service;
var util = requireMinimal();
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(n45, t, e) {
  if (typeof n45 != "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this), this.rpcImpl = n45, this.requestDelimited = !!t, this.responseDelimited = !!e;
}
Service.prototype.rpcCall = function n39(t, e, r, o, s) {
  if (!o)
    throw TypeError("request must be specified");
  var u = this;
  if (!s)
    return util.asPromise(n39, u, t, e, r, o);
  if (!u.rpcImpl) {
    setTimeout(function() {
      s(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return u.rpcImpl(
      t,
      e[u.requestDelimited ? "encodeDelimited" : "encode"](o).finish(),
      function(c, f) {
        if (c)
          return u.emit("error", c, t), s(c);
        if (f === null) {
          u.end(
            /* endedByRPC */
            true
          );
          return;
        }
        if (!(f instanceof r))
          try {
            f = r[u.responseDelimited ? "decodeDelimited" : "decode"](f);
          } catch (d) {
            return u.emit("error", d, t), s(d);
          }
        return u.emit("data", f, t), s(null, f);
      }
    );
  } catch (l) {
    u.emit("error", l, t), setTimeout(function() {
      s(l);
    }, 0);
    return;
  }
};
Service.prototype.end = function n40(t) {
  return this.rpcImpl && (t || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(n45) {
  var t = n45;
  t.Service = service;
})(rpc);
var roots = {};
(function(n45) {
  var t = n45;
  t.build = "minimal", t.Writer = writer, t.BufferWriter = writer_buffer, t.Reader = reader, t.BufferReader = reader_buffer, t.util = requireMinimal(), t.rpc = rpc, t.roots = roots, t.configure = e;
  function e() {
    t.util._configure(), t.Writer._configure(t.BufferWriter), t.Reader._configure(t.BufferReader);
  }
  e();
})(indexMinimal);
var minimal = indexMinimal;
var $Reader$1 = minimal.Reader;
var $util$1 = minimal.util;
var $root$1 = minimal.roots["@REALSEE/FIVE:five/loaders/model/parsers/protobuf/pbm.proto"] || (minimal.roots["@REALSEE/FIVE:five/loaders/model/parsers/protobuf/pbm.proto"] = {});
var Model$2 = $root$1.Model = (() => {
  function n45(t) {
    if (this.chunks = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.chunks = $util$1.emptyArray, n45.prototype.createAt = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, n45.prototype.description = "", n45.decode = function(e, r) {
    e instanceof $Reader$1 || (e = $Reader$1.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root$1.Model();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.chunks && s.chunks.length || (s.chunks = []), s.chunks.push($root$1.Chunk.decode(e, e.uint32()));
          break;
        }
        case 2: {
          s.createAt = e.uint64();
          break;
        }
        case 3: {
          s.description = e.string();
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Model";
  }, n45;
})();
$root$1.Chunk = (() => {
  function n45(t) {
    if (t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.vertices = null, n45.prototype.faces = null, n45.prototype.name = "", n45.prototype.texture = "", n45.decode = function(e, r) {
    e instanceof $Reader$1 || (e = $Reader$1.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root$1.Chunk();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.vertices = $root$1.Vertices.decode(e, e.uint32());
          break;
        }
        case 2: {
          s.faces = $root$1.Faces.decode(e, e.uint32());
          break;
        }
        case 3: {
          s.name = e.string();
          break;
        }
        case 4: {
          s.texture = e.string();
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    if (!s.hasOwnProperty("vertices"))
      throw $util$1.ProtocolError("missing required 'vertices'", { instance: s });
    if (!s.hasOwnProperty("faces"))
      throw $util$1.ProtocolError("missing required 'faces'", { instance: s });
    if (!s.hasOwnProperty("name"))
      throw $util$1.ProtocolError("missing required 'name'", { instance: s });
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Chunk";
  }, n45;
})();
$root$1.Vertices = (() => {
  function n45(t) {
    if (this.xyz = [], this.uvs = [], this.marks = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.xyz = $util$1.emptyArray, n45.prototype.uvs = $util$1.emptyArray, n45.prototype.marks = $util$1.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader$1 || (e = $Reader$1.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root$1.Vertices();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.xyz && s.xyz.length || (s.xyz = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.xyz.push(e.float());
          } else
            s.xyz.push(e.float());
          break;
        }
        case 2: {
          if (s.uvs && s.uvs.length || (s.uvs = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.uvs.push(e.float());
          } else
            s.uvs.push(e.float());
          break;
        }
        case 3: {
          if (s.marks && s.marks.length || (s.marks = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.marks.push(e.int32());
          } else
            s.marks.push(e.int32());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Vertices";
  }, n45;
})();
$root$1.Faces = (() => {
  function n45(t) {
    if (this.indices = [], this.normals = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.indices = $util$1.emptyArray, n45.prototype.normals = $util$1.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader$1 || (e = $Reader$1.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root$1.Faces();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.indices && s.indices.length || (s.indices = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.indices.push(e.uint32());
          } else
            s.indices.push(e.uint32());
          break;
        }
        case 2: {
          if (s.normals && s.normals.length || (s.normals = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.normals.push(e.float());
          } else
            s.normals.push(e.float());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Faces";
  }, n45;
})();
$root$1.VertexMark = (() => {
  const n45 = {}, t = Object.create(n45);
  return t[n45[0] = "VERTEX_MARK_UNSPECIFIED"] = 0, t[n45[1] = "VERTEX_MARK_ROOF"] = 1, t;
})();
function loadPbm(n45, t) {
  var e, r, o, s;
  t === void 0 && (t = {});
  var u = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), l = {
    byteLength: 0
  }, c = autoRestImageOptionsByTextureLength((r = t.textureOptions) !== null && r !== void 0 ? r : {}, (s = (o = t.textureArray) === null || o === void 0 ? void 0 : o.length) !== null && s !== void 0 ? s : 0), f = {};
  if (t.textureArray)
    for (var d = 0, h = t.textureArray; d < h.length; d++) {
      var v = h[d];
      f[v] = loadTexture$1(v, c, u);
    }
  return Promise.resolve().then(function() {
    return u.ajax(n45, {
      responseType: "arraybuffer"
    });
  }).then(function(A) {
    return l.byteLength = A.body.byteLength, delay(function() {
      var g = new Uint8Array(A.body);
      return Model$2.decode(g);
    });
  }).then(function(A) {
    return delay(function() {
      var g, p, y;
      return parse$4(A, (g = t.light) !== null && g !== void 0 ? g : false, (p = t.textureBaseUri) !== null && p !== void 0 ? p : function() {
        var m = n45.lastIndexOf("/");
        if (m >= 0) {
          var E = n45.slice(0, m) + "/";
          return /\/model\/$/.test(E) && (E = E.replace(/\/model\/$/, "/materials/")), E;
        }
        return "";
      }(), ((y = t.textureArray) !== null && y !== void 0 ? y : []).slice(), c, f, u);
    });
  }).then(function(A) {
    var g = new Group();
    g.matrixAutoUpdate = false, g.matrix.compose(g.position, g.quaternion, g.scale), g.name = n45;
    for (var p = 0, y = A.objects; p < y.length; p++) {
      var m = y[p];
      g.add(m);
    }
    return {
      type: "pbm",
      upAxis: "Z",
      uri: n45,
      byteLength: l.byteLength,
      memoryUsage: getMemoryUsage(g),
      scene: g,
      textures: A.textures,
      dispose: function() {
        return A.dispose();
      }
    };
  });
}
function parseFloorName(n45) {
  var t = n45.match(/(group|floor)-?(\d+)/);
  return t ? parseInt(t[2], 10) : 0;
}
function parseChunkName(n45) {
  var t = n45.match(/(chunk)-?(\d+)/);
  return t ? parseInt(t[2], 10) : 0;
}
function parseSubName(n45) {
  var t = n45.match(/(sub)-?(\d+)/);
  return t ? parseInt(t[2], 10) : 0;
}
function chunkOrder(n45) {
  var t = parseFloorName(n45.name), e = parseChunkName(n45.name), r = parseSubName(n45.name);
  return t * 1e6 + e * 1e3 + r;
}
function parsePBMModel(n45) {
  for (var t, e, r, o = typeof n45.createAt == "number" ? n45.createAt : 0, s = (t = n45.description) !== null && t !== void 0 ? t : "", u = [], l = true, c = true, f = 0, d = n45.chunks; f < d.length; f++) {
    var h = d[f];
    if (!h.vertices.marks || h.vertices.marks.length === 0) {
      c = false;
      break;
    }
  }
  for (var v = 0, A = n45.chunks; v < A.length; v++) {
    var h = A[v];
    if (!h.faces.normals || h.faces.normals.length === 0) {
      l = false;
      break;
    }
  }
  for (var g = n45.chunks.sort(function(fe, ne) {
    return chunkOrder(fe) - chunkOrder(ne);
  }), p = [], y = 0, m = g; y < m.length; y++) {
    var h = m[y], E = parseFloorName(h.name);
    p[E] || (p[E] = []), p[E].push(h);
  }
  for (var b = 0; b < p.length; b++) {
    var T = p[b];
    if (T)
      if (l) {
        for (var R = 0, S = 0; S < T.length; S++) {
          var h = T[S];
          R += h.faces.indices.length;
        }
        for (var M = new Float32Array(R * 3), w = new Float32Array(R * 2), H = new Float32Array(R * 3), L = c ? new Float32Array(R) : void 0, C = [], I = [1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0], _ = 0, O = 0; O < T.length; O++) {
          for (var P = [1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0], h = T[O], N = h.vertices.xyz, k = h.vertices.uvs, U = h.faces.indices, D = h.faces.normals, q = h.vertices.marks, z = U.length, S = 0; S < z; S++) {
            var Q = U[S], G = M[_ * 3 + S * 3] = N[Q * 3], X = M[_ * 3 + S * 3 + 1] = N[Q * 3 + 1], $ = M[_ * 3 + S * 3 + 2] = N[Q * 3 + 2];
            L && (L[_ + S] = q[Q]), w[_ * 2 + S * 2] = k[Q * 2], w[_ * 2 + S * 2 + 1] = k[Q * 2 + 1];
            var W = Math.floor(S / 3) * 3;
            H[_ * 3 + S * 3] = D[W], H[_ * 3 + S * 3 + 1] = D[W + 1], H[_ * 3 + S * 3 + 2] = D[W + 2], G < P[0] && (P[0] = G), X < P[1] && (P[1] = X), $ < P[2] && (P[2] = $), G > P[3] && (P[3] = G), X > P[4] && (P[4] = X), $ > P[5] && (P[5] = $);
          }
          P[0] < I[0] && (I[0] = P[0]), P[1] < I[1] && (I[1] = P[1]), P[2] < I[2] && (I[2] = P[2]), P[3] > I[3] && (I[3] = P[3]), P[4] > I[4] && (I[4] = P[4]), P[5] > I[5] && (I[5] = P[5]), C.push({
            materialIndex: O,
            name: h.name,
            chunkName: parseChunkName(h.name),
            start: _,
            count: h.faces.indices.length,
            texture: (e = h.texture) !== null && e !== void 0 ? e : void 0
          }), _ += z;
        }
        var oe = {
          createAt: o,
          description: s,
          vertices: M,
          uvs: w,
          normals: H,
          masks: L,
          indices: null,
          floorIndex: b,
          groups: C,
          extents: I
        };
        u.push(oe);
      } else {
        for (var R = 0, ie = 0, S = 0; S < T.length; S++) {
          var h = T[S];
          ie += h.vertices.xyz.length / 3, R += h.faces.indices.length;
        }
        for (var M = new Float32Array(ie * 3), w = new Float32Array(ie * 2), H = void 0, re = new Float32Array(ie), j = new Uint32Array(R), L = c ? new Float32Array(R) : void 0, C = [], I = [1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0], se = 0, _ = 0, O = 0; O < T.length; O++) {
          for (var P = [1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0], h = T[O], N = h.vertices.xyz, ae = h.vertices.marks, k = h.vertices.uvs, U = h.faces.indices, ue = N.length / 3, z = U.length, S = 0; S < ue; S++) {
            var G = M[_ * 3 + S * 3] = N[S * 3], X = M[_ * 3 + S * 3 + 1] = N[S * 3 + 1], $ = M[_ * 3 + S * 3 + 2] = N[S * 3 + 2];
            L && (L[_ + S] = ae[S]), w[_ * 2 + S * 2] = k[S * 2], w[_ * 2 + S * 2 + 1] = k[S * 2 + 1], re[_ + S] = b, G < P[0] && (P[0] = G), X < P[1] && (P[1] = X), $ < P[2] && (P[2] = $), G > P[3] && (P[3] = G), X > P[4] && (P[4] = X), $ > P[5] && (P[5] = $);
          }
          P[0] < I[0] && (I[0] = P[0]), P[1] < I[1] && (I[1] = P[1]), P[2] < I[2] && (I[2] = P[2]), P[3] > I[3] && (I[3] = P[3]), P[4] > I[4] && (I[4] = P[4]), P[5] > I[5] && (I[5] = P[5]);
          for (var S = 0; S < z; S++)
            j[se + S] = _ + U[S];
          C.push({
            materialIndex: O,
            name: h.name,
            chunkName: parseChunkName(h.name),
            start: se,
            count: h.faces.indices.length,
            texture: (r = h.texture) !== null && r !== void 0 ? r : void 0
          }), _ += ue, se += z;
        }
        var oe = {
          createAt: o,
          description: s,
          vertices: M,
          uvs: w,
          normals: H,
          masks: L,
          indices: j,
          floorIndex: b,
          groups: C,
          extents: I
        };
        u.push(oe);
      }
  }
  return u;
}
function loadTexture$1(n45, t, e) {
  var r = __assign({ key: "texture.pbm" }, pick(t, ["format", "quality", "size", "sharpen", "mappings"])), o = new TextureLoader2(), s = o.loadTexture(n45, {
    imageURL: {
      transform: t.transform,
      options: r
    },
    encoding: sRGBEncoding,
    wrapS: ClampToEdgeWrapping,
    wrapT: ClampToEdgeWrapping,
    minFilter: LinearFilter,
    maxSize: typeof r.size == "number" ? new Vector2(r.size, r.size) : void 0,
    fetcher: e
  }).then(function(u) {
    var l = u.body;
    return l.needsUpdate = true, l;
  });
  return Object.assign(s, { url: n45, textureOptions: t });
}
function parse$4(n45, t, e, r, o, s, u) {
  s === void 0 && (s = {});
  for (var l = parsePBMModel(n45), c = 0, f = "", d = [], h = {}, v = /* @__PURE__ */ new Set(), A = 0, g = 0, p = l; g < p.length; g++) {
    var y = p[g], m = y.createAt, E = y.description, b = y.vertices, T = y.masks, R = y.uvs, S = y.normals, M = y.indices, w = y.floorIndex, H = y.groups, L = y.extents, C = new Box3();
    C.min.x = L[0], C.min.y = L[1], C.min.z = L[2], C.max.x = L[3], C.max.y = L[4], C.max.z = L[5];
    var I = new BufferGeometry();
    I.setAttribute("position", new BufferAttribute(b, 3)), I.setAttribute("uv", new BufferAttribute(R, 2)), S && I.setAttribute("normal", new BufferAttribute(S, 3)), T && I.setAttribute("_feature_id_rsmask", new BufferAttribute(T, 1)), M && I.setIndex(new BufferAttribute(M, 1)), I.boundingBox = C, I.boundingSphere = C.getBoundingSphere(new Sphere());
    for (var _ = 0, O = H; _ < O.length; _++) {
      var P = O[_];
      I.addGroup(P.start, P.count, P.materialIndex);
    }
    v.add(I);
    for (var N = [], k = 0, U = H; k < U.length; k++) {
      var P = U[k], D = r[P.chunkName] || (P.texture ? pathJoin(e || "", P.texture) : void 0), q = new PBMMeshMaterial(t ? "phong" : "basic");
      q.floorIndex = w, I.attributes.normal === void 0 && (q.flatShading = true), I.attributes._feature_id_rsmask && (q.defines.USE_VERTEX_MARK = true), N.push(q), D ? (A++, h[D] ? h[D].push(q) : h[D] = [q]) : q.color = new Color(16777215), v.add(q), q.refreshUniforms();
    }
    var z = new PBMMesh(I, N);
    z.name = "model_floor_" + w, z.userData.createAt = m, z.userData.description = E, z.matrix.compose(z.position, z.quaternion, z.scale), z.matrixAutoUpdate = false, z.frustumCulled = false, c = m, f = E, d.push(z);
  }
  var Q = function(G) {
    G = autoRestImageOptionsByTextureLength(G, A);
    for (var X = [], $ = function(re) {
      var j = null;
      re in s && (j = s[re]), j || (j = loadTexture$1(re, G, u)), X.push(j.then(function(se) {
        for (var ae = 0, ue = h[re]; ae < ue.length; ae++) {
          var fe = ue[ae];
          fe.map && (v.delete(fe.map), fe.map.dispose()), fe.map = se, fe.refreshUniforms(), v.add(se);
        }
        return se;
      }).catch(function() {
        for (var se = 0, ae = h[re]; se < ae.length; se++) {
          var ue = ae[se];
          ue.map && (v.delete(ue.map), ue.map.dispose()), ue.map = null, ue.color = new Color(16777215), ue.refreshUniforms();
        }
        return null;
      }));
    }, W = 0, oe = Object.keys(h); W < oe.length; W++) {
      var ie = oe[W];
      $(ie);
    }
    for (var ie in s)
      delete s[ie];
    return Promise.all(X).then(function(re) {
      return re.filter(function(j) {
        return j;
      });
    });
  };
  return Q(o).then(function(G) {
    return {
      createAt: c,
      description: f,
      objects: d,
      textures: G,
      dispose: function() {
        v.forEach(function(X) {
          X.dispose();
        }), v.clear();
      }
    };
  });
}
function autoRestImageOptionsByTextureLength(n45, t) {
  return n45 = Object.assign({}, n45), n45.autoResize !== false && (t > 96 ? n45.size = Math.min(n45.size || 1 / 0, 100) : t > 48 ? n45.size = Math.min(n45.size || 1 / 0, 200) : t > 24 ? n45.size = Math.min(n45.size || 1 / 0, 400) : t > 22 ? n45.size = Math.min(n45.size || 1 / 0, 800) : t > 5 && (n45.size = Math.min(n45.size || 1 / 0, 1024))), n45;
}
function loadAt3d(n45, t) {
  var e, r, o, s;
  t === void 0 && (t = {});
  var u = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), l = {
    byteLength: 0
  }, c = autoRestImageOptionsByTextureLength((r = t.textureOptions) !== null && r !== void 0 ? r : {}, (s = (o = t.textureArray) === null || o === void 0 ? void 0 : o.length) !== null && s !== void 0 ? s : 0), f = {};
  if (t.textureArray)
    for (var d = 0, h = t.textureArray; d < h.length; d++) {
      var v = h[d];
      f[v] = loadTexture$1(v, c, u);
    }
  return Promise.resolve().then(function() {
    return u.ajax(n45, {
      responseType: "arraybuffer"
    });
  }).then(function(A) {
    return lzma(A.body);
  }).then(function(A) {
    return delay(function() {
      for (var g, p = {
        chunks: [],
        createAt: void 0,
        description: void 0
      }, y = 0, m = A; y < m.length; y++) {
        var E = m[y], b = Model$2.decode(E);
        b.chunks.length && ((g = p.chunks).push.apply(g, b.chunks), p.createAt = b.createAt, p.description = b.description);
      }
      return p;
    });
  }).then(function(A) {
    return delay(function() {
      var g, p, y, m;
      return parse$4(A, (g = t.light) !== null && g !== void 0 ? g : false, (p = t.textureBaseUri) !== null && p !== void 0 ? p : function() {
        var E = n45.lastIndexOf("/");
        if (E >= 0) {
          var b = n45.slice(0, E) + "/";
          return /\/model\/$/.test(b) && (b = b.replace(/\/model\/$/, "/materials/")), b;
        }
        return "";
      }(), ((y = t.textureArray) !== null && y !== void 0 ? y : []).slice(), (m = t.textureOptions) !== null && m !== void 0 ? m : {}, f, u);
    });
  }).then(function(A) {
    var g = new Group();
    g.name = n45;
    for (var p = 0, y = A.objects; p < y.length; p++) {
      var m = y[p];
      g.add(m);
    }
    return {
      type: "at3d",
      upAxis: "Z",
      uri: n45,
      byteLength: l.byteLength,
      memoryUsage: getMemoryUsage(g),
      scene: g,
      textures: A.textures,
      dispose: function() {
        return A.dispose();
      }
    };
  });
}
var $Reader = minimal.Reader;
var $util = minimal.util;
var $root = minimal.roots["@REALSEE/FIVE:five/loaders/model/parsers/protobuf/dome.proto"] || (minimal.roots["@REALSEE/FIVE:five/loaders/model/parsers/protobuf/dome.proto"] = {});
var Model$1 = $root.Model = (() => {
  function n45(t) {
    if (this.meshes = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.meshes = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Model();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.meshes && s.meshes.length || (s.meshes = []), s.meshes.push($root.Mesh.decode(e, e.uint32()));
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Model";
  }, n45;
})();
$root.Mesh = (() => {
  function n45(t) {
    if (this.chunks = [], this.matrix = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.name = "", n45.prototype.chunks = $util.emptyArray, n45.prototype.matrix = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Mesh();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.name = e.string();
          break;
        }
        case 2: {
          s.chunks && s.chunks.length || (s.chunks = []), s.chunks.push($root.Chunk.decode(e, e.uint32()));
          break;
        }
        case 3: {
          s.matrix && s.matrix.length || (s.matrix = []), s.matrix.push($root.Matrix.decode(e, e.uint32()));
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    if (!s.hasOwnProperty("name"))
      throw $util.ProtocolError("missing required 'name'", { instance: s });
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Mesh";
  }, n45;
})();
$root.Matrix = (() => {
  function n45(t) {
    if (this.elements = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.elements = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Matrix();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.elements && s.elements.length || (s.elements = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.elements.push(e.float());
          } else
            s.elements.push(e.float());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Matrix";
  }, n45;
})();
$root.Chunk = (() => {
  function n45(t) {
    if (this.material = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.geometry = null, n45.prototype.material = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Chunk();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 2: {
          s.geometry = $root.Geometry.decode(e, e.uint32());
          break;
        }
        case 3: {
          s.material && s.material.length || (s.material = []), s.material.push($root.Material.decode(e, e.uint32()));
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    if (!s.hasOwnProperty("geometry"))
      throw $util.ProtocolError("missing required 'geometry'", { instance: s });
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Chunk";
  }, n45;
})();
$root.Geometry = (() => {
  function n45(t) {
    if (this.groups = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.position = null, n45.prototype.uv = null, n45.prototype.uv2 = null, n45.prototype.normal = null, n45.prototype.groups = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Geometry();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.position = $root.Position.decode(e, e.uint32());
          break;
        }
        case 2: {
          s.uv = $root.UV.decode(e, e.uint32());
          break;
        }
        case 3: {
          s.uv2 = $root.UV.decode(e, e.uint32());
          break;
        }
        case 4: {
          s.normal = $root.Normal.decode(e, e.uint32());
          break;
        }
        case 5: {
          s.groups && s.groups.length || (s.groups = []), s.groups.push($root.Group.decode(e, e.uint32()));
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    if (!s.hasOwnProperty("position"))
      throw $util.ProtocolError("missing required 'position'", { instance: s });
    if (!s.hasOwnProperty("normal"))
      throw $util.ProtocolError("missing required 'normal'", { instance: s });
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Geometry";
  }, n45;
})();
$root.Position = (() => {
  function n45(t) {
    if (this.array = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.array = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Position();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.array && s.array.length || (s.array = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.array.push(e.float());
          } else
            s.array.push(e.float());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Position";
  }, n45;
})();
$root.UV = (() => {
  function n45(t) {
    if (this.array = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.array = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.UV();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.array && s.array.length || (s.array = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.array.push(e.float());
          } else
            s.array.push(e.float());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/UV";
  }, n45;
})();
$root.Normal = (() => {
  function n45(t) {
    if (this.array = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.array = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Normal();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.array && s.array.length || (s.array = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.array.push(e.float());
          } else
            s.array.push(e.float());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Normal";
  }, n45;
})();
$root.Group = (() => {
  function n45(t) {
    if (t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.start = 0, n45.prototype.count = 0, n45.prototype.materialIndex = 0, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Group();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.start = e.uint32();
          break;
        }
        case 2: {
          s.count = e.uint32();
          break;
        }
        case 3: {
          s.materialIndex = e.uint32();
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    if (!s.hasOwnProperty("start"))
      throw $util.ProtocolError("missing required 'start'", { instance: s });
    if (!s.hasOwnProperty("count"))
      throw $util.ProtocolError("missing required 'count'", { instance: s });
    if (!s.hasOwnProperty("materialIndex"))
      throw $util.ProtocolError("missing required 'materialIndex'", { instance: s });
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Group";
  }, n45;
})();
$root.Material = (() => {
  function n45(t) {
    if (t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.kd = null, n45.prototype.ks = null, n45.prototype.ke = null, n45.prototype.mapkd = "", n45.prototype.mapks = "", n45.prototype.mapke = "", n45.prototype.norm = "", n45.prototype.mapbump = "", n45.prototype.bump = "", n45.prototype.mapd = "", n45.prototype.ns = 0, n45.prototype.d = 0, n45.prototype.tr = 0, n45.prototype.mapkdrepeat = "", n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Material();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          s.kd = $root.Color.decode(e, e.uint32());
          break;
        }
        case 2: {
          s.ks = $root.Color.decode(e, e.uint32());
          break;
        }
        case 3: {
          s.ke = $root.Color.decode(e, e.uint32());
          break;
        }
        case 4: {
          s.mapkd = e.string();
          break;
        }
        case 5: {
          s.mapks = e.string();
          break;
        }
        case 6: {
          s.mapke = e.string();
          break;
        }
        case 7: {
          s.norm = e.string();
          break;
        }
        case 8: {
          s.mapbump = e.string();
          break;
        }
        case 9: {
          s.bump = e.string();
          break;
        }
        case 10: {
          s.mapd = e.string();
          break;
        }
        case 11: {
          s.ns = e.float();
          break;
        }
        case 12: {
          s.d = e.float();
          break;
        }
        case 13: {
          s.tr = e.float();
          break;
        }
        case 14: {
          s.mapkdrepeat = e.string();
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Material";
  }, n45;
})();
$root.Color = (() => {
  function n45(t) {
    if (this.rgb = [], t)
      for (let e = Object.keys(t), r = 0; r < e.length; ++r)
        t[e[r]] != null && (this[e[r]] = t[e[r]]);
  }
  return n45.prototype.rgb = $util.emptyArray, n45.decode = function(e, r) {
    e instanceof $Reader || (e = $Reader.create(e));
    let o = r === void 0 ? e.len : e.pos + r, s = new $root.Color();
    for (; e.pos < o; ) {
      let u = e.uint32();
      switch (u >>> 3) {
        case 1: {
          if (s.rgb && s.rgb.length || (s.rgb = []), (u & 7) === 2) {
            let l = e.uint32() + e.pos;
            for (; e.pos < l; )
              s.rgb.push(e.float());
          } else
            s.rgb.push(e.float());
          break;
        }
        default:
          e.skipType(u & 7);
          break;
      }
    }
    return s;
  }, n45.getTypeUrl = function(e) {
    return e === void 0 && (e = "type.googleapis.com"), e + "/Color";
  }, n45;
})();
var ROTATE_X_MATRIX$5 = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
function loadDome(n45, t) {
  var e;
  t === void 0 && (t = {});
  var r = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), o = {
    byteLength: 0
  };
  return Promise.resolve().then(function() {
    return r.ajax(n45, {
      responseType: "arraybuffer"
    });
  }).then(function(s) {
    var u, l;
    return o.byteLength = s.body.byteLength, parse$3(new Uint8Array(s.body), (u = t.light) !== null && u !== void 0 ? u : true, t.textureBaseUri || "", (l = t.textureOptions) !== null && l !== void 0 ? l : {}, r);
  }).then(function(s) {
    var u = new Group();
    u.matrixAutoUpdate = false, u.applyMatrix4(ROTATE_X_MATRIX$5), u.matrix.compose(u.position, u.quaternion, u.scale), u.name = n45;
    for (var l = 0, c = s.objects; l < c.length; l++) {
      var f = c[l];
      u.add(f);
    }
    return {
      type: "dome",
      upAxis: "Z",
      uri: n45,
      byteLength: o.byteLength,
      memoryUsage: getMemoryUsage(u),
      scene: u,
      textures: s.textures,
      dispose: function() {
        return s.dispose();
      }
    };
  });
}
function flipBufferGeometryNormals(n45) {
  for (var t = [0, 0, 0], e = 0; e < n45.attributes.normal.array.length / 9; e++)
    t[0] = n45.attributes.normal.array[e * 9], t[1] = n45.attributes.normal.array[e * 9 + 1], t[2] = n45.attributes.normal.array[e * 9 + 2], n45.attributes.normal.array[e * 9] = n45.attributes.normal.array[e * 9 + 6], n45.attributes.normal.array[e * 9 + 1] = n45.attributes.normal.array[e * 9 + 7], n45.attributes.normal.array[e * 9 + 2] = n45.attributes.normal.array[e * 9 + 8], n45.attributes.normal.array[e * 9 + 6] = t[0], n45.attributes.normal.array[e * 9 + 7] = t[1], n45.attributes.normal.array[e * 9 + 8] = t[2];
  for (var e = 0; e < n45.attributes.position.array.length / 9; e++)
    t[0] = n45.attributes.position.array[e * 9], t[1] = n45.attributes.position.array[e * 9 + 1], t[2] = n45.attributes.position.array[e * 9 + 2], n45.attributes.position.array[e * 9] = n45.attributes.position.array[e * 9 + 6], n45.attributes.position.array[e * 9 + 1] = n45.attributes.position.array[e * 9 + 7], n45.attributes.position.array[e * 9 + 2] = n45.attributes.position.array[e * 9 + 8], n45.attributes.position.array[e * 9 + 6] = t[0], n45.attributes.position.array[e * 9 + 7] = t[1], n45.attributes.position.array[e * 9 + 8] = t[2];
  for (var e = 0; e < n45.attributes.uv.array.length / 6; e++)
    t[0] = n45.attributes.uv.array[e * 6], t[1] = n45.attributes.uv.array[e * 6 + 1], n45.attributes.uv.array[e * 6] = n45.attributes.uv.array[e * 6 + 4], n45.attributes.uv.array[e * 6 + 1] = n45.attributes.uv.array[e * 6 + 5], n45.attributes.uv.array[e * 6 + 4] = t[0], n45.attributes.uv.array[e * 6 + 5] = t[1];
  n45.attributes.normal.needsUpdate = true, n45.attributes.position.needsUpdate = true, n45.attributes.uv.needsUpdate = true;
}
function parseGeometry(n45) {
  var t = n45.position, e = n45.normal, r = n45.uv, o = n45.uv2, s = n45.groups, u = new BufferGeometry();
  u.setAttribute("position", new BufferAttribute(new Float32Array(t.array), 3)), e && u.setAttribute("normal", new BufferAttribute(new Float32Array(e.array), 3)), r && u.setAttribute("uv", new BufferAttribute(new Float32Array(r.array), 2)), o && u.setAttribute("uv2", new BufferAttribute(new Float32Array(o.array), 2));
  for (var l = 0, c = s; l < c.length; l++) {
    var f = c[l];
    u.addGroup(f.start, f.count, f.materialIndex);
  }
  return u;
}
function loadTexture(n45, t, e, r, o, s, u) {
  if (u.hasOwnProperty(n45))
    return u[n45];
  n45 = n45.split("?")[0], isAbsoluteURL(n45) || (n45 = pathJoin(t, n45)), n45 = n45.replace(/\/\/vrlab-image\d*.ljcdn.com\//, "//vrlab-public.ljcdn.com/"), n45.indexOf("//") === 0 && (n45 = "https:" + n45);
  var l = __assign({ key: "texture.dome", size: 64 }, pick(e, ["quality", "format", "sharpen", "mappings"])), c = u[n45] = o.loadTexture(n45, {
    imageURL: {
      transform: e.transform,
      options: l
    },
    wrapS: RepeatWrapping,
    wrapT: RepeatWrapping,
    fetcher: s
  }).then(function(f) {
    var d = f.body;
    return r && d.repeat.copy(r), d.needsUpdate = true, d.updateMatrix(), d;
  });
  return c;
}
function parseMaterial(n45, t, e, r, o, s, u, l, c) {
  var f = [], d = new PBMMeshMaterial(t ? "phong" : "basic");
  if (l.add(d), n45.kd && (d.color = new Color().fromArray(n45.kd.rgb).convertLinearToSRGB()), n45.mapkd) {
    var h = null;
    if (n45.mapkdrepeat) {
      var v = n45.mapkdrepeat.split(/\s+/).map(function(y) {
        return Number(y);
      }), A = v[0], g = v[1];
      h = new Vector2(A, g);
    }
    f.push(loadTexture(n45.mapkd, e, r, h, o, s, u).then(function(y) {
      y.encoding = sRGBEncoding, d.map = y, l.add(y), c.add(y), d.needsUpdate = true;
    }).catch(noop$1));
  }
  if (n45.ks && (d.specular = new Color().fromArray(n45.ks.rgb).convertLinearToSRGB()), n45.mapks && f.push(loadTexture(n45.mapks, e, r, null, o, s, u).then(function(y) {
    d.specularMap = y, l.add(y), c.add(y);
  }).catch(noop$1)), n45.ke && (d.emissive = new Color().fromArray(n45.ke.rgb).convertLinearToSRGB()), n45.mapke && f.push(loadTexture(n45.mapke, e, r, null, o, s, u).then(function(y) {
    y.encoding = sRGBEncoding, d.emissiveMap = y, l.add(y), c.add(y);
  }).catch(noop$1)), n45.norm && f.push(loadTexture(n45.norm, e, r, null, o, s, u).then(function(y) {
    d.normalMap = y, l.add(y), c.add(y);
  }).catch(noop$1)), n45.mapbump && f.push(loadTexture(n45.mapbump, e, r, null, o, s, u).then(function(y) {
    d.bumpMap = y, l.add(y), c.add(y);
  }).catch(noop$1)), n45.bump && f.push(loadTexture(n45.bump, e, r, null, o, s, u).then(function(y) {
    d.bumpMap = y, l.add(y), c.add(y);
  }).catch(noop$1)), typeof n45.ns == "number" && (d.shininess = n45.ns), typeof n45.d == "number") {
    var p = n45.d;
    p > 0 && p < 1 && (d.opacity = p);
  }
  return d.floorIndex = 0, d.refreshUniforms(), {
    material: d,
    textureReady: Promise.all(f).then(function() {
      return d.refreshUniforms();
    }).then(noop$1)
  };
}
function fromProtoBuf(n45) {
  return Model$1.decode(n45).meshes;
}
function parse$3(n45, t, e, r, o) {
  for (var s = [], u = [], l = /* @__PURE__ */ new Set(), c = fromProtoBuf(n45), f = new TextureLoader2(), d = new Matrix4(), h = new Vector3(), v = new Quaternion(), A = new Vector3(), g = {}, p = /* @__PURE__ */ new Set(), y = 0, m = c; y < m.length; y++) {
    var E = m[y], b = E.name, T = E.chunks, R = E.matrix;
    if (!(b === "Ceiling" || b === "CeilingDrop"))
      for (var S = 0, M = R; S < M.length; S++) {
        var w = M[S];
        d.elements = w.elements;
        for (var H = new Group(), L = 0; L < T.length; L++) {
          var C = parseGeometry(T[L].geometry);
          C.applyMatrix4(d), d.decompose(h, v, A), A.x * A.y * A.z < 0 && C.attributes.normal && C.attributes.position && C.attributes.uv && flipBufferGeometryNormals(C), l.add(C);
          for (var I = [], _ = 0, O = T[L].material; _ < O.length; _++) {
            var P = O[_], N = parseMaterial(P, t, e || "", r, f, o, g, l, p), k = N.material, U = N.textureReady;
            u.push(U), I.push(k);
          }
          var D = new PBMMesh(C, I);
          D.name = "chunk_" + L, D.matrix.compose(D.position, D.quaternion, D.scale), D.matrixAutoUpdate = false, D.frustumCulled = false, H.add(D);
        }
        H.name = b, s.push(H);
      }
  }
  return Promise.all(u).catch(noop$1).then(function() {
    return {
      createAt: 0,
      description: "",
      objects: s,
      textures: Array.from(p),
      dispose: function() {
        l.forEach(function(q) {
          q.dispose();
        }), l.clear();
      }
    };
  });
}
var ROTATE_X_MATRIX$4 = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
function loadDomez(n45, t) {
  var e;
  t === void 0 && (t = {});
  var r = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), o = {
    byteLength: 0
  };
  return Promise.resolve().then(function() {
    return r.ajax(n45, {
      responseType: "arraybuffer"
    });
  }).then(function(s) {
    return o.byteLength = s.body.byteLength, lzma(s.body);
  }).then(function(s) {
    var u = s.reduce(function(f, d) {
      return f + d.length;
    }, 0), l = new Uint8Array(u), c = 0;
    return s.forEach(function(f) {
      l.set(f, c), c += f.length;
    }), l;
  }).then(function(s) {
    var u, l;
    return parse$3(s, (u = t.light) !== null && u !== void 0 ? u : true, t.textureBaseUri || "", (l = t.textureOptions) !== null && l !== void 0 ? l : {}, r);
  }).then(function(s) {
    var u = new Group();
    u.matrixAutoUpdate = false, u.applyMatrix4(ROTATE_X_MATRIX$4), u.matrix.compose(u.position, u.quaternion, u.scale), u.name = n45;
    for (var l = 0, c = s.objects; l < c.length; l++) {
      var f = c[l];
      u.add(f);
    }
    return {
      type: "domez",
      upAxis: "Z",
      uri: n45,
      byteLength: o.byteLength,
      memoryUsage: getMemoryUsage(u),
      scene: u,
      textures: s.textures,
      dispose: function() {
        return s.dispose();
      }
    };
  });
}
var ROTATE_X_MATRIX$3 = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
function loadGltf(n45, t) {
  var e, r;
  t === void 0 && (t = {});
  var o = (e = t.upAxis) !== null && e !== void 0 ? e : "Y", s = (r = t.fetcher) !== null && r !== void 0 ? r : new Fetcher({ allowHosts: ["*"] }), u = 0;
  return Promise.resolve().then(function() {
    return s.ajax(n45, {
      responseType: "arraybuffer"
    }).then(function(l) {
      return u = l.body.byteLength, l.body;
    });
  }).then(function(l) {
    var c;
    return parseGltf(l, {
      copyUV2: false,
      resourcePath: n45.slice(0, n45.lastIndexOf("/") + 1),
      search: (c = n45.split("?")[1]) !== null && c !== void 0 ? c : "",
      jsonModify: function(f) {
        var d;
        if (f.extensionsUsed = (d = f.extensionsUsed) !== null && d !== void 0 ? d : [], typeof t.light == "boolean") {
          var h = "KHR_materials_unlit";
          if (t.light) {
            var v = f.extensionsUsed.indexOf(h);
            v >= 0 && f.extensionsUsed.splice(v, 1);
          } else {
            var v = f.extensionsUsed.indexOf(h);
            v === -1 && f.extensionsUsed.push(h);
          }
        }
        {
          var h = "PBM_mesh", v = f.extensionsUsed.indexOf(h);
          v === -1 && f.extensionsUsed.push(h);
        }
        return f;
      },
      fetcher: s
    });
  }).then(function(l) {
    var c = new Matrix4();
    if (o === "Y" && c.premultiply(ROTATE_X_MATRIX$3), l.CESIUM_RTC) {
      var f = new Matrix4().setPosition(l.CESIUM_RTC.center);
      c.premultiply(f);
    }
    var d = l.scene;
    return d.applyMatrix4(c), {
      type: "gltf",
      upAxis: "Z",
      uri: n45,
      byteLength: u,
      memoryUsage: getMemoryUsage(d),
      scene: d,
      textures: l.textures,
      dispose: function() {
        return l.dispose();
      }
    };
  });
}
var ROTATE_X_MATRIX$2 = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
var scratchColor = new Color();
function loadPly(n45, t) {
  var e, r;
  t === void 0 && (t = {});
  var o = (e = t.upAxis) !== null && e !== void 0 ? e : "Z", s = (r = t.fetcher) !== null && r !== void 0 ? r : new Fetcher({ allowHosts: ["*"] }), u = 0;
  return Promise.resolve().then(function() {
    return s.ajax(n45, {
      responseType: "arraybuffer"
    }).then(function(l) {
      return u = l.body.byteLength, l.body;
    });
  }).then(function(l) {
    var c, f;
    return parsePly(l, {
      propertyNameMapping: (c = t.propertyNameMapping) !== null && c !== void 0 ? c : {},
      customPropertyMapping: (f = t.customPropertyMapping) !== null && f !== void 0 ? f : {}
    });
  }).then(function(l) {
    var c = l.geometry;
    switch (t.type) {
      case "geometry": {
        var f = c;
        return o === "Y" && f.applyMatrix4(ROTATE_X_MATRIX$2), {
          type: "ply",
          upAxis: "Z",
          uri: n45,
          byteLength: u,
          memoryUsage: getGeometryMemoryUsed(f),
          scene: f,
          meta: {},
          textures: [],
          dispose: function() {
            c.dispose();
          }
        };
      }
      case "line": {
        var d = "color" in c.attributes, h = new LineBasicMaterial({
          vertexColors: d
        }), f = new Line(c, h);
        return f.computeLineDistances(), o === "Y" && f.applyMatrix4(ROTATE_X_MATRIX$2), {
          type: "ply",
          upAxis: "Z",
          uri: n45,
          byteLength: u,
          memoryUsage: getMemoryUsage(f),
          scene: f,
          meta: {},
          textures: [],
          dispose: function() {
            c.dispose(), h.dispose();
          }
        };
      }
      case "pbmMesh": {
        var v = new PBMMeshMaterial(t.light ? "phong" : "basic");
        v.vertexColors = "color" in c.attributes;
        var f = new Mesh(c, v);
        return o === "Y" && f.applyMatrix4(ROTATE_X_MATRIX$2), {
          type: "ply",
          upAxis: "Z",
          uri: n45,
          byteLength: u,
          memoryUsage: getMemoryUsage(f),
          scene: f,
          meta: {},
          textures: [],
          dispose: function() {
            c.dispose(), v.dispose();
          }
        };
      }
      case "pbmPointCloud": {
        var A = new PBMPointCloudMaterial(), f = new PBMPointCloud(c, A);
        return o === "Y" && f.applyMatrix4(ROTATE_X_MATRIX$2), {
          type: "ply",
          upAxis: "Z",
          uri: n45,
          byteLength: u,
          memoryUsage: getMemoryUsage(f),
          scene: f,
          meta: {},
          textures: [],
          dispose: function() {
            c.dispose(), A.dispose();
          }
        };
      }
    }
    throw new Error("Invalid Type: ".concat(t.type));
  });
}
function parsePly(n45, t) {
  var e = new Uint8Array(n45), r = extractHeaderText(e), o = r.headerText, s = r.headerLength, u = parseHeader(o, s, t);
  if (u.format === "ascii") {
    var l = new TextDecoder().decode(e);
    return {
      header: u,
      geometry: parseASCII(l, u, t)
    };
  } else
    return {
      header: u,
      geometry: parseBinary(n45, u, t)
    };
}
function makePlyElementProperty(n45, t) {
  var e = {
    name: "",
    type: n45[0]
  };
  return e.type === "list" ? (e.name = n45[3], e.countType = n45[1], e.itemType = n45[2]) : e.name = n45[1], e.name in t.propertyNameMapping && (e.name = t.propertyNameMapping[e.name]), e;
}
function parseHeader(n45, t, e) {
  t === void 0 && (t = 0);
  var r = /^ply([\s\S]*)end_header(\r\n|\r|\n)/, o = "", s = r.exec(n45);
  s !== null && (o = s[1]);
  for (var u = {
    format: "",
    version: "",
    comments: [],
    elements: [],
    headerLength: t,
    objInfo: ""
  }, l = o.split(/\r\n|\r|\n/), c = null, f = 0; f < l.length; f++) {
    var d = l[f];
    if (d = d.trim(), d !== "") {
      var h = d.split(/\s+/), v = h.shift();
      switch (d = h.join(" "), v) {
        case "format":
          u.format = h[0], u.version = h[1];
          break;
        case "comment":
          u.comments.push(d);
          break;
        case "element":
          c && u.elements.push(c), c = {
            name: h[0],
            count: parseInt(h[1]),
            properties: []
          };
          break;
        case "property":
          c && c.properties.push(makePlyElementProperty(h, e));
          break;
        case "obj_info":
          u.objInfo = d;
          break;
        default:
          console.log("unhandled", v, h);
      }
    }
  }
  return c && u.elements.push(c), u;
}
function parseASCIINumber(n45, t) {
  switch (t) {
    case "char":
    case "uchar":
    case "short":
    case "ushort":
    case "int":
    case "uint":
    case "int8":
    case "uint8":
    case "int16":
    case "uint16":
    case "int32":
    case "uint32":
      return parseInt(n45);
    case "float":
    case "double":
    case "float32":
    case "float64":
      return parseFloat(n45);
    default:
      throw new Error("unspport type: " + t);
  }
}
function parseASCIIElement(n45, t) {
  for (var e = {}, r = 0; r < n45.length; r++) {
    if (t.empty())
      return null;
    if (n45[r].type === "list") {
      for (var o = [], s = parseASCIINumber(t.next(), n45[r].countType), u = 0; u < s; u++) {
        if (t.empty())
          return null;
        o.push(parseASCIINumber(t.next(), n45[r].itemType));
      }
      e[n45[r].name] = o;
    } else
      e[n45[r].name] = parseASCIINumber(t.next(), n45[r].type);
  }
  return e;
}
function createBuffer(n45) {
  for (var t = {
    indices: [],
    vertices: [],
    normals: [],
    uvs: [],
    faceVertexUvs: [],
    colors: [],
    faceVertexColors: []
  }, e = 0, r = Object.keys(n45.customPropertyMapping); e < r.length; e++) {
    var o = r[e];
    t[o] = [];
  }
  return t;
}
function mapElementAttributes(n45) {
  var t = n45.map(function(r) {
    return r.name;
  });
  function e(r) {
    for (var o = 0, s = r.length; o < s; o++) {
      var u = r[o];
      if (t.includes(u))
        return u;
    }
    return null;
  }
  return {
    attrX: e(["x", "px", "posx"]) || "x",
    attrY: e(["y", "py", "posy"]) || "y",
    attrZ: e(["z", "pz", "posz"]) || "z",
    attrNX: e(["nx", "normalx"]),
    attrNY: e(["ny", "normaly"]),
    attrNZ: e(["nz", "normalz"]),
    attrS: e(["s", "u", "texture_u", "tx"]),
    attrT: e(["t", "v", "texture_v", "ty"]),
    attrR: e(["red", "diffuse_red", "r", "diffuse_r"]),
    attrG: e(["green", "diffuse_green", "g", "diffuse_g"]),
    attrB: e(["blue", "diffuse_blue", "b", "diffuse_b"])
  };
}
function parseASCII(n45, t, e) {
  var r = createBuffer(e), o = /end_header\s+(\S[\s\S]*\S|\S)\s*$/, s, u = null;
  (u = o.exec(n45)) !== null ? s = u[1].split(/\s+/) : s = [];
  var l = new ArrayStream(s);
  e: for (var c = 0; c < t.elements.length; c++)
    for (var f = t.elements[c], d = mapElementAttributes(f.properties), h = 0; h < f.count; h++) {
      var v = parseASCIIElement(f.properties, l);
      if (!v)
        break e;
      handleElement(r, f.name, v, d, e);
    }
  return postProcess(r, e);
}
function postProcess(n45, t) {
  var e = new BufferGeometry();
  n45.indices.length > 0 && e.setIndex(n45.indices), e.setAttribute("position", new Float32BufferAttribute(n45.vertices, 3)), n45.normals.length > 0 && e.setAttribute("normal", new Float32BufferAttribute(n45.normals, 3)), n45.uvs.length > 0 && e.setAttribute("uv", new Float32BufferAttribute(n45.uvs, 2)), n45.colors.length > 0 && e.setAttribute("color", new Float32BufferAttribute(n45.colors, 3)), (n45.faceVertexUvs.length > 0 || n45.faceVertexColors.length > 0) && (e = e.toNonIndexed(), n45.faceVertexUvs.length > 0 && e.setAttribute("uv", new Float32BufferAttribute(n45.faceVertexUvs, 2)), n45.faceVertexColors.length > 0 && e.setAttribute("color", new Float32BufferAttribute(n45.faceVertexColors, 3)));
  for (var r = 0, o = Object.keys(t.customPropertyMapping); r < o.length; r++) {
    var s = o[r];
    if (n45[s].length > 0) {
      var u = t.customPropertyMapping[s], l = u.itemType, c = u.itemNames, f = u.normalized, d = c.length, h = void 0;
      switch (l) {
        case "float32":
          h = new Float32BufferAttribute(n45[s], d, f);
          break;
        case "uint32":
          h = new Uint32BufferAttribute(n45[s], d, f);
          break;
        case "int32":
          h = new Int32BufferAttribute(n45[s], d, f);
          break;
        case "uint16":
          h = new Uint16BufferAttribute(n45[s], d, f);
          break;
        case "int16":
          h = new Int16BufferAttribute(n45[s], d, f);
          break;
        case "uint8":
          h = new Uint8BufferAttribute(n45[s], d, f);
          break;
        case "int8":
          h = new Int8BufferAttribute(n45[s], d, f);
          break;
        default:
          h = new Float32BufferAttribute(n45[s], d, f);
          break;
      }
      e.setAttribute(s, h);
    }
  }
  return e.computeBoundingSphere(), e;
}
function handleElement(n45, t, e, r, o) {
  if (t === "vertex") {
    r.attrX !== null && r.attrY !== null && r.attrZ !== null && n45.vertices.push(e[r.attrX], e[r.attrY], e[r.attrZ]), r.attrNX !== null && r.attrNY !== null && r.attrNZ !== null && n45.normals.push(e[r.attrNX], e[r.attrNY], e[r.attrNZ]), r.attrS !== null && r.attrT !== null && n45.uvs.push(e[r.attrS], e[r.attrT]), r.attrR !== null && r.attrG !== null && r.attrB !== null && (scratchColor.setRGB(e[r.attrR] / 255, e[r.attrG] / 255, e[r.attrB] / 255), n45.colors.push(scratchColor.r, scratchColor.g, scratchColor.b));
    for (var s = 0, u = Object.keys(o.customPropertyMapping); s < u.length; s++)
      for (var l = u[s], c = 0, f = o.customPropertyMapping[l].itemNames; c < f.length; c++) {
        var d = f[c];
        n45[l].push(e[d]);
      }
  } else if (t === "face") {
    var h = e.vertex_indices || e.vertex_index, v = e.texcoord;
    h.length === 3 ? (n45.indices.push(h[0], h[1], h[2]), v && v.length === 6 && (n45.faceVertexUvs.push(v[0], v[1]), n45.faceVertexUvs.push(v[2], v[3]), n45.faceVertexUvs.push(v[4], v[5]))) : h.length === 4 && (n45.indices.push(h[0], h[1], h[3]), n45.indices.push(h[1], h[2], h[3])), r.attrR !== null && r.attrG !== null && r.attrB !== null && (scratchColor.setRGB(e[r.attrR] / 255, e[r.attrG] / 255, e[r.attrB] / 255), n45.faceVertexColors.push(scratchColor.r, scratchColor.g, scratchColor.b), n45.faceVertexColors.push(scratchColor.r, scratchColor.g, scratchColor.b), n45.faceVertexColors.push(scratchColor.r, scratchColor.g, scratchColor.b));
  }
}
function binaryReadElement(n45, t) {
  for (var e = {}, r = 0, o = 0; o < t.length; o++) {
    var s = t[o], u = s.valueReader;
    if (s.type === "list") {
      var l = [], c = s.countReader.read(n45 + r);
      r += s.countReader.size;
      for (var f = 0; f < c; f++)
        l.push(u.read(n45 + r)), r += u.size;
      e[s.name] = l;
    } else
      e[s.name] = u.read(n45 + r), r += u.size;
  }
  return [e, r];
}
function setPropertyBinaryReaders(n45, t, e) {
  function r(l, c, f) {
    switch (c) {
      case "int8":
      case "char":
        return { read: function(d) {
          return l.getInt8(d);
        }, size: 1 };
      case "uint8":
      case "uchar":
        return { read: function(d) {
          return l.getUint8(d);
        }, size: 1 };
      case "int16":
      case "short":
        return { read: function(d) {
          return l.getInt16(d, f);
        }, size: 2 };
      case "uint16":
      case "ushort":
        return { read: function(d) {
          return l.getUint16(d, f);
        }, size: 2 };
      case "int32":
      case "int":
        return { read: function(d) {
          return l.getInt32(d, f);
        }, size: 4 };
      case "uint32":
      case "uint":
        return { read: function(d) {
          return l.getUint32(d, f);
        }, size: 4 };
      case "float32":
      case "float":
        return { read: function(d) {
          return l.getFloat32(d, f);
        }, size: 4 };
      case "float64":
      case "double":
        return { read: function(d) {
          return l.getFloat64(d, f);
        }, size: 8 };
      default:
        throw new Error("not support type: " + c);
    }
  }
  for (var o = 0, s = n45.length; o < s; o++) {
    var u = n45[o];
    u.type === "list" ? (u.countReader = r(t, u.countType, e), u.valueReader = r(t, u.itemType, e)) : u.valueReader = r(t, u.type, e);
  }
}
function parseBinary(n45, t, e) {
  for (var r = createBuffer(e), o = t.format === "binary_little_endian", s = new DataView(n45, t.headerLength), u, l = 0, c = 0; c < t.elements.length; c++) {
    var f = t.elements[c], d = f.properties, h = mapElementAttributes(d);
    setPropertyBinaryReaders(d, s, o);
    for (var v = 0; v < f.count; v++) {
      u = binaryReadElement(l, d), l += u[1];
      var A = u[0];
      handleElement(r, f.name, A, h, e);
    }
  }
  return postProcess(r, e);
}
function extractHeaderText(n45) {
  var t = 0, e = true, r = "", o = [], s = new TextDecoder().decode(n45.subarray(0, 5)), u = /^ply\r\n/.test(s);
  do {
    var l = String.fromCharCode(n45[t++]);
    l !== `
` && l !== "\r" ? r += l : (r === "end_header" && (e = false), r !== "" && (o.push(r), r = ""));
  } while (e && t < n45.length);
  return u === true && t++, {
    headerText: o.join("\r") + "\r",
    headerLength: t
  };
}
var ArrayStream = (
  /** @class */
  function() {
    function n45(t) {
      this.arr = t, this.i = 0;
    }
    return n45.prototype.empty = function() {
      return this.i >= this.arr.length;
    }, n45.prototype.next = function() {
      return this.arr[this.i++];
    }, n45;
  }()
);
var ROTATE_X_MATRIX$1 = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
var _object_pattern = /^[og]\s*(.+)?/;
var _material_library_pattern = /^mtllib /;
var _material_use_pattern = /^usemtl /;
var _map_use_pattern = /^usemap /;
var _face_vertex_data_separator_pattern = /\s+/;
var _color = new Color();
var ObjState = (
  /** @class */
  function() {
    function n45() {
      this.objects = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.materials = {}, this.materialLibraries = [], this.startObject("", false);
    }
    return n45.prototype.startObject = function(t, e) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = t, this.object.fromDeclaration = e !== false;
        return;
      }
      var r = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize == "function" && this.object._finalize(true), this.object = {
        name: t || "",
        fromDeclaration: e !== false,
        geometry: {
          vertices: [],
          hasNormal: true,
          normals: [],
          hasColor: true,
          colors: [],
          hasUV: true,
          uvs: [],
          index: [],
          indexMap: {}
        },
        materials: [],
        smooth: true,
        startMaterial: function(s, u) {
          var l, c, f = this._finalize(false);
          f && (f.inherited || ((l = f.groupCount) !== null && l !== void 0 ? l : 0) <= 0) && this.materials.splice((c = f.index) !== null && c !== void 0 ? c : 0, 1);
          var d = {
            index: this.materials.length,
            name: s || "",
            mtllib: Array.isArray(u) && u.length > 0 ? u[u.length - 1] : "",
            smooth: f !== void 0 ? f.smooth : this.smooth,
            groupStart: f !== void 0 ? f.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(h) {
              var v = {
                index: typeof h == "number" ? h : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false,
                clone: function() {
                  return this;
                }
              };
              return v.clone = this.clone.bind(v), v;
            }
          };
          return this.materials.push(d), d;
        },
        currentMaterial: function() {
          if (this.materials.length > 0)
            return this.materials[this.materials.length - 1];
        },
        _finalize: function(s) {
          var u, l, c = this.currentMaterial();
          if (c && c.groupEnd === -1 && (c.groupEnd = this.geometry.index.length, c.groupCount = c.groupEnd - ((u = c.groupStart) !== null && u !== void 0 ? u : 0), c.inherited = false), s && this.materials.length > 1)
            for (var f = this.materials.length - 1; f >= 0; f--)
              ((l = this.materials[f].groupCount) !== null && l !== void 0 ? l : 0) <= 0 && this.materials.splice(f, 1);
          return s && this.materials.length === 0 && this.materials.push({
            name: "",
            smooth: this.smooth
          }), c;
        }
      }, r && r.name && typeof r.clone == "function") {
        var o = r.clone(0);
        o.inherited = true, this.object.materials.push(o);
      }
      this.objects.push(this.object);
    }, n45.prototype.finalize = function() {
      this.object && typeof this.object._finalize == "function" && this.object._finalize(true);
    }, n45.prototype.parseVertexIndex = function(t, e) {
      var r = parseInt(t, 10);
      return (r >= 0 ? r - 1 : r + e / 3) * 3;
    }, n45.prototype.parseNormalIndex = function(t, e) {
      var r = parseInt(t, 10);
      return (r >= 0 ? r - 1 : r + e / 3) * 3;
    }, n45.prototype.parseUVIndex = function(t, e) {
      var r = parseInt(t, 10);
      return (r >= 0 ? r - 1 : r + e / 2) * 2;
    }, n45.prototype.addFace = function(t, e, r, o, s, u, l, c, f) {
      var d = this.object.geometry, h = this.vertices.length, v = this.normals.length, A = this.uvs.length, g = this.parseVertexIndex(t, h), p = this.parseVertexIndex(e, h), y = this.parseVertexIndex(r, h), m = l !== void 0 ? this.parseNormalIndex(l, v) : void 0, E = c !== void 0 ? this.parseNormalIndex(c, v) : void 0, b = f !== void 0 ? this.parseNormalIndex(f, v) : void 0, T = o !== void 0 ? this.parseUVIndex(o, A) : void 0, R = s !== void 0 ? this.parseUVIndex(s, A) : void 0, S = u !== void 0 ? this.parseUVIndex(u, A) : void 0;
      (d.hasNormal === true && m === void 0 || E === void 0 || b === void 0) && (d.hasNormal = false), (d.hasUV === true && T === void 0 || R === void 0 || S === void 0) && (d.hasUV = false);
      var M = [g, T, m].join(":"), w = d.indexMap[M];
      w === void 0 && (w = d.vertices.length / 3, d.indexMap[M] = w, d.vertices.push(this.vertices[g + 0], this.vertices[g + 1], this.vertices[g + 2]), d.hasColor && (this.colors[g] === void 0 ? d.hasColor = false : d.colors.push(this.colors[g + 0], this.colors[g + 1], this.colors[g + 2])), d.hasNormal && d.normals.push(this.normals[g + 0], this.normals[g + 1], this.normals[g + 2]), d.hasUV && d.uvs.push(this.uvs[T + 0], this.uvs[T + 1])), d.index.push(w);
      var H = [p, R, E].join(":"), L = d.indexMap[H];
      L === void 0 && (L = d.vertices.length / 3, d.indexMap[H] = L, d.vertices.push(this.vertices[p + 0], this.vertices[p + 1], this.vertices[p + 2]), d.hasColor && (this.colors[p] === void 0 ? d.hasColor = false : d.colors.push(this.colors[p + 0], this.colors[p + 1], this.colors[p + 2])), d.hasNormal && d.normals.push(this.normals[p + 0], this.normals[p + 1], this.normals[p + 2]), d.hasUV && d.uvs.push(this.uvs[R + 0], this.uvs[R + 1])), d.index.push(L);
      var C = [y, S, b].join(":"), I = d.indexMap[C];
      I === void 0 && (I = d.vertices.length / 3, d.indexMap[C] = I, d.vertices.push(this.vertices[y + 0], this.vertices[y + 1], this.vertices[y + 2]), d.hasColor && (this.colors[y] === void 0 ? d.hasColor = false : d.colors.push(this.colors[y + 0], this.colors[y + 1], this.colors[y + 2])), d.hasNormal && d.normals.push(this.normals[y + 0], this.normals[y + 1], this.normals[y + 2]), d.hasUV && d.uvs.push(this.uvs[S + 0], this.uvs[S + 1])), d.index.push(I);
    }, n45;
  }()
);
function parseObj(n45) {
  var t = new ObjState();
  n45.indexOf(`\r
`) !== -1 && (n45 = n45.replace(/\r\n/g, `
`)), n45.indexOf(`\\
`) !== -1 && (n45 = n45.replace(/\\\n/g, ""));
  for (var e = n45.split(`
`), r = [], o = 0, s = e.length; o < s; o++) {
    var u = e[o].trimStart();
    if (u.length !== 0) {
      var l = u.charAt(0);
      if (l !== "#") {
        if (l === "v") {
          var c = u.split(_face_vertex_data_separator_pattern);
          switch (c[0]) {
            case "v":
              t.vertices.push(parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3])), c.length >= 7 ? (_color.setRGB(parseFloat(c[4]), parseFloat(c[5]), parseFloat(c[6])), _color.convertSRGBToLinear(), t.colors.push(_color.r, _color.g, _color.b)) : t.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              t.normals.push(parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3]));
              break;
            case "vt":
              t.uvs.push(parseFloat(c[1]), parseFloat(c[2]));
              break;
          }
        } else if (l === "f") {
          for (var f = u.slice(1).trim(), d = f.split(_face_vertex_data_separator_pattern), h = [], v = 0, A = d.length; v < A; v++) {
            var g = d[v];
            if (g.length > 0) {
              var p = g.split("/");
              h.push(p);
            }
          }
          for (var y = h[0], v = 1, A = h.length - 1; v < A; v++) {
            var m = h[v], E = h[v + 1];
            t.addFace(y[0], m[0], E[0], y[1], m[1], E[1], y[2], m[2], E[2]);
          }
        } else if (l !== "l") {
          if (l !== "p") if ((r = _object_pattern.exec(u)) !== null) {
            var b = (" " + r[0].slice(1).trim()).slice(1);
            t.startObject(b);
          } else if (_material_use_pattern.test(u))
            t.object.startMaterial(u.substring(7).trim(), t.materialLibraries);
          else if (_material_library_pattern.test(u))
            t.materialLibraries.push(u.substring(7).trim());
          else if (_map_use_pattern.test(u))
            console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
          else if (l === "s") {
            if (r = u.split(" "), r.length > 1) {
              var T = r[1].trim().toLowerCase();
              t.object.smooth = T !== "0" && T !== "off";
            } else
              t.object.smooth = true;
            var R = t.object.currentMaterial();
            R && (R.smooth = t.object.smooth);
          } else {
            if (u === "\0")
              continue;
            console.warn('THREE.OBJLoader: Unexpected line: "' + u + '"');
          }
        }
      }
    }
  }
  return t.finalize(), t;
}
function parseMtl(n45, t, e) {
  for (var r = new TextureLoader2(), o = t.split(`
`), s = { name: "" }, u = /\s+/, l = {}, c = 0; c < o.length; c++) {
    var f = o[c];
    if (f = f.trim(), !(f.length === 0 || f.charAt(0) === "#")) {
      var d = f.indexOf(" "), h = d >= 0 ? f.substring(0, d) : f;
      h = h.toLowerCase();
      var v = d >= 0 ? f.substring(d + 1) : "";
      if (v = v.trim(), h === "newmtl")
        s = { name: v }, l[v] = s;
      else if (h === "ka" || h === "kd" || h === "ks" || h === "ke") {
        var A = v.split(u, 3);
        s[h] = [parseFloat(A[0]), parseFloat(A[1]), parseFloat(A[2])];
      } else (h === "map_kd" || h === "map_ks" || h === "map_ke" || h === "norm" || h === "map_bump" || h === "bump" || h === "map_d" || h === "ns" || h === "d" || h === "tr") && (s[h] = v);
    }
  }
  function g(y) {
    var m = {
      url: "",
      scale: new Vector2(1, 1),
      offset: new Vector2(0, 0),
      bumpScale: 1
    }, E = y.split(/\s+/), b;
    return b = E.indexOf("-bm"), b >= 0 && (m.bumpScale = parseFloat(E[b + 1]), E.splice(b, 2)), b = E.indexOf("-s"), b >= 0 && (m.scale.set(parseFloat(E[b + 1]), parseFloat(E[b + 2])), E.splice(b, 4)), b = E.indexOf("-o"), b >= 0 && (m.offset.set(parseFloat(E[b + 1]), parseFloat(E[b + 2])), E.splice(b, 4)), m.url = E.join(" ").trim(), m;
  }
  function p(y, m, E) {
    var b = g(E), T = pathJoin(e.path, b.url);
    return r.loadTexture(T, {
      fetcher: e.fetcher,
      encoding: m === "map" || m === "emissiveMap" ? sRGBEncoding : LinearEncoding,
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      wrapS: RepeatWrapping,
      wrapT: RepeatWrapping
    }).then(function(R) {
      var S = R.body;
      return S.repeat.copy(b.scale), S.offset.copy(b.offset), y.bumpScale = b.bumpScale, y[m] = S, S;
    });
  }
  return {
    name: n45,
    create: function(y) {
      var m = new PBMMeshMaterial(e.light ? "phong" : "basic"), E = [], b = l[y];
      if (b) {
        if (b.kd !== void 0 && m.color.fromArray(b.kd), b.ks !== void 0 && m.specular.fromArray(b.ks), b.ke !== void 0 && m.emissive.fromArray(b.ke), b.map_kd !== void 0 && E.push(p(m, "map", b.map_kd)), b.map_ks !== void 0 && E.push(p(m, "specularMap", b.map_ks)), b.map_ke !== void 0 && E.push(p(m, "emissiveMap", b.map_ke)), b.norm !== void 0 && E.push(p(m, "normalMap", b.norm)), b.map_bump !== void 0 && E.push(p(m, "bumpMap", b.map_bump)), b.bump !== void 0 && E.push(p(m, "bumpMap", b.bump)), b.map_d !== void 0 && E.push(p(m, "alphaMap", b.map_d)), b.ns !== void 0 && (m.shininess = parseFloat(b.ns)), b.d !== void 0) {
          var T = parseFloat(b.d);
          T < 1 && (m.opacity = T, m.transparent = true);
        }
        if (b.tr !== void 0) {
          var T = parseFloat(b.tr);
          T > 0 && (m.opacity = 1 - T, m.transparent = true);
        }
      }
      var R = Promise.all(E).then(function(S) {
        return m.refreshUniforms(), S;
      });
      return [m, R];
    }
  };
}
function build(n45, t) {
  for (var e, r = [], o = [], s = new Group(), u = function(f, d) {
    var h = n45.objects[f], v = h.geometry, A = h.materials, g = false;
    if (v.vertices.length === 0)
      return "continue";
    var p = new BufferGeometry();
    o.push(function() {
      return p.dispose();
    }), p.setAttribute("position", new BufferAttribute(new Float32Array(v.vertices), 3)), v.normals.length > 0 && p.setAttribute("normal", new BufferAttribute(new Float32Array(v.normals), 3)), v.colors.length > 0 && (g = true, p.setAttribute("color", new BufferAttribute(new Float32Array(v.colors), 3))), v.uvs.length > 0 && p.setAttribute("uv", new BufferAttribute(new Float32Array(v.uvs), 2)), v.index.length > 0 && p.setIndex(new BufferAttribute(new Uint32Array(v.index), 1)), p.computeBoundingBox(), p.computeBoundingSphere();
    for (var y = [], m = function(S, M) {
      var w = A[S], H = w.name + "_" + w.smooth + "_" + g, L = n45.materials[H];
      if (!L) {
        for (var C = null, I = 0, _ = t; I < _.length; I++) {
          var O = _[I], P = O.name, N = O.create;
          P === w.mtllib && (C = N(w.name));
        }
        if (!C) {
          var k = new PBMMeshMaterial();
          k.refreshUniforms(), C = [k, Promise.resolve([])];
        }
        L = C[0], L.name = w.name, L.flatShading = !(w.smooth || p.attributes.normal), L.vertexColors = g, n45.materials[H] = L;
        var U = C[1];
        r.push(U), o.push(function() {
          return L.dispose();
        });
      }
      y.push(L);
    }, E = 0, b = A.length; E < b; E++)
      m(E);
    p.clearGroups();
    for (var E = 0, b = A.length; E < b; E++) {
      var T = A[E];
      T.groupCount && p.addGroup((e = T.groupStart) !== null && e !== void 0 ? e : 0, T.groupCount, E);
    }
    (!p.groups || p.groups.length === 0) && p.addGroup(0, p.index ? p.index.count : p.attributes.position.count, 0);
    var R = new PBMMesh(p, y);
    R.name = h.name, s.add(R);
  }, l = 0, c = n45.objects.length; l < c; l++)
    u(l);
  return Promise.all(r).then(function(f) {
    for (var d = [], h = 0, v = f; h < v.length; h++) {
      var A = v[h];
      d = d.concat(A);
    }
    return {
      scene: s,
      textures: d,
      dispose: function() {
        return o.forEach(function(g) {
          return g();
        });
      }
    };
  });
}
function loadObj(n45, t) {
  var e, r;
  t === void 0 && (t = {});
  var o = (e = t.upAxis) !== null && e !== void 0 ? e : "Z", s = (r = t.fetcher) !== null && r !== void 0 ? r : new Fetcher({ allowHosts: ["*"] }), u = n45.slice(0, n45.lastIndexOf("/") + 1), l = 0, c;
  return Promise.resolve().then(function() {
    return s.ajax(n45, {
      responseType: "arraybuffer"
    });
  }).then(function(f) {
    l = f.body.byteLength;
    var d = new TextDecoder();
    return d.decode(f.body);
  }).then(function(f) {
    return c = parseObj(f), Promise.all(c.materialLibraries.map(function(d) {
      var h = pathJoin(u, d), v = h.slice(0, h.lastIndexOf("/") + 1);
      return s.ajax(h, {
        responseType: "text"
      }).then(function(A) {
        var g;
        return parseMtl(d, A.body, {
          path: v,
          light: (g = t.light) !== null && g !== void 0 ? g : false,
          fetcher: s
        });
      });
    }));
  }).then(function(f) {
    return build(c, f);
  }).then(function(f) {
    var d = new Matrix4();
    return o === "Y" && d.premultiply(ROTATE_X_MATRIX$1), f.scene.applyMatrix4(d), {
      type: "obj",
      upAxis: "Z",
      uri: n45,
      byteLength: l,
      memoryUsage: getMemoryUsage(f.scene),
      scene: f.scene,
      textures: f.textures,
      dispose: function() {
        return f.dispose();
      }
    };
  });
}
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(n45, t) {
  for (var e = new u16(31), r = 0; r < 31; ++r)
    e[r] = t += 1 << n45[r - 1];
  for (var o = new i32(e[30]), r = 1; r < 30; ++r)
    for (var s = e[r]; s < e[r + 1]; ++s)
      o[s] = s - e[r] << 5 | r;
  return { b: e, r: o };
};
var _a$3 = freb(fleb, 2);
var fl = _a$3.b;
var revfl = _a$3.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2, x = (x & 61680) >> 4 | (x & 3855) << 4, rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(n45, t, e) {
  for (var r = n45.length, o = 0, s = new u16(t); o < r; ++o)
    n45[o] && ++s[n45[o] - 1];
  var u = new u16(t);
  for (o = 1; o < t; ++o)
    u[o] = u[o - 1] + s[o - 1] << 1;
  var l;
  if (e) {
    l = new u16(1 << t);
    var c = 15 - t;
    for (o = 0; o < r; ++o)
      if (n45[o])
        for (var f = o << 4 | n45[o], d = t - n45[o], h = u[n45[o] - 1]++ << d, v = h | (1 << d) - 1; h <= v; ++h)
          l[rev[h] >> c] = f;
  } else
    for (l = new u16(r), o = 0; o < r; ++o)
      n45[o] && (l[o] = rev[u[n45[o] - 1]++] >> 15 - n45[o]);
  return l;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = hMap(flt, 9, 1);
var fdrm = hMap(fdt, 5, 1);
var max = function(n45) {
  for (var t = n45[0], e = 1; e < n45.length; ++e)
    n45[e] > t && (t = n45[e]);
  return t;
};
var bits = function(n45, t, e) {
  var r = t / 8 | 0;
  return (n45[r] | n45[r + 1] << 8) >> (t & 7) & e;
};
var bits16 = function(n45, t) {
  var e = t / 8 | 0;
  return (n45[e] | n45[e + 1] << 8 | n45[e + 2] << 16) >> (t & 7);
};
var shft = function(n45) {
  return (n45 + 7) / 8 | 0;
};
var slc = function(n45, t, e) {
  return (t == null || t < 0) && (t = 0), (e == null || e > n45.length) && (e = n45.length), new u8(n45.subarray(t, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(n45, t, e) {
  var r = new Error(t || ec[n45]);
  if (r.code = n45, Error.captureStackTrace && Error.captureStackTrace(r, err), !e)
    throw r;
  return r;
};
var inflt = function(n45, t, e, r) {
  var o = n45.length, s = r ? r.length : 0;
  if (!o || t.f && !t.l)
    return e || new u8(0);
  var u = !e, l = u || t.i != 2, c = t.i;
  u && (e = new u8(o * 3));
  var f = function(se) {
    var ae = e.length;
    if (se > ae) {
      var ue = new u8(Math.max(ae * 2, se));
      ue.set(e), e = ue;
    }
  }, d = t.f || 0, h = t.p || 0, v = t.b || 0, A = t.l, g = t.d, p = t.m, y = t.n, m = o * 8;
  do {
    if (!A) {
      d = bits(n45, h, 1);
      var E = bits(n45, h + 1, 3);
      if (h += 3, E)
        if (E == 1)
          A = flrm, g = fdrm, p = 9, y = 5;
        else if (E == 2) {
          var S = bits(n45, h, 31) + 257, M = bits(n45, h + 10, 15) + 4, w = S + bits(n45, h + 5, 31) + 1;
          h += 14;
          for (var H = new u8(w), L = new u8(19), C = 0; C < M; ++C)
            L[clim[C]] = bits(n45, h + C * 3, 7);
          h += M * 3;
          for (var I = max(L), _ = (1 << I) - 1, O = hMap(L, I, 1), C = 0; C < w; ) {
            var P = O[bits(n45, h, _)];
            h += P & 15;
            var b = P >> 4;
            if (b < 16)
              H[C++] = b;
            else {
              var N = 0, k = 0;
              for (b == 16 ? (k = 3 + bits(n45, h, 3), h += 2, N = H[C - 1]) : b == 17 ? (k = 3 + bits(n45, h, 7), h += 3) : b == 18 && (k = 11 + bits(n45, h, 127), h += 7); k--; )
                H[C++] = N;
            }
          }
          var U = H.subarray(0, S), D = H.subarray(S);
          p = max(U), y = max(D), A = hMap(U, p, 1), g = hMap(D, y, 1);
        } else
          err(1);
      else {
        var b = shft(h) + 4, T = n45[b - 4] | n45[b - 3] << 8, R = b + T;
        if (R > o) {
          c && err(0);
          break;
        }
        l && f(v + T), e.set(n45.subarray(b, R), v), t.b = v += T, t.p = h = R * 8, t.f = d;
        continue;
      }
      if (h > m) {
        c && err(0);
        break;
      }
    }
    l && f(v + 131072);
    for (var q = (1 << p) - 1, z = (1 << y) - 1, Q = h; ; Q = h) {
      var N = A[bits16(n45, h) & q], G = N >> 4;
      if (h += N & 15, h > m) {
        c && err(0);
        break;
      }
      if (N || err(2), G < 256)
        e[v++] = G;
      else if (G == 256) {
        Q = h, A = null;
        break;
      } else {
        var X = G - 254;
        if (G > 264) {
          var C = G - 257, $ = fleb[C];
          X = bits(n45, h, (1 << $) - 1) + fl[C], h += $;
        }
        var W = g[bits16(n45, h) & z], oe = W >> 4;
        W || err(3), h += W & 15;
        var D = fd[oe];
        if (oe > 3) {
          var $ = fdeb[oe];
          D += bits16(n45, h) & (1 << $) - 1, h += $;
        }
        if (h > m) {
          c && err(0);
          break;
        }
        l && f(v + 131072);
        var ie = v + X;
        if (v < D) {
          var re = s - D, j = Math.min(D, ie);
          for (re + v < 0 && err(3); v < j; ++v)
            e[v] = r[re + v];
        }
        for (; v < ie; ++v)
          e[v] = e[v - D];
      }
    }
    t.l = A, t.p = Q, t.b = v, t.f = d, A && (d = 1, t.m = p, t.d = g, t.n = y);
  } while (!d);
  return v != e.length && u ? slc(e, 0, v) : e.subarray(0, v);
};
var et = new u8(0);
var b2 = function(n45, t) {
  return n45[t] | n45[t + 1] << 8;
};
var b4 = function(n45, t) {
  return (n45[t] | n45[t + 1] << 8 | n45[t + 2] << 16 | n45[t + 3] << 24) >>> 0;
};
var b8 = function(n45, t) {
  return b4(n45, t) + b4(n45, t + 4) * 4294967296;
};
var zls = function(n45, t) {
  return ((n45[0] & 15) != 8 || n45[0] >> 4 > 7 || (n45[0] << 8 | n45[1]) % 31) && err(6, "invalid zlib data"), (n45[1] >> 5 & 1) == +!t && err(6, "invalid zlib data: " + (n45[1] & 32 ? "need" : "unexpected") + " dictionary"), (n45[1] >> 3 & 4) + 2;
};
function inflateSync(n45, t) {
  return inflt(n45, { i: 2 }, t && t.out, t && t.dictionary);
}
function unzlibSync(n45, t) {
  return inflt(n45.subarray(zls(n45, t), -4), { i: 2 }, t, t);
}
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true }), tds = 1;
} catch (n45) {
}
var dutf8 = function(n45) {
  for (var t = "", e = 0; ; ) {
    var r = n45[e++], o = (r > 127) + (r > 223) + (r > 239);
    if (e + o > n45.length)
      return { s: t, r: slc(n45, e - 1) };
    o ? o == 3 ? (r = ((r & 15) << 18 | (n45[e++] & 63) << 12 | (n45[e++] & 63) << 6 | n45[e++] & 63) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | r & 1023)) : o & 1 ? t += String.fromCharCode((r & 31) << 6 | n45[e++] & 63) : t += String.fromCharCode((r & 15) << 12 | (n45[e++] & 63) << 6 | n45[e++] & 63) : t += String.fromCharCode(r);
  }
};
function strFromU8(n45, t) {
  if (t) {
    for (var e = "", r = 0; r < n45.length; r += 16384)
      e += String.fromCharCode.apply(null, n45.subarray(r, r + 16384));
    return e;
  } else {
    if (td)
      return td.decode(n45);
    var o = dutf8(n45), s = o.s, e = o.r;
    return e.length && err(8), s;
  }
}
var slzh = function(n45, t) {
  return t + 30 + b2(n45, t + 26) + b2(n45, t + 28);
};
var zh = function(n45, t, e) {
  var r = b2(n45, t + 28), o = strFromU8(n45.subarray(t + 46, t + 46 + r), !(b2(n45, t + 8) & 2048)), s = t + 46 + r, u = b4(n45, t + 20), l = e && u == 4294967295 ? z64e(n45, s) : [u, b4(n45, t + 24), b4(n45, t + 42)], c = l[0], f = l[1], d = l[2];
  return [b2(n45, t + 10), c, f, o, s + b2(n45, t + 30) + b2(n45, t + 32), d];
};
var z64e = function(n45, t) {
  for (; b2(n45, t) != 1; t += 4 + b2(n45, t + 2))
    ;
  return [b8(n45, t + 12), b8(n45, t + 4), b8(n45, t + 20)];
};
function unzipSync(n45, t) {
  for (var e = {}, r = n45.length - 22; b4(n45, r) != 101010256; --r)
    (!r || n45.length - r > 65558) && err(13);
  var o = b2(n45, r + 8);
  if (!o)
    return {};
  var s = b4(n45, r + 16), u = s == 4294967295 || o == 65535;
  if (u) {
    var l = b4(n45, r - 12);
    u = b4(n45, l) == 101075792, u && (o = b4(n45, l + 32), s = b4(n45, l + 48));
  }
  for (var c = 0; c < o; ++c) {
    var f = zh(n45, s, u), d = f[0], h = f[1], v = f[2], A = f[3], g = f[4], p = f[5], y = slzh(n45, p);
    s = g, d ? d == 8 ? e[A] = inflateSync(n45.subarray(y, y + h), { out: new u8(v) }) : err(14, "unknown compression type " + d) : e[A] = slc(n45, y, y + h);
  }
  return e;
}
var ROTATE_X_MATRIX = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
function loadFbx(n45, t) {
  var e;
  t === void 0 && (t = {});
  var r = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), o = 0;
  return Promise.resolve().then(function() {
    return r.ajax(n45, {
      responseType: "arraybuffer"
    }).then(function(s) {
      return o = s.body.byteLength, s.body;
    });
  }).then(function(s) {
    var u;
    return parse$2(s, {
      light: t.light,
      resourcePath: n45.slice(0, n45.lastIndexOf("/") + 1),
      search: (u = n45.split("?")[1]) !== null && u !== void 0 ? u : "",
      fetcher: r
    });
  }).then(function(s) {
    var u = s.scene, l = s.unitScale / 100, c = new Matrix4();
    return c.makeScale(l, l, l), s.upAxis === "Y" && c.premultiply(ROTATE_X_MATRIX), u.applyMatrix4(c), {
      type: "fbx",
      upAxis: "Z",
      uri: n45,
      byteLength: o,
      memoryUsage: getMemoryUsage(u),
      scene: u,
      textures: s.textures,
      dispose: function() {
        return s.dispose();
      }
    };
  });
}
function parse$2(n45, t) {
  var e;
  if (isFbxFormatBinary(n45))
    e = new BinaryParser().parse(n45);
  else {
    var r = convertArrayBufferToString(n45);
    if (!isFbxFormatASCII(r))
      throw new Error("THREE.FBXLoader: Unknown format.");
    if (getFbxVersion(r) < 7e3)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(r));
    e = new TextParser().parse(r);
  }
  return new FBXTreeParser(t).parse(e);
}
var FBXTreeParser = (
  /** @class */
  function() {
    function n45(t) {
      var e, r, o;
      this.light = (e = t.light) !== null && e !== void 0 ? e : true, this.resourcePath = (r = t.resourcePath) !== null && r !== void 0 ? r : "", this.search = (o = t.search) !== null && o !== void 0 ? o : "", this.fetcher = t.fetcher;
    }
    return n45.prototype.parse = function(t) {
      var e, r, o, s, u, l, c = this.parseConnections(t), f = new Group(), d = [], h = this.parseImages(t), v = this.parseTextures(t, h, c, d), A = this.parseMaterials(t, v, c), g = this.parseDeformers(t, c), p = new GeometryParser().parse(t, g, c);
      this.parseScene(t, g, p, A, c, f);
      var y = (r = (e = t.GlobalSettings.UpAxis) === null || e === void 0 ? void 0 : e.value) !== null && r !== void 0 ? r : 1, m = (s = (o = t.GlobalSettings.FrontAxis) === null || o === void 0 ? void 0 : o.value) !== null && s !== void 0 ? s : 2, E = (l = (u = t.GlobalSettings.UnitScaleFactor) === null || u === void 0 ? void 0 : u.value) !== null && l !== void 0 ? l : 1, b;
      if (t.GlobalSettings.AmbientColor) {
        var T = t.GlobalSettings.AmbientColor.value, R = T[0], S = T[1], M = T[2];
        if (R !== 0 || S !== 0 || M !== 0) {
          var w = new Color().setRGB(R, S, M);
          b = new AmbientLight(w, 1);
        }
      }
      return Promise.all(d).then(function(H) {
        return {
          scene: f,
          textures: H,
          ambientLight: b,
          upAxis: ["X", "Y", "Z"][y],
          frontAxis: ["X", "Y", "Z"][m],
          unitScale: E,
          dispose: function() {
            H.forEach(function(L) {
              return L.dispose();
            }), A.forEach(function(L) {
              return L.dispose();
            }), p.forEach(function(L) {
              return L.dispose();
            });
          }
        };
      });
    }, n45.prototype.parseConnections = function(t) {
      var e = /* @__PURE__ */ new Map();
      if ("Connections" in t) {
        var r = t.Connections.connections;
        r.forEach(function(o) {
          var s = o[0], u = o[1], l = o[2];
          e.has(s) || e.set(s, {
            parents: [],
            children: []
          });
          var c = { ID: u, relationship: l };
          e.get(s).parents.push(c), e.has(u) || e.set(u, {
            parents: [],
            children: []
          });
          var f = { ID: s, relationship: l };
          e.get(u).children.push(f);
        });
      }
      return e;
    }, n45.prototype.parseImages = function(t) {
      var e = {}, r = {};
      if ("Video" in t.Objects) {
        var o = t.Objects.Video;
        for (var s in o) {
          var u = o[s], l = parseInt(s);
          if (e[l] = u.RelativeFilename || u.Filename, "Content" in u) {
            var c = u.Content instanceof ArrayBuffer && u.Content.byteLength > 0, f = typeof u.Content == "string" && u.Content !== "";
            if (c || f) {
              var d = this.parseImage(o[s]);
              r[u.RelativeFilename || u.Filename] = d;
            }
          }
        }
      }
      for (var l in e) {
        var h = e[l];
        r[h] !== void 0 ? e[l] = r[h] : e[l] = e[l].split("\\").pop();
      }
      return e;
    }, n45.prototype.parseImage = function(t) {
      var e = t.Content, r = t.RelativeFilename || t.Filename, o = r.slice(r.lastIndexOf(".") + 1).toLowerCase(), s;
      switch (o) {
        case "bmp":
          s = "image/bmp";
          break;
        case "jpg":
        case "jpeg":
          s = "image/jpeg";
          break;
        case "png":
          s = "image/png";
          break;
        case "tif":
          s = "image/tiff";
          break;
        case "tga":
          s = "image/tga";
          break;
        default:
          return;
      }
      if (typeof e == "string")
        return "data:" + s + ";base64," + e;
      var u = new Uint8Array(e);
      return window.URL.createObjectURL(new Blob([u], { type: s }));
    }, n45.prototype.parseTextures = function(t, e, r, o) {
      var s = /* @__PURE__ */ new Map();
      if ("Texture" in t.Objects) {
        var u = t.Objects.Texture;
        for (var l in u) {
          var c = this.parseTexture(u[l], e, r, o);
          s.set(parseInt(l), c);
        }
      }
      return s;
    }, n45.prototype.parseTexture = function(t, e, r, o) {
      var s = this.loadTexture(t, e, r, o);
      s.ID = t.id, s.name = t.attrName;
      var u = t.WrapModeU, l = t.WrapModeV, c = u !== void 0 ? u.value : 0, f = l !== void 0 ? l.value : 0;
      if (s.wrapS = c === 0 ? RepeatWrapping : ClampToEdgeWrapping, s.wrapT = f === 0 ? RepeatWrapping : ClampToEdgeWrapping, t.Scaling) {
        var d = t.Scaling.value;
        s.repeat.x = d[0], s.repeat.y = d[1];
      }
      if (t.Translation) {
        var d = t.Translation.value;
        s.offset.x = d[0], s.offset.y = d[1];
      }
      return s;
    }, n45.prototype.loadTexture = function(t, e, r, o) {
      var s = r.get(t.id).children, u = "";
      s !== void 0 && s.length > 0 && e[s[0].ID] !== void 0 && (u = e[s[0].ID]), u = pathJoin(this.resourcePath, appendSearch(u, this.search));
      var l = Object.assign(new Texture(), { ID: 0 }), c;
      c = this.fetcher.loadImage(u, {}, void 0, void 0, void 0, createImageBitmapLikeImage()).then(function(d) {
        return d.body;
      });
      var f = c.then(function(d) {
        return l.image = d, l.needsUpdate = true, l;
      });
      return o.push(f), l;
    }, n45.prototype.parseMaterials = function(t, e, r) {
      var o = /* @__PURE__ */ new Map();
      if ("Material" in t.Objects) {
        var s = t.Objects.Material;
        for (var u in s) {
          var l = this.parseMaterial(t, s[u], e, r);
          l !== null && o.set(parseInt(u), l);
        }
      }
      return o;
    }, n45.prototype.parseMaterial = function(t, e, r, o) {
      var s = e.id;
      e.attrName;
      var u = e.ShadingModel;
      if (typeof u == "object" && (u = u.value), u = u.toLowerCase(), !o.has(s))
        return null;
      var l = new PBMMeshMaterial(this.light ? "phong" : "basic");
      e.BumpFactor && (l.bumpScale = e.BumpFactor.value), e.Diffuse ? l.color = new Color().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (l.color = new Color().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (l.displacementScale = e.DisplacementFactor.value), e.Emissive ? l.emissive = new Color().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (l.emissive = new Color().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (l.emissiveIntensity = parseFloat(e.EmissiveFactor.value));
      var c = 1 - (e.TransparencyFactor ? parseFloat(e.TransparencyFactor.value) : 0);
      (c === 1 || c === 0) && (c = e.Opacity ? parseFloat(e.Opacity.value) : null, c === null && (c = 1 - (e.TransparentColor ? parseFloat(e.TransparentColor.value[0]) : 0))), l.opacity = c, l.opacity < 1 && (l.transparent = true), e.ReflectionFactor && (l.reflectivity = e.ReflectionFactor.value), e.Shininess && (l.shininess = e.Shininess.value), e.Specular ? l.specular = new Color().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (l.specular = new Color().fromArray(e.SpecularColor.value));
      var f = this;
      return o.get(s).children.forEach(function(d) {
        var h = d.relationship;
        switch (h) {
          case "Bump":
            l.bumpMap = f.getTexture(t, r, d.ID, o);
            break;
          case "Maya|TEX_ao_map":
            l.aoMap = f.getTexture(t, r, d.ID, o);
            break;
          case "DiffuseColor":
          case "Maya|TEX_color_map":
            l.map = f.getTexture(t, r, d.ID, o), l.map !== void 0 && (l.map.encoding = sRGBEncoding);
            break;
          case "DisplacementColor":
            l.displacementMap = f.getTexture(t, r, d.ID, o);
            break;
          case "EmissiveColor":
            l.emissiveMap = f.getTexture(t, r, d.ID, o), l.emissiveMap !== void 0 && (l.emissiveMap.encoding = sRGBEncoding);
            break;
          case "NormalMap":
          case "Maya|TEX_normal_map":
            l.normalMap = f.getTexture(t, r, d.ID, o);
            break;
          case "ReflectionColor":
            l.envMap = f.getTexture(t, r, d.ID, o), l.envMap !== void 0 && (l.envMap.mapping = EquirectangularReflectionMapping, l.envMap.encoding = sRGBEncoding);
            break;
          case "SpecularColor":
            l.specularMap = f.getTexture(t, r, d.ID, o), l.specularMap !== void 0 && (l.specularMap.encoding = sRGBEncoding);
            break;
          case "TransparentColor":
          case "TransparencyFactor":
            l.alphaMap = f.getTexture(t, r, d.ID, o), l.transparent = true;
            break;
          case "AmbientColor":
          case "ShininessExponent":
          case "SpecularFactor":
          case "VectorDisplacementColor":
          default:
            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", h);
            break;
        }
      }), l.refreshUniforms(), l;
    }, n45.prototype.getTexture = function(t, e, r, o) {
      return t.Objects.LayeredTexture && r in t.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), r = o.get(r).children[0].ID), e.get(r);
    }, n45.prototype.parseDeformers = function(t, e) {
      var r = {}, o = {};
      if ("Deformer" in t.Objects) {
        var s = t.Objects.Deformer;
        for (var u in s) {
          var l = s[u], c = e.get(parseInt(u));
          if (l.attrType === "Skin") {
            var f = this.parseSkeleton(c, s);
            f.ID = u, c.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), f.geometryID = c.parents[0].ID, r[u] = f;
          } else if (l.attrType === "BlendShape") {
            var d = {
              id: u
            };
            d.rawTargets = this.parseMorphTargets(c, s, e), d.id = u, c.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), o[u] = d;
          }
        }
      }
      return {
        skeletons: r,
        morphTargets: o
      };
    }, n45.prototype.parseSkeleton = function(t, e) {
      var r = [];
      return t.children.forEach(function(o) {
        var s = e[o.ID];
        if (s.attrType === "Cluster") {
          var u = {
            ID: o.ID,
            indices: [],
            weights: [],
            transformLink: new Matrix4().fromArray(s.TransformLink.a)
            // transform: new Matrix4().fromArray( boneNode.Transform.a ),
            // linkMode: boneNode.Mode,
          };
          s.Indexes && (u.indices = s.Indexes.a, u.weights = s.Weights.a), r.push(u);
        }
      }), {
        ID: "",
        geometryID: 0,
        rawBones: r,
        bones: []
      };
    }, n45.prototype.parseMorphTargets = function(t, e, r) {
      for (var o = [], s = 0; s < t.children.length; s++) {
        var u = t.children[s], l = e[u.ID], c = {
          name: l.attrName,
          initialWeight: l.DeformPercent,
          id: l.id,
          fullWeights: l.FullWeights.a,
          geoID: 0
        };
        if (l.attrType !== "BlendShapeChannel")
          return;
        c.geoID = r.get(parseInt(u.ID)).children.filter(function(f) {
          return f.relationship === void 0;
        })[0].ID, o.push(c);
      }
      return o;
    }, n45.prototype.parseScene = function(t, e, r, o, s, u) {
      var l = this.parseModels(t, e.skeletons, r, o, s), c = t.Objects.Model, f = this;
      l.forEach(function(h) {
        var v = c[h.ID];
        f.setLookAtProperties(t, h, v, s, u);
        var A = s.get(h.ID).parents;
        A.forEach(function(g) {
          var p = l.get(g.ID);
          p !== void 0 && p.add(h);
        }), h.parent === null && u.add(h);
      }), this.bindSkeleton(t, e.skeletons, r, l, s), u.traverse(function(h) {
        if (h.userData.transformData) {
          h.parent && (h.userData.transformData.parentMatrix = h.parent.matrix, h.userData.transformData.parentMatrixWorld = h.parent.matrixWorld);
          var v = generateTransform(h.userData.transformData);
          h.applyMatrix4(v), h.updateWorldMatrix(true, true);
        }
      });
      var d = new AnimationParser().parse(t, s, u);
      u.children.length === 1 && u.children[0] instanceof Group && (u.children[0].animations = d, u = u.children[0]), u.animations = d;
    }, n45.prototype.parseModels = function(t, e, r, o, s) {
      var u = /* @__PURE__ */ new Map(), l = t.Objects.Model;
      for (var c in l) {
        var f = parseInt(c), d = l[c], h = s.get(f), v = this.buildSkeleton(h, e, f, d.attrName);
        if (!v) {
          switch (d.attrType) {
            case "Camera":
              v = this.createCamera(t, h);
              break;
            case "Light":
              v = this.createLight(t, h);
              break;
            case "Mesh":
              v = this.createMesh(h, r, o);
              break;
            case "NurbsCurve":
            case "LimbNode":
            case "Root":
              v = new Bone();
              break;
            case "Null":
            default:
              v = new Group();
              break;
          }
          v.name = d.attrName ? PropertyBinding.sanitizeNodeName(d.attrName) : "", v.userData.originalName = d.attrName, v.ID = f;
        }
        this.getTransformData(v, d), u.set(f, v);
      }
      return u;
    }, n45.prototype.buildSkeleton = function(t, e, r, o) {
      var s = null;
      return t.parents.forEach(function(u) {
        var l = function(f) {
          var d = e[f];
          d.rawBones.forEach(function(h, v) {
            if (h.ID === u.ID) {
              var A = s;
              s = new Bone(), s.matrixWorld.copy(h.transformLink), s.name = o ? PropertyBinding.sanitizeNodeName(o) : "", s.userData.originalName = o, s.ID = r, d.bones[v] = s, A !== null && s.add(A);
            }
          });
        };
        for (var c in e)
          l(c);
      }), s;
    }, n45.prototype.createCamera = function(t, e) {
      var r, o;
      if (e.children.forEach(function(A) {
        var g = t.Objects.NodeAttribute[A.ID];
        g !== void 0 && (o = g);
      }), o === void 0)
        r = new Object3D();
      else {
        var s = 0;
        o.CameraProjectionType !== void 0 && o.CameraProjectionType.value === 1 && (s = 1);
        var u = 1;
        o.NearPlane !== void 0 && (u = o.NearPlane.value / 1e3);
        var l = 1e3;
        o.FarPlane !== void 0 && (l = o.FarPlane.value / 1e3);
        var c = window.innerWidth, f = window.innerHeight;
        o.AspectWidth !== void 0 && o.AspectHeight !== void 0 && (c = o.AspectWidth.value, f = o.AspectHeight.value);
        var d = c / f, h = 45;
        o.FieldOfView !== void 0 && (h = o.FieldOfView.value);
        var v = o.FocalLength ? o.FocalLength.value : null;
        switch (s) {
          case 0:
            r = new PerspectiveCamera(h, d, u, l), v !== null && r.setFocalLength(v);
            break;
          case 1:
            console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."), r = new Object3D();
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), r = new Object3D();
            break;
        }
      }
      return r;
    }, n45.prototype.createLight = function(t, e) {
      var r, o;
      if (e.children.forEach(function(v) {
        var A = t.Objects.NodeAttribute[v.ID];
        A !== void 0 && (o = A);
      }), o === void 0)
        r = new Object3D();
      else {
        var s = void 0;
        o.LightType === void 0 ? s = 0 : s = o.LightType.value;
        var u = new Color(16777215);
        o.Color !== void 0 && (u = new Color().fromArray(o.Color.value));
        var l = o.Intensity === void 0 ? 1 : o.Intensity.value / 100;
        o.CastLightOnObject !== void 0 && o.CastLightOnObject.value === 0 && (l = 0);
        var c = 0;
        o.FarAttenuationEnd !== void 0 && (o.EnableFarAttenuation !== void 0 && o.EnableFarAttenuation.value === 0 ? c = 0 : c = o.FarAttenuationEnd.value);
        var f = 1;
        switch (s) {
          case 0:
            r = new PointLight(u, l, c, f);
            break;
          case 1:
            r = new DirectionalLight(u, l);
            break;
          case 2:
            var d = Math.PI / 3;
            o.InnerAngle !== void 0 && (d = MathUtils.degToRad(o.InnerAngle.value));
            var h = 0;
            o.OuterAngle !== void 0 && (h = MathUtils.degToRad(o.OuterAngle.value), h = Math.max(h, 1)), r = new SpotLight(u, l, c, d, h, f);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown light type " + o.LightType.value + ", defaulting to a PointLight."), r = new PointLight(u, l);
            break;
        }
        o.CastShadows !== void 0 && o.CastShadows.value === 1 && (r.castShadow = true);
      }
      return r;
    }, n45.prototype.createMesh = function(t, e, r) {
      var o, s = null, u = [];
      if (t.children.forEach(function(c) {
        e.has(c.ID) && (s = e.get(c.ID)), r.has(c.ID) && u.push(r.get(c.ID));
      }), u.length === 0) {
        var l = new PBMMeshMaterial(this.light ? "phong" : "basic");
        l.color = new Color(13421772), u.push(l);
      }
      return "color" in s.attributes && u.forEach(function(c) {
        c.vertexColors = true;
      }), (!s.groups || s.groups.length === 0) && s.addGroup(0, s.index ? s.index.count : s.attributes.position.count, 0), s.FBX_Deformer ? (o = new PBMSkinnedMesh(s, u), o.normalizeSkinWeights()) : o = new PBMMesh(s, u), o;
    }, n45.prototype.createCurve = function(t, e) {
      var r = t.children.reduce(function(s, u) {
        return e.has(u.ID) && (s = e.get(u.ID)), s;
      }, null), o = new LineBasicMaterial({
        name: "",
        color: 3342591,
        linewidth: 1
      });
      return new Line(r, o);
    }, n45.prototype.getTransformData = function(t, e) {
      var r = {};
      e.InheritType && (r.inheritType = parseInt(e.InheritType.value)), e.RotationOrder ? r.eulerOrder = getEulerOrder(e.RotationOrder.value) : r.eulerOrder = getEulerOrder(0), e.Lcl_Translation && (r.translation = e.Lcl_Translation.value), e.PreRotation && (r.preRotation = e.PreRotation.value), e.Lcl_Rotation && (r.rotation = e.Lcl_Rotation.value), e.PostRotation && (r.postRotation = e.PostRotation.value), e.Lcl_Scaling && (r.scale = e.Lcl_Scaling.value), e.ScalingOffset && (r.scalingOffset = e.ScalingOffset.value), e.ScalingPivot && (r.scalingPivot = e.ScalingPivot.value), e.RotationOffset && (r.rotationOffset = e.RotationOffset.value), e.RotationPivot && (r.rotationPivot = e.RotationPivot.value), t.userData.transformData = r;
    }, n45.prototype.setLookAtProperties = function(t, e, r, o, s) {
      if ("LookAtProperty" in r) {
        var u = o.get(e.ID).children;
        u.forEach(function(l) {
          if (l.relationship === "LookAtProperty") {
            var c = t.Objects.Model[l.ID];
            if (c.Lcl_Translation) {
              var f = c.Lcl_Translation.value;
              "target" in e && e.target instanceof Object3D ? (e.target.position.fromArray(f), s.add(e.target)) : e.lookAt(new Vector3().fromArray(f));
            }
          }
        });
      }
    }, n45.prototype.bindSkeleton = function(t, e, r, o, s) {
      var u = this.parsePoseNodes(t), l = function(f) {
        var d = e[f], h = s.get(parseInt(d.ID)).parents;
        h.forEach(function(v) {
          if (r.has(v.ID)) {
            var A = v.ID, g = s.get(A);
            g.parents.forEach(function(p) {
              if (o.has(p.ID)) {
                var y = o.get(p.ID);
                y instanceof SkinnedMesh && y.bind(new Skeleton(d.bones), u[p.ID]);
              }
            });
          }
        });
      };
      for (var c in e)
        l(c);
    }, n45.prototype.parsePoseNodes = function(t) {
      var e = {};
      if (t.Objects.Pose) {
        var r = t.Objects.Pose;
        for (var o in r)
          if (r[o].attrType === "BindPose" && r[o].NbPoseNodes > 0) {
            var s = r[o].PoseNode;
            Array.isArray(s) ? s.forEach(function(u) {
              e[u.Node] = new Matrix4().fromArray(u.Matrix.a);
            }) : e[s.Node] = new Matrix4().fromArray(s.Matrix.a);
          }
      }
      return e;
    }, n45;
  }()
);
var GeometryParser = (
  /** @class */
  function() {
    function n45() {
      this.negativeMaterialIndices = false;
    }
    return n45.prototype.parse = function(t, e, r) {
      var o = /* @__PURE__ */ new Map();
      if ("Geometry" in t.Objects) {
        var s = t.Objects.Geometry;
        for (var u in s) {
          var l = r.get(parseInt(u)), c = this.parseGeometry(t, l, s[u], e);
          o.set(parseInt(u), c);
        }
      }
      return this.negativeMaterialIndices === true && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), o;
    }, n45.prototype.parseGeometry = function(t, e, r, o) {
      switch (r.attrType) {
        case "Mesh":
          return this.parseMeshGeometry(t, e, r, o);
        case "NurbsCurve":
          return this.parseNurbsGeometry(r);
      }
    }, n45.prototype.parseMeshGeometry = function(t, e, r, o) {
      var s = o.skeletons, u = [], l = e.parents.map(function(v) {
        return t.Objects.Model[v.ID];
      });
      if (l.length !== 0) {
        var c = e.children.reduce(function(v, A) {
          return s[A.ID] !== void 0 && (v = s[A.ID]), v;
        }, null);
        e.children.forEach(function(v) {
          o.morphTargets[v.ID] !== void 0 && u.push(o.morphTargets[v.ID]);
        });
        var f = l[0], d = {};
        f.RotationOrder && (d.eulerOrder = getEulerOrder(f.RotationOrder.value)), f.InheritType && (d.inheritType = parseInt(f.InheritType.value)), f.GeometricTranslation && (d.translation = f.GeometricTranslation.value), f.GeometricRotation && (d.rotation = f.GeometricRotation.value), f.GeometricScaling && (d.scale = f.GeometricScaling.value);
        var h = generateTransform(d);
        return this.genGeometry(t, r, c, u, h);
      }
    }, n45.prototype.genGeometry = function(t, e, r, o, s) {
      var u = new BufferGeometry();
      e.attrName && (u.name = e.attrName);
      var l = this.parseGeoNode(e, r), c = this.genBuffers(l), f = new Float32BufferAttribute(c.vertex, 3);
      if (f.applyMatrix4(s), u.setAttribute("position", f), c.colors.length > 0 && u.setAttribute("color", new Float32BufferAttribute(c.colors, 3)), r && (u.setAttribute("skinIndex", new Uint16BufferAttribute(c.weightsIndices, 4)), u.setAttribute("skinWeight", new Float32BufferAttribute(c.vertexWeights, 4)), u.FBX_Deformer = r), c.normal.length > 0) {
        var d = new Matrix3().getNormalMatrix(s), h = new Float32BufferAttribute(c.normal, 3);
        h.applyNormalMatrix(d), u.setAttribute("normal", h);
      }
      if (c.uvs.forEach(function(y, m) {
        var E = m === 0 ? "uv" : "uv".concat(m + 1);
        u.setAttribute(E, new Float32BufferAttribute(c.uvs[m], 2));
      }), l.material && l.material.mappingType !== "AllSame") {
        var v = c.materialIndex[0], A = 0;
        if (c.materialIndex.forEach(function(y, m) {
          y !== v && (u.addGroup(A, m - A, v), v = y, A = m);
        }), u.groups.length > 0) {
          var g = u.groups[u.groups.length - 1], p = g.start + g.count;
          p !== c.materialIndex.length && u.addGroup(p, c.materialIndex.length - p, v);
        }
        u.groups.length === 0 && u.addGroup(0, c.materialIndex.length, c.materialIndex[0]);
      }
      return this.addMorphTargets(t, u, e, o, s), u;
    }, n45.prototype.parseGeoNode = function(t, e) {
      var r = {};
      if (r.vertexPositions = t.Vertices !== void 0 ? t.Vertices.a : [], r.vertexIndices = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (r.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (r.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (r.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) {
        r.uv = [];
        for (var o = 0; t.LayerElementUV[o]; )
          t.LayerElementUV[o].UV && r.uv.push(this.parseUVs(t.LayerElementUV[o])), o++;
      }
      return r.weightTable = {}, e !== null && (r.skeleton = e, e.rawBones.forEach(function(s, u) {
        s.indices.forEach(function(l, c) {
          r.weightTable[l] === void 0 && (r.weightTable[l] = []), r.weightTable[l].push({
            id: u,
            weight: s.weights[c]
          });
        });
      })), r;
    }, n45.prototype.genBuffers = function(t) {
      var e = {
        vertex: [],
        normal: [],
        colors: [],
        uvs: [],
        materialIndex: [],
        vertexWeights: [],
        weightsIndices: []
      }, r = 0, o = 0, s = false, u = [], l = [], c = [], f = [], d = [], h = [], v = this;
      return t.vertexIndices.forEach(function(A, g) {
        var p = 0, y = false;
        A < 0 && (A = A ^ -1, y = true);
        var m = [], E = [];
        if (u.push(A * 3, A * 3 + 1, A * 3 + 2), t.color) {
          var b = getData(g, r, A, t.color);
          c.push(b[0], b[1], b[2]);
        }
        if (t.skeleton) {
          if (t.weightTable[A] !== void 0 && t.weightTable[A].forEach(function(M) {
            E.push(M.weight), m.push(M.id);
          }), E.length > 4) {
            s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = true);
            var T = [0, 0, 0, 0], R = [0, 0, 0, 0];
            E.forEach(function(M, w) {
              var H = M, L = m[w];
              R.forEach(function(C, I, _) {
                if (H > C) {
                  _[I] = H, H = C;
                  var O = T[I];
                  T[I] = L, L = O;
                }
              });
            }), m = T, E = R;
          }
          for (; E.length < 4; )
            E.push(0), m.push(0);
          for (var S = 0; S < 4; ++S)
            d.push(E[S]), h.push(m[S]);
        }
        if (t.normal) {
          var b = getData(g, r, A, t.normal);
          l.push(b[0], b[1], b[2]);
        }
        t.material && t.material.mappingType !== "AllSame" && (p = getData(g, r, A, t.material)[0], p < 0 && (v.negativeMaterialIndices = true, p = 0)), t.uv && t.uv.forEach(function(M, w) {
          var H = getData(g, r, A, M);
          f[w] === void 0 && (f[w] = []), f[w].push(H[0]), f[w].push(H[1]);
        }), o++, y && (v.genFace(e, t, u, p, l, c, f, d, h, o), r++, o = 0, u = [], l = [], c = [], f = [], d = [], h = []);
      }), e;
    }, n45.prototype.getNormalNewell = function(t) {
      for (var e = new Vector3(0, 0, 0), r = 0; r < t.length; r++) {
        var o = t[r], s = t[(r + 1) % t.length];
        e.x += (o.y - s.y) * (o.z + s.z), e.y += (o.z - s.z) * (o.x + s.x), e.z += (o.x - s.x) * (o.y + s.y);
      }
      return e.normalize(), e;
    }, n45.prototype.getNormalTangentAndBitangent = function(t) {
      var e = this.getNormalNewell(t), r = Math.abs(e.z) > 0.5 ? new Vector3(0, 1, 0) : new Vector3(0, 0, 1), o = r.cross(e).normalize(), s = e.clone().cross(o).normalize();
      return {
        normal: e,
        tangent: o,
        bitangent: s
      };
    }, n45.prototype.flattenVertex = function(t, e, r) {
      return new Vector2(t.dot(e), t.dot(r));
    }, n45.prototype.genFace = function(t, e, r, o, s, u, l, c, f, d) {
      var h;
      if (d > 3) {
        for (var v = [], A = e.baseVertexPositions || e.vertexPositions, g = 0; g < r.length; g += 3)
          v.push(new Vector3(A[r[g]], A[r[g + 1]], A[r[g + 2]]));
        for (var p = this.getNormalTangentAndBitangent(v), y = p.tangent, m = p.bitangent, E = [], b = 0, T = v; b < T.length; b++) {
          var R = T[b];
          E.push(this.flattenVertex(R, y, m));
        }
        h = ShapeUtils.triangulateShape(E, []);
      } else
        h = [[0, 1, 2]];
      for (var S = function(_, O, P) {
        t.vertex.push(e.vertexPositions[r[_ * 3]]), t.vertex.push(e.vertexPositions[r[_ * 3 + 1]]), t.vertex.push(e.vertexPositions[r[_ * 3 + 2]]), t.vertex.push(e.vertexPositions[r[O * 3]]), t.vertex.push(e.vertexPositions[r[O * 3 + 1]]), t.vertex.push(e.vertexPositions[r[O * 3 + 2]]), t.vertex.push(e.vertexPositions[r[P * 3]]), t.vertex.push(e.vertexPositions[r[P * 3 + 1]]), t.vertex.push(e.vertexPositions[r[P * 3 + 2]]), e.skeleton && (t.vertexWeights.push(c[_ * 4]), t.vertexWeights.push(c[_ * 4 + 1]), t.vertexWeights.push(c[_ * 4 + 2]), t.vertexWeights.push(c[_ * 4 + 3]), t.vertexWeights.push(c[O * 4]), t.vertexWeights.push(c[O * 4 + 1]), t.vertexWeights.push(c[O * 4 + 2]), t.vertexWeights.push(c[O * 4 + 3]), t.vertexWeights.push(c[P * 4]), t.vertexWeights.push(c[P * 4 + 1]), t.vertexWeights.push(c[P * 4 + 2]), t.vertexWeights.push(c[P * 4 + 3]), t.weightsIndices.push(f[_ * 4]), t.weightsIndices.push(f[_ * 4 + 1]), t.weightsIndices.push(f[_ * 4 + 2]), t.weightsIndices.push(f[_ * 4 + 3]), t.weightsIndices.push(f[O * 4]), t.weightsIndices.push(f[O * 4 + 1]), t.weightsIndices.push(f[O * 4 + 2]), t.weightsIndices.push(f[O * 4 + 3]), t.weightsIndices.push(f[P * 4]), t.weightsIndices.push(f[P * 4 + 1]), t.weightsIndices.push(f[P * 4 + 2]), t.weightsIndices.push(f[P * 4 + 3])), e.color && (t.colors.push(u[_ * 3]), t.colors.push(u[_ * 3 + 1]), t.colors.push(u[_ * 3 + 2]), t.colors.push(u[O * 3]), t.colors.push(u[O * 3 + 1]), t.colors.push(u[O * 3 + 2]), t.colors.push(u[P * 3]), t.colors.push(u[P * 3 + 1]), t.colors.push(u[P * 3 + 2])), e.material && e.material.mappingType !== "AllSame" && (t.materialIndex.push(o), t.materialIndex.push(o), t.materialIndex.push(o)), e.normal && (t.normal.push(s[_ * 3]), t.normal.push(s[_ * 3 + 1]), t.normal.push(s[_ * 3 + 2]), t.normal.push(s[O * 3]), t.normal.push(s[O * 3 + 1]), t.normal.push(s[O * 3 + 2]), t.normal.push(s[P * 3]), t.normal.push(s[P * 3 + 1]), t.normal.push(s[P * 3 + 2])), e.uv && e.uv.forEach(function(N, k) {
          t.uvs[k] === void 0 && (t.uvs[k] = []), t.uvs[k].push(l[k][_ * 2]), t.uvs[k].push(l[k][_ * 2 + 1]), t.uvs[k].push(l[k][O * 2]), t.uvs[k].push(l[k][O * 2 + 1]), t.uvs[k].push(l[k][P * 2]), t.uvs[k].push(l[k][P * 2 + 1]);
        });
      }, M = 0, w = h; M < w.length; M++) {
        var H = w[M], L = H[0], C = H[1], I = H[2];
        S(L, C, I);
      }
    }, n45.prototype.addMorphTargets = function(t, e, r, o, s) {
      if (o.length !== 0) {
        e.morphTargetsRelative = true, e.morphAttributes.position = [];
        var u = this;
        o.forEach(function(l) {
          l.rawTargets.forEach(function(c) {
            var f = t.Objects.Geometry[c.geoID];
            f !== void 0 && u.genMorphGeometry(e, r, f, s, c.name);
          });
        });
      }
    }, n45.prototype.genMorphGeometry = function(t, e, r, o, s) {
      for (var u = e.Vertices !== void 0 ? e.Vertices.a : [], l = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], c = r.Vertices !== void 0 ? r.Vertices.a : [], f = r.Indexes ? r.Indexes.a : [], d = t.attributes.position.count * 3, h = new Float32Array(d), v = 0; v < f.length; v++) {
        var A = f[v] * 3;
        h[A] = c[v * 3], h[A + 1] = c[v * 3 + 1], h[A + 2] = c[v * 3 + 2];
      }
      var g = {
        vertexIndices: l,
        vertexPositions: h,
        baseVertexPositions: u
      }, p = this.genBuffers(g), y = new Float32BufferAttribute(p.vertex, 3);
      y.name = s || r.attrName, y.applyMatrix4(o), t.morphAttributes.position.push(y);
    }, n45.prototype.parseNormals = function(t) {
      var e = t.MappingInformationType, r = t.ReferenceInformationType, o = t.Normals.a, s = [];
      return r === "IndexToDirect" && (t.NormalIndex ? s = t.NormalIndex.a : t.NormalsIndex && (s = t.NormalsIndex.a)), {
        dataSize: 3,
        buffer: o,
        indices: s,
        mappingType: e,
        referenceType: r
      };
    }, n45.prototype.parseUVs = function(t) {
      var e = t.MappingInformationType, r = t.ReferenceInformationType, o = t.UV.a, s = [];
      return r === "IndexToDirect" && (s = t.UVIndex.a), {
        dataSize: 2,
        buffer: o,
        indices: s,
        mappingType: e,
        referenceType: r
      };
    }, n45.prototype.parseVertexColors = function(t) {
      var e = t.MappingInformationType, r = t.ReferenceInformationType, o = t.Colors.a, s = [];
      r === "IndexToDirect" && (s = t.ColorIndex.a);
      for (var u = 0, l = new Color(); u < o.length; u += 4)
        l.fromArray(o, u), l.toArray(o, u);
      return {
        dataSize: 4,
        buffer: o,
        indices: s,
        mappingType: e,
        referenceType: r
      };
    }, n45.prototype.parseMaterialIndices = function(t) {
      var e = t.MappingInformationType, r = t.ReferenceInformationType;
      if (e === "NoMappingInformation")
        return {
          dataSize: 1,
          buffer: [0],
          indices: [0],
          mappingType: "AllSame",
          referenceType: r
        };
      for (var o = t.Materials.a, s = [], u = 0; u < o.length; ++u)
        s.push(u);
      return {
        dataSize: 1,
        buffer: o,
        indices: s,
        mappingType: e,
        referenceType: r
      };
    }, n45.prototype.parseNurbsGeometry = function(t) {
      var e = parseInt(t.Order);
      if (isNaN(e))
        return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new BufferGeometry();
      for (var r = e - 1, o = t.KnotVector.a, s = [], u = t.Points.a, l = 0, c = u.length; l < c; l += 4)
        s.push(new Vector4().fromArray(u, l));
      var f, d;
      if (t.Form === "Closed")
        s.push(s[0]);
      else if (t.Form === "Periodic") {
        f = r, d = o.length - 1 - f;
        for (var l = 0; l < r; ++l)
          s.push(s[l]);
      }
      var h = new NURBSCurve(r, o, s, f, d), v = h.getPoints(s.length * 12);
      return new BufferGeometry().setFromPoints(v);
    }, n45;
  }()
);
var AnimationParser = (
  /** @class */
  function() {
    function n45() {
    }
    return n45.prototype.parse = function(t, e, r) {
      var o = [], s = this.parseClips(t, e, r);
      if (s !== void 0)
        for (var u in s) {
          var l = s[u], c = this.addClip(l, r);
          o.push(c);
        }
      return o;
    }, n45.prototype.parseClips = function(t, e, r) {
      if (t.Objects.AnimationCurve !== void 0) {
        var o = this.parseAnimationCurveNodes(t);
        this.parseAnimationCurves(t, o, e);
        var s = this.parseAnimationLayers(t, o, e, r), u = this.parseAnimStacks(t, s, e);
        return u;
      }
    }, n45.prototype.parseAnimationCurveNodes = function(t) {
      var e = t.Objects.AnimationCurveNode, r = /* @__PURE__ */ new Map();
      for (var o in e) {
        var s = e[o];
        if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {
          var u = {
            id: s.id,
            attr: s.attrName,
            curves: {}
          };
          r.set(u.id, u);
        }
      }
      return r;
    }, n45.prototype.parseAnimationCurves = function(t, e, r) {
      var o = t.Objects.AnimationCurve;
      for (var s in o) {
        var u = {
          id: o[s].id,
          times: o[s].KeyTime.a.map(convertFBXTimeToSeconds),
          values: o[s].KeyValueFloat.a
        }, l = r.get(u.id);
        if (l !== void 0) {
          var c = l.parents[0].ID, f = l.parents[0].relationship, d = e.get(c);
          d && (f.match(/X/) ? d.curves.x = u : f.match(/Y/) ? d.curves.y = u : f.match(/Z/) ? d.curves.z = u : f.match(/DeformPercent/) && e.has(c) && (d.curves.morph = u));
        }
      }
    }, n45.prototype.parseAnimationLayers = function(t, e, r, o) {
      var s = t.Objects.AnimationLayer, u = /* @__PURE__ */ new Map(), l = function(f) {
        var d = [], h = r.get(parseInt(f));
        if (h !== void 0) {
          var v = h.children;
          v.forEach(function(A, g) {
            if (e.has(A.ID)) {
              var p = e.get(A.ID);
              if (p.curves.x !== void 0 || p.curves.y !== void 0 || p.curves.z !== void 0) {
                if (d[g] === void 0) {
                  var y = r.get(A.ID).parents.filter(function(w) {
                    return w.relationship !== void 0;
                  })[0].ID;
                  if (y !== void 0) {
                    var m = t.Objects.Model[y.toString()];
                    if (m === void 0) {
                      console.warn("THREE.FBXLoader: Encountered a unused curve.", A);
                      return;
                    }
                    var E = {
                      modelName: m.attrName ? PropertyBinding.sanitizeNodeName(m.attrName) : "",
                      ID: m.id,
                      initialPosition: [0, 0, 0],
                      initialRotation: [0, 0, 0],
                      initialScale: [1, 1, 1],
                      transform: new Matrix4(),
                      eulerOrder: "",
                      preRotation: [0, 0, 0],
                      postRotation: [0, 0, 0]
                    };
                    o.traverse(function(w) {
                      w.ID === m.id && (E.transform = w.matrix, w.userData.transformData && (E.eulerOrder = w.userData.transformData.eulerOrder));
                    }), E.transform || (E.transform = new Matrix4()), m.PreRotation && (E.preRotation = m.PreRotation.value), m.PostRotation && (E.postRotation = m.PostRotation.value), d[g] = E;
                  }
                }
                d[g] && (d[g][p.attr] = p);
              } else if (p.curves.morph !== void 0) {
                if (d[g] === void 0) {
                  var b = r.get(A.ID).parents.filter(function(H) {
                    return H.relationship !== void 0;
                  })[0].ID, T = r.get(b).parents[0].ID, R = r.get(T).parents[0].ID, y = r.get(R).parents[0].ID, S = t.Objects.Model[y], M = {
                    modelName: S.attrName ? PropertyBinding.sanitizeNodeName(S.attrName) : "",
                    morphName: t.Objects.Deformer[b].attrName
                  };
                  d[g] = M;
                }
                d[g][p.attr] = p;
              }
            }
          }), u.set(parseInt(f), d);
        }
      };
      for (var c in s)
        l(c);
      return u;
    }, n45.prototype.parseAnimStacks = function(t, e, r) {
      var o = t.Objects.AnimationStack, s = {};
      for (var u in o) {
        var l = r.get(parseInt(u)).children;
        l.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
        var c = e.get(l[0].ID);
        s[u] = {
          name: o[u].attrName,
          layer: c
        };
      }
      return s;
    }, n45.prototype.addClip = function(t, e) {
      var r = [], o = this;
      return t.layer.forEach(function(s) {
        r = r.concat(o.generateTracks(s, e));
      }), new AnimationClip(t.name, -1, r);
    }, n45.prototype.generateTracks = function(t, e) {
      var r = [], o = new Vector3(), s = new Vector3();
      t.transform && t.transform.decompose(o, new Quaternion(), s);
      var u = o.toArray(), l = s.toArray();
      if (t.T !== void 0 && Object.keys(t.T.curves).length > 0) {
        var c = this.generateVectorTrack(t.modelName, t.T.curves, u, "position");
        c !== void 0 && r.push(c);
      }
      if (t.R !== void 0 && Object.keys(t.R.curves).length > 0) {
        var f = this.generateRotationTrack(t.modelName, t.R.curves, t.preRotation, t.postRotation, t.eulerOrder);
        f !== void 0 && r.push(f);
      }
      if (t.S !== void 0 && Object.keys(t.S.curves).length > 0) {
        var d = this.generateVectorTrack(t.modelName, t.S.curves, l, "scale");
        d !== void 0 && r.push(d);
      }
      if (t.DeformPercent !== void 0) {
        var h = this.generateMorphTrack(t, e);
        h !== void 0 && r.push(h);
      }
      return r;
    }, n45.prototype.generateVectorTrack = function(t, e, r, o) {
      var s = this.getTimesForAllAxes(e), u = this.getKeyframeTrackValues(s, e, r);
      return new VectorKeyframeTrack(t + "." + o, s, u);
    }, n45.prototype.generateRotationTrack = function(t, e, r, o, s) {
      var u, l;
      if (e.x !== void 0 && e.y !== void 0 && e.z !== void 0) {
        var c = this.interpolateRotations(e.x, e.y, e.z, s);
        u = c[0], l = c[1];
      }
      var f = getEulerOrder(0), d = new Quaternion(), h = new Quaternion();
      r !== void 0 && (r = r.map(MathUtils.degToRad), r.push(f), d.setFromEuler(new Euler().fromArray(r))), o !== void 0 && (o = o.map(MathUtils.degToRad), o.push(f), h.setFromEuler(new Euler().fromArray(o)), h.inverse());
      var v = new Quaternion(), A = new Euler(), g = [];
      if (!l || !u)
        return new QuaternionKeyframeTrack(t + ".quaternion", [0], [0]);
      for (var p = 0; p < l.length; p += 3) {
        if (A.set(l[p], l[p + 1], l[p + 2], s), v.setFromEuler(A), v.premultiply(d), v.multiply(h), p > 2) {
          var y = new Quaternion().fromArray(g, (p - 3) / 3 * 4);
          y.dot(v) < 0 && v.set(-v.x, -v.y, -v.z, -v.w);
        }
        v.toArray(g, p / 3 * 4);
      }
      return new QuaternionKeyframeTrack(t + ".quaternion", u, g);
    }, n45.prototype.generateMorphTrack = function(t, e) {
      var r = t.DeformPercent.curves.morph, o = r.values.map(function(u) {
        return u / 100;
      }), s = e.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];
      return new NumberKeyframeTrack(t.modelName + ".morphTargetInfluences[" + s + "]", r.times, o);
    }, n45.prototype.getTimesForAllAxes = function(t) {
      var e = [];
      if (t.x !== void 0 && (e = e.concat(t.x.times)), t.y !== void 0 && (e = e.concat(t.y.times)), t.z !== void 0 && (e = e.concat(t.z.times)), e = e.sort(function(l, c) {
        return l - c;
      }), e.length > 1) {
        for (var r = 1, o = e[0], s = 1; s < e.length; s++) {
          var u = e[s];
          u !== o && (e[r] = u, o = u, r++);
        }
        e = e.slice(0, r);
      }
      return e;
    }, n45.prototype.getKeyframeTrackValues = function(t, e, r) {
      var o = r, s = [], u = -1, l = -1, c = -1;
      return t.forEach(function(f) {
        if (e.x && (u = e.x.times.indexOf(f)), e.y && (l = e.y.times.indexOf(f)), e.z && (c = e.z.times.indexOf(f)), u !== -1) {
          var d = e.x.values[u];
          s.push(d), o[0] = d;
        } else
          s.push(o[0]);
        if (l !== -1) {
          var h = e.y.values[l];
          s.push(h), o[1] = h;
        } else
          s.push(o[1]);
        if (c !== -1) {
          var v = e.z.values[c];
          s.push(v), o[2] = v;
        } else
          s.push(o[2]);
      }), s;
    }, n45.prototype.interpolateRotations = function(t, e, r, o) {
      var s = [], u = [];
      s.push(t.times[0]), u.push(MathUtils.degToRad(t.values[0])), u.push(MathUtils.degToRad(e.values[0])), u.push(MathUtils.degToRad(r.values[0]));
      for (var l = 1; l < t.values.length; l++) {
        var c = [
          t.values[l - 1],
          e.values[l - 1],
          r.values[l - 1]
        ];
        if (!(isNaN(c[0]) || isNaN(c[1]) || isNaN(c[2]))) {
          var f = c.map(MathUtils.degToRad), d = [
            t.values[l],
            e.values[l],
            r.values[l]
          ];
          if (!(isNaN(d[0]) || isNaN(d[1]) || isNaN(d[2]))) {
            d.map(MathUtils.degToRad);
            var h = [
              d[0] - c[0],
              d[1] - c[1],
              d[2] - c[2]
            ], v = [
              Math.abs(h[0]),
              Math.abs(h[1]),
              Math.abs(h[2])
            ];
            if (v[0] >= 180 || v[1] >= 180 || v[2] >= 180) {
              var A = Math.max.apply(Math, v), g = A / 180, p = new Euler(f[0], f[1], f[2], o), y = new Euler(f[0], f[1], f[2], o), m = new Quaternion().setFromEuler(p), E = new Quaternion().setFromEuler(y);
              m.dot(E) && E.set(-E.x, -E.y, -E.z, -E.w);
              for (var b = t.times[l - 1], T = t.times[l] - b, R = new Quaternion(), S = new Euler(), M = 0; M < 1; M += 1 / g)
                R.copy(m.clone().slerp(E.clone(), M)), s.push(b + M * T), S.setFromQuaternion(R, o), u.push(S.x), u.push(S.y), u.push(S.z);
            } else
              s.push(t.times[l]), u.push(MathUtils.degToRad(t.values[l])), u.push(MathUtils.degToRad(e.values[l])), u.push(MathUtils.degToRad(r.values[l]));
          }
        }
      }
      return [s, u];
    }, n45;
  }()
);
var TextParser = (
  /** @class */
  function() {
    function n45() {
      this.allNodes = new FBXTree(), this.nodeStack = [], this.currentIndent = 0, this.currentPropName = "";
    }
    return n45.prototype.getPrevNode = function() {
      return this.nodeStack[this.currentIndent - 2];
    }, n45.prototype.getCurrentNode = function() {
      return this.nodeStack[this.currentIndent - 1];
    }, n45.prototype.getCurrentProp = function() {
      return this.currentProp;
    }, n45.prototype.pushStack = function(t) {
      this.nodeStack.push(t), this.currentIndent += 1;
    }, n45.prototype.popStack = function() {
      this.nodeStack.pop(), this.currentIndent -= 1;
    }, n45.prototype.setCurrentProp = function(t, e) {
      this.currentProp = t, this.currentPropName = e;
    }, n45.prototype.parse = function(t) {
      this.currentIndent = 0, this.allNodes = new FBXTree(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
      var e = this, r = t.split(/[\r\n]+/);
      return r.forEach(function(o, s) {
        var u = o.match(/^[\s\t]*;/), l = o.match(/^[\s\t]*$/);
        if (!(u || l)) {
          var c = o.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){"), f = o.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), d = o.match("^\\t{" + (e.currentIndent - 1) + "}}");
          c ? e.parseNodeBegin(o, c) : f ? e.parseNodeProperty(o, f, r[++s]) : d ? e.popStack() : o.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(o);
        }
      }), this.allNodes;
    }, n45.prototype.parseNodeBegin = function(t, e) {
      var r = e[1].trim().replace(/^"/, "").replace(/"$/, ""), o = e[2].split(",").map(function(c) {
        return c.trim().replace(/^"/, "").replace(/"$/, "");
      }), s = { name: r }, u = this.parseNodeAttr(o), l = this.getCurrentNode();
      this.currentIndent === 0 ? this.allNodes.add(r, s) : r in l ? (r === "PoseNode" ? l.PoseNode.push(s) : l[r].id !== void 0 && (l[r] = {}, l[r][l[r].id] = l[r]), u.id !== "" && (l[r][u.id] = s)) : typeof u.id == "number" ? (l[r] = {}, l[r][u.id] = s) : r !== "Properties70" && (r === "PoseNode" ? l[r] = [s] : l[r] = s), typeof u.id == "number" && (s.id = u.id), u.name !== "" && (s.attrName = u.name), u.type !== "" && (s.attrType = u.type), this.pushStack(s);
    }, n45.prototype.parseNodeAttr = function(t) {
      var e = t[0];
      t[0] !== "" && (e = parseInt(t[0]), isNaN(e) && (e = t[0]));
      var r = "", o = "";
      return t.length > 1 && (r = t[1].replace(/^(\w+)::/, ""), o = t[2]), { id: e, name: r, type: o };
    }, n45.prototype.parseNodeProperty = function(t, e, r) {
      var o = e[1].replace(/^"/, "").replace(/"$/, "").trim(), s = e[2].replace(/^"/, "").replace(/"$/, "").trim();
      o === "Content" && s === "," && (s = r.replace(/"/g, "").replace(/,$/, "").trim());
      var u = this.getCurrentNode(), l = u.name;
      if (l === "Properties70") {
        this.parseNodeSpecialProperty(t, o, s);
        return;
      }
      if (o === "C") {
        var c = s.split(",").slice(1), f = parseInt(c[0]), d = parseInt(c[1]), h = s.split(",").slice(3);
        h = h.map(function(v) {
          return v.trim().replace(/^"/, "");
        }), o = "connections", s = [f, d], append(s, h), u[o] === void 0 && (u[o] = []);
      }
      o === "Node" && (u.id = s), o in u && Array.isArray(u[o]) ? u[o].push(s) : o !== "a" ? u[o] = s : u.a = s, this.setCurrentProp(u, o), o === "a" && s.slice(-1) !== "," && (u.a = parseNumberArray(s));
    }, n45.prototype.parseNodePropertyContinued = function(t) {
      var e = this.getCurrentNode();
      e.a += t, t.slice(-1) !== "," && (e.a = parseNumberArray(e.a));
    }, n45.prototype.parseNodeSpecialProperty = function(t, e, r) {
      var o = r.split('",').map(function(d) {
        return d.trim().replace(/^\"/, "").replace(/\s/, "_");
      }), s = o[0], u = o[1], l = o[2], c = o[3], f = o[4];
      switch (u) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
          f = parseFloat(f);
          break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
          f = parseNumberArray(f);
          break;
      }
      this.getPrevNode()[s] = {
        type: u,
        type2: l,
        flag: c,
        value: f
      }, this.setCurrentProp(this.getPrevNode(), s);
    }, n45;
  }()
);
var BinaryParser = (
  /** @class */
  function() {
    function n45() {
    }
    return n45.prototype.parse = function(t) {
      var e = new BinaryReader(t);
      e.skip(23);
      var r = e.getUint32();
      if (r < 6400)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
      for (var o = new FBXTree(); !this.endOfContent(e); ) {
        var s = this.parseNode(e, r);
        s !== null && o.add(s.name, s);
      }
      return o;
    }, n45.prototype.endOfContent = function(t) {
      return t.size() % 16 === 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size();
    }, n45.prototype.parseNode = function(t, e) {
      var r = {}, o = e >= 7500 ? t.getUint64() : t.getUint32(), s = e >= 7500 ? t.getUint64() : t.getUint32();
      e >= 7500 ? t.getUint64() : t.getUint32();
      var u = t.getUint8(), l = t.getString(u);
      if (o === 0)
        return null;
      for (var c = [], f = 0; f < s; f++)
        c.push(this.parseProperty(t));
      var d = c.length > 0 ? c[0] : "", h = c.length > 1 ? c[1] : "", v = c.length > 2 ? c[2] : "";
      for (r.singleProperty = s === 1 && t.getOffset() === o; o > t.getOffset(); ) {
        var A = this.parseNode(t, e);
        A !== null && this.parseSubNode(l, r, A);
      }
      return r.propertyList = c, typeof d == "number" && (r.id = d), h !== "" && (r.attrName = h), v !== "" && (r.attrType = v), l !== "" && (r.name = l), r;
    }, n45.prototype.parseSubNode = function(t, e, r) {
      if (r.singleProperty === true) {
        var o = r.propertyList[0];
        Array.isArray(o) ? (e[r.name] = r, r.a = o) : e[r.name] = o;
      } else if (t === "Connections" && r.name === "C") {
        var s = [];
        r.propertyList.forEach(function(v, A) {
          A !== 0 && s.push(v);
        }), e.connections === void 0 && (e.connections = []), e.connections.push(s);
      } else if (r.name === "Properties70") {
        var u = Object.keys(r);
        u.forEach(function(v) {
          e[v] = r[v];
        });
      } else if (t === "Properties70" && r.name === "P") {
        var l = r.propertyList[0], c = r.propertyList[1], f = r.propertyList[2], d = r.propertyList[3], h = void 0;
        l.indexOf("Lcl ") === 0 && (l = l.replace("Lcl ", "Lcl_")), c.indexOf("Lcl ") === 0 && (c = c.replace("Lcl ", "Lcl_")), c === "Color" || c === "ColorRGB" || c === "Vector" || c === "Vector3D" || c.indexOf("Lcl_") === 0 ? h = [
          r.propertyList[4],
          r.propertyList[5],
          r.propertyList[6]
        ] : h = r.propertyList[4], e[l] = {
          type: c,
          type2: f,
          flag: d,
          value: h
        };
      } else e[r.name] === void 0 ? typeof r.id == "number" ? (e[r.name] = {}, e[r.name][r.id] = r) : e[r.name] = r : r.name === "PoseNode" ? (Array.isArray(e[r.name]) || (e[r.name] = [e[r.name]]), e[r.name].push(r)) : e[r.name][r.id] === void 0 && (e[r.name][r.id] = r);
    }, n45.prototype.parseProperty = function(t) {
      var e = t.getString(1), r;
      switch (e) {
        case "C":
          return t.getBoolean();
        case "D":
          return t.getFloat64();
        case "F":
          return t.getFloat32();
        case "I":
          return t.getInt32();
        case "L":
          return t.getInt64();
        case "R":
          return r = t.getUint32(), t.getArrayBuffer(r);
        case "S":
          return r = t.getUint32(), t.getString(r);
        case "Y":
          return t.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
          var o = t.getUint32(), s = t.getUint32(), u = t.getUint32();
          if (s === 0)
            switch (e) {
              case "b":
              case "c":
                return t.getBooleanArray(o);
              case "d":
                return t.getFloat64Array(o);
              case "f":
                return t.getFloat32Array(o);
              case "i":
                return t.getInt32Array(o);
              case "l":
                return t.getInt64Array(o);
            }
          var l = unzlibSync(new Uint8Array(t.getArrayBuffer(u))), c = new BinaryReader(l.buffer);
          switch (e) {
            case "b":
            case "c":
              return c.getBooleanArray(o);
            case "d":
              return c.getFloat64Array(o);
            case "f":
              return c.getFloat32Array(o);
            case "i":
              return c.getInt32Array(o);
            case "l":
              return c.getInt64Array(o);
          }
          break;
        default:
          throw new Error("THREE.FBXLoader: Unknown property type " + e);
      }
    }, n45;
  }()
);
var BinaryReader = (
  /** @class */
  function() {
    function n45(t, e) {
      this.dv = new DataView(t), this.offset = 0, this.littleEndian = e !== void 0 ? e : true, this._textDecoder = new TextDecoder();
    }
    return n45.prototype.getOffset = function() {
      return this.offset;
    }, n45.prototype.size = function() {
      return this.dv.buffer.byteLength;
    }, n45.prototype.skip = function(t) {
      this.offset += t;
    }, n45.prototype.getBoolean = function() {
      return (this.getUint8() & 1) === 1;
    }, n45.prototype.getBooleanArray = function(t) {
      for (var e = [], r = 0; r < t; r++)
        e.push(this.getBoolean());
      return e;
    }, n45.prototype.getUint8 = function() {
      var t = this.dv.getUint8(this.offset);
      return this.offset += 1, t;
    }, n45.prototype.getInt16 = function() {
      var t = this.dv.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, t;
    }, n45.prototype.getInt32 = function() {
      var t = this.dv.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, t;
    }, n45.prototype.getInt32Array = function(t) {
      for (var e = [], r = 0; r < t; r++)
        e.push(this.getInt32());
      return e;
    }, n45.prototype.getUint32 = function() {
      var t = this.dv.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, t;
    }, n45.prototype.getInt64 = function() {
      var t, e;
      return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), e & 2147483648 ? (e = ~e & 4294967295, t = ~t & 4294967295, t === 4294967295 && (e = e + 1 & 4294967295), t = t + 1 & 4294967295, -(e * 4294967296 + t)) : e * 4294967296 + t;
    }, n45.prototype.getInt64Array = function(t) {
      for (var e = [], r = 0; r < t; r++)
        e.push(this.getInt64());
      return e;
    }, n45.prototype.getUint64 = function() {
      var t, e;
      return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), e * 4294967296 + t;
    }, n45.prototype.getFloat32 = function() {
      var t = this.dv.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, t;
    }, n45.prototype.getFloat32Array = function(t) {
      for (var e = [], r = 0; r < t; r++)
        e.push(this.getFloat32());
      return e;
    }, n45.prototype.getFloat64 = function() {
      var t = this.dv.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, t;
    }, n45.prototype.getFloat64Array = function(t) {
      for (var e = [], r = 0; r < t; r++)
        e.push(this.getFloat64());
      return e;
    }, n45.prototype.getArrayBuffer = function(t) {
      var e = this.dv.buffer.slice(this.offset, this.offset + t);
      return this.offset += t, e;
    }, n45.prototype.getString = function(t) {
      var e = this.offset, r = new Uint8Array(this.dv.buffer, e, t);
      this.skip(t);
      var o = r.indexOf(0);
      return o >= 0 && (r = new Uint8Array(this.dv.buffer, e, o)), this._textDecoder.decode(r);
    }, n45;
  }()
);
var FBXTree = (
  /** @class */
  function() {
    function n45() {
      this.Connections = {
        connections: []
      }, this.Objects = {
        Model: {},
        NodeAttribute: {},
        Geometry: {}
      }, this.GlobalSettings = {};
    }
    return n45.prototype.add = function(t, e) {
      this[t] = e;
    }, n45;
  }()
);
function isFbxFormatBinary(n45) {
  var t = "Kaydara FBX Binary  \0";
  return n45.byteLength >= t.length && t === convertArrayBufferToString(n45, 0, t.length);
}
function isFbxFormatASCII(n45) {
  var t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"], e = 0;
  function r(u) {
    var l = n45[u - 1];
    return n45 = n45.slice(e + u), e++, l;
  }
  for (var o = 0; o < t.length; ++o) {
    var s = r(1);
    if (s === t[o])
      return false;
  }
  return true;
}
function getFbxVersion(n45) {
  var t = /FBXVersion: (\d+)/, e = n45.match(t);
  if (e) {
    var r = parseInt(e[1]);
    return r;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(n45) {
  return n45 / 46186158e3;
}
var dataArray = [];
function getData(n45, t, e, r) {
  var o;
  switch (r.mappingType) {
    case "ByPolygonVertex":
      o = n45;
      break;
    case "ByPolygon":
      o = t;
      break;
    case "ByVertice":
      o = e;
      break;
    case "AllSame":
      o = r.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType), o = 0;
  }
  r.referenceType === "IndexToDirect" && (o = r.indices[o]);
  var s = o * r.dataSize, u = s + r.dataSize;
  return slice(dataArray, r.buffer, s, u);
}
var tempEuler = new Euler();
var tempVec = new Vector3();
function generateTransform(n45) {
  var t = new Matrix4(), e = new Matrix4(), r = new Matrix4(), o = new Matrix4(), s = new Matrix4(), u = new Matrix4(), l = new Matrix4(), c = new Matrix4(), f = new Matrix4(), d = new Matrix4(), h = new Matrix4(), v = new Matrix4(), A = n45.inheritType ? n45.inheritType : 0;
  n45.translation && t.setPosition(tempVec.fromArray(n45.translation));
  var g = getEulerOrder(0);
  if (n45.preRotation) {
    var p = n45.preRotation.map(MathUtils.degToRad);
    p.push(g), e.makeRotationFromEuler(tempEuler.fromArray(p));
  }
  if (n45.rotation) {
    var p = n45.rotation.map(MathUtils.degToRad);
    p.push(n45.eulerOrder || g), r.makeRotationFromEuler(tempEuler.fromArray(p));
  }
  if (n45.postRotation) {
    var p = n45.postRotation.map(MathUtils.degToRad);
    p.push(g), o.makeRotationFromEuler(tempEuler.fromArray(p)), o.copy(new Matrix4().getInverse(o));
  }
  n45.scale && s.scale(tempVec.fromArray(n45.scale)), n45.scalingOffset && l.setPosition(tempVec.fromArray(n45.scalingOffset)), n45.scalingPivot && u.setPosition(tempVec.fromArray(n45.scalingPivot)), n45.rotationOffset && c.setPosition(tempVec.fromArray(n45.rotationOffset)), n45.rotationPivot && f.setPosition(tempVec.fromArray(n45.rotationPivot)), n45.parentMatrixWorld && (h.copy(n45.parentMatrix), d.copy(n45.parentMatrixWorld));
  var y = e.clone().multiply(r).multiply(o), m = new Matrix4();
  m.extractRotation(d);
  var E = new Matrix4();
  E.copyPosition(d);
  var b = new Matrix4().getInverse(E).multiply(d), T = new Matrix4().getInverse(m).multiply(b), R = s, S = new Matrix4();
  if (A === 0)
    S.copy(m).multiply(y).multiply(T).multiply(R);
  else if (A === 1)
    S.copy(m).multiply(T).multiply(y).multiply(R);
  else {
    var M = new Matrix4().scale(new Vector3().setFromMatrixScale(h)), w = new Matrix4().getInverse(M), H = T.clone().multiply(w);
    S.copy(m).multiply(y).multiply(H).multiply(R);
  }
  var L = new Matrix4().getInverse(f), C = new Matrix4().getInverse(u), I = t.clone().multiply(c).multiply(f).multiply(e).multiply(r).multiply(o).multiply(L).multiply(l).multiply(u).multiply(s).multiply(C), _ = new Matrix4().copyPosition(I), O = d.clone().multiply(_);
  return v.copyPosition(O), I = v.clone().multiply(S), I.premultiply(new Matrix4().getInverse(d)), I;
}
function getEulerOrder(n45) {
  n45 = n45 || 0;
  var t = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return n45 === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[n45];
}
function parseNumberArray(n45) {
  var t = n45.split(",").map(function(e) {
    return parseFloat(e);
  });
  return t;
}
function convertArrayBufferToString(n45, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = n45.byteLength), new TextDecoder().decode(new Uint8Array(n45, t, e));
}
function append(n45, t) {
  for (var e = 0, r = n45.length, o = t.length; e < o; e++, r++)
    n45[r] = t[e];
}
function slice(n45, t, e, r) {
  for (var o = e, s = 0; o < r; o++, s++)
    n45[s] = t[o];
  return n45;
}
var NURBSCurve = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o, s, u) {
      var l = n45.call(this) || this, c = r ? r.length - 1 : 0, f = o ? o.length : 0;
      l.degree = e, l.knots = r, l.controlPoints = [], l.startKnot = s || 0, l.endKnot = u || c;
      for (var d = 0; d < f; ++d) {
        var h = o[d];
        l.controlPoints[d] = new Vector4(h.x, h.y, h.z, h.w);
      }
      return l;
    }
    return t.prototype.getPoint = function(e, r) {
      r === void 0 && (r = new Vector3());
      var o = r, s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), u = calcBSplinePoint(this.degree, this.knots, this.controlPoints, s);
      return u.w !== 1 && u.divideScalar(u.w), o.set(u.x, u.y, u.z);
    }, t.prototype.getTangent = function(e, r) {
      r === void 0 && (r = new Vector3());
      var o = r, s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), u = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, s, 1);
      return o.copy(u[1]).normalize(), o;
    }, t.prototype.toJSON = function() {
      var e = n45.prototype.toJSON.call(this);
      return e.degree = this.degree, e.knots = __spreadArray([], this.knots, true), e.controlPoints = this.controlPoints.map(function(r) {
        return r.toArray();
      }), e.startKnot = this.startKnot, e.endKnot = this.endKnot, e;
    }, t.prototype.fromJSON = function(e) {
      return n45.prototype.fromJSON.call(this, e), this.degree = e.degree, this.knots = __spreadArray([], e.knots, true), this.controlPoints = e.controlPoints.map(function(r) {
        return new Vector4(r[0], r[1], r[2], r[3]);
      }), this.startKnot = e.startKnot, this.endKnot = e.endKnot, this;
    }, t;
  }(Curve)
);
function findSpan(n45, t, e) {
  var r = e.length - n45 - 1;
  if (t >= e[r])
    return r - 1;
  if (t <= e[n45])
    return n45;
  for (var o = n45, s = r, u = Math.floor((o + s) / 2); t < e[u] || t >= e[u + 1]; )
    t < e[u] ? s = u : o = u, u = Math.floor((o + s) / 2);
  return u;
}
function calcBasisFunctions(n45, t, e, r) {
  var o = [], s = [], u = [];
  o[0] = 1;
  for (var l = 1; l <= e; ++l) {
    s[l] = t - r[n45 + 1 - l], u[l] = r[n45 + l] - t;
    for (var c = 0, f = 0; f < l; ++f) {
      var d = u[f + 1], h = s[l - f], v = o[f] / (d + h);
      o[f] = c + d * v, c = h * v;
    }
    o[l] = c;
  }
  return o;
}
function calcBSplinePoint(n45, t, e, r) {
  for (var o = findSpan(n45, r, t), s = calcBasisFunctions(o, r, n45, t), u = new Vector4(0, 0, 0, 0), l = 0; l <= n45; ++l) {
    var c = e[o - n45 + l], f = s[l], d = c.w * f;
    u.x += c.x * d, u.y += c.y * d, u.z += c.z * d, u.w += c.w * f;
  }
  return u;
}
function calcBasisFunctionDerivatives(n45, t, e, r, o) {
  for (var s = [], u = 0; u <= e; ++u)
    s[u] = 0;
  for (var l = [], u = 0; u <= r; ++u)
    l[u] = s.slice(0);
  for (var c = [], u = 0; u <= e; ++u)
    c[u] = s.slice(0);
  c[0][0] = 1;
  for (var f = s.slice(0), d = s.slice(0), h = 1; h <= e; ++h) {
    f[h] = t - o[n45 + 1 - h], d[h] = o[n45 + h] - t;
    for (var v = 0, A = 0; A < h; ++A) {
      var g = d[A + 1], p = f[h - A];
      c[h][A] = g + p;
      var y = c[A][h - 1] / c[h][A];
      c[A][h] = v + g * y, v = p * y;
    }
    c[h][h] = v;
  }
  for (var h = 0; h <= e; ++h)
    l[0][h] = c[h][e];
  for (var m = 0; m <= e; ++m) {
    for (var E = 0, b = 1, T = [], u = 0; u <= e; ++u)
      T[u] = s.slice(0);
    T[0][0] = 1;
    for (var R = 1; R <= r; ++R) {
      var S = 0, M = m - R, w = e - R;
      m >= R && (T[b][0] = T[E][0] / c[w + 1][M], S = T[b][0] * c[M][w]);
      for (var H = M >= -1 ? 1 : -M, L = m - 1 <= w ? R - 1 : e - m, C = H; C <= L; ++C)
        T[b][C] = (T[E][C] - T[E][C - 1]) / c[w + 1][M + C], S += T[b][C] * c[M + C][w];
      m <= w && (T[b][R] = -T[E][R - 1] / c[w + 1][m], S += T[b][R] * c[m][w]), l[R][m] = S;
      var h = E;
      E = b, b = h;
    }
  }
  for (var I = e, R = 1; R <= r; ++R) {
    for (var h = 0; h <= e; ++h)
      l[R][h] *= I;
    I *= e - R;
  }
  return l;
}
function calcBSplineDerivatives(n45, t, e, r, o) {
  for (var s = o < n45 ? o : n45, u = [], l = findSpan(n45, r, t), c = calcBasisFunctionDerivatives(l, r, n45, s, t), f = [], d = 0; d < e.length; ++d) {
    var h = e[d].clone(), v = h.w;
    h.x *= v, h.y *= v, h.z *= v, f[d] = h;
  }
  for (var A = 0; A <= s; ++A) {
    for (var h = f[l - n45].clone().multiplyScalar(c[A][0]), g = 1; g <= n45; ++g)
      h.add(f[l - n45 + g].clone().multiplyScalar(c[A][g]));
    u[A] = h;
  }
  for (var A = s + 1; A <= o + 1; ++A)
    u[A] = new Vector4(0, 0, 0);
  return u;
}
function calcKoverI(n45, t) {
  for (var e = 1, r = 2; r <= n45; ++r)
    e *= r;
  for (var o = 1, r = 2; r <= t; ++r)
    o *= r;
  for (var r = 2; r <= n45 - t; ++r)
    o *= r;
  return e / o;
}
function calcRationalCurveDerivatives(n45) {
  for (var t = n45.length, e = [], r = [], o = 0; o < t; ++o) {
    var s = n45[o];
    e[o] = new Vector3(s.x, s.y, s.z), r[o] = s.w;
  }
  for (var u = [], l = 0; l < t; ++l) {
    for (var c = e[l].clone(), o = 1; o <= l; ++o)
      c.sub(u[l - o].clone().multiplyScalar(calcKoverI(l, o) * r[o]));
    u[l] = c.divideScalar(r[0]);
  }
  return u;
}
function calcNURBSDerivatives(n45, t, e, r, o) {
  var s = calcBSplineDerivatives(n45, t, e, r, o);
  return calcRationalCurveDerivatives(s);
}
var _vector = new Vector3();
function getPointArray(n45, t) {
  switch (t) {
    case "D":
      return new Float64Array(n45);
    case "F":
      return new Float32Array(n45);
    case "L":
      return new Int32Array(n45);
    case "I":
      return new Int16Array(n45);
    default:
      return new Uint8Array(n45);
  }
}
function loadX3p(n45, t) {
  var e;
  t === void 0 && (t = {});
  var r = (e = t.fetcher) !== null && e !== void 0 ? e : new Fetcher({ allowHosts: ["*"] }), o = {
    byteLength: 0
  };
  return Promise.resolve().then(function() {
    return r.ajax(n45, {
      responseType: "arraybuffer"
    });
  }).then(function(s) {
    var u, l;
    return o.byteLength = s.body.byteLength, parse$1(new Uint8Array(s.body), {
      light: (u = t.light) !== null && u !== void 0 ? u : true,
      color: t.color,
      resourcePath: n45.slice(0, n45.lastIndexOf("/") + 1),
      search: (l = n45.split("?")[1]) !== null && l !== void 0 ? l : "",
      fetcher: r
    });
  }).then(function(s) {
    var u = new Group();
    return u.matrixAutoUpdate = false, u.matrix.compose(u.position, u.quaternion, u.scale), u.name = n45, u.add(s.object), {
      type: "x3p",
      upAxis: "Z",
      uri: n45,
      byteLength: o.byteLength,
      memoryUsage: getMemoryUsage(u),
      scene: u,
      textures: [],
      dispose: function() {
        return s.dispose();
      }
    };
  });
}
function parse$1(n45, t) {
  for (var e, r, o, s, u, l, c, f, d, h, v, A, g, p, y, m, E, b, T, R, S, M, w, H, L, C, I, _, O, P, N, k, U, D, q, z, Q, G, X, $, W, oe, ie, re, j, se, ae, ue, fe, ne, Te, Re, ve, Ce, Z = unzipSync(n45), te = "", K = null, ye = 0, de = Object.keys(Z); ye < de.length; ye++) {
    var xe = de[ye];
    /(^|\/)main\.xml$/i.test(xe) && (K = Z[xe], te = xe.slice(0, xe.lastIndexOf("/") + 1));
  }
  if (!K)
    throw new Error("X3p: main.xml not found.");
  if (typeof DOMParser == "undefined")
    throw new Error("X3p: DOMParser not found.");
  var Ae = (e = t.color) !== null && e !== void 0 ? e : new Color(10066329), me = new DOMParser(), ce = decodeText(K), pe = me.parseFromString(ce, "text/xml"), ee = pe.querySelector("Record1 Axes"), he = {
    x: {
      type: (s = (o = (r = ee == null ? void 0 : ee.querySelector("CX AxisType")) === null || r === void 0 ? void 0 : r.textContent) === null || o === void 0 ? void 0 : o.toUpperCase()) !== null && s !== void 0 ? s : "I",
      dataType: (c = (l = (u = ee == null ? void 0 : ee.querySelector("CX DataType")) === null || u === void 0 ? void 0 : u.textContent) === null || l === void 0 ? void 0 : l.toUpperCase()) !== null && c !== void 0 ? c : "D",
      increment: Number((d = (f = ee == null ? void 0 : ee.querySelector("CX Increment")) === null || f === void 0 ? void 0 : f.textContent) !== null && d !== void 0 ? d : "1"),
      offset: Number((v = (h = ee == null ? void 0 : ee.querySelector("CX Offset")) === null || h === void 0 ? void 0 : h.textContent) !== null && v !== void 0 ? v : "0")
    },
    y: {
      type: (p = (g = (A = ee == null ? void 0 : ee.querySelector("CY AxisType")) === null || A === void 0 ? void 0 : A.textContent) === null || g === void 0 ? void 0 : g.toUpperCase()) !== null && p !== void 0 ? p : "I",
      dataType: (E = (m = (y = ee == null ? void 0 : ee.querySelector("CY DataType")) === null || y === void 0 ? void 0 : y.textContent) === null || m === void 0 ? void 0 : m.toUpperCase()) !== null && E !== void 0 ? E : "D",
      increment: Number((T = (b = ee == null ? void 0 : ee.querySelector("CY Increment")) === null || b === void 0 ? void 0 : b.textContent) !== null && T !== void 0 ? T : "1"),
      offset: Number((S = (R = ee == null ? void 0 : ee.querySelector("CY Offset")) === null || R === void 0 ? void 0 : R.textContent) !== null && S !== void 0 ? S : "0")
    },
    z: {
      type: (H = (w = (M = ee == null ? void 0 : ee.querySelector("CZ AxisType")) === null || M === void 0 ? void 0 : M.textContent) === null || w === void 0 ? void 0 : w.toUpperCase()) !== null && H !== void 0 ? H : "A",
      dataType: (I = (C = (L = ee == null ? void 0 : ee.querySelector("CZ DataType")) === null || L === void 0 ? void 0 : L.textContent) === null || C === void 0 ? void 0 : C.toUpperCase()) !== null && I !== void 0 ? I : "D",
      increment: Number((O = (_ = ee == null ? void 0 : ee.querySelector("CZ Increment")) === null || _ === void 0 ? void 0 : _.textContent) !== null && O !== void 0 ? O : "1"),
      offset: Number((N = (P = ee == null ? void 0 : ee.querySelector("CZ Offset")) === null || P === void 0 ? void 0 : P.textContent) !== null && N !== void 0 ? N : "0")
    }
  }, Se = null, Ie = pe.querySelector("Record1 Axes Rotation");
  Ie && (Se = new Matrix3(), Se.set(Number((U = (k = Ie.querySelector("r11")) === null || k === void 0 ? void 0 : k.textContent) !== null && U !== void 0 ? U : 0), Number((q = (D = Ie.querySelector("r12")) === null || D === void 0 ? void 0 : D.textContent) !== null && q !== void 0 ? q : 0), Number((Q = (z = Ie.querySelector("r13")) === null || z === void 0 ? void 0 : z.textContent) !== null && Q !== void 0 ? Q : 0), Number((X = (G = Ie.querySelector("r21")) === null || G === void 0 ? void 0 : G.textContent) !== null && X !== void 0 ? X : 0), Number((W = ($ = Ie.querySelector("r22")) === null || $ === void 0 ? void 0 : $.textContent) !== null && W !== void 0 ? W : 0), Number((ie = (oe = Ie.querySelector("r23")) === null || oe === void 0 ? void 0 : oe.textContent) !== null && ie !== void 0 ? ie : 0), Number((j = (re = Ie.querySelector("r31")) === null || re === void 0 ? void 0 : re.textContent) !== null && j !== void 0 ? j : 0), Number((ae = (se = Ie.querySelector("r32")) === null || se === void 0 ? void 0 : se.textContent) !== null && ae !== void 0 ? ae : 0), Number((fe = (ue = Ie.querySelector("r33")) === null || ue === void 0 ? void 0 : ue.textContent) !== null && fe !== void 0 ? fe : 0)));
  var Ue = (ne = pe.querySelector("Record3 DataLink PointDataLink")) === null || ne === void 0 ? void 0 : ne.textContent;
  if (typeof Ue != "string")
    throw new Error("X3p: PointDataLink not found.");
  Ue = pathJoin(te, Ue);
  var be = Z[Ue];
  if (!be)
    throw new Error("X3p: ".concat(be, " not found."));
  for (var ge = getPointArray(be.buffer, he.z.dataType), ze = Number((Re = (Te = pe.querySelector("Record3 MatrixDimension SizeX")) === null || Te === void 0 ? void 0 : Te.textContent) !== null && Re !== void 0 ? Re : "0"), Ne = Number((Ce = (ve = pe.querySelector("Record3 MatrixDimension SizeY")) === null || ve === void 0 ? void 0 : ve.textContent) !== null && Ce !== void 0 ? Ce : "0"), Je = Math.floor(ze - 1), Ke = Math.floor(Ne - 1), De = Je + 1, Ye = Ke + 1, Ve = new Float32Array(De * Ye * 3), nt = new Float32Array(De * Ye * 2), qe = new Uint32Array(Je * Ke * 6), Qe = new Box3(), Pe = 0; Pe < Ye; Pe++)
    for (var Me = Pe * he.y.increment + he.y.offset, He = 0; He < De; He++) {
      var Le = Pe * De + He, ot = He * he.x.increment + he.x.offset, $e = ge[Le], tt = !isNaN($e), Xe = tt ? $e : NaN;
      _vector.set(ot, -Me, Xe), Se && _vector.applyMatrix3(Se), tt && Qe.expandByPoint(_vector), Ve[Le * 3 + 0] = _vector.x, Ve[Le * 3 + 1] = _vector.y, Ve[Le * 3 + 2] = _vector.z, nt[Le * 2 + 0] = He / Je, nt[Le * 2 + 1] = 1 - Pe / Ke;
    }
  for (var Pe = 0; Pe < Ke; Pe++)
    for (var He = 0; He < Je; He++) {
      var rt = He + De * Pe, Ge = He + De * (Pe + 1), st = He + 1 + De * (Pe + 1), ct = He + 1 + De * Pe, je = (Pe * Je + He) * 6;
      qe[je + 0] = rt, qe[je + 1] = Ge, qe[je + 2] = ct, qe[je + 3] = Ge, qe[je + 4] = st, qe[je + 5] = ct;
    }
  var Fe = new BufferGeometry();
  Fe.setAttribute("position", new BufferAttribute(Ve, 3)), Fe.setAttribute("uv", new BufferAttribute(nt, 2)), Fe.setIndex(new BufferAttribute(qe, 1)), (!Fe.groups || Fe.groups.length === 0) && Fe.addGroup(0, Fe.index ? Fe.index.count : Fe.attributes.position.count, 0), Fe.boundingBox = Qe;
  var We = new PBMMeshMaterial(t.light ? "phong" : "basic");
  We.flatShading = true, We.color.copy(Ae), We.refreshUniforms();
  var it = new PBMMesh(Fe, [We]);
  return {
    object: it,
    dispose: function() {
      Fe.dispose(), We.dispose();
    }
  };
}
var scratchMatrix4$3 = new Matrix4();
var MAX_RETRY_DELAY$1 = 5e3;
var RETRY_DELAY_STEP$1 = 1e3;
function attachTileAttributes(n45, t) {
  n45.name = t.id;
  var e = t.tileset.properties.floorInfo;
  n45.traverse(function(r) {
    if ("floor" in t.extras) {
      if (r instanceof Mesh || r instanceof Points)
        for (var o = Array.isArray(r.material) ? r.material : r.material ? [r.material] : [], s = 0, u = o; s < u.length; s++) {
          var l = u[s];
          (l instanceof PBMMeshMaterial || l instanceof PBMPointCloudMaterial) && (l.floorIndex = t.extras.floor);
        }
    } else if (!(r instanceof PBMPointCloud)) {
      if ((r instanceof PBMMesh || r instanceof PBMSkinnedMesh) && e) {
        for (var c = new Box3().expandByObject(r), f = c.getCenter(new Vector3()), d = 0, h = 0; h < e.length; h++) {
          var v = e[h], A = v.ground, g = v.height;
          if (f.y < A + g) {
            d = h;
            break;
          }
        }
        t.floor = d, t.tileset.floorLength = Math.max(t.tileset.floorLength, t.floor + 1), r.material.forEach(function(p) {
          return p.floorIndex = d;
        });
      }
    }
  });
}
function loadTileContent(n45, t) {
  if (!n45.content)
    return Promise.resolve(n45);
  var e = n45.content, r = appendSearch(e.uri, t.search);
  if (n45.type === "TILESET") {
    var o = imageURL(r, { key: "model.".concat(n45.siblingIndex) });
    return e.loadState = "LOADING", e.loadStateUpdateTime = now(), t.fetcher.ajax(o, {
      responseType: "text"
    }).then(function(s) {
      return s.body;
    }).then(function(s) {
      var u = r.slice(0, r.lastIndexOf("/") + 1);
      return normalizeTilesetHeader(JSON.parse(s), u);
    }).then(function(s) {
      e.loadState = "READY", e.loadStateUpdateTime = now(), e.loadfailRetryDelay = 0, n45.children.length === 0 && (n45.children = [new Tile("".concat(n45.id, ".0"), s.root, n45.tileset, n45)]);
    }).then(function() {
      return n45;
    }).catch(function(s) {
      return e.loadState = "FAILED", e.loadStateUpdateTime = now(), e.loadfailRetryDelay = Math.min(e.loadfailRetryDelay + 1e3, 5e3), Promise.reject(s);
    });
  }
  if (n45.type === "SCENEGRAPH")
    return e.loadState = "LOADING", e.loadStateUpdateTime = now(), Promise.resolve().then(function() {
      var s, u, l, c, f, d, h, v, A, g, p = "", y = r.split("#"), m = y[0], E = y[1], b = (E || m).split("?")[0].match(/\.([0-9a-zA-Z]+)$/);
      if (b && (p = b[1]), p === "b3dm") {
        var T = imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadB3dm(T, {
          upAxis: n45.tileset.asset.gltfUpAxis,
          light: t.light,
          fetcher: t.fetcher
        }).then(function(R) {
          return R.scene.applyMatrix4(n45.transform), R.scene.updateWorldMatrix(false, true), R.scene.matrixAutoUpdate = false, attachTileAttributes(R.scene, n45), R;
        });
      }
      if (p === "pnts") {
        var T = imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadPnts(T, {
          computeBoundingBox: false,
          fetcher: t.fetcher
        }).then(function(S) {
          if (S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, n45.boundingVolume) {
            var M = n45.boundingVolume;
            S.scene.traverse(function(w) {
              if (w instanceof PBMPointCloud) {
                scratchMatrix4$3.getInverse(w.matrixWorld);
                var H = new Box3();
                M.getBoundingBox(H), H.applyMatrix4(scratchMatrix4$3), w.geometry.boundingBox = H;
              }
            });
          }
          return attachTileAttributes(S.scene, n45), S;
        });
      }
      if (p === "glb" || p === "gltf") {
        var T = imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadGltf(T, {
          upAxis: n45.tileset.asset.gltfUpAxis,
          light: t.light,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, attachTileAttributes(S.scene, n45), S;
        });
      }
      if (p === "at3d") {
        var T = n45.extras.at3d ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadAt3d(T, {
          light: t.light,
          textureBaseUri: (s = n45.extras.at3d) === null || s === void 0 ? void 0 : s.textureBaseUri,
          textureArray: (u = n45.extras.at3d) === null || u === void 0 ? void 0 : u.textureArray,
          textureOptions: (l = n45.extras.at3d) === null || l === void 0 ? void 0 : l.textureOptions,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "pbm") {
        var T = n45.extras.pbm ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadPbm(T, {
          light: t.light,
          textureBaseUri: (c = n45.extras.pbm) === null || c === void 0 ? void 0 : c.textureBaseUri,
          textureArray: (f = n45.extras.pbm) === null || f === void 0 ? void 0 : f.textureArray,
          textureOptions: (d = n45.extras.pbm) === null || d === void 0 ? void 0 : d.textureOptions,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "dome") {
        var T = n45.extras.dome ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadDome(T, {
          light: t.light,
          textureBaseUri: (h = n45.extras.dome) === null || h === void 0 ? void 0 : h.textureBaseUri,
          textureOptions: (v = n45.extras.dome) === null || v === void 0 ? void 0 : v.textureOptions,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "domez") {
        var T = n45.extras.domez ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadDomez(T, {
          light: t.light,
          textureBaseUri: (A = n45.extras.domez) === null || A === void 0 ? void 0 : A.textureBaseUri,
          textureOptions: (g = n45.extras.domez) === null || g === void 0 ? void 0 : g.textureOptions,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "ply") {
        var T = n45.extras.ply ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadPly(T, {
          type: "pbmPointCloud",
          light: t.light,
          upAxis: "Z",
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "obj") {
        var T = n45.extras.obj ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadObj(T, {
          upAxis: "Z",
          light: t.light,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "fbx") {
        var T = n45.extras.obj ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadFbx(T, {
          light: t.light,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      if (p === "x3p") {
        var T = n45.extras.x3p ? r : imageURL(r, { key: "model.".concat(n45.siblingIndex) });
        return loadX3p(T, {
          light: t.light,
          fetcher: t.fetcher
        }).then(function(S) {
          return S.scene.applyMatrix4(n45.transform), S.scene.updateWorldMatrix(false, true), S.scene.matrixAutoUpdate = false, S;
        });
      }
      throw new Error("Invalid Tile content: ".concat(r));
    }).then(function(s) {
      s.scene.traverse(function(l) {
        if (l instanceof PBMPointCloud)
          l.material.uniforms.geometricError.value = n45.geometricError;
        else if (l instanceof PBMMesh || l instanceof PBMSkinnedMesh)
          for (var c = 0, f = l.material; c < f.length; c++) {
            var d = f[c];
            d.uniforms.geometricError.value = n45.geometricError;
          }
      });
      var u = {
        type: s.type,
        uri: s.uri,
        byteLength: s.byteLength,
        memoryUsage: s.memoryUsage,
        object: new TileNode(n45.id, s.scene, s.dispose)
      };
      return Promise.resolve().then(function() {
        return Promise.all([
          u.object.generateBvhTree(),
          t.renderer && s.textures.length < 16 ? initTextures(s.textures, t.renderer, 1024 * 1024) : null
        ]);
      }).then(function() {
        return e.loadState = "READY", e.loadStateUpdateTime = now(), e.loadfailRetryDelay = 0, e.byteLength = u.byteLength, e.memoryUsage = u.memoryUsage, e.data = u, n45;
      }).catch(function(l) {
        return unloadTileContent(n45), Promise.reject(l);
      });
    }).catch(function(s) {
      return e.loadState = "FAILED", e.loadStateUpdateTime = now(), s instanceof NetworkResponseError && s.httpStatus === 0 || s instanceof NetworkTimeoutError || s instanceof NetworkProxyError ? e.loadfailRetryDelay = clamp$1(e.loadfailRetryDelay + RETRY_DELAY_STEP$1, RETRY_DELAY_STEP$1, MAX_RETRY_DELAY$1) : e.loadfailRetryDelay = 1 / 0, Promise.reject(s);
    });
  throw new Error("Invalid Tile type: ".concat(n45.type));
}
function unloadTileContent(n45) {
  n45.content && (n45.content.data && n45.content.data.object.dispose(), n45.content.data = void 0, n45.content.loadState = "UNLOADED", n45.content.loadStateUpdateTime = now(), n45.content.byteLength = 0, n45.content.memoryUsage = 0);
}
var TrajectoryNode = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      o === void 0 && (o = noop$1);
      var s = n45.call(this) || this;
      return s.name = e, s.contentObject = r, s.name = e, s.add(r), s.disposers = [o], s;
    }
    return t.prototype.update = function(e, r, o) {
      var s = this.contentObject.material[2];
      s.uniforms.dashOffset.value = (s.uniforms.dashOffset.value - 3e-3) % (s.uniforms.dashSize.value.x + s.uniforms.dashSize.value.y), o.needsRender = true;
    }, t.prototype.dispose = function() {
      for (var e = 0, r = this.disposers; e < r.length; e++) {
        var o = r[e];
        o();
      }
      this.disposers.length = 0;
    }, t.prototype.clone = function() {
      return new t(this.name, this.contentObject.clone());
    }, t;
  }(Object3D)
);
var MAX_RETRY_DELAY = 5e3;
var RETRY_DELAY_STEP = 1e3;
var TRAJECTOR_PIPE_SHADER = {
  vertexShader: `
varying vec2 vUv;
uniform float displacementScalar;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
  vUv = uv;
  #include <color_vertex>
  #include <begin_vertex>
  vec3 objectNormal = vec3( normal );
  transformed += normalize( objectNormal ) * displacementScalar;
  #include <morphtarget_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>
  #include <fog_vertex>
}
`,
  fragmentShader: `
varying vec2 vUv;
uniform vec3 diffuse;
uniform vec3 diffuse2;
uniform float opacity;
uniform float dashOffset;
uniform vec2 dashSize;
uniform float totalLength;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {
  if (mod(abs(vUv.x * totalLength + dashOffset), (dashSize.x + dashSize.y)) > dashSize.x) {
    discard;
  }
  #include <clipping_planes_fragment>
  vec3 outgoingLight = vec3( 0.0 );
  vec4 diffuseColor = vec4( mix(diffuse, diffuse2, vUv.x), opacity );

  #include <logdepthbuf_fragment>
  #include <color_fragment>

  outgoingLight = diffuseColor.rgb; // simple shader

  gl_FragColor = vec4( outgoingLight, diffuseColor.a );

  #include <tonemapping_fragment>
  #include <encodings_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
}
`,
  uniforms: {
    diffuse: {
      value: new Color()
    },
    diffuse2: {
      value: new Color()
    },
    opacity: {
      value: 1
    },
    displacementScalar: {
      value: 0
    },
    totalLength: {
      value: 1
    },
    dashSize: {
      value: new Vector3()
    },
    dashOffset: {
      value: 0
    }
  }
};
var TRAJECTOR_SPHERE_SHADER = {
  vertexShader: `
uniform float displacementScalar;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
  #include <color_vertex>
  #include <begin_vertex>
  vec3 objectNormal = vec3( normal );
  transformed += normalize( objectNormal ) * displacementScalar;
  #include <morphtarget_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>
  #include <fog_vertex>
}
`,
  fragmentShader: `
uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {
  #include <clipping_planes_fragment>
  vec3 outgoingLight = vec3( 0.0 );
  vec4 diffuseColor = vec4( diffuse, opacity );

  #include <logdepthbuf_fragment>
  #include <color_fragment>

  outgoingLight = diffuseColor.rgb; // simple shader

  gl_FragColor = vec4( outgoingLight, diffuseColor.a );

  #include <tonemapping_fragment>
  #include <encodings_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
}
`,
  uniforms: {
    diffuse: {
      value: new Color()
    },
    opacity: {
      value: 1
    },
    displacementScalar: {
      value: 0
    }
  }
};
function createPipeBufferGeometry(n45, t, e, r) {
  for (var o = new Float32Array((e + 1) * (r + 1) * 3), s = new Float32Array((e + 1) * (r + 1) * 3), u = new Float32Array((e + 1) * (r + 1) * 2), l = new Uint32Array(e * r * 6), c = n45.computeFrenetFrames(e), f = new Vector3(), d = new Vector3(), h = new Vector2(), v = new Vector3(), A = 0; A <= e; A++) {
    v = n45.getPointAt(A / e, v);
    for (var g = c.normals[A], p = c.binormals[A], y = 0; y <= r; y++) {
      var m = A * (r + 1) + y, E = y / r * Math.PI * 2, b = Math.sin(E), T = -Math.cos(E);
      d.x = T * g.x + b * p.x, d.y = T * g.y + b * p.y, d.z = T * g.z + b * p.z, d.normalize(), d.toArray(s, m * 3), f.x = v.x + t * d.x, f.y = v.y + t * d.y, f.z = v.z + t * d.z, f.toArray(o, m * 3), h.x = A / e, h.y = y / r, h.toArray(u, m * 2);
    }
  }
  for (var A = 0; A < e; A++)
    for (var y = 0; y < r; y++) {
      var R = (A * r + y) * 6, S = (r + 1) * A + y, M = (r + 1) * (A + 1) + y, w = (r + 1) * (A + 1) + (y + 1), H = (r + 1) * A + (y + 1);
      l[R] = S, l[R + 1] = M, l[R + 2] = H, l[R + 3] = M, l[R + 4] = w, l[R + 5] = H;
    }
  var L = new BufferGeometry();
  return L.setIndex(new BufferAttribute(l, 1)), L.setAttribute("position", new BufferAttribute(o, 3)), L.setAttribute("normal", new BufferAttribute(s, 3)), L.setAttribute("uv", new BufferAttribute(u, 2)), L;
}
function parseTrajectoryObject(n45, t) {
  for (var e = new Color(0).convertSRGBToLinear(), r = new Color(52949).convertSRGBToLinear(), o = new Color(3370495).convertSRGBToLinear(), s = new Color(16777215).convertSRGBToLinear(), u = 0, l = new CurvePath(), c = n45.length, f = 3; f < c; f += 3) {
    var d = new Vector3().fromArray(n45, f - 3), h = new Vector3().fromArray(n45, f);
    u += d.distanceTo(h);
    var v = new LineCurve3(d, h);
    l.add(v);
  }
  var A = 0.03, g = Math.ceil(u * 100), p = 6, y = createPipeBufferGeometry(l, A, g, p);
  y.clearGroups(), y.addGroup(0, y.index ? y.index.count : y.attributes.position.count, 0), y.addGroup(0, y.index ? y.index.count : y.attributes.position.count, 1), y.addGroup(0, y.index ? y.index.count : y.attributes.position.count, 2);
  var m = new ShaderMaterial({
    vertexShader: TRAJECTOR_PIPE_SHADER.vertexShader,
    fragmentShader: TRAJECTOR_PIPE_SHADER.fragmentShader,
    uniforms: UniformsUtils.clone(TRAJECTOR_PIPE_SHADER.uniforms),
    side: BackSide
  });
  m.uniforms.totalLength.value = u, m.uniforms.diffuse.value = e, m.uniforms.diffuse2.value = e, m.uniforms.opacity.value = 0.5, m.transparent = true;
  var E = new ShaderMaterial({
    vertexShader: TRAJECTOR_PIPE_SHADER.vertexShader,
    fragmentShader: TRAJECTOR_PIPE_SHADER.fragmentShader,
    uniforms: UniformsUtils.clone(TRAJECTOR_PIPE_SHADER.uniforms),
    side: BackSide
  });
  E.uniforms.totalLength.value = u, E.uniforms.displacementScalar.value = -0.01, E.uniforms.diffuse.value = r, E.uniforms.diffuse2.value = o;
  var b = new ShaderMaterial({
    vertexShader: TRAJECTOR_PIPE_SHADER.vertexShader,
    fragmentShader: TRAJECTOR_PIPE_SHADER.fragmentShader,
    uniforms: UniformsUtils.clone(TRAJECTOR_PIPE_SHADER.uniforms),
    side: DoubleSide
  });
  b.uniforms.totalLength.value = u, b.uniforms.displacementScalar.value = -0.026, b.uniforms.dashSize.value = new Vector2(0.06, 0.09), b.uniforms.diffuse.value = s, b.uniforms.diffuse2.value = s;
  var T = new Mesh(y, [m, E, b]), R = 0.08, S = 24, M = new SphereBufferGeometry(R, S, S);
  M.clearGroups(), M.addGroup(0, y.index ? y.index.count : y.attributes.position.count, 0), M.addGroup(0, y.index ? y.index.count : y.attributes.position.count, 1);
  var w = new ShaderMaterial({
    vertexShader: TRAJECTOR_SPHERE_SHADER.vertexShader,
    fragmentShader: TRAJECTOR_SPHERE_SHADER.fragmentShader,
    uniforms: UniformsUtils.clone(TRAJECTOR_SPHERE_SHADER.uniforms),
    side: BackSide
  });
  w.uniforms.diffuse.value = e, w.uniforms.opacity.value = 0.5, w.transparent = true;
  var H = new ShaderMaterial({
    vertexShader: TRAJECTOR_SPHERE_SHADER.vertexShader,
    fragmentShader: TRAJECTOR_SPHERE_SHADER.fragmentShader,
    uniforms: UniformsUtils.clone(TRAJECTOR_SPHERE_SHADER.uniforms),
    side: FrontSide
  });
  H.uniforms.displacementScalar.value = -0.01, H.uniforms.diffuse.value = r;
  var L = new Mesh(M, [w, H]);
  L.position.fromArray(n45, 0), T.add(L);
  var C = new ShaderMaterial({
    vertexShader: TRAJECTOR_SPHERE_SHADER.vertexShader,
    fragmentShader: TRAJECTOR_SPHERE_SHADER.fragmentShader,
    uniforms: UniformsUtils.clone(TRAJECTOR_SPHERE_SHADER.uniforms),
    side: FrontSide
  });
  C.uniforms.displacementScalar.value = -0.01, C.uniforms.diffuse.value = o;
  var I = new Mesh(M, [w, C]);
  return I.position.fromArray(n45, n45.length - 3), T.add(I), {
    scene: T,
    dispose: function() {
      y.dispose(), m.dispose(), E.dispose(), b.dispose(), M.dispose(), w.dispose(), H.dispose(), C.dispose();
    }
  };
}
function loadTrajectory(n45, t) {
  var e = n45.name, r = appendSearch(n45.content.uri, t.search), o = imageURL(r, { key: "model.0" });
  return n45.content.loadState = "LOADING", n45.content.loadStateUpdateTime = now(), loadPly(o, {
    type: "geometry",
    customPropertyMapping: {
      time: {
        itemType: "uint32",
        itemNames: ["time_milisec"]
      }
    },
    fetcher: t.fetcher
  }).then(function(s) {
    var u, l, c, f, d = (l = (u = s.scene.attributes) === null || u === void 0 ? void 0 : u.time.array) !== null && l !== void 0 ? l : [], h = (f = (c = s.scene.attributes) === null || c === void 0 ? void 0 : c.position.array) !== null && f !== void 0 ? f : [], v = s.byteLength, A = s.memoryUsage, g = parseTrajectoryObject(h);
    g.scene.applyMatrix4(n45.transform), g.scene.updateWorldMatrix(false, true), g.scene.matrixAutoUpdate = false;
    var p = new TrajectoryNode(e, g.scene);
    return n45.content.data = {
      uri: o,
      byteLength: v,
      memoryUsage: A,
      positionArray: h,
      timeArray: d,
      object: p
    }, n45.content.byteLength = v, n45.content.memoryUsage = A, n45.content.loadState = "READY", n45.content.loadStateUpdateTime = now(), n45;
  }).catch(function(s) {
    return n45.content.data = void 0, n45.content.loadState = "FAILED", n45.content.loadStateUpdateTime = now(), s instanceof NetworkResponseError && s.httpStatus === 0 || s instanceof NetworkTimeoutError || s instanceof NetworkProxyError ? n45.content.loadfailRetryDelay = clamp$1(n45.content.loadfailRetryDelay + RETRY_DELAY_STEP, RETRY_DELAY_STEP, MAX_RETRY_DELAY) : n45.content.loadfailRetryDelay = 1 / 0, Promise.reject(s);
  });
}
function unloadTrajectory(n45) {
  n45.content && (n45.content.data && n45.content.data.object.dispose(), n45.content.data = void 0, n45.content.loadState = "UNLOADED", n45.content.loadStateUpdateTime = now(), n45.content.byteLength = 0, n45.content.memoryUsage = 0);
}
var scratchVector3$1 = new Vector3();
var scratchMatrix3 = new Matrix3();
var scratchMatrix4$2 = new Matrix4();
var a = 6378137;
var invF = 298.257223563;
function ecefToLla(n45) {
  for (var t = a - a / invF, e = (a * a - t * t) / (a * a), r = Math.sqrt(n45.x * n45.x + n45.y * n45.y), o = 1e-12, s = 1e3, u = 0, l = Math.atan2(n45.z, r), c = 0; u++ < s; ) {
    var f = Math.sin(l), d = a / Math.sqrt(1 - e * f * f);
    c = r / Math.cos(l) - d;
    var h = Math.atan2(n45.z / (d * (1 - e) + c), r / (d + c));
    if (isNaN(h))
      break;
    var v = Math.abs(h - l);
    if (v < o)
      break;
    l = h;
  }
  return n45.set(l, Math.atan2(n45.y, n45.x), c);
}
function llaToEcef(n45) {
  var t = n45.x, e = n45.y, r = n45.z, o = a - a / invF, s = (a * a - o * o) / (a * a), u = Math.sin(t), l = Math.cos(t), c = Math.sin(e), f = Math.cos(e), d = a / Math.sqrt(1 - s * u * u), h = (d + r) * l * f, v = (d + r) * l * c, A = (o * o / (a * a) * d + r) * u;
  return n45.set(h, v, A);
}
function getEcefToEnuMatrix(n45, t) {
  var e = ecefToLla(scratchVector3$1.copy(n45)), r = e.x, o = e.y, s = e.z, u = Math.sin(r), l = Math.sin(o), c = Math.cos(r), f = Math.cos(o);
  t.fromArray([
    -l,
    -u * f,
    c * f,
    0,
    +f,
    -u * l,
    c * l,
    0,
    0,
    c,
    u,
    0,
    0,
    0,
    0,
    1
  ]);
  var d = scratchMatrix3.setFromMatrix4(t), h = scratchVector3$1.copy(n45).applyMatrix3(d).multiplyScalar(-1);
  t.setPosition(h);
  var v = scratchMatrix4$2.fromArray([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    s,
    1
  ]);
  return t.premultiply(v), t;
}
var StencilConstants = {
  TILE_MASK: 128,
  SKIP_LOD_MASK: 112,
  SKIP_LOD_BIT_SHIFT: 4,
  CLASSIFICATION_MASK: 15
};
var SKIP_BACKFACE_MATERIAL = function() {
  var n45 = new MeshBasicMaterial();
  return n45.side = BackSide, n45.color.setHex(16711935), n45.colorWrite = false, n45.stencilWrite = true, n45.polygonOffset = true, n45.polygonOffsetFactor = 2, n45.polygonOffsetUnits = 2, n45.stencilRef = StencilConstants.TILE_MASK, n45.stencilFunc = AlwaysStencilFunc, n45.stencilFuncMask = StencilConstants.TILE_MASK, n45.stencilZPass = ReplaceStencilOp, n45.stencilWriteMask = StencilConstants.TILE_MASK, n45;
}();
var SKIP_BACKFACE_TRANSPARENT_MATERIAL = function() {
  var n45 = new MeshBasicMaterial();
  return n45.visible = false, n45;
}();
var CLEAR_STENCIL_GEOMETRY = new BufferGeometry();
var CLEAR_STENCIL_MATERIAL = new MeshBasicMaterial();
var Tile3DModel = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o) {
      var s, u, l, c = n45.call(this) || this;
      return c.modelIndex = 0, c.renderObjects = [], c.backfaceObjects = [], c.debugObjects = [], c.tileObjects = [], c.debug = "none", c.name = o.name, c.type = o.type, c.light = o.light, c.upAxis = o.upAxis, c.model = e, c.fetcher = o.fetcher, c.search = (s = o.search) !== null && s !== void 0 ? s : "", c.groundHeight = o.groundHeight, c.coordinateTransform = o.coordinateTransform, c.boundingBox = new Box3(), c.minLevelOfDetail = t.DEFAULT_MIN_LEVEL_OF_DETAIL, c.maxLevelOfDetail = t.DEFAULT_MAX_LEVEL_OF_DETAIL, c.minGeometricError = t.DEFAULT_MIN_GEOMETRIC_ERROR, c.maxGeometricError = t.DEFAULT_MAX_GEOMETRIC_ERROR, c.panoramaMinGeometricError = t.DEFAULT_PANORAMA_MIN_GEOMETRIC_ERROR, c.needsRefined = true, c.refined = false, c.refineProgress = [0, 0], c.loaded = false, c.modelsLoaded = false, c.disposed = false, c.needsRender = true, c.lastRenderHash = "", c.matrixAutoUpdate = false, c.cacheCameras = [], c.clearStencilObject = new Mesh(CLEAR_STENCIL_GEOMETRY, CLEAR_STENCIL_MATERIAL), c.clearStencilObject.frustumCulled = false, c.clearStencilObject.onAfterRender = function(f) {
        return f.clearStencil();
      }, c.tileset = new Tileset((l = (u = c.model.work) === null || u === void 0 ? void 0 : u.workCode) !== null && l !== void 0 ? l : "", r, {
        referer: o.referer,
        tileLoader: function(f) {
          return c.loadContent(f);
        },
        tileUnloader: function(f) {
          return c.unloadContent(f);
        },
        onTileLoad: function() {
        },
        onTileUnload: function(f) {
        },
        onTileError: function(f, d) {
          o.onError && o.onError(Object.assign(d, { error: d })), console.error("Tile error", f.id, d);
        },
        trajectoryLoader: function(f) {
          return c.loadTrajectory(f);
        },
        trajectoryUnloader: function(f) {
          return c.unloadTrajectory(f);
        },
        onTrajectoryLoad: function() {
        },
        onTrajectoryUnload: function(f) {
        },
        onTrajectoryError: function(f, d) {
          o.onError && o.onError(Object.assign(d, { error: d })), console.error("Trajectory error", f, d);
        }
      }), c.tileset.root.boundingVolume && c.tileset.root.boundingVolume.getBoundingBox(c.boundingBox), c;
    }
    return t.prototype.getRecommendProps = function(e) {
      var r, o, s;
      e === void 0 && (e = {});
      var u, l, c, f = 128;
      e.powerPreference === "high" && (f = 512);
      var d = typeof this.tileset.rootMeta.creationTime == "string";
      if (d) {
        var h = typeof this.tileset.rootMeta.numTotalPoints == "number" && this.tileset.rootMeta.numTotalPoints > 0;
        if (h) {
          c = 4, e.powerPreference === "high" && (c = 2), u = c / 1.6;
          var v = 0;
          if (((r = this.tileset.rootMeta.taskParameters) === null || r === void 0 ? void 0 : r.point_homogenization) === "1" && (!((o = this.tileset.rootMeta.taskParameters) === null || o === void 0) && o.homo_point_density)) {
            var A = Number((s = this.tileset.rootMeta.taskParameters) === null || s === void 0 ? void 0 : s.homo_point_density);
            isFinite(A) && !isNaN(A) && (v = A);
          }
          v <= 0 && (v = 0.02), l = v * 1.4;
        } else
          c = 5, e.powerPreference === "high" && (c = 4), u = 1, l = 0.03;
      } else
        c = 6, u = 1, l = 0.03, this.name === "aerophoto" ? (c = 12, e.powerPreference === "high" && (c = 10)) : this.tileset.asset.extras && typeof this.tileset.asset.extras.name == "string" && /^matterport\b/i.test(this.tileset.asset.extras.name) && (c = 5, e.powerPreference === "high" && (c = 4));
      return { pointScale: l, pointMinPixel: u, maxScreenSpaceError: c, maxMemoryUsage: f };
    }, t.prototype.getRenderHash = function() {
      return jsonHash([
        this.tileset.id,
        this.tileset.skipLevelOfDetail,
        this.tileset.selectedTiles.map(function(e) {
          return e.id;
        }),
        this.tileset.selectedTrajectories.map(function(e) {
          return e.index;
        }),
        this.debug
      ]);
    }, Object.defineProperty(t.prototype, "maxMemoryUsage", {
      // The maximum amount of memory (in MB) that may be used to cache tiles.
      get: function() {
        return this.tileset.maxMemoryUsage;
      },
      set: function(e) {
        this.tileset.maxMemoryUsage = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "maxRequests", {
      get: function() {
        return this.tileset.maxRequests;
      },
      set: function(e) {
        this.tileset.maxRequests = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "requestOrder", {
      get: function() {
        return this.tileset.tileRequestOrder;
      },
      set: function(e) {
        this.tileset.tileRequestOrder = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "skipLevelOfDetail", {
      get: function() {
        return this.tileset.skipLevelOfDetail;
      },
      set: function(e) {
        this.tileset.skipLevelOfDetail = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "mostDetail", {
      get: function() {
        return this.tileset.mostDetail;
      },
      set: function(e) {
        this.tileset.mostDetail = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "loadSiblings", {
      get: function() {
        return this.tileset.loadSiblings;
      },
      set: function(e) {
        this.tileset.loadSiblings = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "loadAll", {
      get: function() {
        return this.tileset.loadAll;
      },
      set: function(e) {
        this.tileset.loadAll = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "maxScreenSpaceError", {
      get: function() {
        return this.tileset.maxScreenSpaceError;
      },
      set: function(e) {
        this.tileset.maxScreenSpaceError = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "currentMaxScreenSpaceError", {
      get: function() {
        return this.tileset.currentMaxScreenSpaceError;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "trajectories", {
      get: function() {
        return this.tileset.trajectories;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.localToEnu = function(e) {
      return e.applyMatrix4(this.coordinateTransform.localToEnuMatrix);
    }, t.prototype.enuToLocal = function(e) {
      return e.applyMatrix4(this.coordinateTransform.enuToLocalMatrix);
    }, t.prototype.localToEcef = function(e) {
      return e.applyMatrix4(this.coordinateTransform.localToEcefMatrix);
    }, t.prototype.ecefToLocal = function(e) {
      return e.applyMatrix4(this.coordinateTransform.ecefToLocalMatrix);
    }, t.prototype.localToLla = function(e) {
      return ecefToLla(this.localToEcef(e));
    }, t.prototype.llaToLocal = function(e) {
      return this.ecefToLocal(llaToEcef(e));
    }, t.prototype.worldToEnu = function(e) {
      return this.localToEnu(this.worldToLocal(e));
    }, t.prototype.enuToWorld = function(e) {
      return this.localToWorld(this.enuToLocal(e));
    }, t.prototype.worldToEcef = function(e) {
      return this.localToEcef(this.worldToLocal(e));
    }, t.prototype.ecefToWorld = function(e) {
      return this.localToWorld(this.ecefToLocal(e));
    }, t.prototype.worldToLla = function(e) {
      return this.localToLla(this.worldToLocal(e));
    }, t.prototype.llaToWorld = function(e) {
      return this.localToWorld(this.llaToLocal(e));
    }, t.prototype.loadContent = function(e) {
      var r = this;
      return loadTileContent(e, {
        light: this.light,
        fetcher: this.fetcher,
        search: this.search,
        renderer: this.renderer
      }).then(function(o) {
        e.type === "SCENEGRAPH" && (r.disposed || !e.content ? unloadTileContent(e) : e.content.data && r.boundingBox.expandByObject(e.content.data.object));
      });
    }, t.prototype.unloadContent = function(e) {
      return unloadTileContent(e), Promise.resolve();
    }, t.prototype.loadAllTilesets = function() {
      var e = this, r = function(o) {
        var s = [];
        return e.tileset.root.traverse(function(u) {
          var l;
          u.type === "TILESET" && ((l = u.content) === null || l === void 0 ? void 0 : l.loadState) !== "READY" && s.push(u);
        }), Promise.all(s.map(function(u) {
          return e.loadContent(u).then(function() {
            return r();
          });
        })).then(function() {
        });
      };
      return r(this.tileset.root);
    }, t.prototype.loadTrajectory = function(e) {
      var r = this;
      return loadTrajectory(e, {
        fetcher: this.fetcher,
        search: this.search,
        renderer: this.renderer
      }).then(function(o) {
        r.disposed && unloadTrajectory(o);
      });
    }, t.prototype.unloadTrajectory = function(e) {
      return unloadTrajectory(e), Promise.resolve();
    }, t.prototype.intersectRaycaster = function(e, r, o) {
      var s = this;
      r === void 0 && (r = true), o === void 0 && (o = []);
      for (var u = [this.tileset.root], l = this.tileset.transform, c = this.tileset.transformIsIdentity, f, d = []; f = u.pop(); ) {
        var h = void 0;
        if (f.boundingVolume) {
          var v = c ? f.boundingVolume : f.boundingVolume.clone().applyMatrix4(l);
          h = v.intersectRay(e.ray, e.far);
        } else
          h = true;
        if (h) {
          for (var A = 0, g = f.children.length; A < g; A++)
            u.push(f.children[A]);
          f.selected && f.content && f.content.data && f.content.data.object.visible && f.content.data.object.intersectRaycaster(e, false, d);
        }
      }
      return this.model.shownFloorIndex >= 0 && (d = d.filter(function(p) {
        return p.floor === s.model.shownFloorIndex;
      })), r && d.sort(function(p, y) {
        return p.distance - y.distance;
      }), d.map(function(p) {
        p.model = s.model, p.viewLayer = s.viewLayer;
      }), o.push.apply(o, d), o;
    }, t.prototype.cloneSkipBackfaceObject = function(e) {
      var r;
      e instanceof Mesh ? r = new Mesh(e.geometry, Array.isArray(e.material) ? e.material.map(function(l) {
        return l.transparent ? SKIP_BACKFACE_TRANSPARENT_MATERIAL : SKIP_BACKFACE_MATERIAL;
      }) : e.material && e.material.transparent ? SKIP_BACKFACE_TRANSPARENT_MATERIAL : SKIP_BACKFACE_MATERIAL) : e instanceof Group ? r = new Group() : r = new Object3D(), r.copy(e, false);
      for (var o = 0, s = e.children; o < s.length; o++) {
        var u = s[o];
        r.add(this.cloneSkipBackfaceObject(u));
      }
      return r;
    }, t.prototype.update = function(e, r, o) {
      var s, u, l, c = this, f, d, h;
      this.renderObjects.length = 0, this.backfaceObjects.length = 0, this.debugObjects.length = 0, this.tileObjects.length = 0, this.renderer = e, this.updateMatrixWorld(true), this.tileset.transform.equals(this.matrixWorld) || this.tileset.transform.copy(this.matrixWorld), this.tileset.cache.reset();
      var v = this.tileset.frameNumber + 1, A = this.maxLevelOfDetail;
      A = Math.max(A, 0);
      var g = Math.min(this.minLevelOfDetail, A);
      (!this.visible || !this.loaded || !this.modelsLoaded) && (A = Math.max(g, 0));
      var p = this.minGeometricError, y = this.maxGeometricError;
      if (y = Math.max(p, y), o === "Panorama" || o === "VRPanorama" || o === "XRPanorama") {
        var m = this.model.getMaterial().modelAlpha;
        m < 0.1 && (p = this.panoramaMinGeometricError);
      }
      var E = {
        time: now(),
        camera: {
          type: r.type,
          position: new Vector3().copy(r.position),
          direction: r.getDirection(new Vector3()),
          up: new Vector3().copy(r.up).applyQuaternion(r.quaternion),
          projectionMatrix: r.projectionMatrix.clone(),
          visible: r.visible,
          refine: r.refineModel
        },
        minLevelOfDetail: g,
        maxLevelOfDetail: A,
        minGeometricError: p,
        maxGeometricError: y,
        height: r.resolution.height,
        pixelRatio: r.pixelRatio,
        frameNumber: v,
        sseDenominator: 2 * Math.tan(0.5 * r.fov / 180 * Math.PI),
        cullingVolume: new CullingVolume().setFromCamera(r)
      }, b = this.cacheCameras.map(function(j) {
        return j.updateProjectionMatrix(), __assign(__assign({}, E), { camera: {
          type: r.type,
          position: new Vector3().copy(j.position),
          direction: j.getWorldDirection(new Vector3()),
          up: new Vector3().copy(j.up),
          projectionMatrix: j.projectionMatrix.clone(),
          visible: j.visible,
          refine: true
        }, cullingVolume: new CullingVolume().setFromCamera(j) });
      });
      if (this.needsRefined && this.tileset.update(E, b), this.refined = true, this.refineProgress[0] = 0, this.refineProgress[1] = 0, this.tileset.needsRefinedTiles.forEach(function(j) {
        if (c.refineProgress[1]++, j.content) {
          var se = j.content.loadState;
          if (se === "UNLOADED" || se === "LOADING") {
            c.refined = false;
            return;
          }
        }
        c.refineProgress[0]++;
      }), this.loaded === false && this.needsRefined) {
        this.loaded = true;
        var T = false;
        this.tileset.needsRefinedTiles.forEach(function(j) {
          if (c.loaded !== false && j.content) {
            if (T = true, c.tileset.skipLevelOfDetail) {
              if (j.state.finalResolution) {
                var se = j.state.ancestorWithContentAvailable, ae = se && se.content ? se.content : j.content, ue = ae.loadState;
                (ue === "UNLOADED" || ue === "LOADING") && (c.loaded = false);
              }
            } else if (j.state.visible && j.levelOfContent <= 0) {
              var ue = j.content.loadState;
              (ue === "UNLOADED" || ue === "LOADING") && (c.loaded = false);
            }
          }
        }), T && this.tileset.selectedTiles.length === 0 && (this.loaded = false), this.loaded === true && (this.refined = false, this.refineProgress[1]++);
      }
      this.remove.apply(this, this.children), this.tileset.skipLevelOfDetail || this.tileset.selectedTiles.sort(function(j, se) {
        return j.floor !== se.floor ? j.floor - se.floor : j.levelOfContent !== se.levelOfContent ? se.levelOfContent - j.levelOfContent : j.state.distanceToCamera !== se.state.distanceToCamera ? j.state.distanceToCamera - se.state.distanceToCamera : j.state.centerZDepth - se.state.centerZDepth;
      }), this.debug === "root-bounding-volume" && this.tileset.root.boundingVolumeDebugObject && this.debugObjects.push(this.tileset.root.boundingVolumeDebugObject);
      for (var R = 0, S = this.tileset.selectedTiles; R < S.length; R++) {
        var M = S[R];
        this.debug === "selected-bounding-volume" && M.boundingVolumeDebugObject && this.debugObjects.push(M.boundingVolumeDebugObject);
        var w = (d = (f = M.content) === null || f === void 0 ? void 0 : f.data) === null || d === void 0 ? void 0 : d.object;
        if (w) {
          if (w.update(e, r, this.model, M), this.tileset.hasMixedContent && this.tileset.skipLevelOfDetail) {
            if (!M.state.finalResolution) {
              var H = this.cloneSkipBackfaceObject(w);
              this.backfaceObjects.push(H);
            }
            for (var L = M.state.selectionDepth, C = StencilConstants.TILE_MASK | L << StencilConstants.SKIP_LOD_BIT_SHIFT, I = GreaterEqualStencilFunc, _ = StencilConstants.SKIP_LOD_MASK, O = ReplaceStencilOp, P = StencilConstants.TILE_MASK | StencilConstants.SKIP_LOD_MASK, N = 0, k = w.materials; N < k.length; N++) {
              var U = k[N];
              U.stencilWrite = true, U.stencilRef = C, U.stencilFunc = I, U.stencilFuncMask = _, U.stencilZPass = O, U.stencilWriteMask = P;
            }
          } else
            for (var D = 0, q = w.materials; D < q.length; D++) {
              var U = q[D];
              U.stencilWrite = false, U.stencilRef = StencilConstants.TILE_MASK, U.stencilFunc = AlwaysStencilFunc, U.stencilFuncMask = StencilConstants.TILE_MASK, U.stencilZPass = ReplaceStencilOp, U.stencilWriteMask = StencilConstants.TILE_MASK;
            }
          this.tileObjects.push(w);
        }
      }
      this.tileset.skipLevelOfDetail && this.backfaceObjects.length && (s = this.renderObjects).push.apply(s, this.backfaceObjects), this.tileObjects.length && (u = this.renderObjects).push.apply(u, this.tileObjects), this.tileset.skipLevelOfDetail && this.renderObjects.push(this.clearStencilObject);
      for (var z = 0, Q = this.tileset.selectedTrajectories; z < Q.length; z++) {
        var G = Q[z], X = (h = G.content.data) === null || h === void 0 ? void 0 : h.object;
        X && (X.update(e, r, this.model), this.renderObjects.push(X));
      }
      this.debug && (l = this.renderObjects).push.apply(l, this.debugObjects);
      for (var $ = this.modelIndex * 1e4, W = function(j) {
        var se = oe.renderObjects[j], ae = j + $;
        se.traverse(function(ue) {
          (ue instanceof Mesh || ue instanceof Line || ue instanceof Points) && (ue.renderOrder = ae);
        }), oe.add(se);
      }, oe = this, ie = 0; ie < this.renderObjects.length; ie++)
        W(ie);
      var re = this.getRenderHash();
      this.lastRenderHash !== re && (this.needsRender = true, this.lastRenderHash = re);
    }, t.prototype.dispose = function() {
      this.disposed = true, this.viewLayer = void 0, this.tileset.reset(), this.remove.apply(this, this.children), this.refineProgress[0] = 0, this.refineProgress[1] = 0, this.refined = false, this.loaded = false;
    }, t.DEFAULT_PANORAMA_MIN_GEOMETRIC_ERROR = 1, t.DEFAULT_MIN_LEVEL_OF_DETAIL = 0, t.DEFAULT_MAX_LEVEL_OF_DETAIL = 20, t.DEFAULT_MIN_GEOMETRIC_ERROR = 0, t.DEFAULT_MAX_GEOMETRIC_ERROR = 1e4, t.DEFAULT_MAX_MEMORY_USAGE = 16, t.DEFAULT_MAX_SCREEN_SPACE_ERROR = Tileset.DEFAULT_MAX_SCREEN_SPACE_ERROR, t.DEFAULT_SKIP_LEVEL_OF_DETAIL = Tileset.DEFAULT_SKIP_LEVEL_OF_DETAIL, t.DEFAULT_MOST_DETAIL = Tileset.DEFAULT_MOST_DETAIL, t.DEFAULT_LOAD_SIBLINGS = Tileset.DEFAULT_LOAD_SIBLINGS, t.DEFAULT_LOAD_ALL = Tileset.DEFAULT_LOAD_ALL, t.DEFAULT_MAX_REQUESTS = Tileset.DEFAULT_MAX_REQUESTS, t.DEFAULT_REQUEST_ORDER = Tileset.DEFAULT_REQUEST_ORDER, t;
  }(Object3D)
);
function headingToLongitude(n45) {
  return -((n45 - 0.25) * 360 + 90) / 180 * Math.PI;
}
function equal(n45, t) {
  if (n45 === t)
    return true;
  if (n45 && t && typeof n45 == "object" && typeof t == "object") {
    if (n45.constructor !== t.constructor)
      return false;
    var e, r, o;
    if (Array.isArray(n45)) {
      if (e = n45.length, e != t.length)
        return false;
      for (r = e; r-- !== 0; )
        if (!equal(n45[r], t[r]))
          return false;
      return true;
    }
    if (n45.constructor === RegExp)
      return n45.source === t.source && n45.flags === t.flags;
    if (n45.valueOf !== Object.prototype.valueOf)
      return n45.valueOf() === t.valueOf();
    if (n45.toString !== Object.prototype.toString)
      return n45.toString() === t.toString();
    if (o = Object.keys(n45), e = o.length, e !== Object.keys(t).length)
      return false;
    for (r = e; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[r]))
        return false;
    for (r = e; r-- !== 0; ) {
      var s = o[r];
      if (!equal(n45[s], t[s]))
        return false;
    }
    return true;
  }
  return n45 !== n45 && t !== t;
}
function isNumber(n45) {
  return typeof n45 == "number";
}
function S4() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
function createUuid() {
  return (S4() + S4() + "-" + S4() + "-4" + S4().substr(0, 3) + "-" + S4() + "-" + S4() + S4() + S4()).toLowerCase();
}
var error_invalid_input = function() {
  return new Error("Invalid input.");
};
var error_invalid_certificate = function() {
  return new Error("Invalid certificate.");
};
var error_invalid_signature = function() {
  return new Error("Invalid signature.");
};
var error_date_expired = function(n45) {
  return new Error("date(".concat(n45.toString(), ") expired."));
};
var error_host_not_allowed = function(n45) {
  return new Error("host(".concat(JSON.stringify(n45), ") is not allowed."));
};
function ObjectOmit(n45, t) {
  for (var e = {}, r = 0, o = Object.keys(n45); r < o.length; r++) {
    var s = o[r];
    t.indexOf(s) === -1 && (e[s] = n45[s]);
  }
  return e;
}
function jsonStableNoneNumberStrinfiy_(n45, t) {
  t === void 0 && (t = false);
  var e = typeof n45;
  if (e === "string")
    return JSON.stringify(n45);
  if (n45 === true)
    return "true";
  if (n45 === false)
    return "false";
  if (n45 === null)
    return "null";
  if (n45 instanceof Array) {
    for (var r = "[", o = n45.length - 1, s = 0; s < o; s++)
      r += jsonStableNoneNumberStrinfiy_(n45[s], false) + ",";
    return o > -1 && (r += jsonStableNoneNumberStrinfiy_(n45[s], false)), r + "]";
  }
  if (n45 instanceof Object) {
    if (typeof n45.toJSON == "function")
      return jsonStableNoneNumberStrinfiy_(n45.toJSON(), t);
    for (var u = Object.keys(n45).sort(), l = u.length, r = "", s = 0; s < l; ) {
      var c = u[s], f = jsonStableNoneNumberStrinfiy_(n45[c], true);
      f !== void 0 && (s && r !== "" && (r += ","), r += JSON.stringify(c) + ":" + f), s++;
    }
    return "{" + r + "}";
  }
  switch (e) {
    case "function":
    case "undefined":
      return t ? void 0 : null;
    case "number":
      return 0;
    default:
      return isFinite(n45) ? n45 : null;
  }
}
function jsonStableNoneNumberStrinfiy(n45) {
  return String(jsonStableNoneNumberStrinfiy_(n45, false));
}
function verify(n45) {
  var t, e, r;
  if (Array.isArray(n45)) {
    var o = void 0, s, u;
    if (n45.length <= 0)
      return error_invalid_input();
    for (var l = function(R) {
      var S = verify(n45[R]);
      if (S instanceof Error)
        return { value: S };
      if (!o)
        o = S.issuer;
      else if (o !== S.issuer)
        return { value: error_invalid_certificate() };
      s ? S.expire.getTime() < s.getTime() && (s = S.expire) : s = S.expire, u ? u = u.filter(function(M) {
        return S.allowHosts.indexOf(M) !== -1;
      }) : u = S.allowHosts;
    }, c = 0; c < n45.length; c++) {
      var f = l(c);
      if (typeof f == "object")
        return f.value;
    }
    return deepFreeze({ issuer: o, expire: s, allowHosts: u });
  }
  var d = JSON.parse(n45), h = typeof location != "undefined" ? location.hostname : "", v = Date.now();
  if (typeof d != "object")
    return error_invalid_input();
  var A = new Date(typeof d.expire_at == "string" && /^\d+$/.test(d.expire_at) ? Number(d.expire_at) : d.expire_at), g = Array.isArray(d.allow_hosts) ? d.allow_hosts : [];
  if (h.length === 0 || isIPDomain(h) || BUILDIN_ALLOW_HOST.filter(function(R) {
    return matchDomain(R, h);
  }).length > 0) {
    var p = String((t = d.certificate) !== null && t !== void 0 ? t : "");
    if (p) {
      var y = new X509();
      return y.readCertPEM(p), deepFreeze({ issuer: y.getSubjectString(), expire: A, allowHosts: g });
    }
    return deepFreeze({ issuer: "none", expire: A, allowHosts: g });
  }
  var m = String((e = d.certificate) !== null && e !== void 0 ? e : "");
  if (!m)
    return error_invalid_certificate();
  var E = new X509();
  E.readCertPEM(m);
  var b = String((r = d._signature) !== null && r !== void 0 ? r : "");
  if (!b)
    return error_invalid_signature();
  var T = jsonStableNoneNumberStrinfiy(ObjectOmit(d, ["_signature"]));
  return verifyMessage(T, b, E) === false ? error_invalid_signature() : v < A.getTime() ? g.filter(function(R) {
    return matchDomain(R, h);
  }).length === 0 ? error_host_not_allowed(h) : deepFreeze({ issuer: E.getSubjectString(), expire: A, allowHosts: g }) : error_date_expired(A);
}
var scratchMatrix4$1 = new Matrix4();
var workRawMapping = /* @__PURE__ */ new WeakMap();
var needsUpdateWorkCodeSet = /* @__PURE__ */ new Set();
var Work = (
  /** @class */
  function() {
    function n45(t, e) {
      this.name = "", this.baseURL = "", this.workCode = "", this.expire = /* @__PURE__ */ new Date(), this.allowHosts = [], this.initial = {
        work: this
      }, this.observers = [], this.issuer = "none", this.raw = { works: [""], options: "" }, this.transform = new Matrix4();
      {
        var r = this;
        this.options = {
          get transform() {
            return r.transform;
          },
          set transform(s) {
            r.transform.copy(s);
          }
        };
      }
      if (t !== null)
        if ("up" in t && typeof t.up == "string" && "down" in t && typeof t.down == "string" && "right" in t && typeof t.right == "string" && "left" in t && typeof t.left == "string" && "front" in t && typeof t.front == "string" && "back" in t && typeof t.back == "string" && "size" in t && typeof t.size == "number")
          parsePanoWork(t, this);
        else {
          var o = parse(t, e, this);
          if (o instanceof Error)
            throw new Error("[PARSE FAILED]: " + o.message + `
Error work input:
` + JSON.stringify(t));
        }
      else
        parseNull(t, this);
    }
    return n45.prototype.toJSON = function() {
      return this.raw;
    }, n45.parse = parseWork, n45;
  }()
);
function getType(n45) {
  return n45 == null ? "null" : Array.isArray(n45) ? "array" : typeof n45 == "object" ? "dict" : "value";
}
function deepMerge(n45, t) {
  var e = getType(n45), r = getType(t);
  if (r === "null")
    return n45;
  if (r === "value")
    return t;
  if (r !== e)
    return JSON.parse(JSON.stringify(t));
  if (r === "array")
    for (var o = 0; o < t.length; o++)
      n45[o] = deepMerge(n45[o], t[o]);
  else if (r === "dict")
    for (var s in t)
      n45[s] = deepMerge(n45[s], t[s]);
  return n45;
}
function startWithString(n45, t) {
  return n45.indexOf(t) === 0;
}
function urlWithParseOptions(n45, t, e, r) {
  var o, s = t;
  if (r.jsonp === true) {
    s = t.replace(/([\?\#].*)?$/i, "");
    var u = sha256("".concat(s)).slice(0, 7);
    s = "".concat(s, ".").concat(u, ".jsonp");
  }
  if (r.shortPath === true) {
    var l = s.replace(n45, "").split("."), c = (o = l.shift()) !== null && o !== void 0 ? o : "", f = l.join(".");
    s = pathJoin(n45, sha256(c)) + (f ? "." + f : "");
  }
  var d = s.replace(n45, "");
  return r.baseURL && (s = pathJoin(r.baseURL, d)), r.traverseResource && r.traverseResource({ origin: t, absolute: s, relative: d, type: e }), s;
}
function panoURL(n45, t, e, r, o) {
  var s = e;
  return isAbsoluteURL(e) || (t && (t = pathJoin(t, String(r))), s = pathJoin(t, s)), isAbsoluteURL(s) || (s = pathJoin(n45, s)), startWithString(s, n45) || console.warn("".concat(s, " is not start with base_url(").concat(n45, ").")), urlWithParseOptions(n45, s, "panorama", o);
}
function fileURL(n45, t, e) {
  var r = t;
  return isAbsoluteURL(r) || (r = pathJoin(n45, t)), startWithString(r, n45) || console.warn("".concat(r, " is not start with base_url(").concat(n45, ").")), urlWithParseOptions(n45, r, "model", e);
}
function textureURL$1(n45, t, e, r) {
  var o = t;
  return isAbsoluteURL(o) || (o = pathJoin(e, o)), isAbsoluteURL(o) || (o = pathJoin(n45, o)), startWithString(o, n45) || console.warn("".concat(o, " is not start with base_url(").concat(n45, ").")), urlWithParseOptions(n45, o, "texture", r);
}
var getTileLevel = function(n45) {
  for (var t = 10; t >= 0; t--) {
    var e = 512 * Math.pow(2, t);
    if (e <= n45)
      return t;
  }
  return null;
};
var sortTile = function(n45) {
  n45 = n45.slice().sort(function(u, l) {
    return u.level - l.level;
  });
  for (var t = [], e = 0, r = n45; e < r.length; e++) {
    var o = r[e];
    if (t.length === 0) {
      t.push(o);
      continue;
    }
    var s = t[t.length - 1];
    if (o.level > s.level) {
      t.push(o);
      continue;
    }
    if (o.size > s.size) {
      t[t.length - 1] = o;
      continue;
    }
  }
  return t;
};
function parse(n45, t, e) {
  for (var r, o, s, u, l, c, f, d, h, v, A, g, p, y, m, E, b, T, R, S, M = JSON.stringify(t), w = [], H = 0, L = [].concat(n45); H < L.length; H++) {
    var C = L[H];
    C instanceof Work ? w.push.apply(w, C.raw.works) : typeof C == "string" ? w.push(C) : w.push(JSON.stringify(C));
  }
  var I = verify(w);
  if (I instanceof Error)
    return I;
  Array.isArray(t.transform) ? e.transform.fromArray(t.transform) : t.transform && e.transform.copy(t.transform), n45 = w.map(function(Z) {
    return JSON.parse(Z);
  }).reduce(function(Z, te) {
    return deepMerge(Z, te);
  }), Object.defineProperty(e, "raw", {
    configurable: false,
    get: function() {
      return { works: w, options: M };
    }
  });
  {
    var _;
    if (t.workCode && (typeof t.workCode == "string" ? _ = t.workCode : typeof t.workCode == "function" && (_ = t.workCode(n45))), typeof _ == "undefined" && (_ = String(n45.resource_code || n45.basic_code || n45.vr_code || n45.code || n45.project_id || n45.work_code || n45.workCode)), typeof _ == "undefined")
      return new Error("WorkCode never matched.");
    Object.defineProperty(e, "workCode", {
      configurable: false,
      get: function() {
        return _;
      }
    });
  }
  {
    var O = String(n45.name);
    Object.defineProperty(e, "name", {
      configurable: false,
      get: function() {
        return O;
      }
    });
  }
  if (I instanceof Error)
    return I;
  Object.defineProperty(e, "issuer", {
    configurable: false,
    get: function() {
      return I.issuer;
    }
  }), Object.defineProperty(e, "expire", {
    configurable: false,
    get: function() {
      return I.expire;
    }
  }), Object.defineProperty(e, "allowHosts", {
    configurable: false,
    get: function() {
      return I.allowHosts;
    }
  });
  var P = (r = n45.base_url) !== null && r !== void 0 ? r : "";
  if (P && P[P.length - 1] !== "/" && (P += "/"), e.baseURL = (o = t.baseURL) !== null && o !== void 0 ? o : P, I instanceof Error)
    return I;
  if (n45.model) {
    var N = {
      work: e,
      layers: []
    }, k;
    n45.model.file ? k = fileURL(P, n45.model.file, t) : n45.model.file_url && (k = fileURL(P, n45.model.file_url, t)), Object.defineProperty(N, "file", {
      configurable: false,
      get: function() {
        return k;
      }
    });
    var U;
    n45.model.textureBase ? U = textureURL$1(P, "", n45.model.textureBase, t) : n45.model.material_base_url ? U = textureURL$1(P, "", n45.model.material_base_url, t) : N.file && (U = N.file.split("/").slice(0, -1).join("/").replace("/model/", "/materials/")), Object.defineProperty(N, "textureBase", {
      configurable: false,
      get: function() {
        return U;
      }
    });
    var D;
    Array.isArray(n45.model.textures) ? (D = n45.model.textures.map(function(Z) {
      var te, K;
      return textureURL$1(P, Z, (K = (te = n45.model.textureBase) !== null && te !== void 0 ? te : n45.model.material_base_url) !== null && K !== void 0 ? K : "", t);
    }), Object.freeze(D)) : Array.isArray(n45.model.material_textures) && (D = n45.model.material_textures.map(function(Z) {
      var te, K;
      return textureURL$1(P, Z, (K = (te = n45.model.textureBase) !== null && te !== void 0 ? te : n45.model.material_base_url) !== null && K !== void 0 ? K : "", t);
    }), Object.freeze(D)), Object.defineProperty(N, "textures", {
      configurable: false,
      get: function() {
        return D;
      }
    });
    var q = [];
    if (Array.isArray(n45.model.tiles))
      for (var z = 0, Q = n45.model.tiles; z < Q.length; z++) {
        var G = Q[z];
        G && (G.tileset || G.tileset_url) && q.push(Object.freeze({
          type: (s = G.type) !== null && s !== void 0 ? s : "mesh",
          name: (u = G.name) !== null && u !== void 0 ? u : "",
          upAxis: (c = (l = G.upAxis) !== null && l !== void 0 ? l : G.up_axis) !== null && c !== void 0 ? c : "-Y",
          tileset: fileURL(P, G.tileset || G.tileset_url, t)
        }));
      }
    else
      n45.model.tiles && (n45.model.tiles.tileset || n45.model.tiles.tileset_url) && q.push(Object.freeze({
        type: (f = n45.model.tiles.type) !== null && f !== void 0 ? f : "mesh",
        name: (d = n45.model.tiles.name) !== null && d !== void 0 ? d : "lod",
        upAxis: (v = (h = n45.model.tiles.upAxis) !== null && h !== void 0 ? h : n45.model.tiles.up_axis) !== null && v !== void 0 ? v : "-Y",
        tileset: fileURL(P, n45.model.tiles.tileset || n45.model.tiles.tileset_url, t)
      }));
    if (Array.isArray(n45.model.layers))
      for (var X = 0, $ = n45.model.layers; X < $.length; X++) {
        var W = $[X];
        W && (W.tileset || W.tileset_url) && q.push(Object.freeze({
          type: (A = W.type) !== null && A !== void 0 ? A : "mesh",
          name: (g = W.name) !== null && g !== void 0 ? g : "",
          upAxis: (p = W.upAxis) !== null && p !== void 0 ? p : W.up_axis,
          tileset: fileURL(P, W.tileset || W.tileset_url, t)
        }));
      }
    Object.freeze(q), Object.defineProperty(N, "layers", {
      configurable: false,
      get: function() {
        return q;
      }
    }), Object.defineProperty(e, "model", {
      configurable: false,
      get: function() {
        if (N.file || N.layers.length)
          return N;
      }
    });
  }
  if (I instanceof Error)
    return I;
  var oe = /* @__PURE__ */ new Set(), ie = /* @__PURE__ */ new Set();
  {
    var re = [];
    if (n45.observers && Array.isArray(n45.observers)) {
      var j = [];
      n45.panorama && (Array.isArray(n45.panorama) ? j = n45.panorama : Array.isArray(n45.panorama.list) ? j = n45.panorama.list : Array.isArray(n45.panorama.info) && (j = n45.panorama.info));
      for (var se = function(Z) {
        var te = {}, K = n45.observers[Z];
        if (!K)
          return "break";
        var ye = j[Z];
        if (!ye)
          return "break";
        K = Object.assign({}, K, ye, {
          //  active
          // observer.active | panorama.active  false  false
          active: K.active !== false && ye.active !== false
        }), Object.defineProperty(te, "work", {
          configurable: false,
          get: function() {
            return e;
          }
        }), Object.defineProperty(te, "index", {
          configurable: false,
          get: function() {
            return Z;
          }
        }), ie.add(Z), Object.defineProperty(te, "panoIndex", {
          configurable: false,
          get: function() {
            return Z;
          }
        });
        var de = panoStringify({
          workCode: e.workCode,
          panoIndex: Z
        });
        oe.add(de), Object.defineProperty(te, "panoId", {
          configurable: false,
          get: function() {
            return de;
          }
        });
        var xe = Object.freeze({
          workCode: e.workCode,
          panoIndex: Z
        });
        Object.defineProperty(te, "pano", {
          configurable: false,
          get: function() {
            return xe;
          }
        });
        var Ae = K.active !== false;
        Object.defineProperty(te, "active", {
          configurable: false,
          get: function() {
            return Ae;
          }
        });
        var me = K.loadable === true;
        Object.defineProperty(te, "loadable", {
          configurable: false,
          get: function() {
            return me;
          }
        });
        var ce = K.derived_id;
        Object.defineProperty(te, "derivedId", {
          configurable: false,
          get: function() {
            return ce;
          }
        });
        var pe = K.derived_id_str;
        Object.defineProperty(te, "derivedIdStr", {
          configurable: false,
          get: function() {
            return pe;
          }
        });
        var ee = (R = (b = (m = (y = n45.panorama) === null || y === void 0 ? void 0 : y.pano_high_cube_base_url) !== null && m !== void 0 ? m : (E = n45.panorama) === null || E === void 0 ? void 0 : E.pano_cube_base_url) !== null && b !== void 0 ? b : (T = n45.panorama) === null || T === void 0 ? void 0 : T.base_url) !== null && R !== void 0 ? R : "", he = {
          up: panoURL(P, ee, K.images ? K.images.up : K.up, Z, t),
          down: panoURL(P, ee, K.images ? K.images.down : K.down, Z, t),
          right: panoURL(P, ee, K.images ? K.images.right : K.right, Z, t),
          left: panoURL(P, ee, K.images ? K.images.left : K.left, Z, t),
          front: panoURL(P, ee, K.images ? K.images.front : K.front, Z, t),
          back: panoURL(P, ee, K.images ? K.images.back : K.back, Z, t)
        };
        if (K.size_list)
          he.sizeList = K.size_list.slice();
        else {
          var Se = getImageSizeFromURL(he.up);
          if (Se && (he.sizeList = [Se], K.tiles))
            for (var Ie = K.tiles.slice().sort(function(we, Oe) {
              return we - Oe;
            }).map(function(we) {
              return 512 * Math.pow(2, we);
            }), Ue = 0, be = Ie; Ue < be.length; Ue++) {
              var ge = be[Ue];
              ge > Se && he.sizeList.push(ge);
            }
        }
        var ze = K.images ? K.images.luminance : K.luminance;
        ze && (he.luminance = Object.freeze({
          up: panoURL(P, ee, ze.up, Z, t),
          down: panoURL(P, ee, ze.down, Z, t),
          right: panoURL(P, ee, ze.right, Z, t),
          left: panoURL(P, ee, ze.left, Z, t),
          front: panoURL(P, ee, ze.front, Z, t),
          back: panoURL(P, ee, ze.back, Z, t)
        }));
        var Ne = void 0;
        if (K.images)
          Ne = K.images.tiles;
        else if (Array.isArray(K.size_list)) {
          var Je = K.size_list.slice().sort(function(we, Oe) {
            return we - Oe;
          });
          if (Je[0]) {
            var Ke = getTileLevel(Je[0]);
            if (Ke)
              for (var De = Ke - 1; De >= 0; De--)
                Je.unshift(512 * Math.pow(2, De));
            Ne = Je;
          }
        } else if (Array.isArray(K.tiles) && (Ne = K.tiles.slice(), typeof Ne[0] == "number")) {
          for (var Ye = Ne[0]; --Ye >= 0; )
            Ne.unshift(Ye);
          Ne = Ne.sort(function(we, Oe) {
            return we - Oe;
          }).map(function(we) {
            return 512 * Math.pow(2, we);
          });
        }
        if (Ne) {
          for (var Ve = [], nt = 0, qe = Ne; nt < qe.length; nt++) {
            var ge = qe[nt];
            if (typeof ge == "number") {
              var Qe = getTileLevel(ge);
              if (typeof Qe != "number")
                continue;
              var Pe = getImageSizeFromURL(he.front);
              if (!Pe)
                continue;
              if (ge > Pe) {
                var Me = replaceImageSize(he.up, ge), He = replaceImageSize(he.down, ge), Le = replaceImageSize(he.right, ge), ot = replaceImageSize(he.left, ge), $e = replaceImageSize(he.front, ge), tt = replaceImageSize(he.back, ge);
                Ve.push(Object.freeze({ level: Qe, size: ge, scale: 1, up: Me, down: He, right: Le, left: ot, front: $e, back: tt }));
              } else {
                var Me = he.up, He = he.down, Le = he.right, ot = he.left, $e = he.front, tt = he.back;
                Ve.push(Object.freeze({ level: Qe, size: Pe, scale: ge / Pe, up: Me, down: He, right: Le, left: ot, front: $e, back: tt }));
              }
            } else {
              var Qe = ge.level;
              if (typeof Qe != "number")
                continue;
              var Se = ge.size;
              if (typeof Se != "number")
                continue;
              var Me = panoURL(P, ee, ge.up, Z, t), He = panoURL(P, ee, ge.down, Z, t), Le = panoURL(P, ee, ge.right, Z, t), ot = panoURL(P, ee, ge.left, Z, t), $e = panoURL(P, ee, ge.front, Z, t), tt = panoURL(P, ee, ge.back, Z, t);
              Ve.push(Object.freeze({ level: Qe, size: Se, scale: (S = ge.scale) !== null && S !== void 0 ? S : 1, up: Me, down: He, right: Le, left: ot, front: $e, back: tt }));
            }
          }
          Ve = sortTile(Ve), Object.freeze(Ve), Object.defineProperty(he, "tiles", {
            configurable: false,
            get: function() {
              return Ve;
            }
          });
        }
        Object.freeze(he), Object.defineProperty(te, "images", {
          configurable: false,
          get: function() {
            return he;
          }
        });
        var Xe = new Vector3();
        if (K.position instanceof Vector3)
          Xe.copy(K.position);
        else if (Array.isArray(K.position))
          Xe.fromArray(K.position);
        else
          return "break";
        Object.freeze(Xe), Object.defineProperty(te, "position", {
          configurable: false,
          get: function() {
            return Xe;
          }
        });
        var rt = new Vector3();
        if (K.standingPosition instanceof Vector3)
          rt.copy(K.standingPosition);
        else if (Array.isArray(K.standingPosition))
          rt.fromArray(K.standingPosition);
        else if (K.standing_position instanceof Vector3)
          rt.copy(K.standing_position);
        else if (Array.isArray(K.standing_position))
          rt.fromArray(K.standing_position);
        else
          return "break";
        Object.freeze(rt), Object.defineProperty(te, "standingPosition", {
          configurable: false,
          get: function() {
            return rt;
          }
        });
        var Ge = new Quaternion();
        if (K.quaternion instanceof Quaternion)
          Ge.copy(K.quaternion);
        else if (Array.isArray(K.quaternion))
          Ge.fromArray(K.quaternion);
        else if (K.quaternion) {
          var st = K.quaternion, ct = st.x, je = st.y, Fe = st.z, We = st.w;
          Ge.set(ct, je, Fe, We);
        } else
          return "break";
        Object.freeze(Ge), Object.defineProperty(te, "quaternion", {
          configurable: false,
          get: function() {
            return Ge;
          }
        });
        var it = 0;
        isNumber(K.floorIndex) ? it = K.floorIndex : isNumber(K.floor_index) ? it = K.floor_index : isNumber(K.floor) && (it = K.floor), Object.defineProperty(te, "floorIndex", {
          configurable: false,
          get: function() {
            return it;
          }
        });
        var Be;
        K.video && (Be = {}, typeof K.video.source == "string" && (Be.source = K.video.source), K.video.matrix instanceof Matrix4 ? Be.matrix = K.video.matrix.clone() : Array.isArray(K.video.matrix) && (Be.matrix = new Matrix4().fromArray(K.video.matrix)), K.video.size instanceof Vector2 ? Be.size = K.video.size.clone() : Array.isArray(K.video.size) && (Be.size = new Vector2().fromArray(K.video.size)), Be.source && Be.matrix && Be.size && (te.video = Be)), Object.freeze(Be), Object.defineProperty(te, "video", {
          configurable: false,
          get: function() {
            return Be;
          }
        }), Array.isArray(K.accessibleNodes) ? (te.accessibleNodes = K.accessibleNodes.slice(), te.accessibleIds = K.accessibleNodes.map(function(we) {
          return panoStringify({
            workCode: e.workCode,
            panoIndex: we
          });
        })) : Array.isArray(K.accessible_nodes) && (te.accessibleNodes = K.accessible_nodes.slice(), te.accessibleIds = K.accessible_nodes.map(function(we) {
          return panoStringify({
            workCode: e.workCode,
            panoIndex: we
          });
        })), Array.isArray(K.visibleNodes) ? (te.visibleNodes = K.visibleNodes.slice(), te.visibleIds = K.visibleNodes.map(function(we) {
          return panoStringify({
            workCode: e.workCode,
            panoIndex: we
          });
        })) : Array.isArray(K.visible_nodes) && (te.visibleNodes = K.visible_nodes.slice(), te.visibleIds = K.visible_nodes.map(function(we) {
          return panoStringify({
            workCode: e.workCode,
            panoIndex: we
          });
        })), re[Z] = te;
      }, ae = 0; ae < n45.observers.length; ae++) {
        var ue = se(ae);
        if (ue === "break")
          break;
      }
    }
    for (var fe = function(Z) {
      if (Z.accessibleIds) {
        var ye = Z.accessibleIds.filter(function(ee) {
          return oe.has(ee);
        });
        Object.freeze(ye), Object.defineProperty(Z, "accessibleIds", {
          configurable: false,
          get: function() {
            return ye;
          }
        });
      } else {
        for (var te = [], K = 0; K < re.length; K++)
          re[K] !== Z && (Math.abs(re[K].position.y - Z.position.y) > 3 || re[K].position.distanceTo(Z.position) > 10 || te.push(re[K].panoId));
        Object.freeze(te), Object.defineProperty(Z, "accessibleIds", {
          configurable: false,
          get: function() {
            return te;
          }
        });
      }
      if (Z.accessibleNodes) {
        var xe = Z.accessibleNodes.filter(function(ee) {
          return ie.has(ee);
        });
        Object.freeze(xe), Object.defineProperty(Z, "accessibleNodes", {
          configurable: false,
          get: function() {
            return xe;
          }
        });
      } else {
        for (var de = [], K = 0; K < re.length; K++)
          re[K] !== Z && (Math.abs(re[K].position.y - Z.position.y) > 3 || re[K].position.distanceTo(Z.position) > 10 || de.push(re[K].panoIndex));
        Object.freeze(de), Object.defineProperty(Z, "accessibleNodes", {
          configurable: false,
          get: function() {
            return de;
          }
        });
      }
      if (Z.visibleIds) {
        var me = Z.visibleIds.filter(function(ee) {
          return oe.has(ee);
        });
        Object.freeze(me), Object.defineProperty(Z, "visibleIds", {
          configurable: false,
          get: function() {
            return me;
          }
        });
      } else {
        var Ae = Z.accessibleIds.slice();
        Object.freeze(Ae), Object.defineProperty(Z, "visibleIds", {
          configurable: false,
          get: function() {
            return Ae;
          }
        });
      }
      if (Z.visibleNodes) {
        var pe = Z.visibleNodes.filter(function(ee) {
          return ie.has(ee);
        });
        Object.freeze(pe), Object.defineProperty(Z, "visibleNodes", {
          configurable: false,
          get: function() {
            return pe;
          }
        });
      } else {
        var ce = Z.accessibleNodes.slice();
        Object.freeze(ce), Object.defineProperty(Z, "visibleNodes", {
          configurable: false,
          get: function() {
            return ce;
          }
        });
      }
    }, ne = 0, Te = re; ne < Te.length; ne++) {
      var Re = Te[ne];
      fe(Re);
    }
    Object.freeze(re), Object.defineProperty(e, "observers", {
      configurable: false,
      get: function() {
        return re;
      }
    });
  }
  if (I instanceof Error)
    return I;
  if (n45.initial) {
    if ((n45.initial.mode === "Panorama" && e.observers.length === 0 || n45.initial.mode === "Floorplan" || n45.initial.mode === "Topview" || n45.initial.mode === "Model" || n45.initial.mode === "Mapview" || n45.initial.mode === "DepthPanorama") && (e.initial.mode = n45.initial.mode), isNumber(n45.initial.latitude) && (e.initial.latitude = n45.initial.latitude), isNumber(n45.initial.longitude) ? e.initial.longitude = n45.initial.longitude : isNumber(n45.initial.heading) && (e.initial.longitude = headingToLongitude(n45.initial.heading)), isNumber(n45.initial.fov) && (e.initial.fov = n45.initial.fov), e.observers.length > 0) {
      var ve = void 0;
      isNumber(n45.initial.panoIndex) ? ve = n45.initial.panoIndex : isNumber(n45.initial.pano_index) ? ve = n45.initial.pano_index : isNumber(n45.initial.pano) && (ve = n45.initial.pano), typeof ve == "number" && (ve = clamp$1(ve, 0, e.observers.length - 1), e.initial.panoIndex = ve);
    }
    if (isNumber(n45.initial.distance) && (e.initial.distance = n45.initial.distance), Array.isArray(n45.initial.offset)) {
      var Ce = [0, 0, 0].map(function(Z, te) {
        var K = Number(n45.initial.offset[te]);
        return isNaN(K) || !isFinite(K) ? 0 : K;
      });
      e.initial.offset = new Vector3().fromArray(Ce);
    } else typeof n45.initial.offset == "object" && typeof n45.initial.offset.x == "number" && typeof n45.initial.offset.y == "number" && typeof n45.initial.offset.z == "number" && (e.initial.offset = new Vector3(n45.initial.offset.x, n45.initial.offset.y, n45.initial.offset.z));
    !e.initial.mode && typeof e.initial.panoIndex == "number" && (e.initial.mode = "Panorama");
  }
  return I instanceof Error ? I : (workRawMapping.set(e, { works: w, options: M }), e);
}
function parseNull(n45, t) {
  return t.issuer = "null", deepFreeze(t), workRawMapping.set(t, { works: ["null"], options: "{}" }), t;
}
function parsePanoWork(n45, t) {
  var e;
  t.issuer = "null", t.allowHosts = ["*"], t.workCode = (e = n45.code) !== null && e !== void 0 ? e : createUuid();
  var r = [n45.size], o = [], s = getTileLevel(r[0]);
  if (s)
    for (var u = s - 1; u >= 0; u--)
      r.unshift(512 * Math.pow(2, u));
  for (var l = 0, c = r; l < c.length; l++) {
    var f = c[l], d = getTileLevel(f);
    d && o.push({
      level: d,
      size: n45.size,
      scale: f / n45.size,
      up: n45.up,
      down: n45.down,
      right: n45.right,
      left: n45.left,
      front: n45.front,
      back: n45.back
    });
  }
  var h = {
    up: n45.up,
    down: n45.down,
    right: n45.right,
    left: n45.left,
    front: n45.front,
    back: n45.back,
    sizeList: r
  };
  o && (h.tiles = o);
  var v = {
    accessibleIds: [],
    accessibleNodes: [],
    active: true,
    floorIndex: 0,
    images: h,
    index: 0,
    loadable: false,
    pano: {
      workCode: t.workCode,
      panoIndex: 0
    },
    panoId: "".concat(t.workCode, "[0]"),
    panoIndex: 0,
    position: new Vector3(0, 1.5, 0),
    quaternion: new Quaternion(0, 1, 0, 0),
    standingPosition: new Vector3(0, 0, 0),
    visibleIds: [],
    visibleNodes: [],
    work: t
  };
  return t.observers = [v], deepFreeze(t), workRawMapping.set(t, { works: [JSON.stringify(n45)], options: "{}" }), t;
}
function parseWork(n45, t) {
  typeof n45 == "string" && n45.trim()[0] === "{" && (n45 = JSON.parse(n45));
  var e = workRawMapping.get(n45);
  if (e) {
    if (t && !equal(JSON.parse(e.options), t))
      throw new Error("[PARSE FAILED]: work is parsed with different options.");
    return n45;
  } else
    try {
      return new Work(n45, t != null ? t : {});
    } catch (r) {
      throw new Error("[PARSE FAILED]: " + r.message + `
Error work input:
` + JSON.stringify(n45));
    }
}
function createWorks(n45) {
  for (var t = {}, e = [], r = {}, o = 0, s = n45; o < s.length; o++) {
    var u = s[o], l = t[u.workCode];
    l || (l = t[u.workCode] = new Matrix4().copy(u.transform));
    for (var c = 0, f = u.observers; c < f.length; c++) {
      var d = f[c], h = {
        isResolved: true,
        active: d.active,
        accessibleIds: d.accessibleIds,
        visibleIds: d.visibleIds,
        accessibleNodes: d.accessibleNodes,
        visibleNodes: d.visibleNodes,
        floorIndex: d.floorIndex,
        images: d.images,
        index: d.index,
        panoIndex: d.panoIndex,
        loadable: d.loadable,
        panoId: d.panoId,
        pano: d.pano,
        work: d.work,
        derivedId: d.derivedId,
        video: d.video,
        position: new Vector3().copy(d.position).applyMatrix4(l),
        standingPosition: new Vector3().copy(d.standingPosition).applyMatrix4(l),
        quaternion: new Quaternion().setFromRotationMatrix(scratchMatrix4$1.makeRotationFromQuaternion(d.quaternion).premultiply(l))
      };
      Object.freeze(h), e.push(h), r[h.panoId] = h;
    }
  }
  Object.freeze(e);
  for (var v = n45.slice(), A = {}, g = 0, p = v; g < p.length; g++) {
    var u = p[g];
    A[u.workCode] = u;
  }
  return Object.freeze(Object.assign(v, {
    get initial() {
      return v.length > 0 ? v[0].initial : { work: {} };
    },
    get resolvedObservers() {
      return e;
    },
    getWork: function(y) {
      return A[y];
    },
    getResolvedObserver: function(y) {
      var m, E;
      return isPanoId(y) ? r[y] : typeof y == "number" ? r[panoStringify({ workCode: (E = (m = n45[0]) === null || m === void 0 ? void 0 : m.workCode) !== null && E !== void 0 ? E : "", panoIndex: y })] : r[panoStringify(y)];
    },
    update: function() {
      for (var y = 0, m = v; y < m.length; y++) {
        var E = m[y], b = E.transform, T = t[E.workCode];
        T ? T.equals(b) || (T.copy(b), needsUpdateWorkCodeSet.add(E.workCode)) : (t[E.workCode] = new Matrix4().copy(b), needsUpdateWorkCodeSet.add(E.workCode));
      }
      if (needsUpdateWorkCodeSet.size > 0) {
        for (var R = 0, S = e; R < S.length; R++) {
          var M = S[R];
          if (needsUpdateWorkCodeSet.has(M.work.workCode)) {
            var w = M.work.observers[M.index], H = M.work.transform;
            M.position.copy(w.position).applyMatrix4(H), M.standingPosition.copy(w.standingPosition).applyMatrix4(H), M.quaternion.setFromRotationMatrix(scratchMatrix4$1.makeRotationFromQuaternion(w.quaternion).premultiply(H));
          }
        }
        needsUpdateWorkCodeSet.clear();
      }
    }
  }));
}
var fetcherMap = /* @__PURE__ */ new Map();
function getFetcher(n45) {
  var t = fetcherMap.get(n45);
  if (t)
    return t;
  throw new Error("fetcher never registered.");
}
function registerFetcher(n45, t) {
  return fetcherMap.set(n45, t);
}
var BufferGeometryUtils = {
  computeTangents: function(n45) {
    var t = n45.index, e = n45.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
      return;
    }
    var r = t.array, o = e.position.array, s = e.normal.array, u = e.uv.array, l = o.length / 3;
    e.tangent === void 0 && n45.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * l), 4));
    for (var c = e.tangent.array, f = [], d = [], h = 0; h < l; h++)
      f[h] = new Vector3(), d[h] = new Vector3();
    var v = new Vector3(), A = new Vector3(), g = new Vector3(), p = new Vector2(), y = new Vector2(), m = new Vector2(), E = new Vector3(), b = new Vector3();
    function T(q, z, Q) {
      v.fromArray(o, q * 3), A.fromArray(o, z * 3), g.fromArray(o, Q * 3), p.fromArray(u, q * 2), y.fromArray(u, z * 2), m.fromArray(u, Q * 2);
      var G = A.x - v.x, X = g.x - v.x, $ = A.y - v.y, W = g.y - v.y, oe = A.z - v.z, ie = g.z - v.z, re = y.x - p.x, j = m.x - p.x, se = y.y - p.y, ae = m.y - p.y, ue = 1 / (re * ae - j * se);
      E.set((ae * G - se * X) * ue, (ae * $ - se * W) * ue, (ae * oe - se * ie) * ue), b.set((re * X - j * G) * ue, (re * W - j * $) * ue, (re * ie - j * oe) * ue), f[q].add(E), f[z].add(E), f[Q].add(E), d[q].add(b), d[z].add(b), d[Q].add(b);
    }
    var R = n45.groups;
    R.length === 0 && (R = [{
      start: 0,
      count: r.length
    }]);
    for (var h = 0, S = R.length; h < S; ++h)
      for (var M = R[h], w = M.start, H = M.count, L = w, C = w + H; L < C; L += 3)
        T(r[L + 0], r[L + 1], r[L + 2]);
    var I = new Vector3(), _ = new Vector3(), O = new Vector3(), P = new Vector3(), N, k, U;
    function D(q) {
      O.fromArray(s, q * 3), P.copy(O), k = f[q], I.copy(k), I.sub(O.multiplyScalar(O.dot(k))).normalize(), _.crossVectors(P, k), U = _.dot(d[q]), N = U < 0 ? -1 : 1, c[q * 4] = I.x, c[q * 4 + 1] = I.y, c[q * 4 + 2] = I.z, c[q * 4 + 3] = N;
    }
    for (var h = 0, S = R.length; h < S; ++h)
      for (var M = R[h], w = M.start, H = M.count, L = w, C = w + H; L < C; L += 3)
        D(r[L + 0]), D(r[L + 1]), D(r[L + 2]);
  },
  /**
   * @param  {Array<THREE.BufferGeometry>} geometries
   * @param  {Boolean} useGroups
   * @return {THREE.BufferGeometry}
   */
  mergeBufferGeometries: function(n45, t) {
    for (var e = n45[0].index !== null, r = new Set(Object.keys(n45[0].attributes)), o = new Set(Object.keys(n45[0].morphAttributes)), s = {}, u = {}, l = new BufferGeometry(), c = 0, f = 0; f < n45.length; ++f) {
      var d = n45[f];
      if (e !== (d.index !== null))
        return null;
      for (var h in d.attributes) {
        if (!r.has(h))
          return null;
        s[h] === void 0 && (s[h] = []), s[h].push(d.attributes[h]);
      }
      for (var h in d.morphAttributes) {
        if (!o.has(h))
          return null;
        u[h] === void 0 && (u[h] = []), u[h].push(d.morphAttributes[h]);
      }
      if (l.userData.mergedUserData = l.userData.mergedUserData || [], l.userData.mergedUserData.push(d.userData), t) {
        var v;
        if (e)
          v = d.index.count;
        else if (d.attributes.position !== void 0)
          v = d.attributes.position.count;
        else
          return null;
        l.addGroup(c, v, f), c += v;
      }
    }
    if (e) {
      for (var A = 0, g = [], f = 0; f < n45.length; ++f) {
        for (var p = n45[f].index, y = 0; y < p.count; ++y)
          g.push(p.getX(y) + A);
        A += n45[f].attributes.position.count;
      }
      l.setIndex(g);
    }
    for (var h in s) {
      var m = this.mergeBufferAttributes(s[h]);
      if (!m)
        return null;
      l.setAttribute(h, m);
    }
    for (var h in u) {
      var E = u[h][0].length;
      if (E === 0)
        break;
      l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[h] = [];
      for (var f = 0; f < E; ++f) {
        for (var b = [], y = 0; y < u[h].length; ++y)
          b.push(u[h][y][f]);
        var T = this.mergeBufferAttributes(b);
        if (!T)
          return null;
        l.morphAttributes[h].push(T);
      }
    }
    return l;
  },
  /**
   * @param {Array<THREE.BufferAttribute>} attributes
   * @return {THREE.BufferAttribute}
   */
  mergeBufferAttributes: function(n45) {
    for (var t, e, r, o = 0, s = 0; s < n45.length; ++s) {
      var u = n45[s];
      if (u.isInterleavedBufferAttribute || (t === void 0 && (t = u.array.constructor), t !== u.array.constructor) || (e === void 0 && (e = u.itemSize), e !== u.itemSize) || (r === void 0 && (r = u.normalized), r !== u.normalized))
        return null;
      o += u.array.length;
    }
    for (var l = new t(o), c = 0, s = 0; s < n45.length; ++s)
      l.set(n45[s].array, c), c += n45[s].array.length;
    return new BufferAttribute(l, e, r);
  },
  /**
   * @param {Array<THREE.BufferAttribute>} attributes
   * @return {Array<THREE.InterleavedBufferAttribute>}
   */
  interleaveAttributes: function(n45) {
    for (var t, e = 0, r = 0, o = 0, s = n45.length; o < s; ++o) {
      var u = n45[o];
      if (t === void 0 && (t = u.array.constructor), t !== u.array.constructor)
        return console.warn("AttributeBuffers of different types cannot be interleaved"), null;
      e += u.array.length, r += u.itemSize;
    }
    for (var l = new InterleavedBuffer(new t(e), r), c = 0, f = [], d = ["getX", "getY", "getZ", "getW"], h = ["setX", "setY", "setZ", "setW"], v = 0, s = n45.length; v < s; v++) {
      var u = n45[v], A = u.itemSize, g = u.count, p = new InterleavedBufferAttribute(l, A, c, u.normalized);
      f.push(p), c += A;
      for (var y = 0; y < g; y++)
        for (var m = 0; m < A; m++)
          p[h[m]](y, u[d[m]](y));
    }
    return f;
  },
  /**
   * @param {THREE.BufferGeometry} geometry
   * @return {number}
   */
  estimateBytesUsed: function(n45) {
    var t = 0;
    for (var e in n45.attributes) {
      var r = n45.getAttribute(e);
      t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;
    }
    var o = n45.getIndex();
    return t += o ? o.count * o.itemSize * o.array.BYTES_PER_ELEMENT : 0, t;
  },
  /**
   * @param {THREE.BufferGeometry} geometry
   * @param {number} tolerance
   * @return {THREE.BufferGeometry>}
   */
  mergeVertices: function(n45, t) {
    t === void 0 && (t = 1e-4), t = Math.max(t, Number.EPSILON);
    for (var e = {}, r = n45.getIndex(), o = n45.getAttribute("position"), s = r ? r.count : o.count, u = 0, l = Object.keys(n45.attributes), c = {}, f = {}, d = [], h = ["getX", "getY", "getZ", "getW"], v = 0, A = l.length; v < A; v++) {
      var g = l[v];
      c[g] = [];
      var p = n45.morphAttributes[g];
      p && (f[g] = new Array(p.length).fill().map(function() {
        return [];
      }));
    }
    for (var y = Math.log10(1 / t), m = Math.pow(10, y), v = 0; v < s; v++) {
      for (var E = r ? r.getX(v) : v, b = "", T = 0, A = l.length; T < A; T++)
        for (var g = l[T], R = n45.getAttribute(g), S = R.itemSize, M = 0; M < S; M++)
          b += "".concat(~~(R[h[M]](E) * m), ",");
      if (b in e)
        d.push(e[b]);
      else {
        for (var T = 0, A = l.length; T < A; T++)
          for (var g = l[T], R = n45.getAttribute(g), p = n45.morphAttributes[g], S = R.itemSize, w = c[g], H = f[g], M = 0; M < S; M++) {
            var L = h[M];
            if (w.push(R[L](E)), p)
              for (var C = 0, I = p.length; C < I; C++)
                H[C].push(p[C][L](E));
          }
        e[b] = u, d.push(u), u++;
      }
    }
    for (var _ = n45.clone(), v = 0, A = l.length; v < A; v++) {
      var g = l[v], O = n45.getAttribute(g), P = new O.array.constructor(c[g]), R = new BufferAttribute(P, O.itemSize, O.normalized);
      if (_.setAttribute(g, R), g in f)
        for (var T = 0; T < f[g].length; T++) {
          var N = n45.morphAttributes[g][T], P = new N.array.constructor(f[g][T]), k = new BufferAttribute(P, N.itemSize, N.normalized);
          _.morphAttributes[g][T] = k;
        }
    }
    return _.setIndex(d), _;
  }
};
function isThirdPersonMode(n45) {
  switch (n45) {
    case "Floorplan":
      return true;
    case "Mapview":
      return true;
    default:
      return false;
  }
}
function isFristPersonMode(n45) {
  switch (n45) {
    case "Panorama":
      return true;
    case "VRPanorama":
      return true;
    case "XRPanorama":
      return true;
    case "Model":
      return true;
    default:
      return false;
  }
}
var scratchVector3 = new Vector3();
var scratchSphere = new Sphere();
var scratchMatrix4 = new Matrix4();
var scratchMatrix4Inverse = new Matrix4();
var scratchBoundingBox = new Box3();
var ROTATE_X_90_MATRIX = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  -1,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1
]);
var ROTATE_X_90_MATRIX_INVERSE = new Matrix4().fromArray([
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  1
]);
var DEFAULT_BOUNDING = new Box3(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));
function getEcefToEnuMatrixFromUpAxis(n45, t, e) {
  switch (n45) {
    case "Z":
      break;
    case "Y":
      e.copy(ROTATE_X_90_MATRIX_INVERSE);
      break;
    case "-Y":
      e.copy(ROTATE_X_90_MATRIX);
      break;
    case "WGS84":
    case "GCJ02":
    case "BD09":
      getEcefToEnuMatrix(t, e);
      break;
    default:
      e.identity();
      break;
  }
  return e;
}
function getExt(n45) {
  var t = /([0-9a-z\.\_\-]+)([\?\#].*)?$/i.exec(n45);
  if (t) {
    var e = String(t[1]).trim().split(".").slice(1).reverse()[0];
    if (e)
      return e;
  }
  return "";
}
var ModelViewLayer = (
  /** @class */
  function() {
    function n45(t, e) {
      this.scene = t, this.error = e, t.viewLayer = this;
    }
    return Object.defineProperty(n45.prototype, "name", {
      get: function() {
        return this.scene.name;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "type", {
      get: function() {
        return this.scene.type;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "upAxis", {
      get: function() {
        return this.scene.upAxis;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "groundHeight", {
      get: function() {
        return this.scene.groundHeight;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "model", {
      get: function() {
        return this.scene.model;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "coordinates", {
      /**
       * @deprecated
       *  modelViewLayer.scene.localToLla(new THREE.Vector()) 
       */
      get: function() {
        scratchVector3.setScalar(0);
        var t = this.scene.localToLla(scratchVector3), e = t.x, r = t.y;
        return [e, r].map(function(o) {
          return (o / Math.PI * 180).toFixed(6);
        }).join(",");
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.getTransformMatrix4 = function(t) {
      return t === void 0 && (t = new Matrix4()), t.copy(this.scene.coordinateTransform.ecefToLocalMatrix), this.scene && t.premultiply(this.scene.matrixWorld), t;
    }, n45.prototype.coordinatesToWorldPoint = function(t) {
      var e = new Vector3(t.latitude, t.longitude, t.altitude);
      return this.scene.llaToWorld(e);
    }, n45.prototype.worldPointToCoordinates = function(t) {
      return scratchVector3.copy(t), this.scene.worldToLla(scratchVector3), { latitude: scratchVector3.x, longitude: scratchVector3.y, altitude: scratchVector3.z };
    }, n45;
  }()
);
var Model = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      e === void 0 && (e = {});
      var r, o, s, u = n45.call(this) || this;
      return u.name = "", u.onError = (r = e.onError) !== null && r !== void 0 ? r : noop$1, u.onShownFloorChange = (o = e.onShownFloorChange) !== null && o !== void 0 ? o : noop$1, u.onLoad = (s = e.onLoad) !== null && s !== void 0 ? s : noop$1, u.work = null, u.viewLayers = [], u.bounding = new Box3(new Vector3(), new Vector3()), u.floorLength = 0, u.textureOptions = {}, u.refined = false, u.refineProgress = [0, 0], u.loaded = false, u.matrixAutoUpdate = false, u.needsRender = true, u.autoRefine = true, u.materialVersion = 0, u.materialParameters = __assign({}, defaultPbmParameters), u.cacheCameras = [], u.disposed = false, u;
    }
    return Object.defineProperty(t.prototype, "empty", {
      get: function() {
        return this.viewLayers.length === 0;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.getMaterial = function() {
      return __assign({}, this.materialParameters);
    }, t.prototype.setMaterial = function(e) {
      var r = this.materialParameters.shownFloorIndex, o = updatePBMParameters(this.materialParameters, e);
      if (o) {
        var s = this.materialParameters.shownFloorIndex;
        r !== s && this.onShownFloorChange(s), this.materialVersion++, this.needsRender = true;
      }
    }, Object.defineProperty(t.prototype, "brightness", {
      get: function() {
        return this.materialParameters.brightness;
      },
      set: function(e) {
        this.setMaterial({ brightness: typeof e == "number" ? e : 1 });
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "shownFloorIndex", {
      /**
       * 
       */
      get: function() {
        return this.materialParameters.shownFloorIndex;
      },
      set: function(e) {
        this.setMaterial({ shownFloorIndex: e });
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "shownFloor", {
      /**
       * 
       */
      get: function() {
        return this.shownFloorIndex === -1 ? null : this.shownFloorIndex;
      },
      set: function(e) {
        this.shownFloorIndex = e === null ? -1 : e;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.show = function(e) {
      this.shownFloor = e != null ? e : null;
    }, Object.defineProperty(t.prototype, "clippers", {
      /**
       * 
       */
      get: function() {
        return this.materialParameters.clippers;
      },
      set: function(e) {
        this.setMaterial({ clippers: e });
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "customShaders", {
      get: function() {
        return this.materialParameters.customShaders;
      },
      set: function(e) {
        this.setMaterial({
          customShaders: e
        });
      },
      enumerable: false,
      configurable: true
    }), t.prototype.getEdgesBySphere = function(e, r) {
      r === void 0 && (r = 30 / 180 * Math.PI);
      for (var o = Math.cos(r), s = [], u = 0, l = this.children; u < l.length; u++) {
        var c = l[u];
        c instanceof Tile3DModel && c.tileset.selectedTiles.forEach(function(f) {
          var d, h, v;
          if (!(f.boundingVolume && f.boundingVolume.distanceToPoint(e.center) > e.radius)) {
            var A = (h = (d = f.content) === null || d === void 0 ? void 0 : d.data) === null || h === void 0 ? void 0 : h.object;
            if (A && A.visible) {
              var g = [];
              if (A.traverseVisible(function(Q) {
                if (Q instanceof Mesh) {
                  var G = bvhMeshMap.get(Q);
                  if (G) {
                    scratchMatrix4.copy(Q.matrixWorld), scratchMatrix4Inverse.getInverse(scratchMatrix4), scratchSphere.copy(e).applyMatrix4(scratchMatrix4Inverse);
                    var X = G.trianglesInSphere(scratchSphere.center, scratchSphere.radius), $ = new BufferGeometry();
                    $.setAttribute("position", new BufferAttribute(X, 3)), $.applyMatrix4(Q.matrixWorld), $ = BufferGeometryUtils.mergeVertices($, 0.01), g.push($);
                  }
                }
              }), g.length === 0)
                return;
              for (var p = ["a", "b", "c"], y = BufferGeometryUtils.mergeBufferGeometries(g, false), m = y.getAttribute("position").array, E = ((v = y.getIndex()) === null || v === void 0 ? void 0 : v.array) || [], b = [], T = [], R = 0, S = m.length; R < S; R += 3) {
                var M = new Vector3(m[R], m[R + 1], m[R + 2]);
                b.push(M);
              }
              for (var R = 0, S = E.length; R < S; R += 3) {
                var w = E[R], H = E[R + 1], L = E[R + 2], C = new Vector3().crossVectors(b[H].clone().sub(b[w]), b[L].clone().sub(b[w])).normalize();
                T.push({ a: w, b: H, c: L, normal: C });
              }
              for (var I = {}, R = 0, S = T.length; R < S; R++)
                for (var _ = T[R], O = 0; O < 3; O++) {
                  var P = _[p[O]], N = _[p[(O + 1) % 3]], k = [Math.min(P, N), Math.max(P, N)], U = k[0] + "-" + k[1];
                  I[U] === void 0 ? I[U] = { index1: k[0], index2: k[1], face1: R } : I[U].face2 = R;
                }
              for (var U in I) {
                var D = I[U];
                if (D.face2 === void 0 || T[D.face1].normal.dot(T[D.face2].normal) <= o) {
                  var q = b[D.index1], z = b[D.index2];
                  s.push(new Line3(q, z));
                }
              }
              b.length = 0, T.length = 0;
            }
          }
        });
      }
      return s;
    }, t.prototype.intersectRaycaster = function(e, r, o) {
      r === void 0 && (r = null), o === void 0 && (o = true);
      for (var s = [], u = 0, l = this.children.length; u < l; u++) {
        var c = this.children[u];
        c.visible && c instanceof Tile3DModel && c.intersectRaycaster(e, false, s);
      }
      return r != null && (s = s.filter(function(f) {
        return f.floor === r;
      })), this.getMaterial().pointBack === "HIDDEN" && (s = s.filter(function(f) {
        return !(f.object instanceof PBMPointCloud && f.face && f.face.normal.angleTo(e.ray.direction) < Math.PI / 2);
      })), o && s.sort(function(f, d) {
        return f.distance - d.distance;
      }), s;
    }, t.prototype.load = function(e, r) {
      var o, s = this, u, l, c, f, d;
      if (r === void 0 && (r = {}), this.work = e, this.name = this.work.workCode, !e.model)
        return Promise.resolve();
      for (var h = e.model, v = 0, A = 0, g = e.observers; A < g.length; A++) {
        var p = g[A];
        v = Math.max(v, p.floorIndex);
      }
      this.floorLength = v + 1;
      for (var y = false, m = [], E = function(W) {
        var oe = W.tileset, ie = W.upAxis, re = W.name, j = W.type;
        j === "mesh" && (y = true);
        var se = oe.split("#"), ae = se[0], ue = se[1], fe = (u = (ue || ae).split("?")[1]) !== null && u !== void 0 ? u : "", ne = typeof r["3d-tiles"] == "function" ? r["3d-tiles"](W) : (l = r["3d-tiles"]) !== null && l !== void 0 ? l : {}, Te = getFetcher(e).ajax(oe, {
          responseType: "text"
        }).then(function(Re) {
          var ve, Ce, Z = oe ? oe.slice(0, oe.lastIndexOf("/") + 1) : "", te = normalizeTilesetHeader(JSON.parse(Re.body), Z), K = te.root, ye = te.rootMeta, de = ye === void 0 ? {} : ye;
          de.upAxis && de.upAxis !== ie && (ie = de.upAxis), "lodVersion" in te && (ie = "-Y", "floorInfo" in te && (te.properties = te.properties || {}, te.properties.floorInfo = te.floorInfo.map(function(ge) {
            return {
              ground: -ge.ground,
              height: ge.height
            };
          }), delete te.floorInfo), te.asset.tilesetVersion = String(te.lodVersion), delete te.lodVersion);
          var xe = K.boundingVolume ? makeBoundingVolume(K.boundingVolume) : void 0;
          xe && K.transform && xe.applyMatrix4(scratchMatrix4.fromArray(K.transform));
          var Ae = null, me = new Matrix4(), ce = new Matrix4();
          de.coordinate ? (Ae = de.coordinate.ground_height, me.fromArray(de.coordinate.pose_ecef_to_enu), ce.fromArray(de.coordinate.pose_enu_to_ecef)) : (xe ? xe.getCenter(scratchVector3) : scratchVector3.setScalar(0), getEcefToEnuMatrixFromUpAxis(ie, scratchVector3, me), ce.getInverse(me));
          var pe = new Matrix4().copy(ROTATE_X_90_MATRIX), ee = new Matrix4().copy(ROTATE_X_90_MATRIX_INVERSE), he = new Matrix4().premultiply(me).premultiply(pe), Se = new Matrix4().getInverse(he), Ie;
          if (ne.viewerRequestVolume) {
            var Ue = isBoundingVolume(ne.viewerRequestVolume) ? ne.viewerRequestVolume : makeBoundingVolume(ne.viewerRequestVolume);
            Ue.applyMatrix4(Se), Ie = Ue.toJson();
          }
          te.root = {
            refine: (ve = K.refine) !== null && ve !== void 0 ? ve : "REPLACE",
            geometricError: K.geometricError,
            transform: he.toArray(),
            boundingVolume: xe ? xe.toJson() : void 0,
            viewerRequestVolume: Ie,
            children: [K]
          };
          var be = new Tile3DModel(s, te, {
            name: re,
            light: (Ce = r.light) !== null && Ce !== void 0 ? Ce : false,
            type: j,
            upAxis: ie,
            url: oe,
            referer: oe,
            search: fe,
            fetcher: getFetcher(e),
            groundHeight: Ae,
            coordinateTransform: {
              localToEnuMatrix: ee,
              enuToLocalMatrix: pe,
              enuToEcefMatrix: ce,
              ecefToEnuMatrix: me,
              localToEcefMatrix: Se,
              ecefToLocalMatrix: he
            }
          });
          return be.matrix.copy(e.transform), be.matrix.decompose(be.position, be.quaternion, be.scale), be.matrixWorldNeedsUpdate = true, Object.assign(be.maxMemoryUsage, be.getRecommendProps()), typeof ne.debug != "undefined" && (be.debug = ne.debug), typeof ne.minLevelOfDetail != "undefined" && (be.minLevelOfDetail = ne.minLevelOfDetail), typeof ne.maxLevelOfDetail != "undefined" && (be.maxLevelOfDetail = ne.maxLevelOfDetail), typeof ne.minGeometricError != "undefined" && (be.minGeometricError = ne.minGeometricError), typeof ne.maxGeometricError != "undefined" && (be.maxGeometricError = ne.maxGeometricError), typeof ne.skipLevelOfDetail != "undefined" && (be.skipLevelOfDetail = ne.skipLevelOfDetail), typeof ne.mostDetail != "undefined" && (be.mostDetail = ne.mostDetail), typeof ne.loadSiblings != "undefined" && (be.loadSiblings = ne.loadSiblings), typeof ne.loadAll != "undefined" && (be.loadAll = ne.loadAll), typeof ne.maxMemoryUsage != "undefined" && (be.maxMemoryUsage = ne.maxMemoryUsage), typeof ne.maxRequests != "undefined" && (be.maxRequests = ne.maxRequests), typeof ne.requestOrder != "undefined" && (be.requestOrder = ne.requestOrder), typeof ne.maxScreenSpaceError != "undefined" && (be.maxScreenSpaceError = ne.maxScreenSpaceError), (ne.showLayers === false || Array.isArray(ne.showLayers) && ne.showLayers.indexOf(re) === -1) && (be.visible = false), new ModelViewLayer(be, null);
        });
        m.push(Te.catch(function(Re) {
          var ve;
          s.onError(Re);
          var Ce = new Matrix4(), Z = new Matrix4(), te = new Matrix4().copy(ROTATE_X_90_MATRIX), K = new Matrix4().copy(ROTATE_X_90_MATRIX_INVERSE), ye = new Matrix4().premultiply(Ce).premultiply(te), de = new Matrix4().getInverse(ye), xe = oe ? oe.slice(0, oe.lastIndexOf("/") + 1) : "", Ae;
          if (ne.viewerRequestVolume) {
            var me = isBoundingVolume(ne.viewerRequestVolume) ? ne.viewerRequestVolume : makeBoundingVolume(ne.viewerRequestVolume);
            me.applyMatrix4(de), Ae = me.toJson();
          }
          var ce = normalizeTilesetHeader({
            asset: {
              version: "0.0"
            },
            geometricError: 0,
            viewerRequestVolume: Ae,
            root: {
              geometricError: 0
            }
          }, xe), pe = new Tile3DModel(s, ce, {
            name: re,
            light: (ve = r.light) !== null && ve !== void 0 ? ve : false,
            type: j,
            upAxis: ie,
            url: oe,
            referer: oe,
            search: fe,
            fetcher: getFetcher(e),
            groundHeight: null,
            coordinateTransform: {
              localToEnuMatrix: K,
              enuToLocalMatrix: te,
              enuToEcefMatrix: Z,
              ecefToEnuMatrix: Ce,
              localToEcefMatrix: de,
              ecefToLocalMatrix: ye
            },
            onError: s.onError
          });
          return pe.matrix.copy(e.transform), pe.matrix.decompose(pe.position, pe.quaternion, pe.scale), pe.matrixWorldNeedsUpdate = true, (ne.showLayers === false || Array.isArray(ne.showLayers) && ne.showLayers.indexOf(re) === -1) && (pe.visible = false), new ModelViewLayer(pe, Re);
        }));
      }, b = 0, T = h.layers; b < T.length; b++) {
        var R = T[b];
        E(R);
      }
      if (!y && h.file) {
        var S = h.file, M = h.textureBase, w = h.textures, H = "fallback", L = "mesh", C = "Z", I = "", R = { name: H, type: L, upAxis: C, tileset: I }, _ = typeof r["3d-tiles"] == "function" ? r["3d-tiles"](R) : (c = r["3d-tiles"]) !== null && c !== void 0 ? c : {}, O = getExt(S) || "at3d", P = new Matrix4(), N = new Matrix4(), k = new Matrix4().copy(ROTATE_X_90_MATRIX), U = new Matrix4().copy(ROTATE_X_90_MATRIX_INVERSE);
        getEcefToEnuMatrixFromUpAxis(C, scratchVector3.setScalar(0), P), N.getInverse(P);
        var D = new Matrix4().premultiply(P).premultiply(k), q = new Matrix4().getInverse(D), z = void 0;
        if (_.viewerRequestVolume) {
          var Q = isBoundingVolume(_.viewerRequestVolume) ? _.viewerRequestVolume : makeBoundingVolume(_.viewerRequestVolume);
          Q.applyMatrix4(q), z = Q.toJson();
        }
        var G = normalizeTilesetHeader({
          asset: {
            version: "0.0"
          },
          geometricError: 0,
          root: {
            refine: "REPLACE",
            geometricError: 0,
            transform: D.toArray(),
            viewerRequestVolume: z,
            content: {
              uri: S
            },
            extras: (o = {}, o[O] = {
              textureBaseUri: M,
              textureArray: w,
              textureOptions: (f = r.textureOptions) !== null && f !== void 0 ? f : {}
            }, o)
          }
        }, ""), X = new Tile3DModel(this, G, {
          name: H,
          light: (d = r.light) !== null && d !== void 0 ? d : false,
          type: L,
          upAxis: C,
          url: I,
          referer: S,
          fetcher: getFetcher(e),
          groundHeight: null,
          coordinateTransform: {
            localToEnuMatrix: U,
            enuToLocalMatrix: k,
            enuToEcefMatrix: N,
            ecefToEnuMatrix: P,
            localToEcefMatrix: q,
            ecefToLocalMatrix: D
          },
          onError: this.onError
        });
        X.matrix.copy(e.transform), X.matrix.decompose(X.position, X.quaternion, X.scale), X.matrixWorldNeedsUpdate = true, (_.showLayers === false || Array.isArray(_.showLayers) && _.showLayers.indexOf(H) === -1) && (X.visible = false);
        var $ = new ModelViewLayer(X, null);
        m.push(Promise.resolve($));
      }
      return Promise.all(m).then(function(W) {
        for (var oe = 0, ie = W; oe < ie.length; oe++) {
          var re = ie[oe];
          if (s.disposed) {
            re.scene.dispose();
            continue;
          }
          s.viewLayers.push(re), s.add(re.scene);
        }
      });
    }, t.prototype.update = function(e, r, o) {
      if (this.children.length) {
        var s = this.loaded;
        this.refined = this.work !== null, this.refineProgress[0] = 0, this.refineProgress[1] = 0, this.loaded = this.work !== null;
        for (var u = 0, l = this.viewLayers; u < l.length; u++) {
          var c = l[u], f = c.scene;
          f && (this.work && (f.cacheCameras = this.cacheCameras, this.autoRefine === false ? f.needsRefined = false : isFristPersonMode(o) ? f.needsRefined = this.materialParameters.modelAlpha === 0 || this.materialParameters.modelAlpha === 1 : f.needsRefined = true, this.work.transform.equals(f.matrix) || (f.matrix.copy(this.work.transform), f.matrix.decompose(f.position, f.quaternion, f.scale), f.matrixWorldNeedsUpdate = true)), f.update(e, r, o), f.needsRender === true && (f.needsRender = false, this.needsRender = true), f.refined === false && (this.refined = false), this.refineProgress[0] += f.refineProgress[0], this.refineProgress[1] += f.refineProgress[1], f.loaded === false && (this.loaded = false));
        }
        this.bounding.makeEmpty();
        for (var d = 0, h = this.viewLayers; d < h.length; d++) {
          var c = h[d], f = c.scene;
          f && (f.boundingBox.isEmpty() || (scratchBoundingBox.copy(f.boundingBox).applyMatrix4(f.matrix), this.bounding.union(scratchBoundingBox)));
        }
        this.bounding.isEmpty() && this.bounding.copy(DEFAULT_BOUNDING), s === false && this.loaded === true && this.onLoad();
      } else
        this.work && !this.work.model ? (this.refined = true, this.refineProgress[0] = 0, this.refineProgress[1] = 0, this.loaded = true) : (this.refined = false, this.refineProgress[0] = 0, this.refineProgress[1] = 0, this.loaded = false), this.bounding.set(new Vector3(), new Vector3());
    }, t.prototype.dispose = function() {
      this.disposed = true;
      for (var e; e = this.children[0]; )
        e instanceof Tile3DModel && e.dispose(), this.remove(e);
    }, t;
  }(Object3D)
);
function createModels() {
  var n45 = new Box3(), t = omit(defaultPbmParameters, ["clippers", "shownFloorIndex", "brightness", "customShaders"]), e = Object.assign([], {
    bounding: n45,
    needsRender: false,
    refined: false,
    refineProgress: [0, 0],
    loaded: false,
    materialVersion: 0,
    cacheCameras: [],
    autoUpdate: true,
    intersectRaycaster: function(r, o, s) {
      s === void 0 && (s = true);
      var u;
      if (e.length === 1)
        u = e[0].intersectRaycaster(r, o, s);
      else if (e.length === 0)
        u = [];
      else {
        u = [];
        for (var l = 0, c = e; l < c.length; l++) {
          var f = c[l];
          if (f.visible) {
            var d = f.intersectRaycaster(r, o, false);
            d.length && u.push.apply(u, d);
          }
        }
        s && u.sort(function(h, v) {
          return h.distance - v.distance;
        });
      }
      return u;
    },
    setMaterial: function(r) {
      var o = updatePBMParameters(t, r);
      o && (e.materialVersion++, e.needsRender = true);
    },
    getMaterial: function() {
      return __assign({}, t);
    },
    resetBrightness: function() {
      for (var r = 0, o = e; r < o.length; r++) {
        var s = o[r];
        s.setMaterial({ brightness: 1 });
      }
    },
    update: function(r, o, s) {
      e.refined = e.length > 0, e.loaded = e.length > 0, e.refineProgress[0] = 0, e.refineProgress[1] = 0, n45.makeEmpty();
      for (var u = 0, l = e.cacheCameras; u < l.length; u++) {
        var c = l[u];
        c.updateMatrixWorld(true), c.updateProjectionMatrix();
      }
      for (var f = 0, d = 0, h = e; d < h.length; d++) {
        for (var v = h[d], A = 0, g = v.viewLayers; A < g.length; A++) {
          var p = g[A];
          p.scene.modelIndex = f++;
        }
        v.setMaterial(t), v.cacheCameras = e.cacheCameras, v.autoRefine = this.autoUpdate, v.update(r, o, s), v.needsRender === true && (e.needsRender = true, v.needsRender = false), v.refined === false && (e.refined = false), e.refineProgress[0] += v.refineProgress[0], e.refineProgress[1] += v.refineProgress[1], v.loaded === false && (e.loaded = false), n45.union(v.bounding);
      }
      for (var y = 0, m = e; y < m.length; y++)
        for (var v = m[y], E = 0, b = v.viewLayers; E < b.length; E++) {
          var p = b[E];
          p.scene.modelsLoaded = e.loaded;
        }
      n45.isEmpty() && n45.copy(DEFAULT_BOUNDING);
    }
  });
  return e;
}
var easeOut$2 = function(n45) {
  return n45 * (2 - n45);
};
var sharedGeometry2$2 = function() {
  var n45 = new Float32Array([
    -0.18,
    0,
    -0.18,
    0.18,
    0,
    -0.18,
    -0.18,
    0,
    0.18,
    0.18,
    0,
    0.18
  ]), t = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    1
  ]), e = new Uint8Array([
    0,
    2,
    1,
    2,
    3,
    1
  ]), r = new BufferGeometry();
  return r.setAttribute("position", new BufferAttribute(n45, 3)), r.setAttribute("uv", new BufferAttribute(t, 2)), r.setIndex(new BufferAttribute(e, 1)), r;
}();
var vertexShader$4 = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #include <logdepthbuf_vertex>
}
`;
var fragmentShader$4 = `
uniform vec3 baseColor;
uniform float circleScale;
uniform float ringScale;
uniform float ringOpacity;
uniform float loadingAngle;
uniform float loadingOpacity;
uniform float progress;
uniform float progressOpacity;
uniform float expand0;
uniform float expand1;
uniform float expandOpacity;
uniform float opacity;
uniform float tapScale;
uniform float tapOpacity;
uniform float disable;
varying vec2 vUv;

#include <common>
#include <logdepthbuf_pars_fragment>
#define SMOOTH_DIST 0.017
#define CENTER vec2(0.5, 0.5)

float inside(float innerDist) {
  float dist = length(CENTER - vUv);
  return smoothstep(innerDist, innerDist + SMOOTH_DIST, dist);
}
float outside(float outerDist) {
  float dist = length(CENTER - vUv);
  return 1.0 - smoothstep(outerDist - SMOOTH_DIST, outerDist, dist);
}

vec4 create_circle() {
  float dist = length(CENTER - vUv);
  float gradient = clamp(0.8 + abs(dot(normalize(vec2(1.0, -1.0)), vUv - CENTER)) * 1.5, 0.0, 1.0);
  return vec4(1.0, 1.0, 1.0, gradient * tapOpacity * inside(0.15 * circleScale * tapScale) * outside(0.234 * circleScale * tapScale));
}

vec4 create_disable() {
  float dist = length(CENTER - vUv);
  return vec4(1.0, 1.0, 1.0, 0.5 * tapOpacity * outside(0.32 * circleScale * tapScale));
}

vec4 create_ring() {
  float gradient = clamp(0.5 + abs(dot(normalize(vec2(1.0, 1.0)), vUv - CENTER)), 0.0, 1.0);
  return vec4(1.0, 1.0, 1.0, gradient * tapOpacity * ringOpacity * inside(0.27 * ringScale * tapScale) * outside(0.32 * ringScale * tapScale));
}

vec4 create_loading() {
  float angle = PI - atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  angle = mod(angle + loadingAngle, PI2);
  float gradient = (1.0 - smoothstep(0.0, PI2, angle)) * 0.4 + 0.1;
  return vec4(1.0, 1.0, 1.0, gradient * tapOpacity * loadingOpacity * inside(0.208 * circleScale * tapScale) * outside(0.3 * circleScale * tapScale));
}

vec4 create_progress() {
  float angle = PI + atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  float bar = (1.0 - step(progress * PI2, angle)) * 0.5;
  return vec4(1.0, 1.0, 1.0, bar * tapOpacity * progressOpacity * inside(0.208 * circleScale * tapScale) * outside(0.3 * circleScale * tapScale));
}

vec4 create_expand0() {
  float width = 0.2;
  float radius = 0.2 + (0.43 - 0.2) * expand0;
  float dist = length(CENTER - vUv);
  float gradient = (1.0 - clamp((radius - dist) / width, 0.0, 1.0)) * 0.8 * clamp((1.0 - abs(expand0 - 0.5) * 2.0) * 1.2, 0.0, 1.0);
  return vec4(1.0, 1.0, 1.0, gradient * expandOpacity * outside(radius));
}

vec4 create_expand1() {
  float width = 0.2;
  float radius = 0.2 + (0.43 - 0.2) * expand1;
  float dist = length(CENTER - vUv);
  float gradient = (1.0 - clamp((radius - dist) / width, 0.0, 1.0)) * 0.8 * clamp((1.0 - abs(expand1 - 0.5) * 2.0) * 1.2, 0.0, 1.0);
  return vec4(1.0, 1.0, 1.0, gradient * expandOpacity * outside(radius));
}

void main() {
  #include <logdepthbuf_fragment>
  gl_FragColor = vec4(1.0, 1.0, 1.0, 0);

  vec4 expand1Color = create_expand1();
  gl_FragColor = mix(gl_FragColor, expand1Color, expand1Color.a);

  vec4 expand0Color = create_expand0();
  gl_FragColor = mix(gl_FragColor, expand0Color, expand0Color.a);

  vec4 progressColor = create_progress();
  gl_FragColor = mix(gl_FragColor, progressColor, progressColor.a);

  vec4 loadingColor = create_loading();
  gl_FragColor = mix(gl_FragColor, loadingColor, loadingColor.a);

  vec4 circleColor = create_circle();
  gl_FragColor = mix(gl_FragColor, circleColor, circleColor.a);

  vec4 ringColor = create_ring();
  gl_FragColor = mix(gl_FragColor, ringColor, ringColor.a);

  gl_FragColor = mix(gl_FragColor, create_disable(), disable);

  gl_FragColor = vec4(gl_FragColor.rgb * baseColor, gl_FragColor.a * opacity * opacity);
}
`;
var PanoCircleMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      e === void 0 && (e = {});
      var r, o, s = n45.call(this) || this, u = (r = e.color) !== null && r !== void 0 ? r : 16777215, l = (o = e.scale) !== null && o !== void 0 ? o : 1;
      return s.progress = 0, s.opacity = 0, s.loading = false, s.current = false, s.disabled = false, s.currentMotion = new Motion({ progress: 0 }), s.ringMotion = new Motion({ scale: 1, opacity: 1 }), s.tapMotion = new Motion({ scale: 1, opacity: 1 }), s.loadingOpacityMotion = new Motion({ opacity: 0 }), s.progressMotion = new Motion({ progress: 0 }), s.progressOpacityMotion = new Motion({ opacity: 0 }), s.opacityMotion = new Motion({ opacity: 0 }), s.disableMotion = new Motion({ progress: 0 }), s.panoMesh = new Mesh(sharedGeometry2$2, new ShaderMaterial({
        blending: CustomBlending,
        blendSrc: SrcAlphaFactor,
        blendDst: OneMinusSrcAlphaFactor,
        blendSrcAlpha: OneFactor,
        blendDstAlpha: OneMinusSrcAlphaFactor,
        depthWrite: false,
        vertexShader: vertexShader$4,
        fragmentShader: fragmentShader$4,
        uniforms: {
          baseColor: {
            value: new Color(u)
          },
          circleScale: {
            value: 1
          },
          ringScale: {
            value: 1
          },
          ringOpacity: {
            value: 1
          },
          loadingAngle: {
            value: 0
          },
          loadingOpacity: {
            value: 0
          },
          progress: {
            value: 0
          },
          progressOpacity: {
            value: 0
          },
          expand0: {
            value: 0
          },
          expand1: {
            value: 0
          },
          expandOpacity: {
            value: 0
          },
          opacity: {
            value: 0
          },
          tapScale: {
            value: 1
          },
          tapOpacity: {
            value: 1
          },
          disable: {
            value: 0
          }
        }
      })), s.renderOrder = -2, s.panoMesh.renderOrder = -2, s.panoMesh.position.y = 4e-3, s.panoMesh.scale.set(l, 1, l), s.add(s.panoMesh), s.currentStartTime = now(), s.needsRender = true, s;
    }
    return t.prototype.setProgress = function(e) {
      var r = this;
      this.setDisabled(false), this.setLoading(false), this.progress !== e && (e = clamp$1(e, 0, 1), this.tapMotion.ended && (this.progress === 0 && this.progressOpacityMotion.set({ opacity: 1 }, 500).catch(noop$1), e === 0 ? this.progressOpacityMotion.set({ opacity: 0 }, 500).catch(noop$1).then(function() {
        r.progressMotion.set({ progress: 0 }, 0).catch(noop$1);
      }) : this.progressMotion.set({ progress: clamp$1(e * 1.2, 0, 1) }, 100).catch(noop$1)), this.progress = e);
    }, t.prototype.setOpacity = function(e) {
      this.opacity !== e && (this.opacity = e = clamp$1(e, 0, 1), this.opacityMotion.set({ opacity: e }, 200).catch(noop$1));
    }, t.prototype.setCurrent = function(e) {
      this.current !== e && (this.currentMotion.set({ progress: e ? 1 : 0 }, 2e3).catch(noop$1), this.current = e, this.current === true && (this.currentStartTime = now()));
    }, t.prototype.setLoading = function(e) {
      this.loading !== e && (this.loading = e, this.disabled === true && this.setDisabled(false), this.loadingOpacityMotion.set({ opacity: e ? 1 : 0 }, 500).catch(noop$1));
    }, t.prototype.setDisabled = function(e) {
      this.disabled !== e && (this.disabled = e, this.loading === true && this.setLoading(false), this.disableMotion.set({ progress: e ? 1 : 0 }, 500).catch(noop$1));
    }, t.prototype.tap = function() {
      var e = this;
      if (!this.tapMotion.ended)
        return Promise.resolve();
      var r = [
        { progress: 0, value: { scale: 1, opacity: 1 } },
        { progress: 0.3, value: { scale: 0.85, opacity: 0.5 } },
        { progress: 0.8, value: { scale: 1.05, opacity: 0.6 } },
        { progress: 1, value: { scale: 1, opacity: 1 } }
      ];
      return this.progressOpacityMotion.set({ opacity: 0 }, 0).catch(noop$1), this.progressMotion.set({ progress: 0 }, 0).catch(noop$1), this.tapMotion.setKeyframes(r, 600).then(function() {
        e.progressOpacityMotion.set({ opacity: e.progress > 0 ? 1 : 0 }, 300).catch(noop$1), e.progressMotion.set({ progress: e.progress }, 120).catch(noop$1);
      }).catch(noop$1);
    }, t.prototype.updateTime = function(e, r) {
      if (!this.progressMotion.ended) {
        this.progressMotion.update(e);
        var o = this.progressMotion.value.progress;
        this.panoMesh.material.uniforms.progress.value = o, this.needsRender = true;
      }
      if (!this.progressOpacityMotion.ended) {
        this.progressOpacityMotion.update(e);
        var s = this.progressOpacityMotion.value.opacity;
        this.panoMesh.material.uniforms.progressOpacity.value = s, this.needsRender = true;
      }
      if (!this.opacityMotion.ended) {
        this.opacityMotion.update(e);
        var s = this.opacityMotion.value.opacity;
        this.panoMesh.material.uniforms.opacity.value = s, this.needsRender = true;
      }
      if (this.visible = this.opacityMotion.value.opacity !== 0, (!this.loadingOpacityMotion.ended || this.loadingOpacityMotion.value.opacity > 0) && (this.loadingOpacityMotion.update(e), this.panoMesh.material.uniforms.loadingOpacity.value = this.loadingOpacityMotion.value.opacity, this.panoMesh.material.uniforms.loadingAngle.value = e / 120 % (Math.PI * 2), this.needsRender = true), this.tapMotion.ended || (this.tapMotion.update(e), this.panoMesh.material.uniforms.tapOpacity.value = this.tapMotion.value.opacity, this.panoMesh.material.uniforms.tapScale.value = this.tapMotion.value.scale, this.needsRender = true), this.current || !this.currentMotion.ended) {
        this.currentMotion.update(e), this.panoMesh.material.uniforms.expandOpacity.value = this.currentMotion.value.progress;
        {
          var u = (e - this.currentStartTime - 1500) / 2e3;
          if (u % 5 < 2) {
            var l = 1 + Math.sin(Math.PI * u) / 25 * this.currentMotion.value.progress;
            this.panoMesh.material.uniforms.circleScale.value = l, this.needsRender = true;
          }
        }
        {
          var c = (e - this.currentStartTime - 1500) / 2e3;
          if (c % 5 < 2) {
            var f = c % 1;
            this.panoMesh.material.uniforms.expand0.value = easeOut$2(f) * this.currentMotion.value.progress, this.needsRender = true;
          }
        }
        {
          var d = (e - this.currentStartTime - 1e3) / 2e3;
          if (d % 5 < 2) {
            var f = d % 1;
            this.panoMesh.material.uniforms.expand1.value = easeOut$2(f) * this.currentMotion.value.progress, this.needsRender = true;
          }
        }
      }
      if (this.currentMotion.value.progress > 0.2 && this.progress === 0 && this.loading === false) {
        var h = (e - this.currentStartTime - 1e3) / 2e3;
        h % 5 < 2 ? this.ringMotion.getTargetKeyframe().value.scale !== 0.8 && this.ringMotion.set({ scale: 0.8, opacity: 0 }, 600).catch(noop$1) : this.ringMotion.getTargetKeyframe().value.scale !== 1 && this.ringMotion.set({ scale: 1, opacity: 1 }, 600).catch(noop$1);
      } else
        this.ringMotion.getTargetKeyframe().value.scale !== 1 && this.ringMotion.set({ scale: 1, opacity: 1 }, 600).catch(noop$1);
      if (!this.ringMotion.ended) {
        var v = this.ringMotion.value, l = v.scale, s = v.opacity;
        this.ringMotion.update(e), this.panoMesh.material.uniforms.ringScale.value = l, this.panoMesh.material.uniforms.ringOpacity.value = s, this.needsRender = true;
      }
      if (!this.disableMotion.ended) {
        var o = this.disableMotion.value.progress;
        this.disableMotion.update(e), this.panoMesh.material.uniforms.disable.value = o, this.needsRender = true;
      }
    }, t.prototype.dispose = function() {
      this.ringMotion.dispose(), this.tapMotion.dispose(), this.progressMotion.dispose(), this.progressOpacityMotion.dispose(), this.opacityMotion.dispose(), this.currentMotion.dispose(), this.panoMesh.material.dispose();
    }, t;
  }(Object3D)
);
var easeOut$1 = function(n45) {
  return n45 * (2 - n45);
};
var sharedGeometry2$1 = function() {
  var n45 = new Float32Array([
    -0.18,
    0,
    -0.18,
    0.18,
    0,
    -0.18,
    -0.18,
    0,
    0.18,
    0.18,
    0,
    0.18
  ]), t = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    1
  ]), e = new Uint8Array([
    0,
    2,
    1,
    2,
    3,
    1
  ]), r = new BufferGeometry();
  return r.setAttribute("position", new BufferAttribute(n45, 3)), r.setAttribute("uv", new BufferAttribute(t, 2)), r.setIndex(new BufferAttribute(e, 1)), r;
}();
var vertexShader$3 = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #include <logdepthbuf_vertex>
}
`;
var fragmentShader$3 = `
uniform vec3 baseColor;
uniform float circleScale;
uniform float circleOpacity;
uniform float loadingAngle;
uniform float loadingOpacity;
uniform float progress;
uniform float progressOpacity;
uniform float expand0;
uniform float expand1;
uniform float expandOpacity;
uniform float opacity;
uniform float tapScale;
uniform float tapOpacity;
uniform float disable;
varying vec2 vUv;

#include <common>
#include <logdepthbuf_pars_fragment>
#define SMOOTH_DIST 0.017
#define CENTER vec2(0.5, 0.5)

float inside(float innerDist) {
  float dist = length(CENTER - vUv);
  return smoothstep(innerDist, innerDist + SMOOTH_DIST, dist);
}
float outside(float outerDist) {
  float dist = length(CENTER - vUv);
  return 1.0 - smoothstep(outerDist - SMOOTH_DIST, outerDist, dist);
}

vec4 create_circle() {
  float dist = length(CENTER - vUv);
  return vec4(1.0, 1.0, 1.0, 0.8 * circleOpacity * tapOpacity * inside(0.2 * circleScale * tapScale) * outside(0.3 * circleScale * tapScale));
}

vec4 create_disable() {
  float dist = length(CENTER - vUv);
  return vec4(1.0, 1.0, 1.0, 0.5 * tapOpacity * outside(0.32 * circleScale * tapScale));
}

vec4 create_loading() {
  float angle = PI - atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  angle = mod(angle + loadingAngle, PI2);
  float gradient = (1.0 - smoothstep(0.0, PI2, angle)) * 0.9 + 0.1;
  return vec4(1.0, 1.0, 1.0, gradient * tapOpacity * loadingOpacity * inside(0.2 * circleScale * tapScale) * outside(0.3 * circleScale * tapScale));
}

vec4 create_progress() {
  float angle = PI + atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  float bar = (1.0 - step(progress * PI2, angle)) * 0.7;
  return vec4(1.0, 1.0, 1.0, bar * tapOpacity * progressOpacity * inside(0.2 * circleScale * tapScale) * outside(0.3 * circleScale * tapScale));
}

vec4 create_expand0() {
  float width = 0.2;
  float radius = 0.25 + (0.5 - 0.25) * expand0;
  float dist = length(CENTER - vUv);
  float gradient = (1.0 - clamp((radius - dist) / width, 0.0, 1.0)) * 0.8 * clamp((1.0 - abs(expand0 - 0.5) * 2.0) * 1.2, 0.0, 1.0);
  return vec4(1.0, 1.0, 1.0, gradient * expandOpacity * outside(radius));
}

vec4 create_expand1() {
  float width = 0.2;
  float radius = 0.25 + (0.48 - 0.25) * expand1;
  float dist = length(CENTER - vUv);
  float gradient = (1.0 - clamp((radius - dist) / width, 0.0, 1.0)) * 0.8 * clamp((1.0 - abs(expand1 - 0.5) * 2.0) * 1.2, 0.0, 1.0);
  return vec4(1.0, 1.0, 1.0, gradient * expandOpacity * outside(radius));
}

void main() {
  #include <logdepthbuf_fragment>
  gl_FragColor = vec4(1.0, 1.0, 1.0, 0);

  vec4 expand1Color = create_expand1();
  gl_FragColor = mix(gl_FragColor, expand1Color, expand1Color.a);

  vec4 expand0Color = create_expand0();
  gl_FragColor = mix(gl_FragColor, expand0Color, expand0Color.a);

  vec4 circleColor = create_circle();
  gl_FragColor = mix(gl_FragColor, circleColor, circleColor.a);

  vec4 progressColor = create_progress();
  gl_FragColor = mix(gl_FragColor, progressColor, progressColor.a);

  vec4 loadingColor = create_loading();
  gl_FragColor = mix(gl_FragColor, loadingColor, loadingColor.a);

  gl_FragColor = mix(gl_FragColor, create_disable(), disable);

  gl_FragColor = vec4(gl_FragColor.rgb * baseColor, gl_FragColor.a * opacity * opacity);
}
`;
var PanoCircleMeshSolid = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      e === void 0 && (e = {});
      var r, o, s = n45.call(this) || this, u = (r = e.color) !== null && r !== void 0 ? r : 16777215, l = (o = e.scale) !== null && o !== void 0 ? o : 1;
      return s.progress = 0, s.opacity = 0, s.loading = false, s.current = false, s.disabled = false, s.currentMotion = new Motion({ progress: 0 }), s.tapMotion = new Motion({ scale: 1, opacity: 1 }), s.loadingOpacityMotion = new Motion({ opacity: 0 }), s.progressMotion = new Motion({ progress: 0 }), s.progressOpacityMotion = new Motion({ opacity: 0 }), s.opacityMotion = new Motion({ opacity: 0 }), s.disableMotion = new Motion({ progress: 0 }), s.panoMesh = new Mesh(sharedGeometry2$1, new ShaderMaterial({
        blending: CustomBlending,
        blendSrc: SrcAlphaFactor,
        blendDst: OneMinusSrcAlphaFactor,
        blendSrcAlpha: OneFactor,
        blendDstAlpha: OneMinusSrcAlphaFactor,
        depthWrite: false,
        vertexShader: vertexShader$3,
        fragmentShader: fragmentShader$3,
        uniforms: {
          baseColor: {
            value: new Color(u)
          },
          circleScale: {
            value: 1
          },
          circleOpacity: {
            value: 1
          },
          loadingAngle: {
            value: 0
          },
          loadingOpacity: {
            value: 0
          },
          progress: {
            value: 0
          },
          progressOpacity: {
            value: 0
          },
          expand0: {
            value: 0
          },
          expand1: {
            value: 0
          },
          expandOpacity: {
            value: 0
          },
          opacity: {
            value: 0
          },
          tapScale: {
            value: 1
          },
          tapOpacity: {
            value: 1
          },
          disable: {
            value: 0
          }
        }
      })), s.renderOrder = -2, s.panoMesh.renderOrder = -2, s.panoMesh.position.y = 4e-3, s.panoMesh.scale.set(l, 1, l), s.add(s.panoMesh), s.currentStartTime = now(), s.needsRender = true, s;
    }
    return t.prototype.setProgress = function(e) {
      var r = this;
      this.setDisabled(false), this.setLoading(false), this.progress !== e && (e = clamp$1(e, 0, 1), this.tapMotion.ended && (this.progress === 0 && this.progressOpacityMotion.set({ opacity: 1 }, 500).catch(noop$1), e === 0 ? this.progressOpacityMotion.set({ opacity: 0 }, 500).catch(noop$1).then(function() {
        r.progressMotion.set({ progress: 0 }, 0).catch(noop$1);
      }) : this.progressMotion.set({ progress: clamp$1(e * 1.2, 0, 1) }, 100).catch(noop$1)), this.progress = e);
    }, t.prototype.setOpacity = function(e) {
      this.opacity !== e && (this.opacity = e = clamp$1(e, 0, 1), this.opacityMotion.set({ opacity: e }, 200).catch(noop$1));
    }, t.prototype.setCurrent = function(e) {
      this.current !== e && (this.currentMotion.set({ progress: e ? 1 : 0 }, 2e3).catch(noop$1), this.current = e, this.current === true && (this.currentStartTime = now()));
    }, t.prototype.setLoading = function(e) {
      this.loading !== e && (this.loading = e, this.disabled === true && this.setDisabled(false), this.loadingOpacityMotion.set({ opacity: e ? 1 : 0 }, 500).catch(noop$1));
    }, t.prototype.setDisabled = function(e) {
      this.disabled !== e && (this.disabled = e, this.loading === true && this.setLoading(false), this.disableMotion.set({ progress: e ? 1 : 0 }, 500).catch(noop$1));
    }, t.prototype.tap = function() {
      var e = this;
      if (!this.tapMotion.ended)
        return Promise.resolve();
      var r = [
        { progress: 0, value: { scale: 1, opacity: 1 } },
        { progress: 0.3, value: { scale: 0.85, opacity: 0.5 } },
        { progress: 0.8, value: { scale: 1.05, opacity: 0.6 } },
        { progress: 1, value: { scale: 1, opacity: 1 } }
      ];
      return this.progressOpacityMotion.set({ opacity: 0 }, 0).catch(noop$1), this.progressMotion.set({ progress: 0 }, 0).catch(noop$1), this.tapMotion.setKeyframes(r, 600).then(function() {
        e.progressOpacityMotion.set({ opacity: e.progress > 0 ? 1 : 0 }, 300).catch(noop$1), e.progressMotion.set({ progress: e.progress }, 120).catch(noop$1);
      }).catch(noop$1);
    }, t.prototype.updateTime = function(e, r) {
      if (!this.progressMotion.ended) {
        this.progressMotion.update(e);
        var o = this.progressMotion.value.progress;
        this.panoMesh.material.uniforms.progress.value = o, this.needsRender = true;
      }
      if (!this.progressOpacityMotion.ended) {
        this.progressOpacityMotion.update(e);
        var s = this.progressOpacityMotion.value.opacity;
        this.panoMesh.material.uniforms.progressOpacity.value = s, this.needsRender = true;
      }
      if (!this.opacityMotion.ended) {
        this.opacityMotion.update(e);
        var s = this.opacityMotion.value.opacity;
        this.panoMesh.material.uniforms.opacity.value = s, this.needsRender = true;
      }
      if (this.visible = this.opacityMotion.value.opacity !== 0, (!this.loadingOpacityMotion.ended || this.loadingOpacityMotion.value.opacity > 0) && (this.loadingOpacityMotion.update(e), this.panoMesh.material.uniforms.loadingOpacity.value = this.loadingOpacityMotion.value.opacity, this.panoMesh.material.uniforms.loadingAngle.value = e / 120 % (Math.PI * 2), this.needsRender = true), this.tapMotion.ended || (this.tapMotion.update(e), this.panoMesh.material.uniforms.tapOpacity.value = this.tapMotion.value.opacity, this.panoMesh.material.uniforms.tapScale.value = this.tapMotion.value.scale, this.needsRender = true), this.panoMesh.material.uniforms.circleOpacity.value = Math.max(0.6, 1 - Math.max(this.loadingOpacityMotion.value.opacity, this.progressOpacityMotion.value.opacity)), this.current || !this.currentMotion.ended) {
        this.currentMotion.update(e), this.panoMesh.material.uniforms.expandOpacity.value = this.currentMotion.value.progress;
        {
          var u = (e - this.currentStartTime - 1500) / 2e3;
          if (u % 5 < 2) {
            var l = 1 + Math.sin(Math.PI * u) / 25 * this.currentMotion.value.progress;
            this.panoMesh.material.uniforms.circleScale.value = l, this.needsRender = true;
          }
        }
        {
          var c = (e - this.currentStartTime - 1500) / 2e3;
          if (c % 5 < 2) {
            var f = c % 1;
            this.panoMesh.material.uniforms.expand0.value = easeOut$1(f) * this.currentMotion.value.progress, this.needsRender = true;
          }
        }
        {
          var d = (e - this.currentStartTime - 1e3) / 2e3;
          if (d % 5 < 2) {
            var f = d % 1;
            this.panoMesh.material.uniforms.expand1.value = easeOut$1(f) * this.currentMotion.value.progress, this.needsRender = true;
          }
        }
      }
      if (!this.disableMotion.ended) {
        var o = this.disableMotion.value.progress;
        this.disableMotion.update(e), this.panoMesh.material.uniforms.disable.value = o, this.needsRender = true;
      }
    }, t.prototype.dispose = function() {
      this.tapMotion.dispose(), this.progressMotion.dispose(), this.progressOpacityMotion.dispose(), this.opacityMotion.dispose(), this.currentMotion.dispose(), this.panoMesh.material.dispose();
    }, t;
  }(Object3D)
);
var easeOut = function(n45) {
  return n45 * (2 - n45);
};
var sharedGeometry2 = function() {
  var n45 = new Float32Array([
    -0.18,
    0,
    -0.18,
    0.18,
    0,
    -0.18,
    -0.18,
    0,
    0.18,
    0.18,
    0,
    0.18
  ]), t = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    1
  ]), e = new Uint8Array([
    0,
    2,
    1,
    2,
    3,
    1
  ]), r = new BufferGeometry();
  return r.setAttribute("position", new BufferAttribute(n45, 3)), r.setAttribute("uv", new BufferAttribute(t, 2)), r.setIndex(new BufferAttribute(e, 1)), r;
}();
var vertexShader$2 = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #include <logdepthbuf_vertex>
}
`;
var fragmentShader$2 = `
#if defined(USE_MAP)
uniform sampler2D map;
uniform float mapAlpha;
#endif
#if defined(USE_BORDER)
uniform float borderWidth;
uniform vec3 borderColor;
#endif
uniform vec3 baseColor;
uniform float circleScale;
uniform float circleOpacity;
uniform float loadingAngle;
uniform float loadingOpacity;
uniform float progress;
uniform float progressOpacity;
uniform float expand0;
uniform float expand1;
uniform float expandOpacity;
uniform float opacity;
uniform float tapScale;
uniform float tapOpacity;
uniform float disable;
varying vec2 vUv;

#include <common>
#include <logdepthbuf_pars_fragment>
#define SMOOTH_DIST 0.017
#define CENTER vec2(0.5, 0.5)

float inside(float innerDist) {
  float dist = length(CENTER - vUv);
  return smoothstep(innerDist, innerDist + SMOOTH_DIST, dist);
}
float outside(float outerDist) {
  float dist = length(CENTER - vUv);
  return 1.0 - smoothstep(outerDist - SMOOTH_DIST, outerDist, dist);
}

vec4 create_circle() {
  float dist = length(CENTER - vUv);
  float radius = 0.3 * circleScale * tapScale;
  #if defined(USE_MAP)
    float delta = radius / 0.5;
    vec2 deltaUv = (vUv - CENTER) / delta + CENTER;
    vec4 image = texture2D(map, deltaUv);
    image.a = image.a * mapAlpha;
    #if defined(USE_COLOR)
    image = vec4(baseColor, 1.0) * image;
    #endif
  #endif
  #if defined(USE_REVERSE)
    image = vec4(baseColor, 1.0 - image.a);
  #else
    #if defined(USE_BORDER)
      float borderDist = clamp(borderWidth, 0.0, 1.0);
      float clipAlpha = inside(radius - borderDist * radius);
      float gradient = clamp(borderWidth * 2.0 + abs(dot(normalize(vec2(1.0, -1.0)), vUv - CENTER)), 0.0, 1.0);
      vec4 borderColor = vec4(borderColor, clipAlpha * gradient);
      image = mix(borderColor, image, image.a);
    #endif
  #endif
  return vec4(image.rgb, image.a * circleOpacity * tapOpacity * outside(radius));
}

vec4 create_disable() {
  float dist = length(CENTER - vUv);
  return vec4(baseColor, 0.5 * tapOpacity * outside(0.32 * circleScale * tapScale));
}

vec4 create_loading() {
  float angle = PI - atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  angle = mod(angle + loadingAngle, PI2);
  float gradient = (1.0 - smoothstep(0.0, PI2, angle)) * 0.9 + 0.1;
  float radius = 0.3 * circleScale * tapScale;
  float inner = inside(radius - 0.2 * radius);
  #if defined(USE_BORDER)
    float borderDist = clamp(borderWidth, 0.0, 1.0);
    inner = inside(radius - borderDist * radius);
  #endif
  return vec4(baseColor, gradient * tapOpacity * loadingOpacity * inner * outside(radius));
}

vec4 create_progress() {
  float angle = PI + atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  float bar = (1.0 - step(progress * PI2, angle)) * 0.7;
  float radius = 0.3 * circleScale * tapScale;
  float inner = inside(radius - 0.2 * radius);
  #if defined(USE_BORDER)
    float borderDist = clamp(borderWidth, 0.0, 1.0);
    inner = inside(radius - borderDist * radius);
  #endif
  return vec4(baseColor, bar * tapOpacity * progressOpacity * inner * outside(radius));
}

vec4 create_expand0() {
  float width = 0.2;
  float radius = 0.25 + (0.5 - 0.25) * expand0;
  float dist = length(CENTER - vUv);
  float gradient = (1.0 - clamp((radius - dist) / width, 0.0, 1.0)) * 0.8 * clamp((1.0 - abs(expand0 - 0.5) * 2.0) * 1.2, 0.0, 1.0);
  return vec4(baseColor, gradient * expandOpacity * outside(radius));
}

vec4 create_expand1() {
  float width = 0.2;
  float radius = 0.25 + (0.48 - 0.25) * expand1;
  float dist = length(CENTER - vUv);
  float gradient = (1.0 - clamp((radius - dist) / width, 0.0, 1.0)) * 0.8 * clamp((1.0 - abs(expand1 - 0.5) * 2.0) * 1.2, 0.0, 1.0);
  return vec4(baseColor, gradient * expandOpacity * outside(radius));
}

void main() {
  #include <logdepthbuf_fragment>
  gl_FragColor = vec4(baseColor, 0);

  vec4 expand1Color = create_expand1();
  gl_FragColor = mix(gl_FragColor, expand1Color, expand1Color.a);

  vec4 expand0Color = create_expand0();
  gl_FragColor = mix(gl_FragColor, expand0Color, expand0Color.a);

  vec4 circleColor = create_circle();
  gl_FragColor = mix(gl_FragColor, circleColor, circleColor.a);

  vec4 progressColor = create_progress();
  gl_FragColor = mix(gl_FragColor, progressColor, progressColor.a);

  vec4 loadingColor = create_loading();
  gl_FragColor = mix(gl_FragColor, loadingColor, loadingColor.a);

  gl_FragColor = mix(gl_FragColor, create_disable(), disable);

  gl_FragColor = vec4(gl_FragColor.rgb, gl_FragColor.a * opacity);
}
`;
var PanoCircleMeshCustom = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      e === void 0 && (e = {});
      var r, o, s, u, l, c, f, d = n45.call(this) || this, h = (r = e.color) !== null && r !== void 0 ? r : 16777215, v = (o = e.scale) !== null && o !== void 0 ? o : 1, A = e.map, g = (s = e.mapAlpha) !== null && s !== void 0 ? s : 1, p = (u = e.mapUseColor) !== null && u !== void 0 ? u : false, y = (l = e.mapUseReverse) !== null && l !== void 0 ? l : false, m = (c = e.borderWidth) !== null && c !== void 0 ? c : 0.1, E = (f = e.borderColor) !== null && f !== void 0 ? f : 16777215;
      return d.progress = 0, d.opacity = 0, d.loading = false, d.current = false, d.disabled = false, d.currentMotion = new Motion({ progress: 0 }), d.tapMotion = new Motion({ scale: 1, opacity: 1 }), d.loadingOpacityMotion = new Motion({ opacity: 0 }), d.progressMotion = new Motion({ progress: 0 }), d.progressOpacityMotion = new Motion({ opacity: 0 }), d.opacityMotion = new Motion({ opacity: 0 }), d.disableMotion = new Motion({ progress: 0 }), d.panoMesh = new Mesh(sharedGeometry2, new ShaderMaterial({
        blending: CustomBlending,
        blendSrc: SrcAlphaFactor,
        blendDst: OneMinusSrcAlphaFactor,
        blendSrcAlpha: OneFactor,
        blendDstAlpha: OneMinusSrcAlphaFactor,
        depthWrite: false,
        vertexShader: vertexShader$2,
        fragmentShader: fragmentShader$2,
        defines: {
          USE_COLOR: p,
          USE_MAP: A !== void 0,
          USE_BORDER: m > 0,
          USE_REVERSE: y
        },
        uniforms: {
          baseColor: {
            value: new Color(h)
          },
          circleScale: {
            value: 1
          },
          circleOpacity: {
            value: 1
          },
          loadingAngle: {
            value: 0
          },
          loadingOpacity: {
            value: 0
          },
          progress: {
            value: 0
          },
          progressOpacity: {
            value: 0
          },
          expand0: {
            value: 0
          },
          expand1: {
            value: 0
          },
          expandOpacity: {
            value: 0
          },
          opacity: {
            value: 0
          },
          tapScale: {
            value: 1
          },
          tapOpacity: {
            value: 1
          },
          disable: {
            value: 0
          },
          map: {
            value: A
          },
          mapAlpha: {
            value: g
          },
          borderWidth: {
            value: m
          },
          borderColor: {
            value: new Color(E)
          }
        }
      })), d.renderOrder = -2, d.panoMesh.renderOrder = -2, d.panoMesh.position.y = 4e-3, d.panoMesh.scale.set(v, 1, v), d.add(d.panoMesh), d.currentStartTime = now(), d.needsRender = true, d;
    }
    return t.prototype.setProgress = function(e) {
      var r = this;
      this.setDisabled(false), this.setLoading(false), this.progress !== e && (e = clamp$1(e, 0, 1), this.tapMotion.ended && (this.progress === 0 && this.progressOpacityMotion.set({ opacity: 1 }, 500).catch(noop$1), e === 0 ? this.progressOpacityMotion.set({ opacity: 0 }, 500).catch(noop$1).then(function() {
        r.progressMotion.set({ progress: 0 }, 0).catch(noop$1);
      }) : this.progressMotion.set({ progress: clamp$1(e * 1.2, 0, 1) }, 100).catch(noop$1)), this.progress = e);
    }, t.prototype.setOpacity = function(e) {
      this.opacity !== e && (this.opacity = e = clamp$1(e, 0, 1), this.opacityMotion.set({ opacity: e }, 200).catch(noop$1));
    }, t.prototype.setCurrent = function(e) {
      this.current !== e && (this.currentMotion.set({ progress: e ? 1 : 0 }, 2e3).catch(noop$1), this.current = e, this.current === true && (this.currentStartTime = now()));
    }, t.prototype.setLoading = function(e) {
      this.loading !== e && (this.loading = e, this.disabled === true && this.setDisabled(false), this.loadingOpacityMotion.set({ opacity: e ? 1 : 0 }, 500).catch(noop$1));
    }, t.prototype.setDisabled = function(e) {
      this.disabled !== e && (this.disabled = e, this.loading === true && this.setLoading(false), this.disableMotion.set({ progress: e ? 1 : 0 }, 500).catch(noop$1));
    }, t.prototype.tap = function() {
      var e = this;
      if (!this.tapMotion.ended)
        return Promise.resolve();
      var r = [
        { progress: 0, value: { scale: 1, opacity: 1 } },
        { progress: 0.3, value: { scale: 0.85, opacity: 0.5 } },
        { progress: 0.8, value: { scale: 1.05, opacity: 0.6 } },
        { progress: 1, value: { scale: 1, opacity: 1 } }
      ];
      return this.progressOpacityMotion.set({ opacity: 0 }, 0).catch(noop$1), this.progressMotion.set({ progress: 0 }, 0).catch(noop$1), this.tapMotion.setKeyframes(r, 600).then(function() {
        e.progressOpacityMotion.set({ opacity: e.progress > 0 ? 1 : 0 }, 300).catch(noop$1), e.progressMotion.set({ progress: e.progress }, 120).catch(noop$1);
      }).catch(noop$1);
    }, t.prototype.updateTime = function(e, r) {
      if (!this.progressMotion.ended) {
        this.progressMotion.update(e);
        var o = this.progressMotion.value.progress;
        this.panoMesh.material.uniforms.progress.value = o, this.needsRender = true;
      }
      if (!this.progressOpacityMotion.ended) {
        this.progressOpacityMotion.update(e);
        var s = this.progressOpacityMotion.value.opacity;
        this.panoMesh.material.uniforms.progressOpacity.value = s, this.needsRender = true;
      }
      if (!this.opacityMotion.ended) {
        this.opacityMotion.update(e);
        var s = this.opacityMotion.value.opacity;
        this.panoMesh.material.uniforms.opacity.value = s, this.needsRender = true;
      }
      if (this.visible = this.opacityMotion.value.opacity !== 0, (!this.loadingOpacityMotion.ended || this.loadingOpacityMotion.value.opacity > 0) && (this.loadingOpacityMotion.update(e), this.panoMesh.material.uniforms.loadingOpacity.value = this.loadingOpacityMotion.value.opacity, this.panoMesh.material.uniforms.loadingAngle.value = e / 120 % (Math.PI * 2), this.needsRender = true), this.tapMotion.ended || (this.tapMotion.update(e), this.panoMesh.material.uniforms.tapOpacity.value = this.tapMotion.value.opacity, this.panoMesh.material.uniforms.tapScale.value = this.tapMotion.value.scale, this.needsRender = true), this.panoMesh.material.uniforms.circleOpacity.value = Math.max(0.6, 1 - Math.max(this.loadingOpacityMotion.value.opacity, this.progressOpacityMotion.value.opacity)), this.current || !this.currentMotion.ended) {
        this.currentMotion.update(e), this.panoMesh.material.uniforms.expandOpacity.value = this.currentMotion.value.progress;
        {
          var u = (e - this.currentStartTime - 1500) / 2e3;
          if (u % 5 < 2) {
            var l = u % 1;
            this.panoMesh.material.uniforms.expand0.value = easeOut(l) * this.currentMotion.value.progress, this.needsRender = true;
          }
        }
        {
          var c = (e - this.currentStartTime - 1e3) / 2e3;
          if (c % 5 < 2) {
            var l = c % 1;
            this.panoMesh.material.uniforms.expand1.value = easeOut(l) * this.currentMotion.value.progress, this.needsRender = true;
          }
        }
      }
      if (!this.disableMotion.ended) {
        var o = this.disableMotion.value.progress;
        this.disableMotion.update(e), this.panoMesh.material.uniforms.disable.value = o, this.needsRender = true;
      }
    }, t.prototype.dispose = function() {
      this.tapMotion.dispose(), this.progressMotion.dispose(), this.progressOpacityMotion.dispose(), this.opacityMotion.dispose(), this.currentMotion.dispose(), this.panoMesh.material.dispose();
    }, t;
  }(Object3D)
);
var sharedGeometry$2 = new CircleBufferGeometry(0.1, 16);
var vertexShader$1 = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #include <logdepthbuf_vertex>
}
`;
var fragmentShader$1 = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_fragment>

float smoothDist = 0.01;
void main() {
  #include <logdepthbuf_fragment>
  vec2 center = vec2(0.5, 0.5);
  float dist = length(center - vUv);
  float outerDist = 0.49;
  float innerDist = 0.29;

  float outside = 1.0 - smoothstep(outerDist - smoothDist, outerDist, dist);
  float inside = smoothstep(innerDist, innerDist + smoothDist, dist);

  vec4 bg = vec4(0.576, 0.635, 1.0, 0.3);
  float gradientAlpha = clamp(abs(dist - (outerDist + innerDist) / 2.0) / (outerDist - innerDist) * 1.5 + 0.1, 0.0, 1.0);
  vec4 gradient = vec4(1.0, 1.0, 1.0, gradientAlpha);

  gl_FragColor = mix(bg, gradient, gradient.a);

  gl_FragColor = vec4(gl_FragColor.rgb, gl_FragColor.a * outside * inside);
}
`;
var sharedMaterial = new ShaderMaterial({
  vertexShader: vertexShader$1,
  fragmentShader: fragmentShader$1,
  side: DoubleSide,
  blending: CustomBlending,
  blendSrc: SrcAlphaFactor,
  blendDst: OneMinusSrcAlphaFactor,
  blendSrcAlpha: OneFactor,
  blendDstAlpha: OneMinusSrcAlphaFactor,
  depthWrite: false
});
var IntersectMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      return e.ringMesh = new Mesh(sharedGeometry$2, sharedMaterial), e.ringMesh.position.z = 0.01, e.ringMesh.renderOrder = -2, e.add(e.ringMesh), e;
    }
    return t.prototype.dispose = function() {
      this.remove(this.ringMesh);
    }, t;
  }(Object3D)
);
function isSimilarValue(n45, t, e) {
  var r = Math.abs(n45 - t);
  return r < 1e-3 || typeof e != "undefined" && Math.abs(e - r) < 1e-3;
}
function notSimilarValue(n45, t, e) {
  return !isSimilarValue(n45, t, e);
}
function isSimilarVector3(n45, t) {
  return n45.distanceTo(t) < 1e-3;
}
function notSimilarVector3(n45, t) {
  return !isSimilarVector3(n45, t);
}
var DEFAULT_OFFSET_VECTOR = new Vector3(0, 0, 0);
var BoundingMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      r === void 0 && (r = DEFAULT_OFFSET_VECTOR);
      var o = this, s = new BoxBufferGeometry(e.max.x - e.min.x + r.x * 2, e.max.y - e.min.y + r.y * 2, e.max.z - e.min.z + r.z * 2, 1, 1);
      s.clearGroups(), s.addGroup(0, s.index ? s.index.count : s.attributes.position.count, 0), s.applyMatrix4(new Matrix4().makeScale(-1, 1, 1)), s.computeVertexNormals();
      var u = new PBMMeshMaterial("none");
      return u.refreshUniforms(), o = n45.call(this, s, [u]) || this, o.position.copy(e.getCenter(new Vector3())), o.frustumCulled = false, o.boundingBox = new Box3(), o.boundingBox.setFromObject(o), o.renderOrder = -1001, o;
    }
    return t;
  }(PBMMesh)
);
function generateBoundingMesh(n45, t) {
  return t === void 0 && (t = DEFAULT_OFFSET_VECTOR), new BoundingMesh(n45, t);
}
function cameraWorldToLocal(n45, t) {
  var e = new Vector3(0, 0, -1);
  e.applyQuaternion(n45.quaternion);
  var r = t.quaternion.clone().inverse();
  e.applyQuaternion(r);
  var o = Math.atan2(e.x, -e.z), s = -Math.asin(e.y);
  return { theta: o, phi: s, lookAtVector: e };
}
var TAU$1 = Math.PI * 2;
function formatRad(n45) {
  return n45 >= 0 && n45 < TAU$1 ? n45 : (n45 % TAU$1 + TAU$1) % TAU$1;
}
var PI = Math.PI;
var TAU = PI * 2;
function stepNumber(n45, t, e) {
  if (n45 === t)
    return t;
  var r = t - n45, o = Math.abs(r);
  if (o <= e)
    return t;
  var s = r > 0 ? 1 : -1;
  return n45 + s * e;
}
function stepVector(n45, t, e) {
  if (n45.equals(t))
    return new Vector3().copy(t);
  var r = new Vector3().subVectors(t, n45);
  return r.lengthSq() < e * e ? r.copy(t) : r.setLength(e).add(n45);
}
function stepCoordinates(n45, t, e) {
  if (n45.longitude === t.longitude && n45.latitude === t.latitude)
    return { longitude: t.longitude, latitude: t.latitude };
  var r = formatRad(n45.longitude), o = n45.latitude, s = formatRad(t.longitude), u = t.latitude;
  s - r > PI ? r += TAU : r - s > PI && (r -= TAU);
  var l = Math.sqrt(Math.pow(s - r, 2) + Math.pow(u - o, 2)), c = e / l;
  return c >= 1 ? { longitude: t.longitude, latitude: t.latitude } : {
    longitude: r + (s - r) * c,
    latitude: o + (u - o) * c
  };
}
function isPromise(n45) {
  return !!n45 && (typeof n45 == "object" || typeof n45 == "function") && typeof n45.then == "function";
}
var _a$2;
var userAgent = typeof navigator != "undefined" ? ((_a$2 = navigator == null ? void 0 : navigator.userAgent) !== null && _a$2 !== void 0 ? _a$2 : "").toLowerCase() : "node";
(function() {
  try {
    var n45 = document.createElement("canvas");
    return !!(window.WebGLRenderingContext && (n45.getContext("webgl") || n45.getContext("experimental-webgl")));
  } catch (t) {
    return false;
  }
})();
var isMobile = /android/i.test(userAgent) || /webos/i.test(userAgent) || /ipad|iphone|ipod/i.test(userAgent) || /iemobile/i.test(userAgent) || /opera mini/i.test(userAgent) || /blackberry/i.test(userAgent) || /windows phone/i.test(userAgent);
function createEvent(n45, t) {
  for (var e = false, r = {
    type: n45,
    timeStamp: now(),
    get defaultPrevented() {
      return e;
    },
    preventDefault: function() {
      e = true;
    }
  }, o = 0, s = Object.keys(t); o < s.length; o++) {
    var u = s[o];
    u in r || (r[u] = t[u]);
  }
  return r;
}
function requestDeviceOrientationPermission() {
  return typeof location == "undefined" || location.protocol !== "https:" ? Promise.reject(new Error("Request DeviceOrientation Permission denied.")) : typeof DeviceOrientationEvent != "undefined" && typeof DeviceOrientationEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then(function(n45) {
    if (n45 == "granted")
      return Promise.resolve();
    var t = new Error("Request DeviceOrientation Permission denied.");
    return Promise.reject(t);
  }) : Promise.resolve();
}
function requestXRSessionPermission() {
  if ("xr" in navigator)
    return navigator.xr.isSessionSupported("immersive-vr").then(function(t) {
      return t ? Promise.resolve() : Promise.reject();
    }).then(function() {
      var t = { optionalFeatures: ["local-floor"] };
      return navigator.xr.requestSession("immersive-vr", t).then(function(e) {
        return Promise.resolve(e);
      });
    });
  var n45 = new Error("Request XR Permission denied.");
  return Promise.reject(n45);
}
function assignState(n45, t) {
  n45.mode = t.mode, n45.workCode = t.workCode, n45.panoIndex = t.panoIndex, n45.longitude = t.longitude, n45.latitude = t.latitude, n45.fov = t.fov, n45.offset.copy(t.offset), n45.distance = t.distance;
}
function stateEqual(n45, t) {
  return n45.workCode === t.workCode && n45.mode === t.mode && n45.panoIndex === t.panoIndex && isSimilarValue(n45.longitude, t.longitude, Math.PI * 2) && isSimilarValue(n45.latitude, t.latitude) && isSimilarValue(n45.fov, t.fov) && isSimilarVector3(n45.offset, t.offset) && isSimilarValue(n45.distance, t.distance);
}
function assignPose(n45, t) {
  n45.longitude = t.longitude, n45.latitude = t.latitude, n45.fov = t.fov, n45.distance = t.distance, n45.offset.copy(t.offset);
}
function clonePose(n45) {
  return {
    longitude: n45.longitude,
    latitude: n45.latitude,
    fov: n45.fov,
    offset: n45.offset.clone(),
    distance: n45.distance
  };
}
function omitUndefinedFields(n45) {
  var t = {};
  for (var e in n45) {
    var r = n45[e];
    r !== void 0 && (t[e] = r);
  }
  return t;
}
var defaultIterator = function(n45) {
  return Number(n45);
};
function arrayMin(n45, t, e) {
  var r;
  t === void 0 && (t = defaultIterator), e === void 0 && (e = false);
  for (var o, s = 1 / 0, u = 0, l = n45; u < l.length; u++) {
    var c = l[u], f = t(c);
    f <= s && (r = [c, f], o = r[0], s = r[1]);
  }
  return isFinite(s) || (s = 0), e ? [o, s] : o;
}
function isEmptyObject(n45) {
  for (var t in n45)
    return false;
  return true;
}
var Hammer = function(n45, t, e, r) {
  var o = ["", "webkit", "Moz", "MS", "ms", "o"], s = t.createElement ? t.createElement("div") : r, u = "function", l = Math.round, c = Math.abs, f = Date.now;
  function d(B, F, V) {
    return setTimeout(E(B, V), F);
  }
  function h(B, F, V) {
    return Array.isArray(B) ? (v(B, V[F], V), true) : false;
  }
  function v(B, F, V) {
    var J;
    if (B)
      if (B.forEach)
        B.forEach(F, V);
      else if (B.length !== r)
        for (J = 0; J < B.length; )
          F.call(V, B[J], J, B), J++;
      else
        for (J in B)
          B.hasOwnProperty(J) && F.call(V, B[J], J, B);
  }
  function A(B, F, V) {
    var J = "DEPRECATED METHOD: " + F + `
` + V + ` AT 
`;
    return function() {
      var Y = new Error("get-stack-trace"), le = Y && Y.stack ? Y.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", Ee = n45.console && (n45.console.warn || n45.console.log);
      return Ee && Ee.call(n45.console, J, le), B.apply(this, arguments);
    };
  }
  var g;
  typeof Object.assign != "function" ? g = function(F) {
    if (F === r || F === null)
      throw new TypeError("Cannot convert undefined or null to object");
    for (var V = Object(F), J = 1; J < arguments.length; J++) {
      var Y = arguments[J];
      if (Y !== r && Y !== null)
        for (var le in Y)
          Y.hasOwnProperty(le) && (V[le] = Y[le]);
    }
    return V;
  } : g = Object.assign;
  var p = A(function(F, V, J) {
    for (var Y = Object.keys(V), le = 0; le < Y.length; )
      (!J || J && F[Y[le]] === r) && (F[Y[le]] = V[Y[le]]), le++;
    return F;
  }, "extend", "Use `assign`."), y = A(function(F, V) {
    return p(F, V, true);
  }, "merge", "Use `assign`.");
  function m(B, F, V) {
    var J = F.prototype, Y;
    Y = B.prototype = Object.create(J), Y.constructor = B, Y._super = J, V && g(Y, V);
  }
  function E(B, F) {
    return function() {
      return B.apply(F, arguments);
    };
  }
  function b(B, F) {
    return typeof B == u ? B.apply(F && F[0] || r, F) : B;
  }
  function T(B, F) {
    return B === r ? F : B;
  }
  function R(B, F, V) {
    v(H(F), function(J) {
      B.addEventListener(J, V, false);
    });
  }
  function S(B, F, V) {
    v(H(F), function(J) {
      B.removeEventListener(J, V, false);
    });
  }
  function M(B, F) {
    for (; B; ) {
      if (B == F)
        return true;
      B = B.parentNode;
    }
    return false;
  }
  function w(B, F) {
    return B.indexOf(F) > -1;
  }
  function H(B) {
    return B.trim().split(/\s+/g);
  }
  function L(B, F, V) {
    if (B.indexOf && !V)
      return B.indexOf(F);
    for (var J = 0; J < B.length; ) {
      if (V && B[J][V] == F || !V && B[J] === F)
        return J;
      J++;
    }
    return -1;
  }
  function C(B) {
    return Array.prototype.slice.call(B, 0);
  }
  function I(B, F, V) {
    for (var J = [], Y = [], le = 0; le < B.length; ) {
      var Ee = B[le][F];
      L(Y, Ee) < 0 && J.push(B[le]), Y[le] = Ee, le++;
    }
    return J = J.sort(function(Ze, _e) {
      return Ze[F] > _e[F];
    }), J;
  }
  function _(B, F) {
    for (var V, J, Y = F[0].toUpperCase() + F.slice(1), le = 0; le < o.length; ) {
      if (V = o[le], J = V ? V + Y : F, J in B)
        return J;
      le++;
    }
    return r;
  }
  var O = 1;
  function P() {
    return O++;
  }
  function N(B) {
    var F = B.ownerDocument || B;
    return F.defaultView || F.parentWindow || n45;
  }
  var k = /mobile|tablet|ip(ad|hone|od)|android/i, U = "ontouchstart" in n45, D = _(n45, "PointerEvent") !== r, q = U && k.test(navigator.userAgent), z = "touch", Q = "pen", G = "mouse", X = "kinect", $ = 25, W = 1, oe = 2, ie = 4, re = 8, j = 1, se = 2, ae = 4, ue = 8, fe = 16, ne = se | ae, Te = ue | fe, Re = ne | Te, ve = ["x", "y"], Ce = ["clientX", "clientY"];
  function Z(B, F) {
    var V = this;
    this.manager = B, this.callback = F, this.element = B.element, this.target = B.options.inputTarget, this.domHandler = function(J) {
      b(B.options.enable, [B]) && V.handler(J);
    }, this.init();
  }
  Z.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() {
    },
    /**
     * bind the events
     */
    init: function() {
      this.evEl && R(this.element, this.evEl, this.domHandler), this.evTarget && R(this.target, this.evTarget, this.domHandler), this.evWin && R(N(this.element), this.evWin, this.domHandler);
    },
    /**
     * unbind the events
     */
    destroy: function() {
      this.evEl && S(this.element, this.evEl, this.domHandler), this.evTarget && S(this.target, this.evTarget, this.domHandler), this.evWin && S(N(this.element), this.evWin, this.domHandler);
    }
  };
  function te(B) {
    var F, V = B.options.inputClass;
    return V ? F = V : D ? F = Ye : q ? F = Le : U ? F = Xe : F = ze, new F(B, K);
  }
  function K(B, F, V) {
    var J = V.pointers.length, Y = V.changedPointers.length, le = F & W && J - Y === 0, Ee = F & (ie | re) && J - Y === 0;
    V.isFirst = !!le, V.isFinal = !!Ee, le && (B.session = {}), V.eventType = F, ye(B, V), B.emit("hammer.input", V), B.recognize(V), B.session.prevInput = V;
  }
  function ye(B, F) {
    var V = B.session, J = F.pointers, Y = J.length;
    V.firstInput || (V.firstInput = Ae(F)), Y > 1 && !V.firstMultiple ? V.firstMultiple = Ae(F) : Y === 1 && (V.firstMultiple = false);
    var le = V.firstInput, Ee = V.firstMultiple, ke = Ee ? Ee.center : le.center, Ze = F.center = me(J);
    F.timeStamp = f(), F.deltaTime = F.timeStamp - le.timeStamp, F.angle = he(ke, Ze), F.distance = ee(ke, Ze), de(V, F), F.offsetDirection = pe(F.deltaX, F.deltaY);
    var _e = ce(F.deltaTime, F.deltaX, F.deltaY);
    F.overallVelocityX = _e.x, F.overallVelocityY = _e.y, F.overallVelocity = c(_e.x) > c(_e.y) ? _e.x : _e.y, F.scale = Ee ? Ie(Ee.pointers, J) : 1, F.rotation = Ee ? Se(Ee.pointers, J) : 0, F.maxPointers = V.prevInput ? F.pointers.length > V.prevInput.maxPointers ? F.pointers.length : V.prevInput.maxPointers : F.pointers.length, xe(V, F);
    var dt = B.element;
    M(F.srcEvent.target, dt) && (dt = F.srcEvent.target), F.target = dt;
  }
  function de(B, F) {
    var V = F.center, J = B.offsetDelta || {}, Y = B.prevDelta || {}, le = B.prevInput || {};
    (F.eventType === W || le.eventType === ie) && (Y = B.prevDelta = {
      x: le.deltaX || 0,
      y: le.deltaY || 0
    }, J = B.offsetDelta = {
      x: V.x,
      y: V.y
    }), F.deltaX = Y.x + (V.x - J.x), F.deltaY = Y.y + (V.y - J.y);
  }
  function xe(B, F) {
    var V = B.lastInterval || F, J = F.timeStamp - V.timeStamp, Y, le, Ee, ke;
    if (F.eventType != re && (J > $ || V.velocity === r)) {
      var Ze = F.deltaX - V.deltaX, _e = F.deltaY - V.deltaY, dt = ce(J, Ze, _e);
      le = dt.x, Ee = dt.y, Y = c(dt.x) > c(dt.y) ? dt.x : dt.y, ke = pe(Ze, _e), B.lastInterval = F;
    } else
      Y = V.velocity, le = V.velocityX, Ee = V.velocityY, ke = V.direction;
    F.velocity = Y, F.velocityX = le, F.velocityY = Ee, F.direction = ke;
  }
  function Ae(B) {
    for (var F = [], V = 0; V < B.pointers.length; )
      F[V] = {
        clientX: l(B.pointers[V].clientX),
        clientY: l(B.pointers[V].clientY)
      }, V++;
    return {
      timeStamp: f(),
      pointers: F,
      center: me(F),
      deltaX: B.deltaX,
      deltaY: B.deltaY
    };
  }
  function me(B) {
    var F = B.length;
    if (F === 1)
      return {
        x: l(B[0].clientX),
        y: l(B[0].clientY)
      };
    for (var V = 0, J = 0, Y = 0; Y < F; )
      V += B[Y].clientX, J += B[Y].clientY, Y++;
    return {
      x: l(V / F),
      y: l(J / F)
    };
  }
  function ce(B, F, V) {
    return {
      x: F / B || 0,
      y: V / B || 0
    };
  }
  function pe(B, F) {
    return B === F ? j : c(B) >= c(F) ? B < 0 ? se : ae : F < 0 ? ue : fe;
  }
  function ee(B, F, V) {
    V || (V = ve);
    var J = F[V[0]] - B[V[0]], Y = F[V[1]] - B[V[1]];
    return Math.sqrt(J * J + Y * Y);
  }
  function he(B, F, V) {
    V || (V = ve);
    var J = F[V[0]] - B[V[0]], Y = F[V[1]] - B[V[1]];
    return Math.atan2(Y, J) * 180 / Math.PI;
  }
  function Se(B, F) {
    return he(F[1], F[0], Ce) + he(B[1], B[0], Ce);
  }
  function Ie(B, F) {
    return ee(F[0], F[1], Ce) / ee(B[0], B[1], Ce);
  }
  var Ue = {
    mousedown: W,
    mousemove: oe,
    mouseup: ie
  }, be = "mousedown", ge = "mousemove mouseup";
  function ze() {
    this.evEl = be, this.evWin = ge, this.pressed = false, Z.apply(this, arguments);
  }
  m(ze, Z, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function(F) {
      var V = Ue[F.type];
      V & W && (F.button === 0 || F.button === 2) && (this.pressed = true), V & oe && F.which !== 1 && (V = ie), this.pressed && (V & ie && (this.pressed = false), this.callback(this.manager, V, {
        pointers: [F],
        changedPointers: [F],
        pointerType: G,
        srcEvent: F
      }));
    }
  });
  var Ne = {
    pointerdown: W,
    pointermove: oe,
    pointerup: ie,
    pointercancel: re,
    pointerout: re
  }, Je = {
    2: z,
    3: Q,
    4: G,
    5: X
    // see https://twitter.com/jacobrossi/status/480596438489890816
  }, Ke = "pointerdown", De = "pointermove pointerup pointercancel";
  n45.MSPointerEvent && !n45.PointerEvent && (Ke = "MSPointerDown", De = "MSPointerMove MSPointerUp MSPointerCancel");
  function Ye() {
    this.evEl = Ke, this.evWin = De, Z.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
  }
  m(Ye, Z, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function(F) {
      var V = this.store, J = false, Y = false, le = F.type.toLowerCase().replace("ms", ""), Ee = Ne[le], ke = Je[F.pointerType] || F.pointerType, Ze = ke == z, _e = L(V, F.pointerId, "pointerId");
      Ee & W && (F.button === 0 || F.button === 2 || Ze) ? _e < 0 && (V.push(F), _e = V.length - 1) : Ee & (ie | re) ? J = true : !Ze && F.buttons === 0 && (J = true, Y = true, Ee = Ne.pointerup), !(_e < 0) && (Y || (V[_e] = F), this.callback(this.manager, Ee, {
        pointers: V,
        changedPointers: [F],
        pointerType: ke,
        srcEvent: V[_e]
      }), J && V.splice(_e, 1));
    }
  });
  var Ve = {
    touchstart: W,
    touchmove: oe,
    touchend: ie,
    touchcancel: re
  }, nt = "touchstart", qe = "touchstart touchmove touchend touchcancel";
  function Qe() {
    this.evTarget = nt, this.evWin = qe, this.started = false, Z.apply(this, arguments);
  }
  m(Qe, Z, {
    handler: function(F) {
      var V = Ve[F.type];
      if (V === W && (this.started = true), !!this.started) {
        var J = Pe.call(this, F, V);
        V & (ie | re) && J[0].length - J[1].length === 0 && (this.started = false), this.callback(this.manager, V, {
          pointers: J[0],
          changedPointers: J[1],
          pointerType: z,
          srcEvent: F
        });
      }
    }
  });
  function Pe(B, F) {
    var V = C(B.touches), J = C(B.changedTouches);
    return F & (ie | re) && (V = I(V.concat(J), "identifier")), [V, J];
  }
  var Me = {
    touchstart: W,
    touchmove: oe,
    touchend: ie,
    touchcancel: re
  }, He = "touchstart touchmove touchend touchcancel";
  function Le() {
    this.evTarget = He, this.targetIds = {}, Z.apply(this, arguments);
  }
  m(Le, Z, {
    handler: function(F) {
      var V = Me[F.type], J = ot.call(this, F, V);
      J && this.callback(this.manager, V, {
        pointers: J[0],
        changedPointers: J[1],
        pointerType: z,
        srcEvent: F
      });
    }
  });
  function ot(B, F) {
    var V = C(B.touches), J = this.targetIds;
    if (F & (W | oe) && V.length === 1)
      return J[V[0].identifier] = true, [V, V];
    var Y, le, Ee = C(B.changedTouches), ke = [], Ze = this.target;
    if (le = V.filter(function(_e) {
      return M(_e.target, Ze);
    }), F === W)
      for (Y = 0; Y < le.length; )
        J[le[Y].identifier] = true, Y++;
    for (Y = 0; Y < Ee.length; )
      J[Ee[Y].identifier] && ke.push(Ee[Y]), F & (ie | re) && delete J[Ee[Y].identifier], Y++;
    if (ke.length)
      return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        I(le.concat(ke), "identifier"),
        ke
      ];
  }
  var $e = 2500, tt = 25;
  function Xe() {
    Z.apply(this, arguments);
    var B = E(this.handler, this);
    this.touch = new Le(this.manager, B), this.mouse = new ze(this.manager, B), this.primaryTouch = null, this.lastTouches = [];
  }
  m(Xe, Z, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function(F, V, J) {
      var Y = J.pointerType == z, le = J.pointerType == G;
      if (!(le && J.sourceCapabilities && J.sourceCapabilities.firesTouchEvents)) {
        if (Y)
          rt.call(this, V, J);
        else if (le && st.call(this, J))
          return;
        this.callback(F, V, J);
      }
    },
    /**
     * remove the event listeners
     */
    destroy: function() {
      this.touch.destroy(), this.mouse.destroy();
    }
  });
  function rt(B, F) {
    B & W ? (this.primaryTouch = F.changedPointers[0].identifier, Ge.call(this, F)) : B & (ie | re) && Ge.call(this, F);
  }
  function Ge(B) {
    var F = B.changedPointers[0];
    if (F.identifier === this.primaryTouch) {
      var V = { x: F.clientX, y: F.clientY };
      this.lastTouches.push(V);
      var J = this.lastTouches, Y = function() {
        var le = J.indexOf(V);
        le > -1 && J.splice(le, 1);
      };
      setTimeout(Y, $e);
    }
  }
  function st(B) {
    for (var F = B.srcEvent.clientX, V = B.srcEvent.clientY, J = 0; J < this.lastTouches.length; J++) {
      var Y = this.lastTouches[J], le = Math.abs(F - Y.x), Ee = Math.abs(V - Y.y);
      if (le <= tt && Ee <= tt)
        return true;
    }
    return false;
  }
  var ct = s ? _(s.style, "touchAction") : r, je = ct !== r, Fe = "compute", We = "auto", it = "manipulation", Be = "none", we = "pan-x", Oe = "pan-y", ut = Lt();
  function vt(B, F) {
    this.manager = B, this.set(F);
  }
  vt.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(B) {
      B == Fe && (B = this.compute()), je && this.manager.element.style && ut[B] && (this.manager.element.style[ct] = B), this.actions = B.toLowerCase().trim();
    },
    /**
     * just re-set the touchAction value
     */
    update: function() {
      this.set(this.manager.options.touchAction);
    },
    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
      var B = [];
      return v(this.manager.recognizers, function(F) {
        b(F.options.enable, [F]) && (B = B.concat(F.getTouchAction()));
      }), At(B.join(" "));
    },
    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(B) {
      var F = B.srcEvent, V = B.offsetDirection;
      if (this.manager.session.prevented) {
        F.preventDefault();
        return;
      }
      var J = this.actions, Y = w(J, Be) && !ut[Be], le = w(J, Oe) && !ut[Oe], Ee = w(J, we) && !ut[we];
      if (Y) {
        var ke = B.pointers.length === 1, Ze = B.distance < 2, _e = B.deltaTime < 250;
        if (ke && Ze && _e)
          return;
      }
      if (!(Ee && le) && (Y || le && V & ne || Ee && V & Te))
        return this.preventSrc(F);
    },
    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(B) {
      this.manager.session.prevented = true, B.preventDefault();
    }
  };
  function At(B) {
    if (w(B, Be))
      return Be;
    var F = w(B, we), V = w(B, Oe);
    return F && V ? Be : F || V ? F ? we : Oe : w(B, it) ? it : We;
  }
  function Lt() {
    if (!je)
      return false;
    var B = {}, F = n45.CSS && n45.CSS.supports;
    return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(V) {
      B[V] = F ? n45.CSS.supports("touch-action", V) : true;
    }), B;
  }
  var bt = 1, at = 2, gt = 4, mt = 8, ht = mt, Et = 16, ft = 32;
  function pt(B) {
    this.options = g({}, this.defaults, B || {}), this.id = P(), this.manager = null, this.options.enable = T(this.options.enable, true), this.state = bt, this.simultaneous = {}, this.requireFail = [];
  }
  pt.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},
    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(B) {
      return g(this.options, B), this.manager && this.manager.touchAction.update(), this;
    },
    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(B) {
      if (h(B, "recognizeWith", this))
        return this;
      var F = this.simultaneous;
      return B = Tt(B, this), F[B.id] || (F[B.id] = B, B.recognizeWith(this)), this;
    },
    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(B) {
      return h(B, "dropRecognizeWith", this) ? this : (B = Tt(B, this), delete this.simultaneous[B.id], this);
    },
    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(B) {
      if (h(B, "requireFailure", this))
        return this;
      var F = this.requireFail;
      return B = Tt(B, this), L(F, B) === -1 && (F.push(B), B.requireFailure(this)), this;
    },
    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(B) {
      if (h(B, "dropRequireFailure", this))
        return this;
      B = Tt(B, this);
      var F = L(this.requireFail, B);
      return F > -1 && this.requireFail.splice(F, 1), this;
    },
    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
      return this.requireFail.length > 0;
    },
    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(B) {
      return !!this.simultaneous[B.id];
    },
    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(B) {
      var F = this, V = this.state;
      function J(Y) {
        F.manager.emit(Y, B);
      }
      V < mt && J(F.options.event + Pt(V)), J(F.options.event), B.additionalEvent && J(B.additionalEvent), V >= mt && J(F.options.event + Pt(V));
    },
    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(B) {
      if (this.canEmit())
        return this.emit(B);
      this.state = ft;
    },
    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
      for (var B = 0; B < this.requireFail.length; ) {
        if (!(this.requireFail[B].state & (ft | bt)))
          return false;
        B++;
      }
      return true;
    },
    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(B) {
      var F = g({}, B);
      if (!b(this.options.enable, [this, F])) {
        this.reset(), this.state = ft;
        return;
      }
      this.state & (ht | Et | ft) && (this.state = bt), this.state = this.process(F), this.state & (at | gt | mt | Et) && this.tryEmit(F);
    },
    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(B) {
    },
    // jshint ignore:line
    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() {
    },
    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() {
    }
  };
  function Pt(B) {
    return B & Et ? "cancel" : B & mt ? "end" : B & gt ? "move" : B & at ? "start" : "";
  }
  function Bt(B) {
    return B == fe ? "down" : B == ue ? "up" : B == se ? "left" : B == ae ? "right" : "";
  }
  function Tt(B, F) {
    var V = F.manager;
    return V ? V.get(B) : B;
  }
  function lt() {
    pt.apply(this, arguments);
  }
  m(lt, pt, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },
    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(B) {
      var F = this.options.pointers;
      return F === 0 || B.pointers.length === F;
    },
    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(B) {
      var F = this.state, V = B.eventType, J = F & (at | gt), Y = this.attrTest(B);
      return J && (V & re || !Y) ? F | Et : J || Y ? V & ie ? F | mt : F & at ? F | gt : at : ft;
    }
  });
  function Rt() {
    lt.apply(this, arguments), this.pX = null, this.pY = null;
  }
  m(Rt, lt, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: "pan",
      threshold: 10,
      pointers: 1,
      direction: Re
    },
    getTouchAction: function() {
      var B = this.options.direction, F = [];
      return B & ne && F.push(Oe), B & Te && F.push(we), F;
    },
    directionTest: function(B) {
      var F = this.options, V = true, J = B.distance, Y = B.direction, le = B.deltaX, Ee = B.deltaY;
      return Y & F.direction || (F.direction & ne ? (Y = le === 0 ? j : le < 0 ? se : ae, V = le != this.pX, J = Math.abs(B.deltaX)) : (Y = Ee === 0 ? j : Ee < 0 ? ue : fe, V = Ee != this.pY, J = Math.abs(B.deltaY))), B.direction = Y, V && J > F.threshold && Y & F.direction;
    },
    attrTest: function(B) {
      return lt.prototype.attrTest.call(this, B) && (this.state & at || !(this.state & at) && this.directionTest(B));
    },
    emit: function(B) {
      this.pX = B.deltaX, this.pY = B.deltaY;
      var F = Bt(B.direction);
      F && (B.additionalEvent = this.options.event + F), this._super.emit.call(this, B);
    }
  });
  function xt() {
    lt.apply(this, arguments);
  }
  m(xt, lt, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: "pinch",
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function() {
      return [Be];
    },
    attrTest: function(B) {
      return this._super.attrTest.call(this, B) && (Math.abs(B.scale - 1) > this.options.threshold || this.state & at);
    },
    emit: function(B) {
      if (B.scale !== 1) {
        var F = B.scale < 1 ? "in" : "out";
        B.additionalEvent = this.options.event + F;
      }
      this._super.emit.call(this, B);
    }
  });
  function Mt() {
    pt.apply(this, arguments), this._timer = null, this._input = null;
  }
  m(Mt, pt, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: "press",
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
      // a minimal movement is ok, but keep it low
    },
    getTouchAction: function() {
      return [We];
    },
    process: function(B) {
      var F = this.options, V = B.pointers.length === F.pointers, J = B.distance < F.threshold, Y = B.deltaTime > F.time;
      if (this._input = B, !J || !V || B.eventType & (ie | re) && !Y)
        this.reset();
      else if (B.eventType & W)
        this.reset(), this._timer = d(function() {
          this.state = ht, this.tryEmit();
        }, F.time, this);
      else if (B.eventType & ie)
        return ht;
      return ft;
    },
    reset: function() {
      clearTimeout(this._timer);
    },
    emit: function(B) {
      this.state === ht && (B && B.eventType & ie ? this.manager.emit(this.options.event + "up", B) : (this._input.timeStamp = f(), this.manager.emit(this.options.event, this._input)));
    }
  });
  function Ct() {
    lt.apply(this, arguments);
  }
  m(Ct, lt, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: "rotate",
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function() {
      return [Be];
    },
    attrTest: function(B) {
      return this._super.attrTest.call(this, B) && (Math.abs(B.rotation) > this.options.threshold || this.state & at);
    }
  });
  function wt() {
    lt.apply(this, arguments);
  }
  m(wt, lt, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: "swipe",
      threshold: 10,
      velocity: 0.3,
      direction: ne | Te,
      pointers: 1
    },
    getTouchAction: function() {
      return Rt.prototype.getTouchAction.call(this);
    },
    attrTest: function(B) {
      var F = this.options.direction, V;
      return F & (ne | Te) ? V = B.overallVelocity : F & ne ? V = B.overallVelocityX : F & Te && (V = B.overallVelocityY), this._super.attrTest.call(this, B) && F & B.offsetDirection && B.distance > this.options.threshold && B.maxPointers == this.options.pointers && c(V) > this.options.velocity && B.eventType & ie;
    },
    emit: function(B) {
      var F = Bt(B.offsetDirection);
      F && this.manager.emit(this.options.event + F, B), this.manager.emit(this.options.event, B);
    }
  });
  function St() {
    pt.apply(this, arguments), this.pTime = false, this.pCenter = false, this._timer = null, this._input = null, this.count = 0;
  }
  m(St, pt, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
      // a multi-tap can be a bit off the initial position
    },
    getTouchAction: function() {
      return [it];
    },
    process: function(B) {
      var F = this.options, V = B.pointers.length === F.pointers, J = B.distance < F.threshold, Y = B.deltaTime < F.time;
      if (this.reset(), B.eventType & W && this.count === 0)
        return this.failTimeout();
      if (J && Y && V) {
        if (B.eventType != ie)
          return this.failTimeout();
        var le = this.pTime ? B.timeStamp - this.pTime < F.interval : true, Ee = !this.pCenter || ee(this.pCenter, B.center) < F.posThreshold;
        this.pTime = B.timeStamp, this.pCenter = B.center, !Ee || !le ? this.count = 1 : this.count += 1, this._input = B;
        var ke = this.count % F.taps;
        if (ke === 0)
          return this.hasRequireFailures() ? (this._timer = d(function() {
            this.state = ht, this.tryEmit();
          }, F.interval, this), at) : ht;
      }
      return ft;
    },
    failTimeout: function() {
      return this._timer = d(function() {
        this.state = ft;
      }, this.options.interval, this), ft;
    },
    reset: function() {
      clearTimeout(this._timer);
    },
    emit: function() {
      this.state == ht && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
    }
  });
  function yt(B, F) {
    return F = F || {}, F.recognizers = T(F.recognizers, yt.defaults.preset), new It(B, F);
  }
  yt.VERSION = "2.0.7", yt.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,
    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: Fe,
    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,
    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,
    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,
    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
      // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
      [Ct, { enable: false }],
      [xt, { enable: false }, ["rotate"]],
      [wt, { direction: ne }],
      [Rt, { direction: ne }, ["swipe"]],
      [St],
      [St, { event: "doubletap", taps: 2 }, ["tap"]],
      [Mt]
    ],
    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: "none",
      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: "none",
      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: "none",
      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: "none",
      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: "none",
      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  };
  var Ft = 1, Ht = 2;
  function It(B, F) {
    this.options = g({}, yt.defaults, F || {}), this.options.inputTarget = this.options.inputTarget || B, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = B, this.input = te(this), this.touchAction = new vt(this, this.options.touchAction), _t(this, true), v(this.options.recognizers, function(V) {
      var J = this.add(new V[0](V[1]));
      V[2] && J.recognizeWith(V[2]), V[3] && J.requireFailure(V[3]);
    }, this);
  }
  It.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(B) {
      return g(this.options, B), B.touchAction && this.touchAction.update(), B.inputTarget && (this.input.destroy(), this.input.target = B.inputTarget, this.input.init()), this;
    },
    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(B) {
      this.session.stopped = B ? Ht : Ft;
    },
    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(B) {
      var F = this.session;
      if (!F.stopped) {
        this.touchAction.preventDefaults(B);
        var V, J = this.recognizers, Y = F.curRecognizer;
        (!Y || Y && Y.state & ht) && (Y = F.curRecognizer = null);
        for (var le = 0; le < J.length; )
          V = J[le], F.stopped !== Ht && // 1
          (!Y || V == Y || // 2
          V.canRecognizeWith(Y)) ? V.recognize(B) : V.reset(), !Y && V.state & (at | gt | mt) && (Y = F.curRecognizer = V), le++;
      }
    },
    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(B) {
      if (B instanceof pt)
        return B;
      for (var F = this.recognizers, V = 0; V < F.length; V++)
        if (F[V].options.event == B)
          return F[V];
      return null;
    },
    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(B) {
      if (h(B, "add", this))
        return this;
      var F = this.get(B.options.event);
      return F && this.remove(F), this.recognizers.push(B), B.manager = this, this.touchAction.update(), B;
    },
    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(B) {
      if (h(B, "remove", this))
        return this;
      if (B = this.get(B), B) {
        var F = this.recognizers, V = L(F, B);
        V !== -1 && (F.splice(V, 1), this.touchAction.update());
      }
      return this;
    },
    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(B, F) {
      if (B !== r && F !== r) {
        var V = this.handlers;
        return v(H(B), function(J) {
          V[J] = V[J] || [], V[J].push(F);
        }), this;
      }
    },
    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(B, F) {
      if (B !== r) {
        var V = this.handlers;
        return v(H(B), function(J) {
          F ? V[J] && V[J].splice(L(V[J], F), 1) : delete V[J];
        }), this;
      }
    },
    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(B, F) {
      this.options.domEvents && Ot(B, F);
      var V = this.handlers[B] && this.handlers[B].slice();
      if (!(!V || !V.length)) {
        F.type = B, F.preventDefault = function() {
          F.srcEvent.preventDefault();
        };
        for (var J = 0; J < V.length; )
          V[J](F), J++;
      }
    },
    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
      this.element && _t(this, false), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
    }
  };
  function _t(B, F) {
    var V = B.element;
    if (V.style) {
      var J;
      v(B.options.cssProps, function(Y, le) {
        J = _(V.style, le), F ? (B.oldCssProps[J] = V.style[J], V.style[J] = Y) : V.style[J] = B.oldCssProps[J] || "";
      }), F || (B.oldCssProps = {});
    }
  }
  function Ot(B, F) {
    var V = t.createEvent("Event");
    V.initEvent(B, true, true), V.gesture = F, F.target.dispatchEvent(V);
  }
  return g(yt, {
    INPUT_START: W,
    INPUT_MOVE: oe,
    INPUT_END: ie,
    INPUT_CANCEL: re,
    STATE_POSSIBLE: bt,
    STATE_BEGAN: at,
    STATE_CHANGED: gt,
    STATE_ENDED: mt,
    STATE_RECOGNIZED: ht,
    STATE_CANCELLED: Et,
    STATE_FAILED: ft,
    DIRECTION_NONE: j,
    DIRECTION_LEFT: se,
    DIRECTION_RIGHT: ae,
    DIRECTION_UP: ue,
    DIRECTION_DOWN: fe,
    DIRECTION_HORIZONTAL: ne,
    DIRECTION_VERTICAL: Te,
    DIRECTION_ALL: Re,
    Manager: It,
    Input: Z,
    TouchAction: vt,
    TouchInput: Le,
    MouseInput: ze,
    PointerEventInput: Ye,
    TouchMouseInput: Xe,
    SingleTouchInput: Qe,
    Recognizer: pt,
    AttrRecognizer: lt,
    Tap: St,
    Pan: Rt,
    Swipe: wt,
    Pinch: xt,
    Rotate: Ct,
    Press: Mt,
    on: R,
    off: S,
    each: v,
    merge: y,
    extend: p,
    assign: g,
    inherit: m,
    bindFn: E,
    prefixed: _
  }), yt;
}(typeof window != "undefined" ? window : {}, typeof document != "undefined" ? document : {});
function calculateThreeMouse(n45, t, e) {
  var r = t.getBoundingClientRect(), o = r.top, s = r.left, u = r.width, l = r.height;
  return e && (s = s + u * e.left, o = o + l * (1 - e.bottom - e.height), u = u * e.width, l = l * e.height), new Vector2((n45.x - s) / u * 2 - 1, -(n45.y - o) / l * 2 + 1);
}
var camera$2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var geometry$5 = new BufferGeometry();
geometry$5.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
geometry$5.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var mesh$4 = new Mesh(geometry$5);
var scene$2 = new Scene();
scene$2.add(mesh$4);
var DEFAULT_VERTEX_SHADER = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
var Pass = (
  /** @class */
  function() {
    function n45(t, e) {
      var r;
      this.renderer = t, this.material = new ShaderMaterial({
        vertexShader: (r = e.vertex) !== null && r !== void 0 ? r : DEFAULT_VERTEX_SHADER,
        fragmentShader: e.fragment,
        uniforms: Object.assign({
          inputBuffer: new Uniform(null)
        }, e.uniforms),
        defines: Object.assign({}, e.defines),
        blending: NoBlending,
        depthWrite: false,
        depthTest: false
      });
    }
    return n45.prototype.render = function(t, e) {
      var r = this.renderer.getRenderTarget(), o = mesh$4.material;
      this.material.uniforms.inputBuffer.value = t.texture, mesh$4.material = this.material, this.renderer.setRenderTarget(e || null), this.renderer.render(scene$2, camera$2), this.renderer.setRenderTarget(r), mesh$4.material = o;
    }, n45.prototype.dispose = function() {
      this.material.dispose();
    }, n45;
  }()
);
var VALUE_VERTEX_SHADER = `
void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
var VALUE_FRAGMENT_SHADER = `
uniform vec3 inputValue;
void main() {
  gl_FragColor = vec4(inputValue, 1.0);
}
`;
var ValuePass = (
  /** @class */
  function() {
    function n45(t) {
      this.renderer = t, this.material = new ShaderMaterial({
        vertexShader: VALUE_VERTEX_SHADER,
        fragmentShader: VALUE_FRAGMENT_SHADER,
        uniforms: Object.assign({
          inputValue: new Uniform(new Vector3())
        }),
        blending: NoBlending,
        depthWrite: false,
        depthTest: false
      });
    }
    return n45.prototype.render = function(t, e) {
      var r = this.renderer.getRenderTarget(), o = mesh$4.material;
      this.material.uniforms.inputValue.value.copy(t), mesh$4.material = this.material, this.renderer.setRenderTarget(e || null), this.renderer.render(scene$2, camera$2), this.renderer.setRenderTarget(r), mesh$4.material = o;
    }, n45.prototype.dispose = function() {
      this.material.dispose();
    }, n45;
  }()
);
var FRAGMENT$2 = `
uniform sampler2D inputBuffer;
varying vec2 vUv;
void main() {
  gl_FragColor = texture2D(inputBuffer, vUv);
}
`;
var CopyPass = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      return n45.call(this, e, { fragment: FRAGMENT$2 }) || this;
    }
    return t;
  }(Pass)
);
var FRAGMENT$1 = `
precision mediump float;
precision mediump int;
uniform sampler2D depthBuffer;
varying vec2 vUv;
void main() {
  gl_FragColor = vec4(0.0,0.0,0.0,1.0);
  gl_FragDepthEXT = texture2D(depthBuffer, vUv).r;
}
`;
var VERTEX = `

varying vec2 vUv;

void main() {
	vUv = uv;

	vec4 mvPosition = modelViewMatrix * vec4(position,1.0);

	gl_Position = projectionMatrix * mvPosition;
}
`;
var camera$1 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var geometry$4 = new BufferGeometry();
geometry$4.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
geometry$4.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var noneMaterial = new MeshBasicMaterial();
var mesh$3 = new Mesh(geometry$4, noneMaterial);
var scene$1 = new Scene();
scene$1.add(mesh$3);
var DepthCopyPass = (
  /** @class */
  function() {
    function n45(t) {
      this.renderer = t, this.material = new ShaderMaterial({
        vertexShader: VERTEX,
        fragmentShader: FRAGMENT$1,
        uniforms: Object.assign({
          depthBuffer: new Uniform(null)
        }),
        blending: NoBlending,
        depthWrite: true,
        depthTest: true
      }), this.renderer.getContext() && this.renderer.getContext() instanceof WebGLRenderingContext && (this.material.extensions.fragDepth = true);
    }
    return n45.prototype.render = function(t, e) {
      var r = this.renderer.getRenderTarget();
      this.material.uniforms.depthBuffer.value = t, mesh$3.material = this.material, this.renderer.setRenderTarget(e || null), this.renderer.render(scene$1, camera$1), this.renderer.setRenderTarget(r), mesh$3.material = noneMaterial;
    }, n45.prototype.dispose = function() {
      this.material.dispose();
    }, n45;
  }()
);
var sharedVector2$1 = new Vector2();
var BaseController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r, o, s, u, l, c, f, d = n45.call(this) || this, h = t.parseArgs(e);
      d.mode = "", d.pending = /* @__PURE__ */ new Set(), d.userAction = h.initial.userAction, d.destroyed = false, d.ident = h.ident, d.scene = h.scene, d.xrCustomObjectsScene = h.xrCustomObjectsScene, d.helper = h.helper, d.boundingMesh = h.boundingMesh, d.camera = h.camera, d.renderer = h.renderer, d.scissor = h.scissor, d.element = h.element, d.models = h.models, d.enableWheel = h.enableWheel, d.enableIOSEDR = (r = h.enableIOSEDR) !== null && r !== void 0 ? r : false, d.enableEDL = (o = h.enableEDL) !== null && o !== void 0 ? o : true, d.enableHQ = (s = h.enableHQ) !== null && s !== void 0 ? s : true, d.works = h.works, d.imageOptions = h.imageOptions, d.videoTexture = h.videoTexture, d.extraElements = h.extraElements, d.initial = h.initial, d.currentPano = typeof d.initial.state.panoIndex == "number" ? {
        workCode: (c = (u = d.initial.state.workCode) !== null && u !== void 0 ? u : (l = h.works[0]) === null || l === void 0 ? void 0 : l.workCode) !== null && c !== void 0 ? c : "",
        panoIndex: d.initial.state.panoIndex
      } : {
        workCode: d.initial.currentState.workCode,
        panoIndex: d.initial.currentState.panoIndex
      }, d.needsRender = true, d.modelSceneNeedsRender = true, d.cameraMotion = new Motion({
        longitude: {
          value: d.camera.pose.longitude,
          circle: [0, Math.PI * 2]
        },
        latitude: d.camera.pose.latitude,
        fov: d.camera.pose.fov
      }), d.inMomentumMovement = null, d.eventUnbinds = [h.element].concat(h.extraElements || []).map(function(g) {
        return d.bindEvents(g);
      }), d.pending.add("init-animation"), d.initAnimationReady = new Promise(function(g) {
        AnimationFrameLoop.shared.add(function() {
          d.initAnimation().then(function() {
            d.pending.delete("init-animation"), g();
          });
        }, true);
      }), d.initAnimationIsReady = false, d.initAnimationReady.then(function() {
        return d.initAnimationIsReady = true;
      }), d.modelScene = h.modelScene;
      var v = new Vector2();
      d.renderer.getDrawingBufferSize(v), d.modelRenderTarget = h.modelRenderTarget, d.copyPass = new CopyPass(d.renderer), d.depthCopyPass = new DepthCopyPass(d.renderer), d.screenBuffers = [], d.lastPostProcessingType = null, d.enableLayeringRendering = h.enableLayeringRendering;
      var A = (f = d.renderer) === null || f === void 0 ? void 0 : f.getContext();
      return d.enableFragDepth = d.enableLayeringRendering && (typeof WebGL2RenderingContext != "undefined" && A instanceof WebGL2RenderingContext || A.getExtension("EXT_frag_depth") !== null), d;
    }
    return t.parseArgs = function(e) {
      return e instanceof t ? e : __assign({}, e);
    }, t.initAnimationEndState = function(e) {
      var r, o, s, u, l, c, f, d, h = this.parseArgs(e), v = h.initial, A = v.state, g = v.currentState, p = typeof A.panoIndex == "number" ? {
        workCode: (s = (r = A.workCode) !== null && r !== void 0 ? r : (o = h.works[0]) === null || o === void 0 ? void 0 : o.workCode) !== null && s !== void 0 ? s : "",
        panoIndex: A.panoIndex
      } : {
        workCode: g.workCode,
        panoIndex: g.panoIndex
      };
      return __assign(__assign({}, p), { mode: "", longitude: (u = A.longitude) !== null && u !== void 0 ? u : g.longitude, latitude: (l = A.latitude) !== null && l !== void 0 ? l : g.latitude, fov: (c = A.fov) !== null && c !== void 0 ? c : g.fov, offset: (f = A.offset) !== null && f !== void 0 ? f : g.offset, distance: (d = A.distance) !== null && d !== void 0 ? d : g.distance });
    }, t.prototype.updateConfiguration = function(e) {
      return true;
    }, t.prototype.destroy = function() {
      var e;
      this.stopMomentumMovement(), this.destroyed = true, this.off(), this.cameraMotion.dispose();
      for (var r = 0, o = this.eventUnbinds; r < o.length; r++) {
        var s = o[r];
        s();
      }
      this.copyEffect && (this.copyEffect.dispose(), delete this.copyEffect), delete this.panState, (e = this.pressState) === null || e === void 0 || e.stop(), delete this.pressState;
    }, t.prototype.isReady = function() {
      return this.inMomentumMovement === null && this.pending.size === 0 && this.cameraMotion.ended === true;
    }, t.prototype.bindExtraElement = function(e) {
      for (var r = 0, o = this.eventUnbinds; r < o.length; r++) {
        var s = o[r];
        if (s.element === e)
          return;
      }
      this.eventUnbinds.push(this.bindEvents(e));
    }, t.prototype.unbindExtraElement = function(e) {
      for (var r = [], o = 0, s = this.eventUnbinds; o < s.length; o++) {
        var u = s[o];
        u.element === e ? u() : r.push(u);
      }
      this.eventUnbinds = r;
    }, t.prototype.updateRenderSize = function(e) {
      this.needsRender = true, this.modelSceneNeedsRender = true, this.modelRenderTarget.setSize(e.x, e.y), this.screenBuffers.forEach(function(r) {
        r !== null && r.setSize(e.x, e.y);
      });
    }, t.prototype.updateModel = function(e) {
      this.needsRender = true, this.modelSceneNeedsRender = true;
    }, t.prototype.updateWork = function(e, r, o, s) {
      return this.works = e, this.userAction = s, false;
    }, t.prototype.updateTime = function(e, r) {
      if (!this.destroyed) {
        var o = {};
        this.cameraMotion.ended && (this.cameraMotion.update(e), o.longitude = this.cameraMotion.value.longitude, o.latitude = this.cameraMotion.value.latitude, o.fov = this.cameraMotion.value.fov), isEmptyObject(o) && this.setCamera(o);
      }
    }, t.prototype.render = function(e, r) {
      var o = this.renderer.getRenderTarget();
      this.updateScreenBuffer(r), this.enableFragDepth ? (e && (this.renderer.setRenderTarget(this.modelRenderTarget), this.renderer.render(this.modelScene, this.camera)), this.depthCopyPass.render(this.modelRenderTarget.depthTexture, o), this.renderer.autoClearDepth = false, this.renderer.autoClearColor = true, this.copyPass.render(this.modelRenderTarget, o), this.renderer.setRenderTarget(o), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, this.camera), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true) : (this.renderer.render(this.modelScene, this.camera), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, this.camera), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true);
    }, t.prototype.postProcessing = function(e, r) {
      this.destroyed;
    }, t.prototype.updateCamera = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        var u = {};
        return e.longitude !== void 0 && (u.longitude = e.longitude), e.latitude !== void 0 && (u.latitude = e.latitude), e.fov !== void 0 && (u.fov = e.fov), s.cameraMotion.set(u, r).catch(noop$1);
      });
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        for (var u = [], l = 0, c = e; l < c.length; l++) {
          var f = c[l];
          u.push({
            key: f.key,
            progress: f.progress,
            value: {
              longitude: f.value.longitude,
              latitude: f.value.latitude,
              fov: f.value.fov
            }
          });
        }
        return s.cameraMotion.setKeyframes(u, r);
      });
    }, t.prototype.getTargetState = function() {
      var e = this.cameraMotion.getKeyFrameSegment(now())[1];
      return __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: e.value.longitude, latitude: e.value.latitude, fov: e.value.fov, offset: this.camera.pose.offset.clone(), distance: this.camera.pose.distance });
    }, t.prototype.initAnimation = function() {
      var e = this.initial;
      e.state, e.currentState, e.duration;
      var r = e.userAction, o = t.initAnimationEndState(this);
      return this.userAction = r, this.emit("initAnimation.start", createEvent("initAnimation.start", {
        state: o,
        userAction: this.userAction
      })), this.emit("initAnimation.end", createEvent("initAnimation.end", {
        state: o,
        userAction: this.userAction
      })), Promise.resolve();
    }, t.prototype.setCamera = function(e) {
      var r, o, s, u, l;
      e === void 0 && (e = {});
      var c = (r = e.longitude) !== null && r !== void 0 ? r : this.camera.pose.longitude, f = (o = e.latitude) !== null && o !== void 0 ? o : this.camera.pose.latitude, d = (s = e.fov) !== null && s !== void 0 ? s : this.camera.pose.fov, h = (u = e.distance) !== null && u !== void 0 ? u : this.camera.pose.distance, v = (l = e.offset) !== null && l !== void 0 ? l : this.camera.pose.offset, A = notSimilarValue(c, this.camera.pose.longitude, Math.PI * 2) || notSimilarValue(f, this.camera.pose.latitude), g = notSimilarValue(d, this.camera.pose.fov), p = notSimilarValue(h, this.camera.pose.distance), y = notSimilarVector3(v, this.camera.pose.offset);
      (g || A || y || p) && (this.camera.setFromPose({ longitude: c, latitude: f, fov: d, distance: h, offset: v }), this.emit("camera.update", createEvent("camera.update", {
        userAction: this.userAction,
        state: __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: c, latitude: f, fov: d, offset: v, distance: h })
      })), this.needsRender = true, this.modelSceneNeedsRender = true);
    }, t.prototype.stopMomentumMovement = function() {
      if (this.inMomentumMovement && this.inMomentumMovement.event && !this.inMomentumMovement.event.defaultPrevented && !this.inMomentumMovement.event.isFinal) {
        var e = createEvent("gesture.momentum", __assign(__assign({}, this.inMomentumMovement.event), { isFirst: false, isFinal: true }));
        this.emit("gesture.momentum", e);
      }
      this.inMomentumMovement = null;
    }, t.prototype.onPanGesture = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.pan", e);
    }, t.prototype.onTapGesture = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.tap", e);
    }, t.prototype.onDblTapGesture = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.dbltap", e), !e.defaultPrevented && (e.type = "gesture.tap", this.onTapGesture(e));
    }, t.prototype.onPressGesture = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.press", e);
    }, t.prototype.onPinchGesture = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.pinch", e);
    }, t.prototype.onMouseWheel = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.mousewheel", e);
    }, t.prototype.onMouseMove = function(e) {
      this.stopMomentumMovement(), this.emit("gesture.mousemove", e);
    }, t.prototype.relativeClientPosition = function(e) {
      return calculateThreeMouse(e, this.element, this.scissor);
    }, t.prototype.bindEvents = function(e) {
      var r = this, o = function(C) {
        var I = calculateThreeMouse(C, r.element, r.scissor);
        return !(Math.abs(I.x) > 1 || Math.abs(I.y) > 1);
      }, s = new Hammer.Manager(e), u = function(C) {
        var I = C.session;
        return I.firstInput || null;
      }, l = new Hammer.Pan({ threshold: 10, pointers: 0 }), c = new Hammer.Tap({ interval: 410 }), f = new Hammer.Pinch({ threshold: 0, pointers: 2 });
      s.add([
        l,
        // dblTapRecogniser,
        c,
        f
      ]), s.on("panstart pan", function(C) {
        var I = u(s);
        if (!(I && !o(I.center))) {
          var _ = createEvent("gesture.pan", {
            target: C.target,
            pointerType: C.pointerType,
            srcEvent: C.srcEvent,
            pointers: C.pointers.map(function(O) {
              var P = r.relativeClientPosition(O), N = new Raycaster();
              return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                x: O.x,
                y: O.y,
                delta: 0,
                buttons: 0,
                coords: P,
                raycaster: N
              };
            }),
            isFirst: C.isFirst,
            isFinal: C.isFinal,
            scale: C.scale,
            center: function(O) {
              var P = r.relativeClientPosition(O), N = new Raycaster();
              return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                x: O.x,
                y: O.y,
                delta: 0,
                buttons: 0,
                coords: P,
                raycaster: N
              };
            }(C.center),
            velocityX: C.velocityX,
            velocityY: C.velocityY,
            overallVelocityX: C.overallVelocityX,
            overallVelocityY: C.overallVelocityY,
            userAction: true,
            state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
          });
          r.onPanGesture(_), b();
        }
      }), s.on("tap", function(C) {
        if (!(C.pointerType === "mouse" && C.srcEvent.button !== 0)) {
          var I = u(s);
          if (!(I && !o(I.center))) {
            var _ = createEvent("gesture.tap", {
              target: C.target,
              pointerType: C.pointerType,
              srcEvent: C.srcEvent,
              pointers: C.pointers.map(function(O) {
                var P = r.relativeClientPosition(O), N = new Raycaster();
                return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                  x: O.x,
                  y: O.y,
                  delta: 0,
                  buttons: 0,
                  coords: P,
                  raycaster: N
                };
              }),
              isFirst: true,
              isFinal: true,
              scale: C.scale,
              center: function(O) {
                var P = r.relativeClientPosition(O), N = new Raycaster();
                return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                  x: O.x,
                  y: O.y,
                  delta: 0,
                  buttons: 0,
                  coords: P,
                  raycaster: N
                };
              }(C.center),
              velocityX: C.velocityX,
              velocityY: C.velocityY,
              overallVelocityX: C.overallVelocityX,
              overallVelocityY: C.overallVelocityY,
              userAction: true,
              state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
            });
            r.onTapGesture(_), b();
          }
        }
      }), s.on("pinchstart pinch pinchend", function(C) {
        var I = u(s);
        if (!(I && !o(I.center))) {
          var _ = createEvent("gesture.pinch", {
            target: C.target,
            pointerType: C.pointerType,
            srcEvent: C.srcEvent,
            pointers: C.pointers.map(function(O) {
              var P, N = r.relativeClientPosition(O), k = new Raycaster();
              return k.params.Points = { threshold: 0.1 }, k.setFromCamera(N, r.camera), {
                x: O.x,
                y: O.y,
                delta: (P = O.delta) !== null && P !== void 0 ? P : 0,
                buttons: 0,
                coords: N,
                raycaster: k
              };
            }),
            isFirst: C.type === "pinchstart",
            isFinal: C.type === "pinchend",
            scale: C.scale,
            center: function(O) {
              var P = r.relativeClientPosition(O), N = new Raycaster();
              return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                x: O.x,
                y: O.y,
                delta: 0,
                buttons: 0,
                coords: P,
                raycaster: N
              };
            }(C.center),
            velocityX: C.velocityX,
            velocityY: C.velocityY,
            overallVelocityX: C.overallVelocityX,
            overallVelocityY: C.overallVelocityY,
            userAction: true,
            state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
          });
          r.onPinchGesture(_), b();
        }
      }), s.on("dbltap", function(C) {
        if (!(C.pointerType === "mouse" && C.srcEvent.button !== 0)) {
          var I = u(s);
          if (!(I && !o(I.center))) {
            var _ = createEvent("gesture.dbltap", {
              target: C.target,
              pointerType: C.pointerType,
              srcEvent: C.srcEvent,
              pointers: C.pointers.map(function(O) {
                var P = r.relativeClientPosition(O), N = new Raycaster();
                return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                  x: O.x,
                  y: O.y,
                  delta: 0,
                  buttons: 0,
                  coords: P,
                  raycaster: N
                };
              }),
              isFirst: true,
              isFinal: true,
              scale: C.scale,
              center: function(O) {
                var P = r.relativeClientPosition(O), N = new Raycaster();
                return N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera), {
                  x: O.x,
                  y: O.y,
                  delta: 0,
                  buttons: 0,
                  coords: P,
                  raycaster: N
                };
              }(C.center),
              velocityX: C.velocityX,
              velocityY: C.velocityY,
              overallVelocityX: C.overallVelocityX,
              overallVelocityY: C.overallVelocityY,
              userAction: true,
              state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
            });
            r.onDblTapGesture(_), b();
          }
        }
      });
      var d = null, h = null, v = function(C, I, _) {
        var O = {
          x: _.clientX,
          y: _.clientY
        }, P = r.relativeClientPosition(O), N = new Raycaster();
        N.params.Points = { threshold: 0.1 }, N.setFromCamera(P, r.camera);
        var k = __assign(__assign({}, O), { coords: P, raycaster: N, buttons: _.buttons, delta: 0 }), U = C === "pinchend" ? I : I - _.deltaY / 280, D = createEvent("gesture.pinch", {
          target: _.target,
          pointerType: "mouse",
          srcEvent: _,
          pointers: [__assign({}, k)],
          isFirst: C === "pinchstart",
          isFinal: C === "pinchend",
          scale: clamp$1(U, 0.1, 10),
          center: __assign({}, k),
          velocityX: 0,
          velocityY: 0,
          overallVelocityX: 0,
          overallVelocityY: 0,
          userAction: true,
          state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
        });
        return D;
      }, A = function(C) {
        var I, _ = { x: C.clientX, y: C.clientY };
        if (o(_)) {
          if (C.preventDefault(), C.ctrlKey) {
            var O = (I = d == null ? void 0 : d.prevEvent.scale) !== null && I !== void 0 ? I : 1, P = v(d ? "pinch" : "pinchstart", O, C);
            d === null ? d = {
              firstEvent: P,
              prevEvent: P
            } : d.prevEvent = P, r.onPinchGesture(P), h !== null && window.clearTimeout(h), h = window.setTimeout(function() {
              var Q;
              h = null;
              var G = (Q = d == null ? void 0 : d.prevEvent.scale) !== null && Q !== void 0 ? Q : 1, X = v("pinchend", G, C);
              d = null, r.onPinchGesture(X);
            }, 200);
          } else {
            var N = (Math.abs(C.deltaY) > Math.abs(C.deltaX) ? C.deltaY : C.deltaX) / -60, k = r.mouseWheelState !== void 0, U = {
              x: C.clientX,
              y: C.clientY
            }, D = r.relativeClientPosition(U), q = new Raycaster();
            q.params.Points = { threshold: 0.1 }, q.setFromCamera(D, r.camera);
            var z = __assign(__assign({}, U), { coords: D, raycaster: q, buttons: C.buttons, delta: N }), P = createEvent("gesture.mousewheel", {
              target: C.target,
              pointerType: "mouse",
              srcEvent: C,
              pointers: [__assign({}, z)],
              isFirst: k,
              isFinal: false,
              scale: 0,
              center: __assign({}, z),
              velocityX: 0,
              velocityY: 0,
              overallVelocityX: 0,
              overallVelocityY: 0,
              userAction: true,
              state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
            });
            r.onMouseWheel(P), r.mouseWheelState && clearTimeout(r.mouseWheelState.timer), r.mouseWheelState = {
              timer: setTimeout(function() {
                delete r.mouseWheelState;
                var G = createEvent("gesture.mousewheel", {
                  target: C.target,
                  pointerType: "mouse",
                  srcEvent: C,
                  pointers: [__assign(__assign({}, z), { delta: 0 })],
                  isFirst: false,
                  isFinal: true,
                  scale: 0,
                  center: __assign(__assign({}, z), { delta: 0 }),
                  velocityX: 0,
                  velocityY: 0,
                  overallVelocityX: 0,
                  overallVelocityY: 0,
                  userAction: true,
                  state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
                });
                r.onMouseWheel(G);
              }, 100)
            };
          }
          b();
        }
      }, g = function(C) {
        if (!isMobile) {
          if (!o({ x: C.clientX, y: C.clientY })) {
            p();
            return;
          }
          var I = false;
          r.mouseMoveState || (I = true);
          var _ = {
            x: C.clientX,
            y: C.clientY
          }, O = r.relativeClientPosition(_), P = new Raycaster();
          P.params.Points = { threshold: 0.1 }, P.setFromCamera(O, r.camera);
          var N = __assign(__assign({}, _), { coords: O, raycaster: P, buttons: C.buttons, delta: 0 }), k = createEvent("gesture.mousemove", {
            target: C.target,
            pointerType: "mouse",
            srcEvent: C,
            pointers: [__assign({}, N)],
            isFirst: I,
            isFinal: false,
            scale: 0,
            center: __assign({}, N),
            velocityX: 0,
            velocityY: 0,
            overallVelocityX: 0,
            overallVelocityY: 0,
            userAction: true,
            state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
          });
          r.mouseMoveState = {
            timeStamp: now(),
            event: k
          }, r.onMouseMove(k), r.pressState && Math.abs(C.clientX - r.pressState.event.center.y) > 10 && Math.abs(C.clientY - r.pressState.event.center.y) > 10 && b();
        }
      }, p = function() {
        if (r.mouseMoveState) {
          var C = createEvent(r.mouseMoveState.event.type, __assign(__assign({}, r.mouseMoveState.event), { isFinal: true }));
          delete r.mouseMoveState, r.onMouseMove(C);
        }
        b();
      }, y = function(C) {
        if (!o(C.center)) {
          b();
          return;
        }
        var I = false;
        r.pressState || (I = true, r.pressState = {
          event: C,
          timeStamp: now(),
          stop: noop$1
        });
        var _ = now() - r.pressState.timeStamp, O = createEvent(r.pressState.event.type, __assign(__assign({}, r.pressState.event), { isFirst: I, isFinal: false, center: __assign(__assign({}, r.pressState.event.center), { delta: _ }), pointers: r.pressState.event.pointers.map(function(P) {
          return __assign(__assign({}, P), { delta: _ });
        }) }));
        r.onPressGesture(O), r.pressState && (r.pressState.stop = AnimationFrameLoop.shared.add(function(P) {
          y(C);
        }, true, 1));
      }, m = function(C) {
        if (b(), !(C.touches.length > 1 || C.changedTouches.length <= 0)) {
          var I = {
            x: C.changedTouches[0].clientX,
            y: C.changedTouches[0].clientY
          }, _ = r.relativeClientPosition(I), O = new Raycaster();
          O.params.Points = { threshold: 0.1 }, O.setFromCamera(_, r.camera);
          var P = __assign(__assign({}, I), { coords: _, raycaster: O, buttons: 0, delta: 0 }), N = createEvent("gesture.press", {
            target: C.target,
            pointerType: "touch",
            srcEvent: C,
            pointers: [__assign({}, P)],
            isFirst: false,
            isFinal: false,
            scale: 0,
            center: P,
            velocityX: 0,
            velocityY: 0,
            overallVelocityX: 0,
            overallVelocityY: 0,
            userAction: true,
            state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
          });
          y(N);
        }
      }, E = function(C) {
        b();
        var I = {
          x: C.clientX,
          y: C.clientY
        }, _ = r.relativeClientPosition(I), O = new Raycaster();
        O.params.Points = { threshold: 0.1 }, O.setFromCamera(_, r.camera);
        var P = __assign(__assign({}, I), { coords: _, raycaster: O, buttons: C.buttons, delta: 0 }), N = createEvent("gesture.press", {
          target: C.target,
          pointerType: "mouse",
          srcEvent: C,
          pointers: [__assign({}, P)],
          isFirst: false,
          isFinal: false,
          scale: 0,
          center: P,
          velocityX: 0,
          velocityY: 0,
          overallVelocityX: 0,
          overallVelocityY: 0,
          userAction: true,
          state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
        });
        y(N);
      }, b = function() {
        var C;
        if (r.pressState) {
          var I = now() - r.pressState.timeStamp, _ = createEvent(r.pressState.event.type, __assign(__assign({}, r.pressState.event), { center: __assign(__assign({}, r.pressState.event.center), { delta: I }), isFirst: false, isFinal: true, pointers: r.pressState.event.pointers.map(function(O) {
            return __assign(__assign({}, O), { delta: I });
          }) }));
          r.onPressGesture(_), (C = r.pressState) === null || C === void 0 || C.stop(), delete r.pressState;
        }
      }, T = null, R = function(C) {
        var I, _ = false, O = false;
        switch (C.type) {
          case "gesturestart":
            _ = true;
            break;
          case "gestureend":
            O = true;
            break;
        }
        var P = {
          x: C.clientX,
          y: C.clientY
        }, N = r.relativeClientPosition(P), k = new Raycaster();
        k.params.Points = { threshold: 0.1 }, k.setFromCamera(N, r.camera);
        var U = __assign(__assign({}, P), { coords: N, raycaster: k, buttons: 0, delta: 0 }), D = createEvent("gesture.pinch", {
          target: C.target,
          pointerType: "mouse",
          srcEvent: C,
          pointers: [__assign({}, U)],
          isFirst: _,
          isFinal: O,
          scale: (I = C.scale) !== null && I !== void 0 ? I : 1,
          center: __assign({}, U),
          velocityX: 0,
          velocityY: 0,
          overallVelocityX: 0,
          overallVelocityY: 0,
          userAction: true,
          state: __assign(__assign({ mode: r.mode }, r.currentPano), clonePose(r.camera.pose))
        });
        return D;
      }, S = function(C) {
        if (C.preventDefault(), !isMobile) {
          var I = R(C);
          T = {
            firstEvent: I
          };
          var _ = T.firstEvent;
          _ && !o(_.center) || r.onPinchGesture(I);
        }
      }, M = function(C) {
        if (C.preventDefault(), !isMobile && T) {
          var I = R(C), _ = T.firstEvent;
          _ && !o(_.center) || r.onPinchGesture(I);
        }
      }, w = function(C) {
        if (C.preventDefault(), !isMobile && T) {
          var I = R(C), _ = T.firstEvent;
          T = null, !(_ && !o(_.center)) && r.onPinchGesture(I);
        }
      }, H = function(C) {
        if (C && typeof C.preventDefault == "function" && C.currentTarget === e && C.preventDefault(), typeof getSelection == "function") {
          var I = getSelection();
          I && I.focusNode && (I.removeAllRanges && I.removeAllRanges(), I.empty && I.empty());
        }
      };
      this.enableWheel && e.addEventListener("wheel", A, { passive: false }), e.addEventListener("mousemove", g, false), e.addEventListener("mouseout", p, false), e.addEventListener("touchstart", m, { passive: true }), e.addEventListener("touchend", b, false), e.addEventListener("touchcancel", b, false), e.addEventListener("mousedown", E, false), e.addEventListener("mouseup", b, false), e.addEventListener("gesturestart", S, { passive: false }), e.addEventListener("gesturechange", M, { passive: false }), e.addEventListener("gestureend", w, { passive: false }), e.addEventListener("touchstart", H, { passive: false }), e.addEventListener("contextmenu", H, false);
      var L = function() {
        s.destroy(), e.removeEventListener("wheel", A, false), e.removeEventListener("mousemove", g, false), e.removeEventListener("mouseout", p, false), e.removeEventListener("touchstart", m, false), e.removeEventListener("touchend", b, false), e.removeEventListener("touchcancel", b, false), e.removeEventListener("mousedown", E, false), e.removeEventListener("mouseup", b, false), e.removeEventListener("gesturestart", S, false), e.removeEventListener("gesturechange", M, false), e.removeEventListener("gestureend", w, false), e.removeEventListener("touchstart", H, false), e.removeEventListener("contextmenu", H, false);
      };
      return Object.assign(L, { element: e });
    }, t.prototype.preloadPano = function(e, r) {
      var o = this;
      r === void 0 && (r = noop$1);
      var s = this.works.getResolvedObserver(e);
      if (!s)
        return Promise.resolve();
      var u = ["right", "left", "up", "down", "front", "back"];
      return Promise.all(u.map(function(l) {
        var c = __assign({ key: "pano.".concat(panoStringify(e), ".").concat(l) }, pick(o.imageOptions, ["size", "format", "quality", "mappings"])), f = s.images[l], d = applyImageURLOptions(f, o.imageOptions.transform, c);
        return getFetcher(s.work).preload(d, { timeout: 500 });
      })).then(function() {
        return r(e), e;
      });
    }, t.prototype.updateScreenBuffer = function(e) {
      var r, o, s, u, l, c;
      if (this.lastPostProcessingType !== e)
        if (this.lastPostProcessingType = e, e === "luminance") {
          if (this.screenBuffers.length === 0) {
            var f = this.renderer.getDrawingBufferSize(sharedVector2$1);
            this.screenBuffers = [
              new WebGLRenderTarget(f.x, f.y, {
                generateMipmaps: false,
                encoding: (o = (r = this.renderer) === null || r === void 0 ? void 0 : r.outputEncoding) !== null && o !== void 0 ? o : sRGBEncoding
              }),
              this.enableFragDepth ? this.modelRenderTarget : null
            ];
          }
        } else if (e === "edl") {
          if (this.screenBuffers.length === 0) {
            var f = this.renderer.getDrawingBufferSize(sharedVector2$1);
            this.screenBuffers = [
              new WebGLRenderTarget(f.x, f.y, {
                generateMipmaps: false,
                encoding: (u = (s = this.renderer) === null || s === void 0 ? void 0 : s.outputEncoding) !== null && u !== void 0 ? u : sRGBEncoding,
                minFilter: NearestFilter,
                magFilter: NearestFilter,
                format: RGBAFormat,
                type: FloatType
              }),
              this.enableFragDepth ? this.modelRenderTarget : null
            ];
          }
          this.models.setMaterial({
            useEDL: true
          });
        } else if (e === "hq") {
          if (this.screenBuffers.length === 0) {
            var f = this.renderer.getDrawingBufferSize(sharedVector2$1), d = new WebGLRenderTarget(f.x, f.y, {
              generateMipmaps: false,
              minFilter: NearestFilter,
              magFilter: NearestFilter,
              format: RGBAFormat,
              type: FloatType,
              depthTexture: new DepthTexture(f.x, f.y, UnsignedIntType)
            });
            d.depthTexture.format = DepthFormat, d.depthBuffer = true;
            var h = new WebGLRenderTarget(f.x, f.y, {
              generateMipmaps: false,
              encoding: (c = (l = this.renderer) === null || l === void 0 ? void 0 : l.outputEncoding) !== null && c !== void 0 ? c : sRGBEncoding,
              minFilter: NearestFilter,
              magFilter: NearestFilter,
              format: RGBAFormat,
              type: FloatType,
              depthTexture: d.depthTexture
            });
            this.screenBuffers = [
              d,
              h,
              this.enableFragDepth ? this.modelRenderTarget : null
            ];
          }
          this.models.setMaterial({
            useHQDepth: true,
            useHQWeight: false,
            pointShape: "CIRCLE"
          });
        } else
          this.screenBuffers && (this.screenBuffers.forEach(function(v) {
            v !== null && v.dispose();
          }), this.screenBuffers = []), this.models.setMaterial({
            useEDL: false,
            useHQDepth: false,
            useHQWeight: false
          });
    }, t;
  }(Subscribe)
);
var defaultFloorplanControllerCustomInitArgs = {
  defaultLongitude: Math.PI / 4,
  defaultLatitude: Math.PI / 4,
  defaultFov: 80,
  maxFov: 120,
  minFov: 20,
  maxLatitude: +Math.PI / 2,
  minLatitude: -Math.PI / 2,
  intersectMeshCreator: function() {
    return new IntersectMesh();
  }
};
var FloorplanController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o, s = t.parseArgs(e);
      return r = n45.call(this, s) || this, r.mode = "Floorplan", r.defaultLongitude = s.defaultLongitude, r.defaultLatitude = s.defaultLatitude, r.defaultFov = s.defaultFov, r.maxFov = s.maxFov, r.minFov = s.minFov, r.maxLatitude = s.maxLatitude, r.minLatitude = s.minLatitude, r.locationMotion = new Motion({
        x: r.camera.pose.offset.x,
        y: r.camera.pose.offset.y,
        z: r.camera.pose.offset.z,
        distance: r.camera.pose.distance
      }), r.modelAlphaMotion = new Motion({
        modelAlpha: (o = r.models.getMaterial().modelAlpha) !== null && o !== void 0 ? o : 0
      }), r.perspToOrthoMotion = new Motion({
        perspToOrtho: r.camera.perspToOrtho.x
      }), r.currentTapId = null, r.intersectMeshCreator = s.intersectMeshCreator, r.intersectMesh = r.intersectMeshCreator(), r.intersectMesh.name = "intersect", r.intersectMesh.visible = false, r.helper.add(r.intersectMesh), r;
    }
    return t.distanceFromModel = function(e, r, o) {
      var s = e.bounding, u = Math.pow(Math.pow(s.max.x - s.min.x + 1, 2) + Math.pow(s.max.y - s.min.y + 1, 2) + Math.pow(s.max.z - s.min.z + 1, 2), 1 / 2), l = u / 2 / Math.tan(Math.PI * r / 360);
      return o < 1 && (l = l / o), isNaN(l) ? u : l;
    }, t.parseArgs = function(e) {
      var r, o, s, u, l, c, f, d;
      if (e instanceof t)
        return e;
      var h = n45.parseArgs.call(this, e);
      return __assign(__assign({}, h), { defaultLongitude: (r = e.defaultLongitude) !== null && r !== void 0 ? r : defaultFloorplanControllerCustomInitArgs.defaultLongitude, defaultLatitude: (o = e.defaultLatitude) !== null && o !== void 0 ? o : defaultFloorplanControllerCustomInitArgs.defaultLatitude, defaultFov: (s = e.defaultFov) !== null && s !== void 0 ? s : defaultFloorplanControllerCustomInitArgs.defaultFov, maxFov: (u = e.maxFov) !== null && u !== void 0 ? u : defaultFloorplanControllerCustomInitArgs.maxFov, minFov: (l = e.minFov) !== null && l !== void 0 ? l : defaultFloorplanControllerCustomInitArgs.minFov, maxLatitude: (c = e.maxLatitude) !== null && c !== void 0 ? c : defaultFloorplanControllerCustomInitArgs.maxLatitude, minLatitude: (f = e.minLatitude) !== null && f !== void 0 ? f : defaultFloorplanControllerCustomInitArgs.minLatitude, intersectMeshCreator: (d = e.intersectMeshCreator) !== null && d !== void 0 ? d : defaultFloorplanControllerCustomInitArgs.intersectMeshCreator });
    }, t.initAnimationEndState = function(e) {
      var r, o, s, u, l, c, f, d = this.parseArgs(e), h = e.initial, v = h.state, A = h.currentState, g = typeof v.panoIndex == "number" ? {
        workCode: (s = (r = v.workCode) !== null && r !== void 0 ? r : (o = d.works[0]) === null || o === void 0 ? void 0 : o.workCode) !== null && s !== void 0 ? s : "",
        panoIndex: v.panoIndex
      } : {
        workCode: A.workCode,
        panoIndex: A.panoIndex
      }, p = __assign(__assign({}, g), { mode: "Floorplan", longitude: (u = v.longitude) !== null && u !== void 0 ? u : isThirdPersonMode(A.mode) ? A.longitude : d.defaultLongitude, latitude: clamp$1((l = v.latitude) !== null && l !== void 0 ? l : A.mode === "Floorplan" ? A.latitude : d.defaultLatitude, d.minLatitude, d.maxLatitude), fov: (c = v.fov) !== null && c !== void 0 ? c : d.defaultFov, offset: v.offset ? v.offset.clone() : e.models.bounding.getCenter(new Vector3()), distance: (f = v.distance) !== null && f !== void 0 ? f : t.distanceFromModel(d.models, d.defaultFov, d.camera.aspect) });
      return p;
    }, t.prototype.updateConfiguration = function(e) {
      var r = n45.prototype.updateConfiguration.call(this, e);
      if (r === false)
        return false;
      if (e.defaultLongitude !== void 0 && this.defaultLongitude !== e.defaultLongitude && (this.defaultLongitude = e.defaultLongitude), e.defaultLatitude !== void 0 && this.defaultLatitude !== e.defaultLatitude && (this.defaultLatitude = e.defaultLatitude), e.defaultFov !== void 0 && this.defaultFov !== e.defaultFov && (this.defaultFov = e.defaultFov), e.maxFov !== void 0 && this.maxFov !== e.maxFov && (this.maxFov = e.maxFov), e.minFov !== void 0 && this.minFov !== e.minFov && (this.minFov = e.minFov), e.maxLatitude !== void 0 && this.maxLatitude !== e.maxLatitude && (this.maxLatitude = e.maxLatitude), e.minLatitude !== void 0 && this.minLatitude !== e.minLatitude && (this.minLatitude = e.minLatitude), e.intersectMeshCreator !== void 0 && this.intersectMeshCreator !== e.intersectMeshCreator) {
        this.intersectMeshCreator = e.intersectMeshCreator;
        var o = this.intersectMesh;
        this.intersectMesh = this.intersectMeshCreator(), this.intersectMesh.name = o.name, this.intersectMesh.visible = o.visible;
        var s = this.intersectMesh.parent;
        s && s.add(this.intersectMesh), o.dispose();
      }
      return true;
    }, t.prototype.destroy = function() {
      n45.prototype.destroy.call(this), this.locationMotion.dispose(), delete this.panState, this.intersectMesh.dispose(), this.helper.remove(this.intersectMesh);
    }, t.prototype.isReady = function() {
      return this.locationMotion.ended === false ? false : n45.prototype.isReady.call(this);
    }, t.prototype.updateWork = function(e, r, o, s) {
      var u;
      return this.works = e, this.updateCamera(r, (u = o.duration) !== null && u !== void 0 ? u : 0, s), true;
    }, t.prototype.updateModel = function(e) {
      n45.prototype.updateModel.call(this, e);
      var r = e.bounding.getCenter(new Vector3()), o = t.distanceFromModel(e, this.defaultFov, this.camera.aspect);
      this.updateCamera({ offset: r, distance: o }, 0, true);
    }, t.prototype.updateCamera = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        var u = {}, l = {};
        return e.distance !== void 0 && (u.distance = e.distance), e.offset !== void 0 && (u.x = e.offset.x, u.y = e.offset.y, u.z = e.offset.z), e.longitude !== void 0 && (l.longitude = e.longitude), e.latitude !== void 0 && (l.latitude = e.latitude), e.fov !== void 0 && (l.fov = e.fov), s.locationMotion.set(u, r).catch(noop$1), s.cameraMotion.set(l, r).catch(noop$1);
      });
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        for (var u = [], l = [], c = 0, f = e; c < f.length; c++) {
          var d = f[c];
          u.push({
            key: d.key,
            progress: d.progress,
            value: {
              distance: d.value.distance,
              x: d.value.offset.x,
              y: d.value.offset.x,
              z: d.value.offset.x
            }
          }), l.push({
            key: d.key,
            progress: d.progress,
            value: {
              longitude: d.value.longitude,
              latitude: d.value.latitude,
              fov: d.value.fov
            }
          });
        }
        return s.locationMotion.setKeyframes(u, r).catch(noop$1), s.cameraMotion.setKeyframes(e, r);
      });
    }, t.prototype.updateTime = function(e, r) {
      if (!this.destroyed) {
        var o = {}, s = {};
        if (this.modelAlphaMotion.ended || (this.modelAlphaMotion.update(e), o.modelAlpha = this.modelAlphaMotion.value.modelAlpha), this.perspToOrthoMotion.ended || (this.perspToOrthoMotion.update(e), this.camera.perspToOrtho.setScalar(clamp$1(this.perspToOrthoMotion.value.perspToOrtho, 0, 1))), this.locationMotion.ended || (this.locationMotion.update(e), s.distance = this.locationMotion.value.distance, s.offset = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z)), this.cameraMotion.ended || (this.cameraMotion.update(e), s.longitude = this.cameraMotion.value.longitude, s.latitude = this.cameraMotion.value.latitude, s.fov = this.cameraMotion.value.fov), isEmptyObject(o) || this.models.setMaterial(o), isEmptyObject(s) || this.setCamera(s), this.intersectMesh && this.intersectMesh.parent) {
          var u = this.camera.position.distanceTo(this.intersectMesh.position), l = 2 * Math.tan(0.5 * this.camera.fov / 180 * Math.PI), c = u * l / 5;
          this.intersectMesh.scale.setScalar(c);
        }
      }
    }, t.prototype.getTargetState = function() {
      var e = this.cameraMotion.getKeyFrameSegment(now())[1], r = this.locationMotion.getKeyFrameSegment(now())[1];
      return __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: e.value.longitude, latitude: e.value.latitude, fov: e.value.fov, offset: new Vector3(r.value.x, r.value.y, r.value.z), distance: r.value.distance });
    }, t.prototype.initAnimation = function() {
      var e = this;
      return this.destroyed ? Promise.resolve() : new Promise(function(r) {
        var o = e.initial;
        o.state, o.currentState;
        var s = o.duration, u = o.userAction;
        e.userAction = u;
        var l = t.initAnimationEndState(e), c = pick(l, ["longitude", "latitude", "fov"]), f = {
          x: l.offset.x,
          y: l.offset.y,
          z: l.offset.z,
          distance: l.distance
        }, d = {
          modelAlpha: 1
        }, h = {
          perspToOrtho: 0
        };
        e.emit("initAnimation.start", createEvent("initAnimation.start", {
          state: l,
          userAction: e.userAction
        })), e.modelAlphaMotion.set(d, s / 3).catch(noop$1), e.perspToOrthoMotion.set(h, s).catch(noop$1), e.cameraMotion.set(c, s).catch(noop$1), e.locationMotion.set(f, s).then(
          /* resolve */
          function() {
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: l,
              userAction: e.userAction
            }));
          },
          /* reject */
          function(v) {
            var A = __assign(__assign(__assign({}, e.currentPano), { mode: e.mode }), clonePose(e.camera.pose));
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: A,
              userAction: e.userAction
            }));
          }
        ).then(function() {
          r();
        });
      });
    }, t.prototype.updateRenderSize = function(e) {
      this.needsRender = true, this.modelSceneNeedsRender = true, this.screenBuffers.forEach(function(r) {
        r !== null && r.setSize(e.x, e.y);
      });
    }, t.prototype.getForwardObserverOrNot = function(e) {
      var r = this, o = this.models.intersectRaycaster(e)[0];
      if (!o)
        return null;
      var s = this.works.resolvedObservers.filter(function(f) {
        for (var d, h = 0, v = r.models; h < v.length; h++) {
          var A = v[h];
          if (A.visible && ((d = A.work) === null || d === void 0 ? void 0 : d.workCode) === f.work.workCode)
            return true;
        }
        return false;
      }), u = arrayMin(s, function(f) {
        return f.standingPosition.distanceTo(o.point);
      }, true), l = u[0], c = u[1];
      return l && c < 10 ? l : null;
    }, t.prototype.coordinatesForOffset = function(e) {
      var r = this.renderer.getSize(new Vector2());
      return {
        longitude: -2 * e.x / (r.x * this.scissor.width),
        latitude: 2 * e.y / (r.y * this.scissor.height)
      };
    }, t.prototype.requestMomentumMovement = function(e, r, o, s) {
      var u = this;
      if (this.inMomentumMovement !== null) {
        for (var l = __assign({}, o), c = { longitude: 0, latitude: 0 }, f = 0; f < s; f++)
          l.longitude *= 0.996, l.latitude *= 0.996 * 0.998, c.longitude += l.longitude, c.latitude += l.latitude;
        var d = formatRad(this.cameraMotion.value.longitude + c.longitude), h = clamp$1(this.cameraMotion.value.latitude + c.latitude, this.minLatitude, this.maxLatitude), v = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: d, latitude: h, fov: this.cameraMotion.value.fov, offset: this.camera.pose.offset.clone(), distance: this.camera.pose.distance }), A = !(l.longitude > 1e-4 || l.longitude < -1e-4 || l.latitude > 1e-4 || l.latitude < -1e-4), g = createEvent("gesture.momentum", __assign(__assign({}, e), { isFirst: r, isFinal: A, state: v }));
        if (this.inMomentumMovement.event = g, this.emit("gesture.momentum", g), e.defaultPrevented) {
          this.inMomentumMovement = null;
          return;
        }
        this.inMomentumMovement && (this.cameraMotion.set({ longitude: d, latitude: h }, 0).catch(noop$1), A ? this.inMomentumMovement = null : AnimationFrameLoop.shared.add(function(p, y) {
          u.requestMomentumMovement(e, false, l, y | 0);
        }, true, 1));
      }
    }, t.prototype.onPanGesture = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement(), this.hideIntersectMesh();
      var r = this.panState, o = e.pointers.length;
      if (e.isFinal ? delete this.panState : this.panState = {
        pointerLength: o,
        x: e.center.x,
        y: e.center.y
      }, !(typeof r == "undefined" || r.pointerLength !== o)) {
        var s = {
          x: e.center.x - r.x,
          y: e.center.y - r.y
        }, u = this.relativeClientPosition(e.center), l = this.camera.pose.latitude < Math.PI / 6 || u.y < 0 ? 1 : -1;
        s.x *= l;
        var c = this.coordinatesForOffset(s), f = formatRad(this.cameraMotion.value.longitude + c.longitude), d = clamp$1(this.cameraMotion.value.latitude + c.latitude, this.minLatitude, this.maxLatitude);
        this.camera.aspect < 1 && Math.abs(e.overallVelocityX) > 0.2 && Math.atan2(Math.abs(e.overallVelocityY), Math.abs(e.overallVelocityX)) < Math.PI / 6.923 && (d = this.cameraMotion.value.latitude);
        var h = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: f, latitude: d, fov: this.camera.pose.fov, offset: this.camera.pose.offset, distance: this.camera.pose.distance });
        if (e.state = h, this.emit("gesture.pan", e), !e.defaultPrevented && (this.cameraMotion.set({ longitude: h.longitude, latitude: h.latitude }, 0).catch(noop$1), e.isFinal)) {
          var v = e.velocityX * l, A = e.velocityY;
          this.inMomentumMovement = {
            uuid: createUuid()
          }, this.requestMomentumMovement(e, true, this.coordinatesForOffset({ x: v, y: A }), 0);
        }
      }
    }, t.prototype.onPinchGesture = function(e) {
      var r;
      if (this.initAnimationIsReady) {
        this.userAction = e.userAction, this.stopMomentumMovement();
        var o = (r = this.pinchState) === null || r === void 0 ? void 0 : r.fov;
        if (e.isFirst) {
          this.pinchState = {
            x: e.center.x,
            y: e.center.y,
            fov: this.cameraMotion.value.fov
          };
          return;
        }
        if (e.isFinal && (delete this.panState, delete this.pinchState), typeof o != "undefined") {
          var s = clamp$1(o / e.scale, this.minFov, this.maxFov);
          e.state.fov = s, this.emit("gesture.pinch", e), !e.defaultPrevented && (this.cameraMotion.set({ fov: s }, 0).catch(noop$1), this.onPanGesture(e));
        }
      }
    }, t.prototype.onMouseMove = function(e) {
      var r, o;
      if (this.intersectMesh.parent && !this.panState) {
        if (this.emit("gesture.mousemove", e), e.defaultPrevented) {
          this.hideIntersectMesh();
          return;
        }
        var s = e.center.raycaster;
        if (e.isFinal && this.intersectMesh.parent && this.intersectMesh.visible === true) {
          this.hideIntersectMesh();
          return;
        }
        var u = this.models.intersectRaycaster(s)[0], l = createEvent("intersect.update", {
          raycaster: s,
          intersection: u != null ? u : null,
          object: this.intersectMesh
        });
        if (this.emit("intersect.update", l), l.defaultPrevented) {
          this.hideIntersectMesh();
          return;
        }
        if (u) {
          var c = (o = (r = u.face) === null || r === void 0 ? void 0 : r.normal) !== null && o !== void 0 ? o : new Vector3().copy(s.ray.direction).multiplyScalar(-1), f = c.clone(), d = u.point.clone();
          this.intersectMesh.position.copy(d);
          var h = d.clone().add(f);
          if (this.intersectMesh.lookAt(h), Math.abs(c.y) > 0.99) {
            var v = this.camera.position.clone().sub(d);
            this.intersectMesh.rotation.z = -Math.atan2(v.z, v.x);
          }
          this.intersectMesh.visible = true, this.needsRender = true;
        } else
          this.hideIntersectMesh();
      }
    }, t.prototype.onMouseWheel = function(e) {
      if (this.initAnimationIsReady) {
        this.userAction = e.userAction, this.stopMomentumMovement();
        var r = this, o = r.minFov, s = r.maxFov, u = clamp$1(this.camera.fov - e.center.delta, o, s);
        e.state.fov = u, this.emit("gesture.mousewheel", e), !e.defaultPrevented && this.cameraMotion.set({ fov: u }, 0).catch(noop$1);
      }
    }, t.prototype.onTapGesture = function(e) {
      var r = this;
      this.userAction = true, this.stopMomentumMovement();
      var o = e.center.raycaster, s = this.getForwardObserverOrNot(o);
      if (!s)
        this.emit("gesture.tap", e);
      else {
        var u = {
          longitude: this.camera.pose.longitude,
          latitude: 0
        }, l = __assign(__assign({}, e.state), { mode: "Panorama", workCode: s.pano.workCode, panoIndex: s.pano.panoIndex, longitude: u.longitude, latitude: u.latitude, offset: s ? s.position.clone() : new Vector3(), distance: 0 });
        if (e.state = l, this.emit("gesture.tap", e), !e.defaultPrevented && (this.emit("pano.select", createEvent("pano.select", {
          prevPano: this.currentPano,
          state: l,
          userAction: e.userAction,
          options: u,
          progress: 0,
          error: null
        })), s && s.active)) {
          var c = this.currentTapId = createUuid();
          this.preloadPano(s.pano).then(function(f) {
            r.currentTapId === c && r.emit("pano.request", createEvent("pano.request", {
              userAction: true,
              prevPano: r.currentPano,
              progress: 0,
              state: l,
              options: u,
              error: null
            }));
          });
        }
      }
    }, t.prototype.onDblTapGesture = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement();
      var r = this.cameraMotion.value.fov, o = this.minFov - r < r - this.defaultFov ? this.minFov : this.defaultFov;
      e.state.fov = o, this.emit("gesture.dbltap", e), !e.defaultPrevented && (this.cameraMotion.set({ fov: o }, 360).catch(noop$1), this.hideIntersectMesh());
    }, t.prototype.hideIntersectMesh = function() {
      this.intersectMesh.visible = false, this.needsRender = true;
    }, t;
  }(BaseController)
);
var defaultTopviewControllerCustomInitArgs = __assign({}, omit(defaultFloorplanControllerCustomInitArgs, ["defaultLongitude", "defaultLatitude", "maxLatitude", "minLatitude"]));
var TopviewController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o = t.parseArgs(e);
      return r = n45.call(this, o) || this, r.mode = "Topview", r;
    }
    return t.parseArgs = function(e) {
      if (e instanceof t)
        return e;
      var r = __assign(__assign({}, e), { defaultLongitude: 0, defaultLatitude: Math.PI / 2 });
      return n45.parseArgs.call(this, r);
    }, t.initAnimationEndState = function(e) {
      var r = this.parseArgs(e), o = n45.initAnimationEndState.call(this, r);
      return __assign(__assign({}, o), { longitude: r.defaultLongitude, latitude: r.defaultLatitude, mode: "Topview" });
    }, t.prototype.updateConfiguration = function(e) {
      return n45.prototype.updateConfiguration.call(this, __assign(__assign({}, e), { defaultLongitude: 0, defaultLatitude: Math.PI / 2 }));
    }, t.prototype.updateModel = function(e) {
      this.needsRender = true, this.modelSceneNeedsRender = true;
      var r = this.models.bounding.getCenter(new Vector3());
      this.locationMotion.set({
        x: r.x,
        y: r.y,
        z: r.z,
        distance: FloorplanController.distanceFromModel(this.models, this.defaultFov, this.camera.aspect)
      }, 0).catch(noop$1);
    }, t.prototype.updateCamera = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        var u = {}, l = {};
        return e.distance !== void 0 && (u.distance = e.distance), e.offset !== void 0 && (u.x = e.offset.x, u.y = e.offset.y, u.z = e.offset.z), e.longitude !== void 0 && (l.longitude = e.longitude), e.latitude !== void 0 && (l.latitude = e.latitude), e.fov !== void 0 && (l.fov = e.fov), s.locationMotion.set(u, r).catch(noop$1), s.cameraMotion.set(l, r).catch(noop$1);
      });
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        for (var u = [], l = [], c = 0, f = e; c < f.length; c++) {
          var d = f[c];
          u.push({
            key: d.key,
            progress: d.progress,
            value: {
              distance: d.value.distance,
              x: d.value.offset.x,
              y: d.value.offset.y,
              z: d.value.offset.z
            }
          }), l.push({
            key: d.key,
            progress: d.progress,
            value: {
              longitude: d.value.longitude,
              latitude: d.value.latitude,
              fov: d.value.fov
            }
          });
        }
        return s.locationMotion.setKeyframes(u, r).catch(noop$1), s.cameraMotion.setKeyframes(e, r);
      });
    }, t.prototype.initAnimation = function() {
      var e = this;
      return this.destroyed ? Promise.resolve() : new Promise(function(r) {
        var o = e.initial;
        o.state, o.currentState;
        var s = o.duration, u = o.userAction;
        e.userAction = u;
        var l = t.initAnimationEndState(e), c = {
          longitude: l.longitude,
          latitude: l.latitude,
          fov: l.fov
        }, f = {
          x: l.offset.x,
          y: l.offset.y,
          z: l.offset.z,
          distance: l.distance
        }, d = {
          modelAlpha: 1
        }, h = {
          perspToOrtho: 1
        };
        e.emit("initAnimation.start", createEvent("initAnimation.start", {
          state: l,
          userAction: e.userAction
        })), e.modelAlphaMotion.set(d, s / 3).catch(noop$1), e.perspToOrthoMotion.set(h, s).catch(noop$1), e.cameraMotion.set(c, s).catch(noop$1), e.locationMotion.set(f, s).then(
          /* resolve */
          function() {
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: l,
              userAction: e.userAction
            }));
          },
          /* reject */
          function(v) {
            var A = __assign(__assign(__assign({}, e.currentPano), { mode: e.mode }), clonePose(e.camera.pose));
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: A,
              userAction: e.userAction
            }));
          }
        ).then(function() {
          r();
        });
      });
    }, t.prototype.requestMomentumMovement = function() {
      this.inMomentumMovement = null;
    }, t.prototype.onPanGesture = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement();
      var r = this.panState, o = e.pointers.length;
      if (e.isFinal ? delete this.panState : this.panState = {
        pointerLength: o,
        x: e.center.x,
        y: e.center.y
      }, !(typeof r == "undefined" || r.pointerLength !== o)) {
        var s = {
          x: e.center.x - r.x,
          y: e.center.y - r.y
        }, u = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z), l = this.locationMotion.value.distance;
        l *= Math.tan(this.cameraMotion.value.fov / 2 * Math.PI / 180);
        var c = this.renderer.getSize(new Vector2()), f = 2 * s.x * l / c.y, d = 2 * s.y * l / c.y, h = new Vector3();
        h.setFromMatrixColumn(this.camera.matrix, 0), h.multiplyScalar(-f), u.add(h), h.setFromMatrixColumn(this.camera.matrix, 1), h.multiplyScalar(d), u.add(h);
        var v = this.models.bounding.getCenter(new Vector3()), A = this.models.bounding.getSize(new Vector3()), g = Math.max(A.x, A.y, A.z) / 2;
        u.clamp(v.clone().sub(new Vector3().setScalar(g)), v.clone().add(new Vector3().setScalar(g)));
        var p = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: 0, latitude: Math.PI / 2, fov: this.cameraMotion.value.fov, offset: u, distance: this.locationMotion.value.distance });
        e.state = p, this.emit("gesture.pan", e), !e.defaultPrevented && this.locationMotion.set({ x: u.x, y: u.y, z: u.z }, 0).catch(noop$1);
      }
    }, t.prototype.onPinchGesture = function(e) {
      var r;
      if (this.initAnimationIsReady) {
        this.userAction = e.userAction, this.stopMomentumMovement();
        var o = (r = this.pinchState) === null || r === void 0 ? void 0 : r.fov;
        if (e.isFirst) {
          this.pinchState = {
            x: e.center.x,
            y: e.center.y,
            fov: this.cameraMotion.value.fov
          };
          return;
        }
        if (e.isFinal && delete this.pinchState, typeof o != "undefined") {
          var s = clamp$1(o / e.scale, this.minFov, this.maxFov);
          e.state.fov = s, this.emit("gesture.pinch", e), !e.defaultPrevented && (this.cameraMotion.set({ fov: s }, 0).catch(noop$1), e.type = "gesture.pan", this.onPanGesture(e));
        }
      }
    }, t.prototype.onMouseWheel = function(e) {
      if (this.initAnimationIsReady) {
        this.userAction = e.userAction, this.stopMomentumMovement();
        var r = clamp$1(this.cameraMotion.value.fov - e.center.delta, this.minFov, this.maxFov);
        e.state.fov = r, this.emit("gesture.mousewheel", e), !e.defaultPrevented && this.cameraMotion.set({ fov: r }, 0).catch(noop$1);
      }
    }, t;
  }(FloorplanController)
);
var defaultPanoramaLikeControllerCustomInitArgs = {
  defaultLatitude: 0,
  defaultFov: 90,
  maxFov: 120,
  minFov: 20,
  maxLatitude: +Math.PI / 2,
  minLatitude: -Math.PI / 2,
  moveSpeed: 3.4,
  intersectMeshCreator: function() {
    return new IntersectMesh();
  }
};
var PanoramaLikeController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o = t.parseArgs(e);
      return r = n45.call(this, o) || this, r.mode = "PanoramaLike", r.defaultLatitude = o.defaultLatitude, r.defaultFov = o.defaultFov, r.maxFov = o.maxFov, r.minFov = o.minFov, r.maxLatitude = o.maxLatitude, r.minLatitude = o.minLatitude, r.moveSpeed = o.moveSpeed, r.intersectMeshCreator = o.intersectMeshCreator, r.intersectMesh = r.intersectMeshCreator(), r.intersectMesh.name = "intersect", r.intersectMesh.visible = false, r.helper.add(r.intersectMesh), r;
    }
    return t.parseArgs = function(e) {
      var r, o, s, u, l, c, f, d;
      if (e instanceof t)
        return e;
      var h = n45.parseArgs.call(this, e);
      return __assign(__assign({}, h), { defaultLatitude: (r = e.defaultLatitude) !== null && r !== void 0 ? r : defaultPanoramaLikeControllerCustomInitArgs.defaultLatitude, defaultFov: (o = e.defaultFov) !== null && o !== void 0 ? o : defaultPanoramaLikeControllerCustomInitArgs.defaultFov, maxFov: (s = e.maxFov) !== null && s !== void 0 ? s : defaultPanoramaLikeControllerCustomInitArgs.maxFov, minFov: (u = e.minFov) !== null && u !== void 0 ? u : defaultPanoramaLikeControllerCustomInitArgs.minFov, maxLatitude: (l = e.maxLatitude) !== null && l !== void 0 ? l : defaultPanoramaLikeControllerCustomInitArgs.maxLatitude, minLatitude: (c = e.minLatitude) !== null && c !== void 0 ? c : defaultPanoramaLikeControllerCustomInitArgs.minLatitude, moveSpeed: (f = e.moveSpeed) !== null && f !== void 0 ? f : defaultPanoramaLikeControllerCustomInitArgs.moveSpeed, intersectMeshCreator: (d = e.intersectMeshCreator) !== null && d !== void 0 ? d : defaultPanoramaLikeControllerCustomInitArgs.intersectMeshCreator });
    }, t.initAnimationEndState = function(e) {
      var r, o, s, u, l, c, f = this.parseArgs(e), d = f.works, h = e.initial, v = h.state, A = h.currentState, g = typeof v.panoIndex == "number" ? {
        workCode: (s = (r = v.workCode) !== null && r !== void 0 ? r : (o = f.works[0]) === null || o === void 0 ? void 0 : o.workCode) !== null && s !== void 0 ? s : "",
        panoIndex: v.panoIndex
      } : {
        workCode: A.workCode,
        panoIndex: A.panoIndex
      }, p = d.getResolvedObserver(g), y = (u = v.longitude) !== null && u !== void 0 ? u : A.longitude, m = clamp$1((l = v.latitude) !== null && l !== void 0 ? l : isFristPersonMode(A.mode) ? A.latitude : f.defaultLatitude, f.minLatitude, f.maxLatitude), E = clamp$1((c = v.fov) !== null && c !== void 0 ? c : isFristPersonMode(A.mode) ? A.fov : f.defaultFov, f.minFov, f.maxFov), b = p ? p.position.clone() : new Vector3();
      return {
        workCode: g.workCode,
        panoIndex: g.panoIndex,
        mode: "PanoramaLike",
        longitude: y,
        latitude: m,
        fov: E,
        offset: b,
        distance: 0
      };
    }, t.prototype.updateConfiguration = function(e) {
      var r = n45.prototype.updateConfiguration.call(this, e);
      if (r === false)
        return false;
      if (e.defaultLatitude !== void 0 && this.defaultLatitude !== e.defaultLatitude && (this.defaultLatitude = e.defaultLatitude), e.maxLatitude !== void 0 && this.maxLatitude !== e.maxLatitude && (this.maxLatitude = e.maxLatitude), e.minLatitude !== void 0 && this.minLatitude !== e.minLatitude && (this.minLatitude = e.minLatitude), e.defaultFov !== void 0 && this.defaultFov !== e.defaultFov && (this.defaultFov = e.defaultFov), e.maxFov !== void 0 && this.maxFov !== e.maxFov && (this.maxFov = e.maxFov), e.minFov !== void 0 && this.minFov !== e.minFov && (this.minFov = e.minFov), e.moveSpeed !== void 0 && this.moveSpeed !== e.moveSpeed && (this.moveSpeed = e.moveSpeed), e.intersectMeshCreator !== void 0 && this.intersectMeshCreator !== e.intersectMeshCreator) {
        this.intersectMeshCreator = e.intersectMeshCreator;
        var o = this.intersectMesh;
        this.intersectMesh = this.intersectMeshCreator(), this.intersectMesh.name = o.name, this.intersectMesh.visible = o.visible;
        var s = this.intersectMesh.parent;
        s && s.add(this.intersectMesh), o.dispose();
      }
      return true;
    }, t.prototype.destroy = function() {
      n45.prototype.destroy.call(this), this.intersectMesh && (this.helper.remove(this.intersectMesh), this.intersectMesh.dispose()), delete this.panState;
    }, t.prototype.isReady = function() {
      return this.panState || this.pinchState ? false : n45.prototype.isReady.call(this);
    }, t.prototype.calculateMovingDuration = function(e, r) {
      switch (typeof e) {
        case "function":
          return e(r, this.moveSpeed);
        case "number":
          return e;
        case "string":
          return Number(e);
        default:
          return clamp$1(r, 2, 5) / this.moveSpeed * 1e3;
      }
    }, t.prototype.hideIntersectMesh = function() {
      this.intersectMesh.visible = false, this.needsRender = true;
    }, t.prototype.coordinatesForOffset = function(e) {
      var r = this.cameraMotion.value.fov, o = this.camera.aspect, s = this.renderer.getSize(new Vector2());
      return {
        longitude: 2 * e.x / (s.x * this.scissor.width) * r / 95 * o,
        latitude: -2 * e.y / (s.y * this.scissor.height) * r / 95
      };
    }, t.prototype.cameraBounce = function() {
      var e = this.cameraMotion.value, r = e.longitude, o = e.latitude, s = e.fov, u = [
        { progress: 0, value: { longitude: r, latitude: o, fov: s } },
        { progress: 0.5, value: { longitude: r, latitude: o, fov: s * 0.98 } },
        { progress: 1, value: { longitude: r, latitude: o, fov: s } }
      ];
      this.cameraMotion.setKeyframes(u, 500).catch(noop$1);
    }, t.prototype.requestMomentumMovement = function(e, r, o, s) {
      var u = this;
      if (this.inMomentumMovement !== null) {
        for (var l = __assign({}, o), c = { longitude: 0, latitude: 0 }, f = 0; f < s; f++)
          l.longitude *= 0.996, l.latitude *= 0.996 * 0.99, c.longitude += l.longitude, c.latitude += l.latitude;
        var d = formatRad(this.cameraMotion.value.longitude + c.longitude), h = clamp$1(this.cameraMotion.value.latitude + c.latitude, this.minLatitude, this.maxLatitude), v = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: d, latitude: h, fov: this.cameraMotion.value.fov, offset: this.camera.pose.offset.clone(), distance: this.camera.pose.distance }), A = !(l.longitude > 1e-4 || l.longitude < -1e-4 || l.latitude > 1e-4 || l.latitude < -1e-4), g = createEvent("gesture.momentum", __assign(__assign({}, e), { isFirst: r, isFinal: A, state: v }));
        if (this.inMomentumMovement.event = g, this.emit("gesture.momentum", g), e.defaultPrevented) {
          this.inMomentumMovement = null;
          return;
        }
        this.inMomentumMovement && (this.cameraMotion.set({ longitude: d, latitude: h }, 0).catch(noop$1), A ? this.inMomentumMovement = null : AnimationFrameLoop.shared.add(function(p, y) {
          u.requestMomentumMovement(e, false, l, y | 0);
        }, true, 1));
      }
    }, t.prototype.onPanGesture = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement(), this.hideIntersectMesh();
      var r = this.panState, o = e.pointers.length;
      if (e.isFinal ? delete this.panState : this.panState = {
        pointerLength: o,
        x: e.center.x,
        y: e.center.y
      }, !(typeof r == "undefined" || r.pointerLength !== o)) {
        var s = {
          x: e.center.x - r.x,
          y: e.center.y - r.y
        }, u = this.coordinatesForOffset(s), l = formatRad(this.cameraMotion.value.longitude + u.longitude), c = clamp$1(this.cameraMotion.value.latitude + u.latitude, this.minLatitude, this.maxLatitude);
        this.camera.aspect < 1 && Math.abs(e.overallVelocityX) > 0.2 && Math.atan2(Math.abs(e.overallVelocityY), Math.abs(e.overallVelocityX)) < Math.PI / 6.923 && (c = this.cameraMotion.value.latitude);
        var f = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: l, latitude: c, fov: this.cameraMotion.value.fov, offset: this.camera.pose.offset.clone(), distance: this.camera.pose.distance });
        if (e.state = f, this.emit("gesture.pan", e), !e.defaultPrevented) {
          var d = {
            longitude: f.longitude,
            latitude: f.latitude,
            fov: f.fov
          };
          if (this.cameraMotion.set(d, 0).catch(noop$1), e.isFinal) {
            var h = e.velocityX, v = e.velocityY * 0.6;
            Math.abs(v) > 0.5 && Math.abs(h) < 0.5 && (h = 0), this.inMomentumMovement = { uuid: createUuid() }, this.requestMomentumMovement(e, true, this.coordinatesForOffset({ x: h, y: v }), 0);
          }
        }
      }
    }, t.prototype.onPinchGesture = function(e) {
      var r;
      this.userAction = e.userAction, this.stopMomentumMovement();
      var o = (r = this.pinchState) === null || r === void 0 ? void 0 : r.fov, s = e.scale;
      if (e.isFirst) {
        this.pinchState = {
          x: e.center.x,
          y: e.center.y,
          fov: this.cameraMotion.value.fov
        };
        return;
      }
      if (e.isFinal && delete this.pinchState, typeof o != "undefined") {
        var u = clamp$1(o / s, this.minFov, this.maxFov);
        e.state.fov = u, this.emit("gesture.pinch", e), !e.defaultPrevented && (this.cameraMotion.set({ fov: u }, 0).catch(noop$1), e.type = "gesture.pan", this.onPanGesture(e));
      }
    }, t.prototype.onMouseWheel = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement();
      var r = clamp$1(this.cameraMotion.value.fov - e.center.delta, this.minFov, this.maxFov);
      e.state.fov = r, this.emit("gesture.mousewheel", e), !e.defaultPrevented && (this.cameraMotion.set({ fov: r }, 0).catch(noop$1), this.onMouseMove(e));
    }, t.prototype.onMouseMove = function(e) {
      var r, o;
      if (this.intersectMesh.parent && !this.panState && (this.emit("gesture.mousemove", e), !e.defaultPrevented)) {
        var s = e.center.raycaster;
        if (e.isFinal && this.intersectMesh.parent) {
          this.hideIntersectMesh();
          return;
        }
        var u = this.models.intersectRaycaster(s)[0], l = createEvent("intersect.update", {
          raycaster: s,
          intersection: u != null ? u : null,
          object: this.intersectMesh
        });
        if (this.emit("intersect.update", l), l.defaultPrevented) {
          this.hideIntersectMesh();
          return;
        }
        if (u) {
          var c = (o = (r = u.face) === null || r === void 0 ? void 0 : r.normal) !== null && o !== void 0 ? o : new Vector3().copy(s.ray.direction).multiplyScalar(-1), f = c.clone(), d = u.point.clone();
          this.intersectMesh.position.copy(d);
          var h = d.clone().add(f);
          if (this.intersectMesh.lookAt(h), Math.abs(c.y) > 0.99) {
            var v = this.camera.position.clone().sub(d);
            this.intersectMesh.rotation.z = -Math.atan2(v.z, v.x);
          }
          this.intersectMesh.visible = true, this.needsRender = true;
        } else
          this.hideIntersectMesh();
      }
    }, t.prototype.onDblTapGesture = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement();
      var r = this.cameraMotion.value.fov, o = 2, s = this.works.getResolvedObserver(this.currentPano);
      if (s) {
        var u = s.images.tiles;
        u && u.length && (o = Math.max.apply(Math, u.map(function(f) {
          return f.level;
        })));
      }
      var l = Math.max(40 - o * 5, this.minFov, 5), c = l - r < r - this.defaultFov ? l : this.defaultFov;
      e.state.fov = c, this.emit("gesture.dbltap", e), !e.defaultPrevented && (this.cameraMotion.set({ fov: c }, 360).catch(noop$1), this.hideIntersectMesh());
    }, t;
  }(BaseController)
);
var blankVideo = "data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw";
var result;
function canplayVideo() {
  return result || (result = new Promise(function(n45) {
    var t, e = document.createElement("video");
    e.muted = true, e.src = blankVideo, e.addEventListener("timeupdate", function r() {
      e.removeEventListener("timeupdate", r, false), clearTimeout(t);
      var o = document.createElement("canvas");
      o.width = o.height = 1;
      var s = o.getContext("2d");
      if (!s) {
        n45(false);
        return;
      }
      s.drawImage(e, 0, 0, 1, 1);
      var u = s.getImageData(0, 0, 1, 1).data;
      u[3] > 10 ? n45(true) : n45(false);
    }, false), e.addEventListener("canplay", function r() {
      e.removeEventListener("canplay", r, false), e.play();
    }, false), t = window.setTimeout(function() {
      return n45(false);
    }, 1e3);
  }));
}
var FRAGMENT = `
#include <common>
uniform sampler2D inputBuffer;
uniform float scale;
varying vec2 vUv;

void main() {
  float u = (vUv.x - 0.5) * scale + 0.5;
  float v = (vUv.y - 0.5) * scale + 0.5;
  vec3 rgb = texture2D(inputBuffer, vec2(u, v)).rgb;
  float luminance = clamp(linearToRelativeLuminance(rgb), 0.1, 0.9);
  gl_FragColor = vec4(luminance);
}
`;
var LuminancePass = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      return r === void 0 && (r = 0.5), n45.call(this, e, {
        uniforms: {
          inputBuffer: new Uniform(null),
          scale: new Uniform(r)
        },
        fragment: FRAGMENT
      }) || this;
    }
    return t;
  }(Pass)
);
var Effect = (
  /** @class */
  function() {
    function n45(t, e, r, o) {
      this.enable = true, this.renderer = t, this.camera = r, this.models = o, this.scene = e, this.copyPass = new CopyPass(this.renderer);
    }
    return n45.prototype.render = function(t, e) {
    }, n45.prototype.dispose = function() {
      this.copyPass.dispose();
    }, n45;
  }()
);
var NextStepPass = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      r === void 0 && (r = 2e-3);
      var o = n45.call(this, e, {
        uniforms: {
          targetBuffer: new Uniform(null),
          inputBuffer: new Uniform(null),
          step: new Uniform(r)
        },
        fragment: `
        uniform sampler2D targetBuffer;
        uniform sampler2D inputBuffer;
        uniform float step;
        varying vec2 vUv;
        void main() {

          #ifdef GL_EXT_shader_texture_lod
            #if __VERSION__ < 300
              float target = texture2DLodEXT(targetBuffer, vUv, 5.0).r;
            #else
              float target = textureLod(targetBuffer, vUv, 5.0).r;
            #endif
          #else
            float target = texture2D(targetBuffer, vUv).r;
          #endif
          float current = texture2D(inputBuffer, vUv).r;

          float result;
          if (abs(target - current) < step) {
            result = target;
          } else if (target - current > 0.0) {
            result = current + step;
          } else {
            result = current - step;
          }
          gl_FragColor = vec4(result, result, result, 1.0);
        }
      `
      }) || this;
      return o.material.extensions.shaderTextureLOD = true, o;
    }
    return Object.defineProperty(t.prototype, "targetBuffer", {
      get: function() {
        return this.material.uniforms.targetBuffer.value;
      },
      set: function(e) {
        this.material.uniforms.targetBuffer.value = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "step", {
      get: function() {
        return this.material.uniforms.step.value;
      },
      set: function(e) {
        this.material.uniforms.step.value = e;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Pass)
);
var LuminanceAdaptivePass = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, e, {
        uniforms: {
          inputBuffer: new Uniform(null),
          luminanceAdaptiveBuffer: new Uniform(null),
          progress: new Uniform(0)
        },
        fragment: `
        #include <common>
        uniform sampler2D inputBuffer;
        uniform sampler2D luminanceAdaptiveBuffer;
        uniform float progress;
        varying vec2 vUv;

        void main() {
          float middleGrey = 1.5;
          float whitePoint = 13.0;
          float exposure = 1.4;
          vec4 inputColor = texture2D(inputBuffer, vUv);
          vec3 rgb = inputColor.rgb * exposure;
          float alpha = inputColor.a;
          float luminance = linearToRelativeLuminance(rgb);
          float lumAvg = texture2D(luminanceAdaptiveBuffer, vec2(0.5)).r;
          float lumScaled = (luminance * middleGrey) / max(lumAvg, 1e-6);
          float lumCompressed = lumScaled * (1.0 + lumScaled / (whitePoint * whitePoint));
          lumCompressed /= (1.0 + lumScaled);
          rgb = clamp(lumCompressed * rgb, 0.0, 1.0);
          gl_FragColor = mix(inputColor, vec4(rgb, alpha), progress * 0.9);
        }
      `
      }) || this;
      return r.material.transparent = true, r;
    }
    return Object.defineProperty(t.prototype, "luminanceAdaptiveBuffer", {
      get: function() {
        return this.material.uniforms.luminanceAdaptiveBuffer.value;
      },
      set: function(e) {
        this.material.uniforms.luminanceAdaptiveBuffer.value = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "progress", {
      get: function() {
        return this.material.uniforms.progress.value;
      },
      set: function(e) {
        this.material.uniforms.progress.value = e;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Pass)
);
var LuminanceAdaptiveEffect = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o, s) {
      var u = n45.call(this, e, r, o, s) || this;
      return u.enableTime = now(), u.renderer = e, u.valuePass = new ValuePass(u.renderer), u.luminancePass = new LuminancePass(u.renderer, Math.sqrt(1 / 3)), u.nextStepPass = new NextStepPass(u.renderer, 0.01), u.luminanceAdaptivePass = new LuminanceAdaptivePass(u.renderer), u;
    }
    return t.prototype.render = function(e) {
      this.renderer.setRenderTarget(e[0]), this.renderer.render(this.scene, this.camera), this.enableTime === null && (this.enableTime = now()), this.luminanceTargetBuffer || (this.luminanceTargetBuffer = new WebGLRenderTarget(128, 128, {
        minFilter: LinearMipmapLinearFilter,
        magFilter: LinearFilter,
        encoding: this.renderer.outputEncoding,
        stencilBuffer: false,
        depthBuffer: false,
        format: RGBAFormat,
        generateMipmaps: true
      }), this.nextStepPass.targetBuffer = this.luminanceTargetBuffer.texture), this.luminancePass.render(e[0], this.luminanceTargetBuffer), this.luminancePrevBuffer || (this.luminancePrevBuffer = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        type: HalfFloatType,
        encoding: this.renderer.outputEncoding,
        stencilBuffer: false,
        depthBuffer: false
      }), this.valuePass.render(new Vector3(0.5, 0.5, 0.5), this.luminancePrevBuffer)), this.luminanceNextBuffer || (this.luminanceNextBuffer = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        type: HalfFloatType,
        encoding: this.renderer.outputEncoding,
        stencilBuffer: false,
        depthBuffer: false
      }), this.valuePass.render(new Vector3(0.5, 0.5, 0.5), this.luminanceNextBuffer), this.luminanceAdaptivePass.luminanceAdaptiveBuffer = this.luminanceNextBuffer.texture), this.copyPass.render(this.luminanceNextBuffer, this.luminancePrevBuffer), this.nextStepPass.render(this.luminancePrevBuffer, this.luminanceNextBuffer), this.luminanceAdaptivePass.progress = Math.min((now() - this.enableTime) / 100, 1), this.luminanceAdaptivePass.render(e[0], e[1]);
    }, t.prototype.dispose = function() {
      var e, r, o;
      (e = this.luminanceTargetBuffer) === null || e === void 0 || e.dispose(), (r = this.luminancePrevBuffer) === null || r === void 0 || r.dispose(), (o = this.luminanceNextBuffer) === null || o === void 0 || o.dispose(), this.copyPass.dispose(), this.luminancePass.dispose(), this.nextStepPass.dispose(), this.luminanceAdaptivePass.dispose();
    }, t;
  }(Effect)
);
var _a$1;
var sharedSortVector3 = new Vector3();
var MAX_TILE_COUNT = 64;
var SQRT1_2 = (_a$1 = Math.SQRT1_2) !== null && _a$1 !== void 0 ? _a$1 : Math.sqrt(2);
var TILE_QUATERNION = {
  up: new Quaternion(SQRT1_2, 0, 0, SQRT1_2),
  down: new Quaternion(-SQRT1_2, 0, 0, SQRT1_2),
  left: new Quaternion(0, SQRT1_2, 0, SQRT1_2),
  right: new Quaternion(0, -SQRT1_2, 0, SQRT1_2),
  front: new Quaternion(0, 0, 0, 1),
  back: new Quaternion(0, 1, 0, 0)
};
var vertices$2 = new Float32Array([
  -0.5,
  -0.5,
  0,
  0.5,
  -0.5,
  0,
  -0.5,
  0.5,
  0,
  0.5,
  0.5,
  0
]);
var uvs$1 = new Float32Array([
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  1
]);
var index$2 = new Uint8Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var geometry$3 = new BufferGeometry();
geometry$3.setAttribute("position", new BufferAttribute(vertices$2, 3));
geometry$3.setAttribute("uv", new BufferAttribute(uvs$1, 2));
geometry$3.setIndex(new BufferAttribute(index$2, 1));
var TILE_MATERIAL_VERTEX_SHADER = `
uniform float flipY;
varying vec2 vUv;
void main() {
  vUv = vec2(uv.x, mix((1.0 - uv.y), uv.y, flipY));
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
var TILE_MATERIAL_FRAGMENT_SHADER = `
#if defined(USE_LUMINANCE)
uniform sampler2D luminanceMap;
#endif
uniform sampler2D map;
uniform float level;
varying vec2 vUv;

void main() {
  gl_FragColor = texture2D(map, vUv);
  #if defined(USE_LUMINANCE)
  gl_FragColor.a = 1.0 - texture2D(luminanceMap, vUv).r;
  #endif
}
`;
var TileMaterial = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this, {
        uniforms: {
          map: { value: null },
          luminanceMap: { value: null },
          flipY: { value: 1 },
          level: { value: 0 }
        },
        vertexShader: TILE_MATERIAL_VERTEX_SHADER,
        fragmentShader: TILE_MATERIAL_FRAGMENT_SHADER
      }) || this;
      return e.depthTest = false, e.depthWrite = false, e.blending = NoBlending, e.map = e.uniforms.map.value, e.luminanceMap = e.uniforms.luminanceMap.value, e.flipY = !!e.uniforms.flipY.value, e.level = e.uniforms.level.value, Object.defineProperties(e, {
        /**  */
        map: {
          get: function() {
            return this.uniforms.map.value;
          },
          set: function(r) {
            this.uniforms.map.value = r;
          }
        },
        luminanceMap: {
          get: function() {
            return this.uniforms.luminanceMap.value;
          },
          set: function(r) {
            this.uniforms.luminanceMap.value = r, this.defines.USE_LUMINANCE = r !== null, this.needsUpdate = true;
          }
        },
        flipY: {
          get: function() {
            return this.uniforms.flipY.value === 1;
          },
          set: function(r) {
            this.uniforms.flipY.value = r ? 1 : 0;
          }
        },
        level: {
          get: function() {
            return this.uniforms.level.value;
          },
          set: function(r) {
            this.uniforms.level.value = r;
          }
        }
      }), e;
    }
    return t;
  }(ShaderMaterial)
);
var TileMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      var o = n45.call(this, geometry$3, new TileMaterial()) || this;
      return e.box.getCenter(o.position), o.quaternion.multiplyQuaternions(new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), -Math.PI), TILE_QUATERNION[e.face]), o.scale.setScalar(e.size), o.node = e, o.name = "tiling:tile", o.material.visible = false, o.activeTime = -1, o.disposed = false, o.needsRender = false, o.frustumCulled = false, r.then(function(s) {
        var u = s[0], l = s[1];
        o.disposed ? (u.dispose(), l == null || l.dispose()) : (o.material.map = u, o.material.luminanceMap = l, o.material.flipY = !!u.flipY, o.material.level = e.level, o.material.needsUpdate = true, o.material.visible = true, o.needsRender = true);
      }).catch(noop$1), o;
    }
    return t.prototype.updateTime = function(e) {
    }, t.prototype.dispose = function() {
      var e;
      this.disposed = true, this.material.map && (this.material.map.dispose(), (e = this.material.luminanceMap) === null || e === void 0 || e.dispose()), this.material.dispose();
    }, t;
  }(Mesh)
);
var TilingObject3D = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      return e.needsRender = false, e.name = "tiling", e;
    }
    return t;
  }(Group)
);
var Tiling = (
  /** @class */
  function() {
    function n45(t, e, r) {
      this.disposed = false, this.textureLoader = new TextureLoader2(), this.minLevel = e, this.level = 0, this.panoId = "[0]", this.maxRequest = n45.DEFAULT_MAX_REQUEST, this.pedding = 0, this.tileTree = createTileCubeTree(this.minLevel), this.tileMeshes = /* @__PURE__ */ new Map(), this.resource = [], this.luminance = null, this.imageOptions = r, this.fetcher = t, this.object = new TilingObject3D(), this.object.renderOrder = -3;
    }
    return n45.prototype.setFetcher = function(t) {
      this.fetcher = t;
    }, n45.prototype.cleanup = function() {
      var t = this;
      this.tileMeshes.forEach(function(e) {
        e.dispose(), t.object.remove(e), t.object.needsRender = true;
      }), this.tileMeshes.clear();
    }, n45.prototype.setRotation = function(t) {
      this.disposed || this.object.quaternion.equals(t) || (this.object.quaternion.copy(t), this.object.needsRender = true);
    }, n45.prototype.setPosition = function(t) {
      this.disposed || this.object.position.equals(t) || (this.object.position.copy(t), this.object.needsRender = true);
    }, n45.prototype.setResource = function(t, e) {
      var r, o;
      if (!this.disposed && !(this.resource === t && this.luminance === e)) {
        this.cleanup(), this.resource = t;
        var s = (o = (r = t.slice().sort(function(u, l) {
          return l.level - u.level;
        })[0]) === null || r === void 0 ? void 0 : r.level) !== null && o !== void 0 ? o : 0;
        this.tileTree = createTileCubeTree(s), this.luminance = e, this.object.needsRender = true;
      }
    }, n45.prototype.update = function(t, e, r) {
      var o = this;
      if (!this.disposed) {
        this.level = e;
        var s = t.planes[5].normal, u = [];
        e >= this.minLevel && traverseTileCubeNode(this.tileTree, function(E) {
          if (!(E.level < o.minLevel)) {
            if (E.level > e || !t.intersectsBox(E.box))
              return false;
            u.push(E);
          }
        }), u.sort(function(E, b) {
          return E.level !== b.level ? E.level - b.level : E.box.getCenter(sharedSortVector3).angleTo(s) - b.box.getCenter(sharedSortVector3).angleTo(s);
        });
        for (var l = /* @__PURE__ */ new Set(), c = function(E) {
          var b = f.resource.filter(function(z) {
            return z.level === E.level;
          })[0];
          if (!b)
            return "continue";
          if (l.add(E), f.tileMeshes.has(E))
            return f.tileMeshes.get(E).activeTime = r, "continue";
          if (f.pedding >= f.maxRequest)
            return "continue";
          var T = b.size, R = f.imageOptions.transform, S = Math.pow(2, E.level) * E.position.y, M = Math.pow(2, E.level) * E.position.x, w = "".concat(f.panoId, ".").concat(E.face, ".").concat(E.level, ".").concat(S, ".").concat(M), H = __assign(__assign({}, pick(f.imageOptions, ["format", "sharpen", "mappings"])), { key: "pano_tile.".concat(w), size: b.scale >= 1 ? void 0 : T * E.size * b.scale, cut: E.size === 1 ? void 0 : [
            T * E.position.x,
            T * E.position.y,
            T * E.size,
            T * E.size
          ] });
          E.size === 1 && console.warn("tile: ".concat(H.key, " should not appear.")), E.level === 1 && b.scale >= 0.5 && (H.format === "jpg" || /\.jpg$/.test(b[E.face])) && (H.size = void 0, H.quality || (H.quality = 70));
          var L = f.textureLoader.loadTexture(b[E.face], {
            imageURL: {
              transform: R,
              options: H
            },
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            generateMipmaps: false,
            fetcher: f.fetcher
          }).then(function(z) {
            return z.body;
          }), C = null;
          if (f.luminance) {
            var I = f.luminance[E.face], _ = I.match(/\/cube_(\d+)\//), O = _ ? Number(_[1]) : false;
            if (O !== false) {
              var P = b.size * b.scale / 2, N = P * E.size, k = O < P ? I.replace(/\/cube_(\d+)\//, "cube_" + P) : I, U = __assign(__assign({}, H), { size: O * E.size === N ? void 0 : N, cut: E.size === 1 ? void 0 : [
                O * E.position.x,
                O * E.position.y,
                O * E.size,
                O * E.size
              ], key: "pano_tile_luminance.".concat(w) });
              E.size === 1 && console.warn("tile: ".concat(U.key, " should not appear.")), C = f.textureLoader.loadTexture(k, {
                imageURL: {
                  transform: f.imageOptions.transform,
                  options: U
                },
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                fetcher: f.fetcher
              }).then(function(z) {
                return z.body;
              }).catch(function() {
                return null;
              });
            }
          }
          f.pedding++;
          var D = Promise.all([L, C]).then(function(z) {
            return o.pedding--, z;
          }, function(z) {
            return o.pedding--, Promise.reject(z);
          }), q = new TileMesh(E, D);
          q.name = "tiling:tile-".concat(w), q.activeTime = r, q.renderOrder = E.level, f.tileMeshes.set(E, q), f.object.needsRender = true, f.object.add(q);
        }, f = this, d = 0, h = u; d < h.length; d++) {
          var v = h[d];
          c(v);
        }
        var A = [];
        this.tileMeshes.forEach(function(E, b) {
          l.has(b) || A.push(b), E.visible = b.level <= e;
        });
        for (var g = A.sort(function(E, b) {
          var T, R, S, M;
          return ((R = (T = o.tileMeshes.get(b)) === null || T === void 0 ? void 0 : T.activeTime) !== null && R !== void 0 ? R : 0) - ((M = (S = o.tileMeshes.get(E)) === null || S === void 0 ? void 0 : S.activeTime) !== null && M !== void 0 ? M : 0);
        }).slice(Math.max(0, MAX_TILE_COUNT - l.size)), p = 0, y = g; p < y.length; p++) {
          var v = y[p], m = this.tileMeshes.get(v);
          m && (m.dispose(), this.object.remove(m), this.object.needsRender = true), this.tileMeshes.delete(v);
        }
      }
    }, n45.prototype.dispose = function() {
      this.cleanup(), this.resource = [], this.disposed = true;
    }, n45.DEFAULT_MAX_REQUEST = 3, n45;
  }()
);
var vertices$1 = new Float32Array([
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1
]);
var index$1 = new Uint8Array([
  0,
  2,
  1,
  2,
  3,
  1,
  4,
  6,
  5,
  6,
  7,
  5,
  8,
  10,
  9,
  10,
  11,
  9,
  12,
  14,
  13,
  14,
  15,
  13,
  16,
  18,
  17,
  18,
  19,
  17,
  20,
  22,
  21,
  22,
  23,
  21
]);
var sharedGeometry$1 = new BufferGeometry();
sharedGeometry$1.setAttribute("position", new BufferAttribute(vertices$1, 3));
sharedGeometry$1.setIndex(new BufferAttribute(index$1, 1));
var PANO_VIDEO_MATERIAL_VERTEX_SHADER = `
#if defined(USE_PANO_VIDEO)
varying vec3 worldPosition;
#endif
void main() {
  vec4 transformed = vec4(position, 1.0);
  #if defined(USE_PANO_VIDEO)
  worldPosition = (modelMatrix * transformed).xyz;
  #endif
  gl_Position = projectionMatrix * modelViewMatrix * transformed;
}
`;
var PANO_VIDEO_TILE_MATERIAL_FRAGMENT_SHADER = `
uniform vec2 size;
uniform mat4 matrix;
uniform float alpha;
uniform sampler2D map;
#if defined(USE_PANO_VIDEO)
varying vec3 worldPosition;
#endif
#include <common>
void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
  #if defined(USE_PANO_VIDEO)
  vec3 cameraToVertex = worldPosition - cameraPosition;
  vec4 mapCoods = vec4(cameraToVertex, 1.0) * matrix;
  vec2 uv = vec2(
    0.5 + mapCoods.x / mapCoods.z / size.x,
    0.5 - mapCoods.y / mapCoods.z / size.y
  );
  vec4 videoColor = texture2D(map, uv);
  float match = (1.0 - step(0.0, mapCoods.z)) * (1.0 - step(0.5, abs(uv.x - 0.5))) * (1.0 - step(0.5, abs(uv.y - 0.5)));
  float blendAlpha = clamp(0.0, 1.0, 5.0 * (1.0 - clamp(distance(uv, vec2(0.5, 0.5)) / 0.55 , 0.0, 1.0)));
  gl_FragColor = vec4(videoColor.rgb, match * blendAlpha * alpha);
  #endif
}
`;
var PanoVideo = (
  /** @class */
  function() {
    function n45() {
      this.material = new ShaderMaterial({
        vertexShader: PANO_VIDEO_MATERIAL_VERTEX_SHADER,
        fragmentShader: PANO_VIDEO_TILE_MATERIAL_FRAGMENT_SHADER,
        uniforms: {
          size: new Uniform(null),
          matrix: new Uniform(null),
          alpha: new Uniform(null),
          map: new Uniform(null)
        },
        depthTest: false,
        depthWrite: false,
        defines: {
          USE_PANO_VIDEO: false
        },
        blending: CustomBlending,
        blendSrc: SrcAlphaFactor,
        blendDst: OneMinusSrcAlphaFactor,
        blendSrcAlpha: OneFactor,
        blendDstAlpha: OneMinusSrcAlphaFactor
      }), this.object = new Mesh(sharedGeometry$1, this.material), this.object.visible = false, this.object.renderOrder = -1, this.object.frustumCulled = false, this.object.name = "pano-video", this.alphaMotion = new Motion({ alpha: 0 });
    }
    return n45.prototype.setMaterial = function(t) {
      t ? (this.material.uniforms.size.value = t.size, this.material.uniforms.matrix.value = t.matrix, this.material.uniforms.map.value = t.map, this.alphaMotion.set({ alpha: t.alpha }, 500).catch(noop$1), this.material.uniforms.alpha.value = t.alpha) : (this.material.uniforms.size.value = null, this.material.uniforms.matrix.value = null, this.material.uniforms.map.value = null, this.alphaMotion.set({ alpha: 0 }, 0).catch(noop$1));
      var e = t !== null, r = this.material.defines.USE_PANO_VIDEO;
      e !== r && (this.material.defines.USE_PANO_VIDEO = e, this.material.needsUpdate = true, this.object.visible = t !== null);
    }, n45.prototype.updateTime = function(t) {
      this.alphaMotion.ended || (this.alphaMotion.update(t), this.material.uniforms.alpha.value = this.alphaMotion.value.alpha);
    }, n45.prototype.dispose = function() {
      this.material.dispose();
    }, n45;
  }()
);
var ROTATE_Y_PI_MATRIX$1 = new Matrix4().makeRotationAxis(new Vector3(0, 1, 0), Math.PI);
var PANO_TEXTURE_SCALE$1 = new Vector3(-1, 1, 1);
var CubeRenderTargetPool = (
  /** @class */
  function() {
    function n45(t) {
      t === void 0 && (t = 0), this.width = t, this.pool = [];
    }
    return Object.defineProperty(n45.prototype, "size", {
      get: function() {
        return this.pool.length;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.create = function() {
      return new WebGLCubeRenderTarget(this.width, { stencilBuffer: false, depthBuffer: false });
    }, n45.prototype.pop = function() {
      var t = this.pool.pop();
      return t || this.create();
    }, n45.prototype.push = function(t) {
      this.pool.indexOf(t) === -1 && this.pool.push(t);
    }, n45.prototype.clear = function() {
      for (var t = 0, e = this.pool; t < e.length; t++) {
        var r = e[t];
        r.dispose();
      }
      this.pool.length = 0;
    }, n45;
  }()
);
var defaultPanoramaControllerCustomInitArgs = __assign(__assign({}, defaultPanoramaLikeControllerCustomInitArgs), { maxAccessibleDistance: 5, panoTapTriggerRadius: 0.5, panoCircleMeshCreator: function(n45) {
  return new PanoCircleMesh();
}, tiledCubeTextureLevel: 2, tileLevelForFov: function(n45, t) {
  var e, r = function(l) {
    return l / 180 * Math.PI;
  }, o = (e = Math.log2) !== null && e !== void 0 ? e : function(l) {
    return Math.log(l) * Math.LOG2E;
  }, s = t.height / 2 / Math.tan(r(n45 / 2)) * Math.tan(r(45)) * 2, u = Math.max(o(s / 512), 0);
  return u < 2.3 && u > 0.1 && (u = 1), u = u % 1 > 0.75 ? Math.ceil(u) : Math.floor(u), u;
}, tileMaxRequest: 3, luminanceAdaptiveEffectEnable: true });
var PanoramaController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o, s, u, l, c = t.parseArgs(e);
      r = n45.call(this, c) || this, r.mode = "Panorama", r.tileLevel = 0, r.initAnimationed = false, r.maxAccessibleDistance = c.maxAccessibleDistance, r.panoTapTriggerRadius = c.panoTapTriggerRadius, r.panoCircleMeshCreator = c.panoCircleMeshCreator, r.tiledCubeTextureLevel = c.tiledCubeTextureLevel, r.tileLevelForFov = c.tileLevelForFov, r.tileMaxRequest = c.tileMaxRequest, r.luminanceAdaptiveEffectEnable = c.luminanceAdaptiveEffectEnable, r.luminanceAdaptiveEffect = new LuminanceAdaptiveEffect(r.renderer, r.modelScene, r.camera, r.models), r.colorCubeRenderTargetPool = new CubeRenderTargetPool(), r.luminanceCubeRenderTargetPool = new CubeRenderTargetPool();
      var f = r.models.getMaterial() || {}, d = f.pano0, h = f.pano1;
      d && (h == null ? void 0 : h.map) !== d.map && (r.models.setMaterial({ pano0: h }), d.map.dispose(), d.map instanceof TileCubeTextureTarget && d.map.cubeRenderTarget && r.colorCubeRenderTargetPool.push(d.map.cubeRenderTarget), d.luminanceMap && (d.luminanceMap.dispose(), d.luminanceMap instanceof TileCubeTextureTarget && d.luminanceMap.cubeRenderTarget && r.luminanceCubeRenderTargetPool.push(d.luminanceMap.cubeRenderTarget)));
      var v = /* @__PURE__ */ new Set();
      d && v.add(d), h && v.add(h);
      for (var A = r.colorCubeRenderTargetPool.size + v.size; A < 2; A++) {
        var g = Math.max(1024 * r.tiledCubeTextureLevel, 512), p = r.colorCubeRenderTargetPool.create();
        p.setSize(g, g), renderCubeTextureToCubeRenderTarget(null, p, r.renderer), r.colorCubeRenderTargetPool.push(p);
      }
      r.panoMeshes = {}, r.updatePanoMeshes(), r.locationMotion = new Motion({
        count: 0,
        distance: r.camera.pose.distance
      }), r.modelAlphaMotion = new Motion({
        modelAlpha: (s = (o = r.models.getMaterial()) === null || o === void 0 ? void 0 : o.modelAlpha) !== null && s !== void 0 ? s : 0
      }), r.perspToOrthoMotion = new Motion({
        perspToOrtho: r.camera.perspToOrtho.x
      }), r.panoResources = {}, r.panoResources[r.locationMotion.keyframes[0].key = r.locationMotion.keyframes[1].key = createUuid()] = {
        panoId: panoStringify(r.currentPano),
        panoPicture: (l = (u = r.models.getMaterial()) === null || u === void 0 ? void 0 : u.pano1) !== null && l !== void 0 ? l : null,
        position: r.camera.pose.offset.clone(),
        effect: "fly",
        fixCameraTransform: new Matrix4()
      };
      var y = r.works.getResolvedObserver(r.currentPano);
      return r.textureLoader = new TextureLoader2(), r.tiling = new Tiling(y ? getFetcher(y.work) : internalFetcher, r.tiledCubeTextureLevel + 1, r.imageOptions), r.scene.add(r.tiling.object), r.panoVideo = new PanoVideo(), r.scene.add(r.panoVideo.object), r;
    }
    return t.parseArgs = function(e) {
      var r, o, s, u, l, c, f;
      if (e instanceof t)
        return e;
      var d = n45.parseArgs.call(this, e);
      return __assign(__assign({}, d), { maxAccessibleDistance: (r = e.maxAccessibleDistance) !== null && r !== void 0 ? r : defaultPanoramaControllerCustomInitArgs.maxAccessibleDistance, panoTapTriggerRadius: (o = e.panoTapTriggerRadius) !== null && o !== void 0 ? o : defaultPanoramaControllerCustomInitArgs.panoTapTriggerRadius, panoCircleMeshCreator: (s = e.panoCircleMeshCreator) !== null && s !== void 0 ? s : defaultPanoramaControllerCustomInitArgs.panoCircleMeshCreator, tiledCubeTextureLevel: (u = e.tiledCubeTextureLevel) !== null && u !== void 0 ? u : defaultPanoramaControllerCustomInitArgs.tiledCubeTextureLevel, tileLevelForFov: (l = e.tileLevelForFov) !== null && l !== void 0 ? l : defaultPanoramaControllerCustomInitArgs.tileLevelForFov, tileMaxRequest: (c = e.tileMaxRequest) !== null && c !== void 0 ? c : defaultPanoramaControllerCustomInitArgs.tileMaxRequest, luminanceAdaptiveEffectEnable: (f = e.luminanceAdaptiveEffectEnable) !== null && f !== void 0 ? f : defaultPanoramaControllerCustomInitArgs.luminanceAdaptiveEffectEnable });
    }, t.initAnimationEndState = function(e) {
      var r = this.parseArgs(e), o = n45.initAnimationEndState.call(this, r);
      return __assign(__assign({}, o), { mode: "Panorama" });
    }, t.prototype.updateConfiguration = function(e) {
      var r = this, o = n45.prototype.updateConfiguration.call(this, e);
      if (o === false)
        return false;
      if (e.maxAccessibleDistance !== void 0 && this.maxAccessibleDistance !== e.maxAccessibleDistance && (this.maxAccessibleDistance = e.maxAccessibleDistance), e.panoTapTriggerRadius !== void 0 && this.panoTapTriggerRadius !== e.panoTapTriggerRadius && (this.panoTapTriggerRadius = e.panoTapTriggerRadius), e.panoCircleMeshCreator !== void 0 && this.panoCircleMeshCreator !== e.panoCircleMeshCreator && (this.panoCircleMeshCreator = e.panoCircleMeshCreator, this.panoMeshes)) {
        for (var s = Object.keys(this.panoMeshes), u = 0, l = s; u < l.length; u++) {
          var c = l[u], f = this.panoMeshes[c];
          this.helper.remove(f), f.dispose(), delete this.panoMeshes[c];
        }
        this.updatePanoMeshes();
      }
      return e.tiledCubeTextureLevel !== void 0 && this.tiledCubeTextureLevel !== e.tiledCubeTextureLevel && (this.tiledCubeTextureLevel = e.tiledCubeTextureLevel, setTimeout(function() {
        r.moveToPano(r.currentPano, {}, true);
      }, 30)), e.tileLevelForFov !== void 0 && this.tileLevelForFov !== e.tileLevelForFov && (this.tileLevelForFov = e.tileLevelForFov), e.tileMaxRequest !== void 0 && this.tileMaxRequest !== e.tileMaxRequest && (this.tileMaxRequest = e.tileMaxRequest), e.luminanceAdaptiveEffectEnable !== void 0 && this.luminanceAdaptiveEffectEnable !== e.luminanceAdaptiveEffectEnable && (this.luminanceAdaptiveEffectEnable = e.luminanceAdaptiveEffectEnable), true;
    }, t.prototype.destroy = function() {
      var e, r;
      if (n45.prototype.destroy.call(this), this.scene.remove(this.tiling.object), this.tiling.dispose(), this.locationMotion.dispose(), this.colorCubeRenderTargetPool.clear(), this.luminanceCubeRenderTargetPool.clear(), delete this.pendingTextureTask, this.panoMeshes)
        for (var o = Object.keys(this.panoMeshes), s = 0, u = o; s < u.length; s++) {
          var l = u[s], c = this.panoMeshes[l];
          this.helper.remove(c), c.dispose(), delete this.panoMeshes[l];
        }
      var f = this.videoTexture.image;
      f.pause(), f.oncanplay = function() {
      }, f.ontimeupdate = function() {
      }, this.scene.remove(this.panoVideo.object), this.panoVideo.setMaterial(null), this.panoVideo.dispose();
      for (var d = (e = this.models.getMaterial()) !== null && e !== void 0 ? e : {}, h = d.pano0, v = d.pano1, A = 0, g = Object.keys(this.panoResources); A < g.length; A++) {
        var p = g[A], y = this.panoResources[p];
        if (y.panoPicture) {
          var m = y.panoPicture.map;
          m && m !== (h == null ? void 0 : h.map) && m !== (v == null ? void 0 : v.map) && (m.dispose(), (r = y.panoPicture.luminanceMap) === null || r === void 0 || r.dispose(), y.panoPicture = null);
        }
        delete this.panoResources[p];
      }
      this.luminanceAdaptiveEffect.dispose();
    }, t.prototype.isReady = function() {
      return this.locationMotion.ended !== true ? false : n45.prototype.isReady.call(this);
    }, t.prototype.isTileReady = function() {
      var e, r, o, s = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[this.locationMotion.keyframes.length - 1]), u = ((e = s.panoPicture) === null || e === void 0 ? void 0 : e.map) instanceof TileCubeTextureTarget && (o = (r = s.panoPicture) === null || r === void 0 ? void 0 : r.map.tilePending) !== null && o !== void 0 ? o : 0, l = u <= 0, c = this.tiling.pedding, f = this.tiling.object.visible && c <= 0;
      return this.initAnimationed && l && f;
    }, t.prototype.updateWork = function(e, r, o, s) {
      var u = this;
      this.userAction = s, this.works = e;
      var l = t.initAnimationEndState(__assign(__assign({}, this), { initial: {
        currentState: __assign(__assign({}, this.currentPano), this.camera.pose),
        duration: o.duration,
        effect: o.effect,
        state: r,
        userAction: s
      } })), c = {
        workCode: l.workCode,
        panoIndex: l.panoIndex
      }, f = this.works.getWork(c.workCode);
      return this.tiling.setFetcher(f ? getFetcher(f) : internalFetcher), this.tiling.cleanup(), this.initAnimationed = false, this.hideIntersectMesh(), this.updatePanoMeshes(), this.moveToPano(c, {
        effect: o.effect,
        duration: o.duration,
        longitude: r.longitude,
        latitude: r.latitude,
        fov: r.fov,
        moveEndCallback: function() {
          u.initAnimationed = true;
        },
        moveCancelCallback: function() {
          u.initAnimationed = true;
        }
      }, s), true;
    }, t.prototype.updateModel = function(e) {
      this.models = e, this.updatePanoMeshes();
    }, t.prototype.updateTime = function(e, r) {
      var o = this, s, u, l, c, f, d, h, v, A, g;
      if (!this.destroyed) {
        var p = {}, y = {}, m = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[0]), E = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[this.locationMotion.keyframes.length - 1]), b = false;
        if (this.cameraMotion.ended === false && (this.cameraMotion.update(e), y.longitude = this.cameraMotion.value.longitude, y.latitude = this.cameraMotion.value.latitude, y.fov = this.cameraMotion.value.fov), this.modelAlphaMotion.ended === false && (this.modelAlphaMotion.update(e), p.modelAlpha = this.modelAlphaMotion.value.modelAlpha), this.perspToOrthoMotion.ended === false && (this.perspToOrthoMotion.update(e), this.camera.perspToOrtho.setScalar(clamp$1(this.perspToOrthoMotion.value.perspToOrtho, 0, 1))), this.locationMotion.ended === false) {
          this.locationMotion.update(e);
          var T = this.locationMotion.getKeyFrameSegment(e), R = T[0], S = T[1], M = this.panoResourceFromLocationMotionKeyframe(R), w = this.panoResourceFromLocationMotionKeyframe(S), H = new Vector3().copy(M.position), L = new Vector3().copy(w.position), C = this.locationMotion.value.count - S.value.count + 1;
          p.progress = C, w.panoPicture && (C < 1 ? M.panoPicture && (p.pano0 = M.panoPicture) : p.pano0 = w.panoPicture, p.pano1 = w.panoPicture), w.effect === "montage" ? p.transition = "BLACK" : w.effect === "spread" ? p.transition = "SPREAD" : p.transition = "FADE", (w.effect === "zoomin" || w.effect === "zoomout") && (p.progress = Math.pow(C, 3)), C < 1 && w.effect !== "fly" && (p.pano0 && M.panoPicture && (p.pano0 = {
            map: p.pano0.map,
            zoom: p.pano0.zoom,
            luminanceMap: p.pano0.luminanceMap,
            matrix: M.panoPicture.matrix.clone().premultiply(M.fixCameraTransform).setPosition(w.position)
          }), H.copy(L), b = true), y.distance = this.locationMotion.value.distance, y.offset = new Vector3(H.x + (L.x - H.x) * C, H.y + (L.y - H.y) * C, H.z + (L.z - H.z) * C);
          for (var I = [], _ = [], O = 0, P = this.locationMotion.keyframes; O < P.length; O++) {
            var N = P[O], k = N.key, U = N.progress;
            k !== void 0 && (I.push(k), U > this.locationMotion.progress && _.push(k));
          }
          for (var D = 0, q = Object.keys(this.panoResources); D < q.length; D++) {
            var z = q[D];
            if (!(_.indexOf(z) >= 0)) {
              var Q = this.panoResources[z];
              if (Q.panoPicture) {
                var G = Q.panoPicture.map, X = Q.panoPicture.luminanceMap;
                if (G) {
                  if (G === ((s = p.pano0) === null || s === void 0 ? void 0 : s.map) || G === ((u = p.pano1) === null || u === void 0 ? void 0 : u.map))
                    continue;
                  G instanceof TileCubeTextureTarget && G.cubeRenderTarget && this.colorCubeRenderTargetPool.push(G.cubeRenderTarget), G.dispose(), X && (X instanceof TileCubeTextureTarget && X.cubeRenderTarget && this.luminanceCubeRenderTargetPool.push(X.cubeRenderTarget), X.dispose()), Q.panoPicture = null;
                }
              }
              I.indexOf(z) >= 0 || delete this.panoResources[z];
            }
          }
          this.currentPano = panoParse(w.panoId), this.emit("pano.moving", createEvent("pano.moving", {
            userAction: this.userAction,
            prevPano: panoParse(m.panoId),
            state: __assign(__assign(__assign(__assign({}, panoParse(E.panoId)), { mode: this.mode }), clonePose(this.camera.pose)), y),
            options: {},
            progress: this.locationMotion.progress,
            error: null
          }));
        }
        isEmptyObject(p) === false && (!((l = p.pano0) === null || l === void 0) && l.map && p.pano0.map instanceof TileCubeTextureTarget && !p.pano0.map.cubeRenderTarget && (p.pano0.map.cubeRenderTarget = this.colorCubeRenderTargetPool.pop()), !((c = p.pano0) === null || c === void 0) && c.luminanceMap && p.pano0.luminanceMap instanceof TileCubeTextureTarget && !p.pano0.luminanceMap.cubeRenderTarget && (p.pano0.luminanceMap.cubeRenderTarget = this.luminanceCubeRenderTargetPool.pop()), !((f = p.pano1) === null || f === void 0) && f.map && p.pano1.map instanceof TileCubeTextureTarget && !p.pano1.map.cubeRenderTarget && (p.pano1.map.cubeRenderTarget = this.colorCubeRenderTargetPool.pop()), !((d = p.pano1) === null || d === void 0) && d.luminanceMap && p.pano1.luminanceMap instanceof TileCubeTextureTarget && !p.pano1.luminanceMap.cubeRenderTarget && (p.pano1.luminanceMap.cubeRenderTarget = this.luminanceCubeRenderTargetPool.pop()), this.models.setMaterial(p)), isEmptyObject(y) === false && this.setCamera(y);
        var $ = this.works.getResolvedObserver(this.currentPano), W = this.locationMotion.ended ? this.getForwardObserverOrNot() : null;
        if (this.camera.pose.distance > 0.1 || b)
          for (var oe = 0, ie = Object.keys(this.panoMeshes); oe < ie.length; oe++) {
            var re = ie[oe], j = this.panoMeshes[re];
            j.setOpacity(0), j.setCurrent(false), j.updateTime && j.updateTime(e, r), j.visible = false;
          }
        else if ($) {
          var se = arrayMin($.visibleIds, function(me) {
            var ce = o.works.getResolvedObserver(me);
            return ce ? $.standingPosition.distanceTo(ce.standingPosition) : 1 / 0;
          }, true), ae = se[1];
          ae = clamp$1(ae, 2.5, 1 / 0);
          for (var ue = $.visibleIds.concat(panoStringify(this.currentPano)), fe = this.camera.getDirection(new Vector3()), ne = 0, Te = Object.keys(this.panoMeshes); ne < Te.length; ne++) {
            var re = Te[ne], j = this.panoMeshes[re], Re = this.works.getResolvedObserver(re);
            if (ue.indexOf(re) === -1)
              j.setCurrent(false), j.setOpacity(0);
            else if (!Re)
              j.setCurrent(false), j.setOpacity(0);
            else if (!Re.loadable && !Re.active)
              j.setCurrent(false), j.setOpacity(0);
            else {
              var ve = j.position.clone().setY(this.camera.position.y).distanceTo(this.camera.position);
              j.setCurrent(!j.loading && j.progress === 0 && W !== null && W.panoId === re), j.setOpacity(ve < 0.01 ? 0 : clamp$1(ae / ve * 1.2, 0.4, 0.85));
              var Ce = this.camera.position.clone().setY(j.position.y), Z = new Vector3().copy(j.position).sub(Ce).normalize();
              if (re === panoStringify(this.currentPano)) {
                var te = clamp$1((0.5 - Ce.distanceTo(j.position)) / 0.5, 0, 1);
                Z.multiplyScalar(1 - te).add(fe.clone().multiplyScalar(te));
              }
              Z.length() > 0 && j.quaternion.setFromEuler(new Euler(0, Math.atan2(Z.x, Z.z), 0));
            }
            j.updateTime && j.updateTime(e, r);
          }
        }
        var K = this.tileLevel = function() {
          if (o.tileLevelForFov === false)
            return 0;
          var me = o.renderer.getDrawingBufferSize(new Vector2());
          me.width *= o.scissor.width, me.height *= o.scissor.height;
          var ce = E.panoId, pe = o.works.getResolvedObserver(ce), ee = o.imageOptions.size;
          if (typeof ee == "undefined" && pe) {
            var he = pe.images.up.match(/\/cube_(\d+)\//);
            he && (ee = Number(he[1]));
          }
          typeof ee == "undefined" && (ee = 2048);
          var Se = 0;
          ee >= 1024 && (Se = 1), ee >= 2048 && (Se = 2), ee >= 4096 && (Se = 3), ee >= 8192 && (Se = 4);
          var Ie = o.tileLevelForFov(o.camera.fov, me);
          return Ie > Se ? Ie : 0;
        }(), ye = function() {
          var me = o.camera.quaternion.clone(), ce = o.works.getResolvedObserver(E.panoId), pe = ce != null ? ce : $;
          pe && me.premultiply(pe.quaternion.clone().inverse());
          var ee = new Matrix4().makeRotationFromQuaternion(me), he = new Matrix4().getInverse(ee), Se = new Frustum().setFromProjectionMatrix(new Matrix4().multiplyMatrices(o.camera.projectionMatrix, he));
          return Se;
        }();
        E.panoId === panoStringify(this.currentPano) && (((h = E.panoPicture) === null || h === void 0 ? void 0 : h.map) instanceof TileCubeTextureTarget && (E.panoPicture.map.maxRequest = this.tileMaxRequest, E.panoPicture.map.update(ye, Math.min(K, this.tiledCubeTextureLevel)), E.panoPicture.map.needsRender === true && (E.panoPicture.map.needsRender = false, this.needsRender = true, this.modelSceneNeedsRender = true)), ((v = E.panoPicture) === null || v === void 0 ? void 0 : v.luminanceMap) instanceof TileCubeTextureTarget && (E.panoPicture.luminanceMap.maxRequest = this.tileMaxRequest, E.panoPicture.luminanceMap.update(ye, Math.min(K, this.tiledCubeTextureLevel)), E.panoPicture.luminanceMap.needsRender === true && (E.panoPicture.luminanceMap.needsRender = false, this.needsRender = true, this.modelSceneNeedsRender = true)));
        {
          var de = this.tiling.object.visible;
          if (this.initAnimationed) {
            var xe = E.panoId, Ae = this.works.getResolvedObserver(xe);
            Ae ? isSimilarVector3(this.camera.position, Ae.position) && this.locationMotion.ended ? (this.tiling.object.visible = true, this.tiling.panoId !== xe && this.tiling.cleanup(), this.tiling.panoId = xe, this.tiling.setResource((g = (A = Ae.images) === null || A === void 0 ? void 0 : A.tiles) !== null && g !== void 0 ? g : [], this.enableIOSEDR && Ae.images.luminance ? Ae.images.luminance : null), this.tiling.setFetcher(getFetcher(Ae.work)), this.tiling.setRotation(Ae.quaternion), this.tiling.setPosition(Ae.position), this.tiling.maxRequest = this.tileMaxRequest, K > this.tiledCubeTextureLevel ? this.tiling.update(ye, K, e) : this.tiling.update(ye, 0, e)) : this.tiling.object.visible = false : this.tiling.object.visible = false;
          } else
            this.tiling.object.visible = false;
          de !== this.tiling.object.visible && (this.tiling.object.needsRender = true, this.modelSceneNeedsRender = true);
        }
        this.panoVideo.object.position.copy(this.camera.position), this.panoVideo.updateTime(e), this.intersectMesh.scale.setScalar(clamp$1(this.cameraMotion.value.fov / 45, 0, 1));
      }
    }, t.prototype.render = function(e, r) {
      var o = this.renderer.getRenderTarget(), s = this.works.getResolvedObserver(this.currentPano);
      s && s.video && (this.needsRender = true, this.modelSceneNeedsRender = true), this.updateScreenBuffer(r), this.enableFragDepth ? (e && (r === "luminance" ? (this.luminanceAdaptiveEffect.enable = this.luminanceAdaptiveEffectEnable, this.luminanceAdaptiveEffect.render(this.screenBuffers)) : (this.renderer.setRenderTarget(this.modelRenderTarget), this.renderer.render(this.modelScene, this.camera))), this.depthCopyPass.render(this.modelRenderTarget.depthTexture, o), this.renderer.autoClearDepth = false, this.renderer.autoClearColor = true, this.copyPass.render(this.modelRenderTarget, o), this.renderer.setRenderTarget(o), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, this.camera), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true) : r === "luminance" ? (this.luminanceAdaptiveEffect.enable = this.luminanceAdaptiveEffectEnable, this.luminanceAdaptiveEffect.render(this.screenBuffers)) : (this.renderer.render(this.modelScene, this.camera), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, this.camera), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true);
    }, t.prototype.postProcessing = function(e, r) {
      if (!this.destroyed && r === "luminance")
        return this.luminanceAdaptiveEffect || (this.luminanceAdaptiveEffect = new LuminanceAdaptiveEffect(this.renderer, this.scene, this.camera, this.models), this.luminanceAdaptiveEffect.enable = this.luminanceAdaptiveEffectEnable), this.luminanceAdaptiveEffect.render(e);
    }, t.prototype.getTargetState = function() {
      var e = this.cameraMotion.getKeyFrameSegment(now())[1], r = this.locationMotion.getKeyFrameSegment(now())[1], o = this.panoResourceFromLocationMotionKeyframe(r), s = this.works.getResolvedObserver(o.panoId);
      return {
        workCode: s ? s.work.workCode : this.currentPano.workCode,
        panoIndex: s ? s.panoIndex : this.currentPano.panoIndex,
        mode: this.mode,
        longitude: e.value.longitude,
        latitude: e.value.latitude,
        fov: e.value.fov,
        offset: s ? s.position.clone() : this.camera.position.clone(),
        distance: this.locationMotion.value.distance
      };
    }, t.prototype.moveToPano = function(e, r, o) {
      var s = this, u, l, c, f, d = (u = r.effect) !== null && u !== void 0 ? u : "fly";
      this.userAction = o, this.stopMomentumMovement();
      var h = this.works.getResolvedObserver(e);
      if (!h)
        throw new Error("Invalid PanoId ".concat(JSON.stringify(e)));
      var v = getImageSizeFromURL(h.images.up), A = this.imageOptions.size;
      typeof A == "undefined" && h && v && (A = Number(v)), typeof A == "undefined" && (A = 2048);
      var g = this.imageOptions.transform, p = __assign({ key: "pano.".concat(h.panoId) }, pick(this.imageOptions, ["format", "size", "quality", "sharpen", "mappings"])), y = h.images, m = (c = (l = h.images.tiles) === null || l === void 0 ? void 0 : l.filter(function(P) {
        return P.size > A;
      })) !== null && c !== void 0 ? c : null, E = g, b = {
        key: "pano_luminance.".concat(h.panoId),
        size: p.size ? p.size / 2 : void 0
      }, T = this.enableIOSEDR && h.images.luminance ? h.images.luminance : null, R = function() {
        if (!h.images.tiles || !T)
          return null;
        var P = getImageSizeFromURL(T.up);
        return P ? m == null ? void 0 : m.map(function(N) {
          var k = N.size * N.scale / 2;
          return P < k ? {
            level: N.level,
            size: k,
            scale: 1,
            back: replaceImageSize(T.back, k),
            front: replaceImageSize(T.front, k),
            left: replaceImageSize(T.left, k),
            right: replaceImageSize(T.right, k),
            up: replaceImageSize(T.up, k),
            down: replaceImageSize(T.down, k)
          } : {
            level: N.level,
            size: P,
            scale: k / P,
            back: T.back,
            front: T.front,
            left: T.left,
            right: T.right,
            up: T.up,
            down: T.down
          };
        }) : null;
      }(), S = "pano:" + jsonHash([
        y,
        p,
        g,
        this.tiledCubeTextureLevel
      ]);
      if (this.pendingTextureTask) {
        if (this.pendingTextureTask.hash === S)
          return;
        var M = this.pendingTextureTask.panoId;
        (f = this.panoMeshes[M]) === null || f === void 0 || f.setProgress(0), this.emit("pano.texture.abort", createEvent("pano.texture.abort", {
          error: null,
          progress: 0,
          meta: null,
          pano: h.pano
        }));
      }
      var w = "move-to-pano-" + h.panoId;
      this.pending.add(w);
      var H = this.models.getMaterial() || {}, L = H.pano0, C = H.pano1, I;
      if (L && L.map.name === S && L.luminanceMap !== null === this.enableIOSEDR ? I = L : (C == null ? void 0 : C.map.name) === S && C.luminanceMap !== null === this.enableIOSEDR && (I = C), I) {
        var _ = {
          panoId: h.panoId,
          effect: d,
          panoPicture: {
            zoom: 1,
            map: I.map,
            luminanceMap: I.luminanceMap,
            matrix: new Matrix4().compose(h.position, h.quaternion, PANO_TEXTURE_SCALE$1)
          },
          position: h.position.clone(),
          fixCameraTransform: new Matrix4()
        };
        AnimationFrameLoop.shared.add(function() {
          s.pending.delete(w), s.doMoveToPano(h.pano, _, r);
        }, true, 1);
        return;
      }
      this.pendingTextureTask = {
        panoId: h.panoId,
        hash: S,
        onLoad: function(P, N) {
          var k;
          if (s.pending.delete(w), s.destroyed)
            P.body.dispose();
          else {
            P.body.name = S;
            var U = {
              panoId: h.panoId,
              effect: d,
              panoPicture: {
                zoom: 1,
                map: P.body,
                luminanceMap: (k = N == null ? void 0 : N.body) !== null && k !== void 0 ? k : null,
                matrix: new Matrix4().compose(h.position, h.quaternion, PANO_TEXTURE_SCALE$1)
              },
              position: h.position.clone(),
              fixCameraTransform: new Matrix4()
            };
            s.doMoveToPano(h.pano, U, r);
          }
        },
        onError: function(P) {
          s.pending.delete(w);
          var N = __assign(__assign(__assign({}, h.pano), { mode: s.mode }), clonePose(s.camera.pose));
          s.emit("pano.error", createEvent("pano.error", {
            error: P,
            userAction: s.userAction,
            options: r,
            prevPano: s.currentPano,
            progress: 0,
            state: N
          })), s.emit("pano.cancel", createEvent("pano.cancel", {
            error: P,
            userAction: s.userAction,
            options: r,
            prevPano: s.currentPano,
            progress: 0,
            state: N
          })), s.emit("error", P), r.moveCancelCallback && r.moveCancelCallback();
        }
      };
      var O = this.panoMeshes[h.panoId];
      O && O.tap && O.tap(), Promise.all([
        this.tileLevelForFov && m && m.length ? this.textureLoader.loadTiledCubeTexture(y, m, {
          tileMaxLevel: this.tiledCubeTextureLevel,
          imageURL: {
            transform: g,
            options: p
          },
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          generateMipmaps: false,
          format: RGBAFormat,
          viaAjax: true,
          fetcher: getFetcher(h.work)
        }, void 0, void 0, function(P) {
          var N, k;
          s.emit("pano.texture.progress", createEvent("pano.texture.progress", {
            error: null,
            progress: P,
            meta: null,
            pano: h.pano
          })), ((N = s.pendingTextureTask) === null || N === void 0 ? void 0 : N.hash) === S && ((k = s.panoMeshes[h.panoId]) === null || k === void 0 || k.setProgress(P));
        }, this.renderer) : this.textureLoader.loadCubeTexture(y, {
          imageURL: {
            transform: g,
            options: p
          },
          format: RGBAFormat,
          viaAjax: true,
          fetcher: getFetcher(h.work)
        }, void 0, void 0, function(P) {
          var N, k;
          s.emit("pano.texture.progress", createEvent("pano.texture.progress", {
            error: null,
            progress: P,
            meta: null,
            pano: h.pano
          })), ((N = s.pendingTextureTask) === null || N === void 0 ? void 0 : N.hash) === S && ((k = s.panoMeshes[h.panoId]) === null || k === void 0 || k.setProgress(P));
        }, this.renderer),
        T ? this.tileLevelForFov && R && R.length ? this.textureLoader.loadTiledCubeTexture(T, R, {
          tileMaxLevel: this.tiledCubeTextureLevel,
          imageURL: {
            transform: E,
            options: b
          },
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          generateMipmaps: false,
          fetcher: getFetcher(h.work)
        }, void 0, void 0, void 0, this.renderer).catch(function() {
          return null;
        }) : this.textureLoader.loadCubeTexture(T, {
          imageURL: {
            transform: E,
            options: b
          },
          fetcher: getFetcher(h.work)
        }, void 0, void 0, void 0, this.renderer).catch(function() {
          return null;
        }) : Promise.resolve(null)
      ]).then(function(P) {
        var N, k, U = P[0], D = P[1];
        ((N = s.pendingTextureTask) === null || N === void 0 ? void 0 : N.hash) === S ? (s.pendingTextureTask.onLoad(U, D), (k = s.panoMeshes[h.panoId]) === null || k === void 0 || k.setProgress(0), delete s.pendingTextureTask, s.emit("pano.texture.success", createEvent("pano.texture.success", {
          error: null,
          progress: 1,
          meta: U.meta,
          pano: h.pano
        }))) : (U.body.dispose(), D == null || D.body.dispose());
      }).catch(function(P) {
        var N, k;
        ((N = s.pendingTextureTask) === null || N === void 0 ? void 0 : N.hash) === S && (s.pendingTextureTask.onError(P), (k = s.panoMeshes[h.panoId]) === null || k === void 0 || k.setProgress(0), delete s.pendingTextureTask, s.emit("pano.texture.error", createEvent("pano.texture.error", {
          error: P,
          progress: 0,
          meta: null,
          pano: h.pano
        })), s.emit("error", P));
      }), this.emit("pano.texture.load", createEvent("pano.texture.load", {
        error: null,
        progress: 0,
        meta: null,
        pano: h.pano
      }));
    }, t.prototype.initAnimation = function() {
      var e = this;
      return this.destroyed ? Promise.resolve() : new Promise(function(r) {
        var o = e.initial, s = o.duration, u = o.effect, l = o.userAction;
        e.userAction = l;
        var c = t.initAnimationEndState(e), f = {
          workCode: c.workCode,
          panoIndex: c.panoIndex
        }, d = {
          modelAlpha: 0
        }, h = {
          perspToOrtho: 0
        }, v = false;
        e.moveToPano(f, {
          longitude: c.longitude,
          latitude: c.latitude,
          fov: c.fov,
          effect: u,
          duration: s,
          moveStartCallback: function(A) {
            v = true, e.perspToOrthoMotion.set(h, s).catch(noop$1), e.modelAlphaMotion.setKeyframes([
              { progress: 0, value: __assign({}, e.modelAlphaMotion.value) },
              { progress: 0.6, value: __assign({}, e.modelAlphaMotion.value) },
              { progress: 1, value: d }
            ], s).catch(noop$1), e.emit("initAnimation.start", createEvent("initAnimation.start", {
              state: A,
              userAction: e.userAction
            }));
          },
          moveEndCallback: function(A) {
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: A,
              userAction: e.userAction
            })), e.initAnimationed = true, r();
          },
          moveCancelCallback: function() {
            var A = __assign(__assign(__assign({}, f), { mode: e.mode }), clonePose(e.camera.pose));
            v === false && e.emit("initAnimation.start", createEvent("initAnimation.start", {
              state: A,
              userAction: e.userAction
            })), e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: A,
              userAction: e.userAction
            })), e.initAnimationed = true, r();
          }
        }, l);
      });
    }, t.prototype.panoResourceFromLocationMotionKeyframe = function(e) {
      return this.panoResources[e.key];
    }, t.prototype.locationMotionKeyframesLength = function(e) {
      for (var r = 0, o = 1; o < e.length; o++) {
        var s = this.panoResourceFromLocationMotionKeyframe(e[o - 1]).position, u = this.panoResourceFromLocationMotionKeyframe(e[o]).position, l = s.distanceTo(u) * (e[o].value.count - e[o - 1].value.count);
        r += l;
      }
      return r;
    }, t.prototype.updatePanoMeshes = function() {
      for (var e = this, r = {}, o = Object.keys(this.panoMeshes), s = 0, u = o; s < u.length; s++) {
        var l = u[s], c = this.panoMeshes[l];
        r[l] = c, delete this.panoMeshes[l];
      }
      for (var f = 1, d = {}, h = function(S) {
        var M = arrayMin(S.accessibleIds, function(H) {
          var L = e.works.getResolvedObserver(H);
          if (!L)
            return 1 / 0;
          var C = L.standingPosition.distanceTo(S.standingPosition);
          return clamp$1(C, 1, 1 / 0);
        }, true), w = M[1];
        d[S.panoId] === void 0 && (d[S.panoId] = w);
      }, v = 0, A = this.works.resolvedObservers; v < A.length; v++) {
        var g = A[v];
        h(g);
      }
      var p = Object.keys(d).map(function(S) {
        return d[S];
      });
      if (p.length) {
        var y = p.reduce(function(S, M) {
          return S + M;
        }, 0) / p.length;
        f = clamp$1(y * 0.6, 1, 3);
      }
      for (var m = 0, E = this.works.resolvedObservers; m < E.length; m++) {
        var g = E[m], c = void 0;
        r[g.panoId] ? (c = r[g.panoId], c.loading === true && g.loadable === false && c.setLoading(false), delete r[g.panoId]) : (c = this.panoCircleMeshCreator(g.pano), c.name = "PanoCircleMesh_" + g.panoId, this.helper.add(c)), c.scale.set(f, 1, f), c.position.copy(g.standingPosition), this.panoMeshes[g.panoId] = c;
      }
      for (var b = 0, T = Object.keys(r); b < T.length; b++) {
        var R = T[b];
        this.helper.remove(r[R]), r[R].dispose(), delete r[R];
      }
    }, t.prototype.doMoveToPano = function(e, r, o) {
      var s = this, u, l, c, f, d, h, v, A, g, p, y;
      o === void 0 && (o = {});
      var m = now(), E = createUuid();
      this.tiling.cleanup(), this.panoResources[E] = r;
      var b = 1, T, R, S;
      if (this.locationMotion.ended) {
        var M = this.locationMotion.getKeyFrameSegment(m);
        M[0];
        var w = M[1], H = this.locationMotion.value, L = ((u = this.panoResourceFromLocationMotionKeyframe(w)) !== null && u !== void 0 ? u : this.camera).position, C = r.position;
        T = Math.max(L.distanceTo(C), b), R = [
          { key: w.key, progress: 0, value: __assign(__assign({}, H), { count: 0 }) },
          { key: E, progress: 1, value: { distance: 0, count: 1 } }
        ], S = 0;
      } else {
        var I = this.locationMotion.getKeyFrameSegment(m), _ = I[0], w = I[1], H = this.locationMotion.value, O = this.panoResourceFromLocationMotionKeyframe(_).position, L = this.panoResourceFromLocationMotionKeyframe(w).position, C = r.position, P = w.value.count - H.count, N = Math.max(O.distanceTo(L), b) * P, k = Math.max(L.distanceTo(C), b);
        T = N + k, R = [
          { key: _.key, progress: 0, value: __assign({}, H) },
          { key: w.key, progress: N / T, value: w.value },
          { key: E, progress: 1, value: { count: w.value.count + 1, distance: 0 } }
        ];
        var U = this.locationMotionKeyframesLength(this.locationMotion.keyframes), D = this.locationMotionKeyframesLength(R);
        U === 0 || U === 0 ? S = 0 : S = this.locationMotion.getProgressVelocity(m) * U / D;
      }
      var q = r.effect === "instant" ? 0 : this.calculateMovingDuration(o.duration, r.effect === "fly" ? T : 0), z = {
        longitude: o.longitude,
        latitude: o.latitude,
        fov: o.fov
      }, Q = __assign(__assign({}, e), { mode: this.mode, longitude: (l = z.longitude) !== null && l !== void 0 ? l : this.camera.pose.longitude, latitude: (c = z.latitude) !== null && c !== void 0 ? c : this.camera.pose.latitude, fov: (f = z.fov) !== null && f !== void 0 ? f : this.camera.pose.fov, offset: r.position.clone(), distance: this.camera.pose.distance }), G = this.currentPano;
      if (this.emit("pano.moveTo", createEvent("pano.moveTo", {
        options: o,
        prevPano: G,
        progress: 0,
        state: Q,
        userAction: this.userAction,
        error: null
      })), o.moveStartCallback && o.moveStartCallback(Q), this.videoTexture && this.videoTexture.image instanceof HTMLVideoElement && this.videoTexture.image.getAttribute("src") && (this.videoTexture.image.pause(), this.videoTexture.image.removeAttribute("uuid"), this.videoTexture.image.removeAttribute("src"), this.videoTexture.image.oncanplay = noop$1, this.videoTexture.needsUpdate = true), this.panoVideo.setMaterial(null), r.effect === "fly")
        this.cameraMotion.set(z, q).catch(noop$1);
      else {
        var X = coordinatesToVector({
          longitude: this.cameraMotion.value.longitude,
          latitude: this.cameraMotion.value.latitude
        }), $ = coordinatesToVector({
          longitude: (d = z.longitude) !== null && d !== void 0 ? d : this.cameraMotion.value.longitude,
          latitude: (h = z.latitude) !== null && h !== void 0 ? h : this.cameraMotion.value.latitude
        }), W = new Object3D();
        W.lookAt(X);
        var oe = new Matrix4().makeRotationFromQuaternion(W.quaternion);
        W.lookAt($);
        var ie = new Matrix4().makeRotationFromQuaternion(W.quaternion), re = new Matrix4().getInverse(oe).premultiply(ie), j = this.cameraMotion.value.fov, se = (v = z.fov) !== null && v !== void 0 ? v : this.cameraMotion.value.fov, ae = 1;
        r.effect === "zoomin" ? ae = 1.5 : r.effect === "zoomout" && (ae = 0.4);
        for (var ue = clamp$1(se * ae, 1, 170), fe = 0; fe < R.length - 1; fe++) {
          var ne = R[fe].key;
          if (ne) {
            var Te = this.panoResources[ne];
            Te && (Te.fixCameraTransform.copy(re), Te.panoPicture && (Te.panoPicture.zoom = Math.tan(j / 2 / 180 * Math.PI) / Math.tan(ue / 2 / 180 * Math.PI)));
          }
        }
        this.cameraMotion.setKeyframes([
          {
            progress: 0,
            value: {
              longitude: this.cameraMotion.value.longitude,
              latitude: this.cameraMotion.value.latitude,
              fov: this.cameraMotion.value.fov
            }
          },
          {
            progress: 0,
            value: {
              longitude: (A = z.longitude) !== null && A !== void 0 ? A : this.cameraMotion.value.longitude,
              latitude: (g = z.latitude) !== null && g !== void 0 ? g : this.cameraMotion.value.latitude,
              fov: ue
            }
          },
          {
            progress: 1,
            value: {
              longitude: (p = z.longitude) !== null && p !== void 0 ? p : this.cameraMotion.value.longitude,
              latitude: (y = z.latitude) !== null && y !== void 0 ? y : this.cameraMotion.value.latitude,
              fov: se
            }
          }
        ], q).catch(noop$1);
      }
      var Re = this.locationMotion.setKeyframes(R, q, S);
      Re.then(
        // resolve
        // 
        function() {
          for (var ve, Ce, Z = 0, te = s.models; Z < te.length; Z++) {
            var K = te[Z];
            K.show();
          }
          var ye = __assign(__assign({}, e), { mode: s.mode, longitude: s.camera.pose.longitude, latitude: s.camera.pose.latitude, fov: s.camera.pose.fov, offset: s.camera.pose.offset.clone(), distance: s.camera.pose.distance });
          s.emit("pano.arrived", createEvent("pano.arrived", {
            options: o,
            prevPano: G,
            progress: 1,
            state: ye,
            userAction: s.userAction,
            error: null
          })), o.moveEndCallback && o.moveEndCallback(ye);
          var de = s.works.getResolvedObserver(e);
          if (de && de.video && s.videoTexture && s.videoTexture.image instanceof HTMLVideoElement) {
            var xe = ROTATE_Y_PI_MATRIX$1.clone().multiply((Ce = (ve = s.models.getMaterial().pano1) === null || ve === void 0 ? void 0 : ve.matrix) !== null && Ce !== void 0 ? Ce : new Matrix4()).multiply(de.video.matrix), Ae = {
              map: s.videoTexture,
              size: de.video.size,
              matrix: xe,
              alpha: 1
            }, me = createUuid(), ce = s.videoTexture.image;
            ce.setAttribute("uuid", me), canplayVideo().then(function(pe) {
              pe && de.video && ce.getAttribute("uuid") === me && (ce.oncanplay = function() {
                ce.oncanplay = noop$1, ce.play();
              }, ce.ontimeupdate = function() {
                ce.currentTime > 0.5 && (ce.ontimeupdate = noop$1, s.panoVideo.setMaterial(Ae));
              }, ce.src = de.video.source);
            }).catch(function() {
              ce.removeAttribute("uuid");
            });
          }
        },
        // reject
        // 
        function() {
          s.emit("pano.cancel", createEvent("pano.cancel", {
            options: o,
            prevPano: G,
            progress: 0,
            state: Q,
            userAction: s.userAction,
            error: null
          })), o.moveCancelCallback && o.moveCancelCallback();
        }
      );
    }, t.prototype.getForwardObserverOrNot = function(e) {
      var r = this, o = this.works.getResolvedObserver(this.currentPano);
      if (!o)
        return null;
      var s = e != null ? e : new Raycaster(this.camera.position.clone(), this.camera.getDirection(new Vector3()));
      s.params.Points = { threshold: 0.1 };
      var u = o.standingPosition.clone();
      if (o.position.distanceTo(s.ray.origin) > 1) {
        var l = this.models.intersectRaycaster(new Raycaster(s.ray.origin, new Vector3(0, -1, 0)))[0];
        l && l.distance <= 2 ? u.copy(l.point) : u.copy(s.ray.origin).add(new Vector3(0, -1.5, 0));
      }
      var c = this.models.intersectRaycaster(s)[0], f = c ? c.point : s.ray.origin.clone().add(s.ray.direction.clone().normalize().multiplyScalar(3)), d = f.clone().sub(u).normalize();
      if (d.length() === 0)
        return null;
      for (var h = o.accessibleIds.filter(function(R) {
        if (R === panoStringify(r.currentPano))
          return false;
        var S = r.works.getResolvedObserver(R);
        if (!S)
          return false;
        var M = S.standingPosition.clone().project(r.camera);
        return Math.abs(M.z) > 1 || Math.abs(M.x) > 1 || Math.abs(M.y) > 1 ? false : S.loadable || S.active;
      }), v = h.slice().sort(function(R, S) {
        var M = r.works.getResolvedObserver(R).standingPosition.clone().distanceTo(u), w = r.works.getResolvedObserver(S).standingPosition.clone().distanceTo(u);
        return M - w;
      }), A = 0, g = [Math.PI / 8, Math.PI / 6, Math.PI / 4, Math.PI / 3]; A < g.length; A++)
        for (var p = g[A], y = 0, m = v; y < m.length; y++) {
          var E = m[y], b = this.works.getResolvedObserver(E);
          if (b) {
            var T = b.standingPosition.clone().sub(u);
            if (T && T.length() !== 0 && d.angleTo(T) < p)
              return b;
          }
        }
      return null;
    }, t.prototype.onTapGesture = function(e) {
      var r = this, o;
      if (this.userAction = e.userAction, this.stopMomentumMovement(), !!this.initAnimationed) {
        if (!this.locationMotion.ended) {
          var s = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[this.locationMotion.keyframes.length - 1]);
          if (s.panoId !== panoStringify(this.currentPano))
            return;
        }
        var u = e.center.raycaster, l = this.camera.getDirection(new Vector3()).setY(0), c = null, f = this.works.getResolvedObserver(this.currentPano);
        if (f) {
          var d = f.accessibleIds.filter(function(D) {
            if (D === panoStringify(r.currentPano))
              return false;
            var q = r.works.getResolvedObserver(D);
            return !q || q.position.distanceTo(r.camera.position) > r.maxAccessibleDistance ? false : q.loadable || q.active;
          }), h = this.models.intersectRaycaster(u)[0];
          if (h) {
            var v = arrayMin(d, function(D) {
              var q = r.works.getResolvedObserver(D);
              if (!q)
                return 1 / 0;
              var z = q.standingPosition.clone();
              return z.distanceTo(h.point);
            }, true), A = v[0], g = v[1];
            A && g < this.panoTapTriggerRadius && (c = (o = this.works.getResolvedObserver(A)) !== null && o !== void 0 ? o : null);
          }
          c || (c = this.getForwardObserverOrNot(u));
          for (var p = 0, y = this.locationMotion.keyframes; p < y.length; p++) {
            var m = y[p], E = this.panoResourceFromLocationMotionKeyframe(m);
            if (!(m.progress < this.locationMotion.progress) && c && E.panoId === c.panoId) {
              c = null;
              break;
            }
          }
          if (!c)
            this.emit("gesture.tap", e), e.defaultPrevented || this.locationMotion.ended === true && this.cameraBounce();
          else {
            for (var b = {}, T = Math.PI / 6, R = Math.PI / 12, S = c.position.clone().setY(0).sub(f.position.clone().setY(0)).normalize(), M = [], w = [], H = [], L = 0, C = c.accessibleIds; L < C.length; L++) {
              var A = C[L], I = panoParse(A);
              if (!(panoEqual(I, this.currentPano) || panoEqual(I, c.pano))) {
                var _ = this.works.getResolvedObserver(A);
                if (_) {
                  var O = _.position.clone().sub(c.position).setY(0);
                  S.angleTo(O) < T && H.push(O);
                }
              }
            }
            var P = H.length > 0 ? H : __spreadArray(__spreadArray([], M, true), w, true), N = P.slice().sort(function(D, q) {
              return D.angleTo(S) - q.angleTo(S);
            })[0];
            N && N.angleTo(l) > R && (b.longitude = Math.atan2(-N.x, -N.z)), this.cameraMotion.value.latitude < -Math.PI / 4 && (b.latitude = clamp$1(0, this.minLatitude, this.maxLatitude));
            var k = __assign({}, e.state);
            if (k.workCode = c.pano.workCode, k.panoIndex = c.pano.panoIndex, b.longitude !== void 0 && (k.longitude = b.longitude), b.latitude !== void 0 && (k.latitude = b.latitude), b.fov !== void 0 && (k.fov = b.fov), k.distance = 0, k.offset = c.position.clone(), e.state = k, this.emit("gesture.tap", e), !e.defaultPrevented) {
              if (this.emit("pano.select", createEvent("pano.select", {
                prevPano: this.currentPano,
                state: k,
                userAction: e.userAction,
                options: b,
                progress: 0,
                error: null
              })), c && !c.active) {
                var U = c.panoId;
                this.panoMeshes[U] && (this.panoMeshes[U].setDisabled(false), this.panoMeshes[U].setLoading(true));
              }
              c && c.active && this.emit("pano.request", createEvent("pano.request", {
                userAction: e.userAction,
                prevPano: this.currentPano,
                progress: 0,
                state: k,
                options: b,
                error: null
              }));
            }
          }
        }
      }
    }, t;
  }(PanoramaLikeController)
);
var DEG_TO_RAD = Math.PI / 180;
var RAD_TO_DEG = 180 / Math.PI;
var MIN_TIMESTEP = 1e-3;
var MAX_TIMESTEP = 1;
var isIOS = function() {
  var n45 = typeof navigator != "undefined" && /iPad|iPhone|iPod/.test(navigator.platform);
  return function() {
    return n45;
  };
}();
var isSafari = function() {
  var n45 = typeof navigator != "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  return function() {
    return n45;
  };
}();
var isFirefoxAndroid = function() {
  var n45 = typeof navigator != "undefined" && navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
  return function() {
    return n45;
  };
}();
var getChromeVersion = function() {
  var n45 = typeof navigator != "undefined" ? navigator.userAgent.match(/.*Chrome\/([0-9]+)/) : null, t = n45 ? parseInt(n45[1], 10) : null;
  return function() {
    return t;
  };
}();
var isChromeWithoutDeviceMotion = function() {
  var n45 = false;
  if (getChromeVersion() === 65) {
    var t = typeof navigator != "undefined" ? navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/) : null;
    if (t) {
      var e = t[1].split(".");
      e[0], e[1];
      var r = e[2], o = e[3];
      n45 = parseInt(r, 10) === 3325 && parseInt(o, 10) < 148;
    }
  }
  return function() {
    return n45;
  };
}();
var isSafariWithoutDeviceMotion = function() {
  var n45 = isIOS() && isSafari() && typeof navigator != "undefined" && navigator.userAgent.indexOf("13_4") !== -1;
  return function() {
    return n45;
  };
}();
var isR7 = function() {
  var n45 = typeof navigator != "undefined" && navigator.userAgent.indexOf("R7 Build") !== -1;
  return function() {
    return n45;
  };
}();
function isLandscapeMode() {
  var n45 = typeof window != "undefined" && (window.orientation == 90 || window.orientation == -90);
  return isR7() ? !n45 : n45;
}
function isTimestampDeltaValid(n45) {
  return !(isNaN(n45) || n45 <= MIN_TIMESTEP || n45 > MAX_TIMESTEP);
}
function getQuaternionAngle(n45) {
  if (n45.w > 1)
    return 0;
  var t = 2 * Math.acos(n45.w);
  return t;
}
var warnOnce = /* @__PURE__ */ function() {
  var n45 = {};
  return function(t, e) {
    n45[t] === void 0 && (console.warn("cardboard: " + e), n45[t] = true);
  };
}();
function getOriginFromUrl(n45) {
  var t, e = n45.indexOf("://");
  e !== -1 ? t = e + 3 : t = 0;
  var r = n45.indexOf("/", t);
  return r === -1 && (r = n45.length), n45.substring(0, r);
}
function isInsideCrossOriginIFrame() {
  if (typeof window == "undefined" || typeof document == "undefined")
    return false;
  var n45 = window.self !== window.top, t = getOriginFromUrl(document.referrer), e = getOriginFromUrl(window.location.href);
  return n45 && t !== e;
}
var updateEyeViewMatrices = /* @__PURE__ */ function() {
  function n45(r, o, s) {
    var u = o ? o[0] : 0, l = o ? o[1] : 0, c = o ? o[2] : 0, f = o ? o[3] : 1, d = u + u, h = l + l, v = c + c, A = u * d, g = u * h, p = u * v, y = l * h, m = l * v, E = c * v, b = f * d, T = f * h, R = f * v;
    return r[0] = 1 - (y + E), r[1] = g + R, r[2] = p - T, r[3] = 0, r[4] = g - R, r[5] = 1 - (A + E), r[6] = m + b, r[7] = 0, r[8] = p + T, r[9] = m - b, r[10] = 1 - (A + y), r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
  }
  function t(r, o, s) {
    var u = s[0], l = s[1], c = s[2], f, d, h, v, A, g, p, y, m, E, b, T;
    return o === r ? (r[12] = o[0] * u + o[4] * l + o[8] * c + o[12], r[13] = o[1] * u + o[5] * l + o[9] * c + o[13], r[14] = o[2] * u + o[6] * l + o[10] * c + o[14], r[15] = o[3] * u + o[7] * l + o[11] * c + o[15]) : (f = o[0], d = o[1], h = o[2], v = o[3], A = o[4], g = o[5], p = o[6], y = o[7], m = o[8], E = o[9], b = o[10], T = o[11], r[0] = f, r[1] = d, r[2] = h, r[3] = v, r[4] = A, r[5] = g, r[6] = p, r[7] = y, r[8] = m, r[9] = E, r[10] = b, r[11] = T, r[12] = f * u + A * l + m * c + o[12], r[13] = d * u + g * l + E * c + o[13], r[14] = h * u + p * l + b * c + o[14], r[15] = v * u + y * l + T * c + o[15]), r;
  }
  function e(r, o) {
    var s = o[0], u = o[1], l = o[2], c = o[3], f = o[4], d = o[5], h = o[6], v = o[7], A = o[8], g = o[9], p = o[10], y = o[11], m = o[12], E = o[13], b = o[14], T = o[15], R = s * d - u * f, S = s * h - l * f, M = s * v - c * f, w = u * h - l * d, H = u * v - c * d, L = l * v - c * h, C = A * E - g * m, I = A * b - p * m, _ = A * T - y * m, O = g * b - p * E, P = g * T - y * E, N = p * T - y * b, k = R * N - S * P + M * O + w * _ - H * I + L * C;
    return k ? (k = 1 / k, r[0] = (d * N - h * P + v * O) * k, r[1] = (l * P - u * N - c * O) * k, r[2] = (E * L - b * H + T * w) * k, r[3] = (p * H - g * L - y * w) * k, r[4] = (h * _ - f * N - v * I) * k, r[5] = (s * N - l * _ + c * I) * k, r[6] = (b * M - m * L - T * S) * k, r[7] = (A * L - p * M + y * S) * k, r[8] = (f * P - d * _ + v * C) * k, r[9] = (u * _ - s * P - c * C) * k, r[10] = (m * H - E * M + T * R) * k, r[11] = (g * M - A * H - y * R) * k, r[12] = (d * I - f * O - h * C) * k, r[13] = (s * O - u * I + l * C) * k, r[14] = (E * S - m * w - b * R) * k, r[15] = (A * w - g * S + p * R) * k, r) : null;
  }
  return function(r, o, s) {
    n45(r, o), s && t(r, r, s), e(r, r);
  };
}();
var SensorSample = (
  /** @class */
  function() {
    function n45(t, e) {
      t === void 0 && (t = new Vector3()), e === void 0 && (e = 0), this.sample = t, this.timestampS = e;
    }
    return n45.prototype.set = function(t, e) {
      this.sample = t, this.timestampS = e;
    }, n45.prototype.copy = function(t) {
      this.set(t.sample, t.timestampS);
    }, n45;
  }()
);
var ComplementaryFilter = (
  /** @class */
  function() {
    function n45(t, e) {
      this.kFilter = t, this.isDebug = e, this.currentAccelMeasurement = new SensorSample(), this.currentGyroMeasurement = new SensorSample(), this.previousGyroMeasurement = new SensorSample(), isIOS() ? this.filterQ = new Quaternion(-1, 0, 0, 1) : this.filterQ = new Quaternion(1, 0, 0, 1), this.previousFilterQ = new Quaternion(), this.previousFilterQ.copy(this.filterQ), this.accelQ = new Quaternion(), this.isOrientationInitialized = false, this.estimatedGravity = new Vector3(), this.measuredGravity = new Vector3(), this.gyroIntegralQ = new Quaternion();
    }
    return n45.prototype.addAccelMeasurement = function(t, e) {
      this.currentAccelMeasurement.set(t, e);
    }, n45.prototype.addGyroMeasurement = function(t, e) {
      this.currentGyroMeasurement.set(t, e);
      var r = e - this.previousGyroMeasurement.timestampS;
      isTimestampDeltaValid(r) && this.run_(), this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
    }, n45.prototype.getOrientation = function() {
      return this.filterQ;
    }, n45.prototype.run_ = function() {
      if (!this.isOrientationInitialized) {
        this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = true;
        return;
      }
      var t = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS, e = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, t);
      this.gyroIntegralQ.multiply(e), this.filterQ.copy(this.previousFilterQ), this.filterQ.multiply(e);
      var r = new Quaternion();
      r.copy(this.filterQ), r.inverse(), this.estimatedGravity.set(0, 0, -1), this.estimatedGravity.applyQuaternion(r), this.estimatedGravity.normalize(), this.measuredGravity.copy(this.currentAccelMeasurement.sample), this.measuredGravity.normalize();
      var o = new Quaternion();
      o.setFromUnitVectors(this.estimatedGravity, this.measuredGravity), o.inverse(), this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", RAD_TO_DEG * getQuaternionAngle(o), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
      var s = new Quaternion();
      s.copy(this.filterQ), s.multiply(o), this.filterQ.slerp(s, 1 - this.kFilter), this.previousFilterQ.copy(this.filterQ);
    }, n45.prototype.accelToQuaternion_ = function(t) {
      var e = new Vector3();
      e.copy(t), e.normalize();
      var r = new Quaternion();
      return r.setFromUnitVectors(new Vector3(0, 0, -1), e), r.inverse(), r;
    }, n45.prototype.gyroToQuaternionDelta_ = function(t, e) {
      var r = new Quaternion(), o = new Vector3();
      return o.copy(t), o.normalize(), r.setFromAxisAngle(o, t.length() * e), r;
    }, n45;
  }()
);
var PosePredictor = (
  /** @class */
  function() {
    function n45(t, e) {
      this.predictionTimeS = t, this.isDebug = e, this.previousQ = new Quaternion(), this.previousTimestampS = null, this.deltaQ = new Quaternion(), this.outQ = new Quaternion();
    }
    return n45.prototype.getPrediction = function(t, e, r) {
      if (!this.previousTimestampS)
        return this.previousQ.copy(t), this.previousTimestampS = r, t;
      var o = new Vector3();
      o.copy(e), o.normalize();
      var s = e.length();
      if (s < DEG_TO_RAD * 20)
        return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (RAD_TO_DEG * s).toFixed(1)), this.outQ.copy(t), this.previousQ.copy(t), this.outQ;
      var u = s * this.predictionTimeS;
      return this.deltaQ.setFromAxisAngle(o, u), this.outQ.copy(this.previousQ), this.outQ.multiply(this.deltaQ), this.previousQ.copy(t), this.previousTimestampS = r, this.outQ;
    }, n45;
  }()
);
var Distortion = (
  /** @class */
  function() {
    function n45(t) {
      this.coefficients = t;
    }
    return n45.prototype.distortInverse = function(t) {
      for (var e = 0, r = 1, o = t - this.distort(e); Math.abs(r - e) > 1e-4; ) {
        var s = t - this.distort(r), u = r - s * ((r - e) / (s - o));
        e = r, r = u, o = s;
      }
      return r;
    }, n45.prototype.distort = function(t) {
      for (var e = t * t, r = 0, o = 0; o < this.coefficients.length; o++)
        r = e * (r + this.coefficients[o]);
      return (r + 1) * t;
    }, n45;
  }()
);
var Pose = (
  /** @class */
  /* @__PURE__ */ function() {
    function n45() {
      this.angularAcceleration = null, this.angularVelocity = null, this.linearAcceleration = null, this.linearVelocity = null, this.orientation = null, this.position = null;
    }
    return n45;
  }()
);
var FieldOfView = (
  /** @class */
  /* @__PURE__ */ function() {
    function n45() {
      this.leftDegrees = 0, this.rightDegrees = 0, this.upDegrees = 0, this.downDegrees = 0;
    }
    return n45;
  }()
);
var Sensor = (
  /** @class */
  function() {
    function n45(t, e, r, o) {
      this.viewer = {
        id: "CardboardV1",
        label: "Cardboard I/O 2014",
        fov: 40,
        interLensDistance: 0.06,
        baselineLensDistance: 0.035,
        screenLensDistance: 0.042,
        distortionCoefficients: [0.441, 0.156],
        inverseCoefficients: [
          -0.4410035,
          0.42756155,
          -0.4804439,
          0.5460139,
          -0.58821183,
          0.5733938,
          -0.48303202,
          0.33299083,
          -0.17573841,
          0.0651772,
          -0.01488963,
          1559834e-9
        ]
      }, this.device = {
        widthMeters: 0.11,
        heightMeters: 0.062,
        bevelMeters: 4e-3
      }, this.depthNear = 0.01, this.depthFar = 1e4, this.yawOnly = r, this.accelerometer = new Vector3(), this.gyroscope = new Vector3(), this.filter = new ComplementaryFilter(t, o), this.posePredictor = new PosePredictor(e, o), this.isFirefoxAndroid = isFirefoxAndroid(), this.isIOS = isIOS();
      var s = getChromeVersion();
      this.isDeviceMotionInRadians = !this.isIOS && s !== null && s < 66, this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion() || isSafariWithoutDeviceMotion(), this.filterToWorldQ = new Quaternion(), isIOS() ? this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2), this.inverseWorldToScreenQ = new Quaternion(), this.worldToScreenQ = new Quaternion(), this.originalPoseAdjustQ = new Quaternion();
      var u = typeof window != "undefined" ? -window.orientation * Math.PI / 180 : 0;
      this.originalPoseAdjustQ.setFromAxisAngle(new Vector3(0, 0, 1), u), this.setScreenTransform_(), isLandscapeMode() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ), this.resetQ = new Quaternion(), this.orientationOut_ = new Float32Array(4), this.previousTimestampS = Date.now();
    }
    return n45.prototype.getPosition = function() {
      return null;
    }, n45.prototype.getOrientation = function() {
      var t;
      if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
        this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
          var s = new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), 0), u = new Quaternion();
          return typeof window != "undefined" && window.orientation === -90 ? u.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / -2) : u.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2), s.multiply(u);
        }(), this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
          var s = new Quaternion();
          return s.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2), s;
        }(), t = this._deviceOrientationQ;
        var e = new Quaternion();
        return e.copy(t), e.multiply(this.deviceOrientationFilterToWorldQ), e.multiply(this.resetQ), e.multiply(this.worldToScreenQ), e.multiplyQuaternions(this.deviceOrientationFixQ, e), this.yawOnly && (e.x = 0, e.z = 0, e.normalize()), this.orientationOut_[0] = e.x, this.orientationOut_[1] = e.y, this.orientationOut_[2] = e.z, this.orientationOut_[3] = e.w, this.orientationOut_;
      } else {
        var r = this.filter.getOrientation();
        t = this.posePredictor.getPrediction(r, this.gyroscope, this.previousTimestampS);
      }
      var o = new Quaternion();
      return o.copy(this.filterToWorldQ), o.multiply(this.resetQ), o.multiply(t), o.multiply(this.worldToScreenQ), this.yawOnly && (o.x = 0, o.z = 0, o.normalize()), this.orientationOut_[0] = o.x, this.orientationOut_[1] = o.y, this.orientationOut_[2] = o.z, this.orientationOut_[3] = o.w, this.orientationOut_;
    }, n45.prototype.getPose = function() {
      var t = new Pose();
      return t.orientation = this.getOrientation(), t;
    }, n45.prototype.resetPose = function() {
      this.resetQ.copy(this.filter.getOrientation()), this.resetQ.x = 0, this.resetQ.y = 0, this.resetQ.z *= -1, this.resetQ.normalize(), isLandscapeMode() && this.resetQ.multiply(this.inverseWorldToScreenQ), this.resetQ.multiply(this.originalPoseAdjustQ);
    }, n45.prototype.getFrameData = function(t) {
      var e = this.getOrientation(), r = this.getEyeOffset(), o = this.getEyeProjectionMatrix();
      return t.pose.angularAcceleration = null, t.pose.angularVelocity = null, t.pose.linearAcceleration = null, t.pose.linearVelocity = null, t.pose.orientation = e, t.pose.position = null, t.timestamp = this.previousTimestampS, t.leftProjectionMatrix.set(o.left), t.rightProjectionMatrix.set(o.right), updateEyeViewMatrices(t.leftViewMatrix, e, r.left), updateEyeViewMatrices(t.rightViewMatrix, e, r.right), t;
    }, n45.prototype.start = function() {
      if (typeof window == "undefined")
        return function() {
        };
      var t = this.onDeviceMotion_.bind(this), e = this.onOrientationChange_.bind(this), r = this.onMessage_.bind(this), o = this.onDeviceOrientation_.bind(this);
      return isIOS() && isInsideCrossOriginIFrame() && window.addEventListener("message", r), window.addEventListener("orientationchange", e), this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", o) : window.addEventListener("devicemotion", t), function() {
        window.removeEventListener("devicemotion", t), window.removeEventListener("deviceorientation", e), window.removeEventListener("orientationchange", e), window.removeEventListener("message", r);
      };
    }, n45.prototype.getEyeOffset = function() {
      return {
        left: [-this.viewer.interLensDistance * 0.5, 0, 0],
        right: [this.viewer.interLensDistance * 0.5, 0, 0]
      };
    }, n45.prototype.getEyeProjectionMatrix = function() {
      var t = this.getEyeFieldOfView(), e = this.depthNear, r = this.depthFar, o = { left: [], right: [] };
      {
        var s = t.left.upDegrees * DEG_TO_RAD, u = t.left.downDegrees * DEG_TO_RAD, l = t.left.leftDegrees * DEG_TO_RAD, c = t.left.rightDegrees * DEG_TO_RAD, f = 2 / (l + c), d = 2 / (s + u);
        o.left[0] = f, o.left[1] = 0, o.left[2] = 0, o.left[3] = 0, o.left[4] = 0, o.left[5] = d, o.left[6] = 0, o.left[7] = 0, o.left[8] = -((l - c) * f * 0.5), o.left[9] = (s - u) * d * 0.5, o.left[10] = r / (e - r), o.left[11] = -1, o.left[12] = 0, o.left[13] = 0, o.left[14] = r * e / (e - r), o.left[15] = 0;
      }
      {
        var s = t.right.upDegrees * DEG_TO_RAD, u = t.right.downDegrees * DEG_TO_RAD, l = t.right.leftDegrees * DEG_TO_RAD, c = t.right.rightDegrees * DEG_TO_RAD, f = 2 / (l + c), d = 2 / (s + u);
        o.right[0] = f, o.right[1] = 0, o.right[2] = 0, o.right[3] = 0, o.right[4] = 0, o.right[5] = d, o.right[6] = 0, o.right[7] = 0, o.right[8] = -((l - c) * f * 0.5), o.right[9] = (s - u) * d * 0.5, o.right[10] = r / (e - r), o.right[11] = -1, o.right[12] = 0, o.right[13] = 0, o.right[14] = r * e / (e - r), o.right[15] = 0;
      }
      return o;
    }, n45.prototype.getEyeFieldOfView = function() {
      var t = this.viewer, e = this.device, r = new Distortion(t.distortionCoefficients), o = t.screenLensDistance, s = (e.widthMeters - t.interLensDistance) / 2, u = t.interLensDistance / 2, l = t.baselineLensDistance - e.bevelMeters, c = e.heightMeters - l, f = RAD_TO_DEG * Math.atan(r.distort(s / o)), d = RAD_TO_DEG * Math.atan(r.distort(u / o)), h = RAD_TO_DEG * Math.atan(r.distort(l / o)), v = RAD_TO_DEG * Math.atan(r.distort(c / o)), A = new FieldOfView(), g = new FieldOfView();
      return A.leftDegrees = Math.min(f, t.fov), A.rightDegrees = Math.min(d, t.fov), A.downDegrees = Math.min(h, t.fov), A.upDegrees = Math.min(v, t.fov), g.leftDegrees = A.rightDegrees, g.rightDegrees = A.leftDegrees, g.upDegrees = A.upDegrees, g.downDegrees = A.downDegrees, { left: A, right: g };
    }, n45.prototype.onDeviceOrientation_ = function(t) {
      this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion();
      var e = t.alpha, r = t.beta, o = t.gamma;
      e = (e || 0) * Math.PI / 180, r = (r || 0) * Math.PI / 180, o = (o || 0) * Math.PI / 180, this._deviceOrientationQ.setFromEuler(new Euler(e, r, -o, "YXZ"));
    }, n45.prototype.onDeviceMotion_ = function(t) {
      this.updateDeviceMotion_(t);
    }, n45.prototype.updateDeviceMotion_ = function(t) {
      var e = t.accelerationIncludingGravity, r = t.rotationRate, o = t.timeStamp / 1e3, s = o - this.previousTimestampS;
      if (s < 0) {
        warnOnce("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion"), this.previousTimestampS = o;
        return;
      } else if (s <= MIN_TIMESTEP || s > MAX_TIMESTEP) {
        warnOnce("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range."), this.previousTimestampS = o;
        return;
      }
      e && (this.accelerometer.set(-e.x, -e.y, -e.z), r && (isR7() ? this.gyroscope.set(-r.beta, r.alpha, r.gamma) : this.gyroscope.set(r.alpha, r.beta, r.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, o)), this.filter.addAccelMeasurement(this.accelerometer, o)), this.previousTimestampS = o;
    }, n45.prototype.onOrientationChange_ = function() {
      this.setScreenTransform_();
    }, n45.prototype.onMessage_ = function(t) {
      var e = t.data;
      if (!(!e || !e.type)) {
        var r = e.type.toLowerCase();
        r === "devicemotion" && this.updateDeviceMotion_(e.deviceMotionEvent);
      }
    }, n45.prototype.setScreenTransform_ = function() {
      this.worldToScreenQ.set(0, 0, 0, 1);
      var t = typeof window != "undefined" ? window.orientation : 0;
      switch (t) {
        case 0:
          break;
        case 90:
          this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), -Math.PI / 2);
          break;
        case -90:
          this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
          break;
      }
      this.inverseWorldToScreenQ.copy(this.worldToScreenQ), this.inverseWorldToScreenQ.inverse();
    }, n45;
  }()
);
var defaultLeftBounds = [0, 0, 0.5, 1];
var defaultRightBounds = [0.5, 0, 0.5, 1];
var Cardboard = (
  /** @class */
  function() {
    function n45(t) {
      var e = this;
      this.renderer = t, this.sensor = new Sensor(0.98, 0.04, false, false), this.scale = 1, this.cameraL = new PerspectiveCamera(), this.cameraR = new PerspectiveCamera();
      var r = this.sensor.start();
      this.dispose = function() {
        var o = e.renderer.getSize(new Vector2());
        e.renderer.setScissor(0, 0, o.width, o.height), e.renderer.setViewport(0, 0, o.width, o.height), e.renderer.setScissorTest(false), r();
      };
    }
    return n45.prototype.render = function(t, e) {
      var r = this.renderer.getSize(new Vector2());
      if (r.width > r.height) {
        var o = t.autoUpdate;
        o && (t.updateMatrixWorld(), t.autoUpdate = false);
        var s = {
          x: Math.round(r.width * defaultLeftBounds[0]),
          y: Math.round(r.height * defaultLeftBounds[1]),
          width: Math.round(r.width * defaultLeftBounds[2]),
          height: Math.round(r.height * defaultLeftBounds[3])
        }, u = {
          x: Math.round(r.width * defaultRightBounds[0]),
          y: Math.round(r.height * defaultRightBounds[1]),
          width: Math.round(r.width * defaultRightBounds[2]),
          height: Math.round(r.height * defaultRightBounds[3])
        };
        this.renderer.setScissorTest(true), this.renderer.autoClear && this.renderer.clear(), e.parent === null && e.updateMatrixWorld(), e.matrixWorld.decompose(this.cameraL.position, this.cameraL.quaternion, this.cameraL.scale), e.matrixWorld.decompose(this.cameraR.position, this.cameraR.quaternion, this.cameraR.scale);
        var l = this.sensor.getEyeOffset();
        this.cameraL.translateOnAxis(new Vector3().fromArray(l.left), this.scale), this.cameraR.translateOnAxis(new Vector3().fromArray(l.right), this.scale);
        var c = this.sensor.getEyeProjectionMatrix();
        this.cameraL.projectionMatrix.elements = c.left.slice(), this.cameraR.projectionMatrix.elements = c.right.slice(), this.renderer.setViewport(s.x, s.y, s.width, s.height), this.renderer.setScissor(s.x, s.y, s.width, s.height), this.renderer.render(t, this.cameraL), this.renderer.setViewport(u.x, u.y, u.width, u.height), this.renderer.setScissor(u.x, u.y, u.width, u.height), this.renderer.render(t, this.cameraR), this.renderer.setViewport(0, 0, r.width, r.height), this.renderer.setScissor(0, 0, r.width, r.height), this.renderer.setScissorTest(false), o && (t.autoUpdate = true);
      } else
        this.renderer.render(t, e);
    }, n45.prototype.dispose = function() {
    }, n45;
  }()
);
var cardboard = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAADqCAMAAAAvZYhaAAAC/VBMVEUAAAD///99fX37+/v5+fn29vbx8fHv7+/Nzc3o6Ojq6urh4eHU1NTR0dGDg4Pl5eWSkpLHx8fj4+Pe3t7X19fAwMDZ2dnCwsKrq6uioqLb29uNjY2enp67u7t5eXmAgIC2traWlpa5ubnKysqmpqZycnKHh4eurq6ysrKKioqDg4Pd3d12dnb9/f1vb2/s7OxlZWXz8/OoqKiZmZlpaWmbm5teXl7W1tbJycnExMRiYmJsbGywsLCPj49aWlq9vb1UVFRYWFhra2t+fn7t7e1RUVFOTk6Dg4OAgICCgoKKioqEhISIiIhqamqCgoKIiIiQkJCIiIiWlpawsLBmZmaAgICenp6Li4uBgYGTk5OMjIyVlZWFhYWCgoKvr6+Ojo59fX2SkpKvr6+Ojo6QkJCurq6BgYGxsbF8fHx4eHitra2enp6srKyJiYmurq54eHj5+fl+fn57e3v////5+fnS0tLAwMCVlZWwsLCurq5QUFCtra2EhISUlJSwsLCUlJSUlJSlpaWVlZW3t7diYmLAwMCFhYV3d3f///+tra3///9XV1eampqnp6d8fHz///////9VVVVlZWVtbW3+/v5SUlKcnJytra28vLzGxsbR0dHX19doaGiWlpafn5/Hx8ezs7Nzc3Nubm7AwMCIiIjj4+NTU1P29vZbW1vl5eVkZGTMzMxYWFjq6upfX1/k5OT////4+PjV1dWkpKRoaGj4+Pizs7Pm5ubAwMCfn5+vr6+urq4wMDCxsbG2tra5ubliYmIuLi6zs7NHR0empqY0NDRCQkKqqqo5OTmoqKg7OztfX19dXV1oaGikpKRkZGStra0hISE/Pz89PT0pKSlmZmZJSUlERERbW1s2NjZVVVUmJia7u7uEhIRXV1dZWVlLS0tOTk6srKxqamojIyNTU1MrKyuAgICCgoJRUVFra2ttbW13d3dxcXFvb299fX1zc3N2dnZ5eXl8fHyHh4eSkpKenp6Ojo6VlZWMjIyYmJihoaGcnJyJiYmamprZ2YdEAAAAunRSTlMAs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7P9s7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Oz+QSzswb9DiH3FyI57Jn1ajgu7uHYmIgr8OHHwqVOQybv6OZuUvTt3dHPrIeFSNVgLCAWD9/UqKebiH1iXVTczcvKvambhnBuY/vGrKqjlHlzVDj37s/Fw7+tpJGAeN7VzcWTgGJNQ8O9u7iko5aVjvbNsa+so1pd3mNGAAAqAElEQVR42uzZzWvTYBwH8DxNmvRlfVNr17Wl05a9dISyiugO4qVQ2g1pVyx2Q7QKCoIivgxF1HnTXbbDDnNDJ8iQHcQX8O3We1t6GnjJyYPSuTmdf4C/ZE260U5rl6bJ2g8Pu2zP5cvz++ZJhilOcOxcfPHq/NuFhVcftK8WXizeCGItFWKKX5x/23Zk3/6OPr1+j0mr1fkpkuxXv5luBbbZWPzevEWjMRja2iCrvXs3stJRFGRFEDhOT1xv5QWCkYvPPtosFg+XFZyrvSYdRUJEBA4Igg2LRuBhk+cVOndv3uWyWm0DlqMajWafXkcSNNrexA2sSQ1dvPK+86DruNUGWRn6dGoa/dvk9BjWbMLxZ7e7e3ogK5fVZtBTOKrew6Y6Xufu3Qm0d3f3dEJWGj1Fo/81dbU52isUf2T3etvZrHoG9vtxVKOJm9guF049ddrt3gBkdVCzh0DlWtO4YejT00OHnU44VwHXPgqJ4PV1bFeKDD8xH4Cs7PaAtY9AYpncfeUFSR0zc1l5B/Q4EhW9q+KCpHodXFYBjxZxWnFtk9SZrl4uK6/Hj+pmWvlxDQ2fMRq7eh0OSIpCW7Ti2iJ8/4zK7WazcloqJtUaxqLweFSl4rI6ZNOhylpxsUKpqFsF3EazS4ukNLmIKcuJpFHF6erUI8lNKeiaGrl7WcUxtu+nUUO8VsZLEDz8VBy33YCjxnko+1dsrtI5hz1q1GATcm76YCrpVnHMVgrJgWwfjCN3u1Sc3k4TkgtZNv3QcLHS3Wyly4ncqis8/qSYlFNDINl5IZ9ZDKaifFHZSCRLkzKZxZEkX1QHtUi+ZDCLQlEZ2/uQzDX2c0T4vjzuntWaatiVPiQU1YEBoahoRMNCNRBzv9zuqCNJo1BUdGU4jcOiqyDhfgmLvryoOnClkfRwhcehqDh2A4ErkGTNBa9+paLClUqSK2rkrnCjMhFK9mYMqy+4Jwhf8wjlIWcvjcYGGYbxxUZvmd6V93w9XmicHpJQmD0zifM+ZovYzFWsjMifiB0urVpRyMeJmI+pyBnCxBcaF8avQ60kL58nYkyJ78f3leUvXwqrP9e/MqzBCCaykWRp/NTKQT0fHfzN8L79WlteSm9S+MUdt2t16XR4+vVXTd2vhtVfRrL9cw9ijGB9rZDOgPRm+XxunQGnRD9Ubm8bqRgvZ0Z9woFaX81lNqQzW7MCKwy4IE5T8YfKbNWRSmG6FCtN3upSNpspKosKLBXY6jorxuPPyF+pSKWYezDIFP1YyWXYpLJlSeWFqNi0fFD7O235VFTFOWbVUjUiKRIWBaTZP5vgk/r2vZDOgkylAczD4tMCy5DW6R2V+vBlvqkohZhN8DX1dY09UkJW5b0uJMXJ/dzRIEaKpe5wmShlmEv4hOHLf84WlU8gEKLi5Zagtk5itTkR5f/trvNvj/JTsKr4Xf3366GnhKSy2WJWmZJKpypfDCoHVmHriZpu6hvzZ+zu0HH8kBj8+KvKfyfN/j/UnclvG1UcxxGnhGxKaVIIioBEosi9gVAaCSkHkFhFgAOrBEIgDixCnOAAAgmVG1cEZ7jxHzi2YzvYcWyP3cRNY6e1J2sdJ7bjbLXTLOL73rzFz88TGqip+cyLZ+kMJB++v988jwN0fSJMFb1JIFxxXXq3kq4wCIjWw/+gVT3G6+++/wOtP7wmMuUVooASqtmNQim/6djd36tUyuX9o930WnZrXagCJdwQnz3lc+JvrVb16MXW+/4P/PaRg3X0AstUUm1WRil7VIn5xzkeD74EU4fl3c0CVC0bG/iLvHi6rs7vf60ncR9E4kXbVvcbf724+a2VZpMUdCuhysgfHS5xR1KVR+dyZQdvrNdOdT9851X+IWnr/wDR0h15I2kmuSwK8eQetwG+dGP+4200rW9Oq+r8/a3NT9cPH/K3x+tRSJKx8haObvqvXx8fx8CLrokOLBp/7q69daq5An5BtrWL0trVitHFkcea4M9/FY2qGBGhQreKFNI3x68TdFXSGIaO3+P3e6a+vK1Uvc+ev7R1NT1i7pktxU3AVEU2HIee64JxDCy1lrgqrBVV3Ne7r/ztZMFq6w+NtHWdUeg604Vhu62f2/Dr277m8wQ0KqkqvnkMUSo2uWKFWKvKTxaMy1+c7Oq7Tuu9ctuZZucX/mnD5kbUpCSBkT6AG00VXNkJ0/BzYeCxk2L1Ki3AnjNtZzDaFGqPnXROw6//46vnHWmHNaMyhari/iS86EAThgYNVd0ZBM0V5U37mdXnZF51/kJbc9Mr5wmzTJSZjG7tuXVTateyK0U9WXR1oq0PHiaz9fa25kY0qp31ZIaHKn8LEYEOLDpSVI0w2dv5SvoS/F5/wkBcPYH/Is791WC3DcNuXz+3oddXzxMyXFUBmQJWZ1Kxb1oeeVPUVPF82dt6Ea4e7r+/iRnCPIG6Wit5M1zV+v6YNMDE6NiUIPmqh99aGPrs9OXH4GoY39KF+y9o4KB+XD8HNOz6vs9ek40qg4Vg7E5JUdZig83NUE7h9ZuhYLJ2vvUs6e0DfVVc6LtAwErsY9gepzTs+l8/WuPzhCQyRWPlzR6M12Bri/4Rhh6setGCKMXWz8/VzK/g6nxfczLE737ZQiQDiKpoibZ0NVeQYhcs20Kki4rfGsQY0G+JL6BhPdnX19vXS8BKbst9sVaQ5zTm+h9G0w5HGsvWbIZhzh45x+tio4pmyq4SdagqDI7br3zq+jYaVktv8/HHG8+z8ltPilBt36Sh0pNFZdzmNMvjnIzdPK5Ubh0fHsRik6oq4Fei9XP1nRBF+EDvWYXes70YyrZyTDt+56/HM2KaKtz95rkqY99pdWUdmyJURTljt/Y3C7ORqMB6ompsrZUP3doMntMpZX2L5zHtZ5uLDv5AYdswM4zk9oEw5dFUKcL0jjVWLpq5mXDIlUpM5PhDeWEMzkwzshlTmrxUNiUeMj/XiWCdBUNnhwTYwbDbVtaUO3s9OhXBkS1G55Eqind3TE636+pi9aZNGpbKxZxrenpl5Uo4HE75XC5XYC4TEb4iUpdZONBuh8DtFj3+A9Kx2sFQ+xAFGwLsYNhuC+7g9QiV1dS3Z2GKsVHxezgyWZov7Z4Y21kNTFNWgA+2Ai5CYAKf9AhhEalrR86zJO7Jl5msV3ErbG8aLrFnL1aosJD624kJUWypmyzZ6qm0qWwGgWKsEK4FwuGQJcsVMr0WoiKT1FaexkpNlt/dyaoQ84aB9uag47OXECmwbWTmCRkQP3J6JGp71xsXS9ZSOpqaBqqra1dC4USKuAKpjBdIXyRcNFtIFhC+3BjuGHsHTaqwg9De0Y5B14BuA2Xf7pw7cv2ljzBTgKxsKQJPzJWxJ+pP6lKipfs63JiBH10VcKEQ4YqSMr0CIouHa1/t7sgVhvUW8XU8Re5oAj57ic+pTOqJpqp4rImCKm5Kr0Ow5w1M18JcXQGkxwcYoSj9CF+my7KVPKhtWRjv8pb1YMfd5hKefZJUkTkVsGSZedGqVF+gfo937mZuMD+aKyaLdC3mKhWYicOVECYaVxx2PGq03JdfILLQsh7p6GjpaMGgawX1mN05//L6H0bp3S+dRagY6OrZSevGpCCCpatypxeuTduoYrkCrnAiHOC2Urk4gCvFlmkeacGy6vBlTN+7tR+QLjp25/2b61s+hSaSqq34vMBSRVuHrqtez/KXvSGIsXXFZd24weswRUC0KN64Yis6SaIlVRE+svp7Z8vdA/VnzRQ2kqurMlVrl627Ud0iBDVPPPeMYDi1cmKs4MqSFbLqMEUJRfHLRlXhYm3edCjJosKW8Hs13+PznJa7xXujaTpVwPSzSlXUAVUED1noi16JUtgtIxGGAKUEtdbOVIFAOBGCKiZrdRayLF1xflckn9M6FVtu0rbwbxN8jF/Uxrc92DKIYa0BVicfA+r26a8f/PQlqwC3IsSU7FVjXBXXpCNq8KAQ9LlCiitNFZCufIFEIsxzFQpdhSyqS9qihVjmomSLf4w+nnlq8C7QjfojqcpumKsyVfPm9pRf4lGalpYsZ3bB5fP5UgjWFRtXTJV05XNBFhEFVSA4q9mihVjA31h44k2LzhwGL14cvDhIwQaGsmaIff3c019/CQ+KHaz+qmNViklR9Lu1D5anEgn4XD7MMOHKZ+NKVQWxVFYCrhhhwzCYL2JLFuJYdRVSZQf33PMjHjngB+m+2E3BBoayBnxbX1NOe/17L1lPP0uov2pXxZt+BXE71J1NbgXhicpCEQbsVNWXNROStuIGELbkLbGi1iDwv0hldf+nkFYFWdmiSU0J4hV62wF/27PKpgv4YApFWL9haaq4K9fMTDAk8RrSFtNFu9amlMV9fUxkne/+7xjGVJ2kKrucWaWIiVXayfKu2tJ9TRUSSBRVhVdShDdOaFcM6coVDEpZ4VDUkLZEISJa62qwAKalnUTWMKV7uJuCDQxlDcS2ft5tX49WRVOFVqWqyuSnSNAxavDU+tozXdQUf4GrgH2srimqAFpclSxcnDQseLJ414q6hS0erd+JrMeH8X/UODeMcQ7IbbwAbVs/9zavHxh1ULZYq5IlaBy6qStVkx6tpe0gc4SBxSrCldtrV8AFAnNzc0wVkWUajNpoxVgFimjhcenDkHXuv+C9Uev9XzGphAqYu043hf9TlCgzh0NvgBcfXuiPXq8IV6avKa5uSFeE1NzcBI8VMJeXZbRmq6J1LBoW84UHD/fiffS5xvMTujppVeu8VUlbxZjbggdeLUEmy7+f8wFY4g2LBStVq2paUwVXMlihiYk5pgokMsvVtiCLt/g9tWWBnyFLJKvnXI8CDgiwg6GstXPsr/8UXR1kDThSSzATKbsFfvqlNS1weTtIJbHyoyvW3a+oroDqSlUVCIQhK8xVJSALCFmA1+GuejMEB1RWT2NhqnbisKS6ymQKU+5q1Dr0sNeYEWB5wop90X1tiqXfBVVXYObq1SBTJWQpXYvJyrJYyWjFGi5rBKpIr8p7V3PClZgv7ON7cApRdBG3RA+rxMOIiyCDhQFEsPRYAZtYgbmFhSCPFZivKwu2xERL6Joisp7uGRnpGenBoGsNebz+OSP214+QaRVk5SM57mpeulqOOYFbhaqSuioZmiQ2A1WGOndHt1Jc6d3K4ipkcVdqstRZ/DYVVc0SldU/Iugf6SdgpW4DrPTj9Jjd9f3szXIpmsvxUMkKNNc0VVrHKi8SR0wTT5XQhh9Zzt0VVbauUqGFxcUZ4WpmBrJAtay41eHzRJXa4oms8/2NgfWqUjIHVxzhKnqLqHLSFylLMVZegBjpCJvKfgrBkqki6K5UVZCVWFxcJKY0WUDp8HnpqfGyfnrGAdYKJlelPF7IrP/ppKI0xORhfwFCmCTmSN1nHcv+LsiQrvBoZm5x8SoTBVVclt60aLKsRZU1MDDQP9CPQdcCdV85DsQ1QL9+YDRNVBUzMCVKcFW62hyzTPFcqdECe0QVF0M3a/fJ5zQiVnbtClTFCiws5ia4KhA8QRa+Dz1ZDwzccf6i7Wx60zjCON5PEPVoq5WcRFGd+ugoN/fUSy9VT1UPTXuu1EPVr5B7T/02wAG0ZrFZMAjMshCVBRziXTCOncR2Xtqq/3nZfXZmdrdJtf15CsYiCvzyf56dmd3iH3msLv2kqvGCTnK9KcVAmNbfMf4e8xSRoor5GO29JlTlzq5UV028Ipu5EtiZyXIuKVP/r6zfWLd6Xg0ByQLUrqQo9mXqetep14D0wi3pj6m9K0dBmlw909uV2Ege4gUlVNm2nyWL9aw0Wbfv3r199zbGXUDfp9wDeh491v78Y97XF0qzwojOMw+OSgQKUWtZjXUfnVtEiVbNxuO6WOlAFLnKjFW86T5bLKZwJbFJljF3OIMqNihgJSGrWH5m3aoNU2Zj5639sKzI0nS9rD05aMJWnCQxKtpjUYVP02IFjKOgPD/Rx2sZkqocWa0zocpMVqH8FmAV2AoBqUq4Om+UFNQavOohLMzWQSV70hBPsqAqyxWeRLKEKWAh4mRKkaVPtDLLUHD/9n2M24T2c/qe7s3nRa7SGju46JZLZUOXFHbYEoUlL9GrKY7Ux/xYCFm5rurkittqLsaTKalieFClL6VlsjRKvAx37xcJjoNBNX2+AC5MVRiSPyrRKeQabFWAsn9Fj8EIT8ieiFY4SgWC5hCvwOaNPcbPkZWWrHtFuvpmJ4CrDFVwBUoYiitRi0dh4nQ7XByY+1fyMQOV+kw7h0qySBXVIGiGvh+qroZZyXLMZCmy9u7vcfANBr+X0GP6efpzfsZc9DyUpqgCJes5c0XZSs61dmqRKsCjpe9fyccCrO6eGCcGZQkKDFVN2/d9y04wHJIshiJLC1ZJytrb3t7b3vtg8Icw6J6BCdbzlKOgYNngwUrT1ZioV+ixHj8y9q8SJpC8FFdKCequmgvf8xVVubIUU/yGy9ouir3vMGtwVFOTCL+zXxaUjGRd1bUp03EFNvT9q0pEnbWskdKujlNjBejkxNBrtdzYFFylyBpklWFJytrcLoyvsHI25wsc33kHT13Zs9Sp1sUTc+9O1GEtMRLUR81+XTw5P1cHUhbfbve8ieLKlAXSZfHGymVtbCtsbG9g0L3AfGz+DMEKfNnYSRTwJ773ttyFKoZWhQ3e2RVXgO3sqftXMlR1puKg368oqgD5NHIF+pbXclxhKlZlWSmyqjkNHrKKAh1rrbgax678V1DVFclS29b1QeqqhS1nlKkoIBXNvl0zF86mKnLV8x1nbAukKbh6H1liBQuKlLX9eCc4pQv4FFX+ZVfUoJGtmxq19mRd8aZF+1cUKw7WdzWtBOk5HM1Vf4rFsStFkSur9T6yMNh/hSbr252dM2VuRa46h10AX1HTinj+xFBFsmj/KqIuwVTpmXJunlzRslkg9pDtllMdQ5USq3xZpCqRrE83dnc3djc4+AaD7kH69wT9mdOdYBD3dYnP8f7sCihYGGBtlqA0wGdaVIEUKw7e8zN1O4ZUyRIckSowgQDLpmYVkS+LhGEIWbvF8BjtfUKqkrL+mHNT+Ooq04e2VoLJsEhZZqwAzsGTLHPdzKBYgV4IAaGq6v2TVRIjlnVv9x5Gjgl6jvaYvkcVXgpVlCvBct6VtqJgiduqkiutXeNd1pOx4pAsqyYTyEjaVEtQbLdbeP9eXIGEazm5sshXXIb3igHHQlmFZIrjXXNXZYzIF6/DTnasuKxePVYFyBR84B3XUtqV2q+aUa7sFvZdrKEkocp1nZx5FonCbbGyNoOdoJUswUiVFyBYXJc6e1iqsyv9hHu/J2XVKVjSBpdVORbdioJl5Eqe7uotOp3BLBJFuMD51+VOKRL2n2Vt3tvEUH6EiUMwmcSpIledxnwOVaIQqRQv8nIFcMCrU2OnVAlZrjtiz8xuVwhVJGsKV75ZgS6YVvNk0RwrTtbDzQ8GogweYeJAswVy5b2BK6ji0Gzr1VNylXrdmU2yDFcHtus2a0oJGjPROFduZzCoWqqpmGr+Fk0JQ/giWUXwbbBzThUo8ECbu5pryXp7DFV5ripox5DFRgx1JHs6tckVSHfVA1Zn0B5MaWYF3FjXtJMnq0TJKlgWtkjbhilwI13FTYuxX08/DJKrOt4bTOnNSuro4cQyyapndHaosodVaAgVVZIpY5CzU0ozB5L1oBhZ2HHoKK6EreW8MQdQlZg/dMOnubkCIws9XK9AmmvikgW2GMpy1U+6OlkYzQqqhCxypcsSoZKmSNanRbDJtrLiXuVhCP5qxLLk/AGyXuS2q/hyxmSqaFrOmYZhP32PoZl0ZTvtk5NxiirhajY7yT4VBleA6yJZdwqR9SAIdjytBoFzCFGNuAzn3NWfx6kLHEVW33JtowRJlhWGrrp1BVRXYIj+vfRJFfUqwSxUZAE6yQpV0XGwcFmPg+DUFyQ/sveMqeLQEXHeI1dmu5IGcLzrGc2KsLETNKKjIKkiV7ZtdZbLZUtLFUxJUMqTrAk8ZJGqFFkPP32I8Z9l4XShVoEtjLeNhm6rfGLmSnMFrOm0KVxpoZJOwvHYUkrQdDVtL5erhCuJNDWdAT9TVkbPuvOwCLBL+tIHpIoFq81UUYfnvM09CkpXB3g/IzVWZIpJGWKtcJCUSapkv1qcLFcrzyhAyhXIWhqKnhVDsj5+8GFaHjx8gKF//10QvFRccU4bgFciNflQqCJZhivQw9shVXqsQD/0/YXZregw6EDVapKnCnSMCTzJolApsooAyXohRZErVOG8S1XIm/zrfzkMCqzZbGi4IlUwMsS/y1SLFR0GwxOoWoYZfV26ov5uXlN6SaqKl/UoCM6oswucKg8WG7Jn4Wb2Pq5GeCN9vQKpK3ErM/xFbl1tV1KVW12BgZsbq4z+LibwkAVSZN0pgkfsSj9SJbiAK64qttW9TlFlbqD3wzA8SDdFK+QJ/oaZ3q6gyvJWDD/jEEiEmS0LZaiKKmNA1lZxsmRjp9/e8gqqulKXtLXObVfSFZtGTXVXTXIltNg+/gq/py1w3NYKnHdm2jKQKlCCf492xvydl6FGGcnaKkjWt0FwQaakrOsGo5s4JM6beq5SN9DDxcJWelWTXAlTgNnCW5tY9GNrMmCmzpdjbXvBzBVceeSKggXgytNllVGGW1tbX3xcBNhUXsMUpQoMeKgYcSG+1qYMRqyYIj7lRBUarihV0ta4WsVmVdVf4N0vJk57xThf+i65Sq3BcBaCQWzK/L8zLzVT2AkXsu4U8IVkrePGLmWtSRRuOOdmripaCYLZYjxLqcB+BF3oOHUGoA3YDJSnaqCmapqeKuC1iYGy1mkZZVgWsm4VlCzIIleC5w2gHhCHWTUY5wr0sTttG65IlnJVaNhqA6wBIet8NfBmlkCqipuV4Wqiu1I+rOCFago3hx9t3br1ScGy6NcnvWkA0gX2kwvn9HYF3MlkYajSChAjwgonLQfv1PFDV18HZsQKjAe6q2SwvD+MYB19dKtAWeeaq+p1QpVo8jfHuisJ5Qp2sCtm6Y29T644NqGcj3+vZgX8DFcyWP6NMmtgXHNZXxTBT7jkT/t1i51GgjnP1lq7kkNr7YIptsWapCq9/kiVJHsfJkXVuKqp0j9fxb+OXTFZ7Ot7LiuFL2AQNwr5z2HJckgWY9VQmMNXKGXJvavU/fM+NsXcgxxZdhI9VUBVhaHLWjgkKuOTezrJboVb8IjLKoSfgmBFseK80GRhjPTODvQz7ljGTJLLQF1VzzBFqvKPgYJFa8AtER3jM6H8QG3vZfBDobLOhSoMwU5Dt3VE7SrzOlmbLfnSZ6HATutWZqqymxVUqXSUz8+SRei/k6IAbkC3/AuT9XkhsnByZ8XrD0NyYwTrylg3V8zLZFstv5k9tSJRdmZbp1QRslc5eqRErvRP/XvBTQlfksbXXJbGJ7CHG+NxPl/KMqwSfzc05qdQlZcr2Bni5VoyVn1KlV6Bw+liylWRK5dildHYJ06y8MSd+Zl/kNXaj0qQovX6I8j67PMCkLKqBF7B/uGhZuuEYpVx7WfPbzl+/mzBcs5ujso4nVC+Wrt5qlRXC6+ajBRhfvamfxNNGOQd6P4KWbBVmKwqgRfQNoLVmNQEGbGCnxCbYMMcV8OTqzK2MCP21yQrt7GPW51UqqSKXJ1Sa2eI0+i/C1kJPoc53KSS/xwui2KFsTxs6MlyyVVdm10JPxbCGZIqo1d1jqSpEh/gapYWK0LWn2mJ00n5BFz/MpqJ8iF9/UPdufy4FMVx/MYf4E9ghURELMQCEa/Em3gl4hWPeEYICfGKJREiQbARwULEwoYVG4nGdWk7DUHTpEbbSKudajvtdDpjiO9533POvUXNovOZ03tvaybRT76/X29Oz22HFzvOZLgaFfRk9YAqVBm+XofWIPODhVQvou9NV6pZ9Yl3XCBKbOKfIatdqlJJ4UShdNmfrVyBKAypiq0rQxU655GsUZaFVFH6XatnSVd2CQK68hNFGNrYS/rVwriRjRfVp/f0XoUpr0BMVfJTu4fUrAxTRcvQewhZmyYjW+P/CH4Jo92xkKW+nLnieUawmsKVWr6gvQmRwd9mQpoVSGWpKYrbHPn14znLl/tCr0BFKvn2z6JAVLarYlNkSgFXiTUOODt+FJCyVKzwwpx2abQwBC0RKztXdJoTf55sc2L16xkn0UrX6/VKJf+Lta5E7ItExeorXlgZ7TyBqKzAF0MsUloRYiSy1x2wdzRl+VX1fBjyzKbVCHcFW5/IH78SqmxXVeGqWahX4IrQ4k2sZKr6+jmp5tZszK+wIPTGBhNSk4AvsV7rEHaOoqzvSIbv+9EHPbMOK1IVMFcnvCITxF/0SSv/+XrG5a7ieRIrThOuSLz6NFOpXu2dEwzbEtkwkkRWD2JKMHQxV+4xh7ByPJhoMX7ieIx/eYzI0r93vwVVTJcwVtVipbl69+otWSXLVGGItq5s/XzGSdcr3FU+X5ma4E2s1StNiWVPXJhC1Jz5tTvF/qEfwhJumih62+pQFp+XrjrHkPWBEhuBKKZLUISsQFewk8RffOOuguasPgtXkYoEtvL8839wa5VTeFOILZeWvgA1YsD+4W2sXME3vBuz7eqknW5Ac5UDeNMaTVkfhKsPPzyKqxrXC7tdEZirWCxFVYXMhMqZy2FpqpIHaf+Viz9+9hejKeFLCdN0vYiVapX0UKvp6ZLIjeBTxVb9ZI84nOVE1jj8UHBggofsx+3fYbI+SFexGG9ZdMPola6YKVWD5I2WJDElZBmqECxBi5mSNOWZFycbHx78ma7U+2u1avk7KFf76pV8+ufgwPBIHIaC4ReNajXIxlFHsonI+m+kLOmq6HFcaetrmCvMXObeolUFpIrbasgLyYaoK6WL9zKurBNYm2I7lSn2Qgi2LHEkqxGtUZKlVElZvGlhgIxWgkIVrqyJ5YpRX6iMXIFMVs4vpVkBKnjP6VzYczp8mVLtCsQ3Oz7OTkS0JozDmEBRx9p9sQ8CD0tZMbgilDyOOjd9yVQZrf0bVBWTsGRXoJw37ucXdGKDUGmuCqKbdZoqtgU4Yqp4pNh2nUNQXQu2JvwvkFWWqkCu7ElcLuwVZL3mqHYFVcWUZsqeNI6TOqFPx9ViVSDEO1dFN2xIEmzw9cJ3HJ1j49HBR11WVakCLuG9cKVi9eVDEWTet3EFWz1EFQtAxG+K2po69B/Bko3KbuzAdAUWn8Xr4KjIinGw4CJX8wTy5PT1a721v3sZhalSz0tblRRF+cmvu8OI533AFEiPdGBJDtxUosSOxyp7xrFYdoVEa9qEaRLcwQg7Nh8TsqQrdKFcn67KxU7UIFf1qbdI+Bz0GkhVCVlf3OeAxWAEiiAJgzKVfL1mw+3Ektjo9ccjxWwddkK+cxu2/odF+XyZq6IUIcvQFddq8GMyR2P1UU5Z2Y2dU3quGC5I8ixXYPBfMqV2ovz08wXFRSeQ5ePAf8kSycpRW9DQ7wFN1483cpLhZaqnCEq5b/Y7p/ZbXAPi0js8tQGRLLqHK0qTS7BRZjD8Z1X22TobuCFTuN3a54SwGZWEaE2aNkmAQ3VfYf473wtZOaYK1D0D90dPNPWNLTorUlXFVFizAsrV1yxXRdi97ezeYzv2btq2gqWL2GqkG54qMrPo9DwxUdp8FdtiT1WJEjy0ywll1RVia1LHkDKkqopwRah4Js0ecXIPSqWeb6+Eq/bLPMp4BrL/yqeweMe2pdQXsdUYpI1a5gZH1n3ey7kms1OpMyuYIu1qsdOGlReQrM5tIVnVWIyqCpHljlBXOWYq9fIdxzZlXJk0wOqDPTH/c1i2aSnt9JDVGGalBrgZ677csKHBSlBxaL3TniVHaFl1LqsMVUJWqZiPeBFPo/UpQ+Yvk5+/fnylFqUZbd12lXETgL9SHTRex8+TUkQxNhpxJkKLkryv7TVFdKuRTRzc54Sigk1VTfcxafokjND76jGaLCJKuCoVInCly8LscQfrrGKsQJix7VZBjC/kQSHfiHBH8rRAv6+EAX+3Ms4Ysof2ifS2Z/kF4qoj0LOqyhUoQI/ua8CWFe4KprisRgIIYWcC/tPbWLrSEV909HNzw5DogapPgSwzddgswHCWXJ/+37JKjKmGKshqs35PmrKClYknfNx1Alh2diNk5ac2lSpgqbLbFDY8sbdObj91+OL6E84/sWrSnOlzMJgCHAB2v83jAGVYU65AOuIZXWuQuQqvwMBFoaVE1hetsG6y+ey2rSumYsGIhpkoYYjYOXhy+5RTZw5fPLdv/a7jRuH9Q7jmdALpWdSUkgU8U1bQREzblY6ZEchSvv5UJLsunpm7/eTBPZyDB08eOrR9+1xoOXP48F2Y2bd+/S5bTudsuD1n4ZyFFBxQcIBB90HgYVKGJSHrOwZk0aalhA3JVGmEqqKy8uJTIRgnnG5jyfWZC2diLMSYyVH3sQHiWOxJskrSFWa+GzRZRJiUxVWFL3S01+8Vhaosve1xupANt2f+I0hWjasCTJan6xoSrmxVGNyUvoI25mYpohK3O93Ikmv/KGs/GjxVpWSxaPnKMGx6L2z53reSuqiTHRx2uhOEawZl5oyZGHQPxLHYa7KUq3K5wWIl4wVZfzqzErK4qlRNXqkoivGc06UsucZU/R378/k+WoJKlkCWoW0K2C+BGETV57wLU9SWzNcup2vZcHvGX4Nk9clYwRVkCVHY0O2QPb1nNytAVJFPNiWuXP7DuOV0MSRc/5AsnyozWRiQZTWr4AtuMlDVOwBHTJfilNPVbJg9e8ZspgMHGHyvHuMcgCzlyp8ssqUHg393bdI38qEj0WEXJKgvDC6ta1uWDNfs9ihZ/T5V1XI6IvHYGNBOQkMueMO1g3D19he1BF3UlajE7jsltcL117KkKsiqTo1oQNeAOWllX5uUgSq46vmhXafIo9XtVcjDNWv2rNkYs+QeGI8dKBQgi4vCqBYMV16kpdefHSuooq5ycSFJ9i2ycdc7Y4ENj2f9CSSrXhZUQT5i4A0HTcT4U8VX7dcirglsjY1g0XBd+pOse5AlTYXI4t3KMsVVcVfpIFVgz3FnrLDq8R9lVZQqUImYNImq4NfAr0lxNciLlhvMky4+IbVYfGnerFnzZs3DCJRVKFSUqlqtVo/EDVnxb8SUfWUSQiWvyPoed4O5OXZyRVl5dV4495Gsalm4Av1wZZAMUIVQ+a5eS7NVgjZblzhjjYdtZeWlKmoLdgxfL4zP/mKhArwGY7+gCsMicsUZgyx7wNQsmLcAQ5rC4VMpq8aJWHxI4mMqpCryPr66eg1UInLJrs7lY87YZMPpBYE8giyVKtAXj5vJKiahpPcz/QrpqH71WjL6YdgD3JSWsN0rnbHKkkuhsmqQVeWq+oisiO6rytejv6XAEweuVKzUVRlc23hnLLPyKtUzf8F8DLbHEWT1iVBRWSMRostvq94LW/rVRzxXMcRKiBI/LFvNvc4Y5wb8mGASvi5l9YGBOGRp0Wr0MlvUl9whVr/bO3fdtmEoDPNJ0r1P0UW+oKC1GGjRJoCBdKinwB09B/DgIICHvELRIQ+RQYuHnqxdjI42ejMqVWpguUWPKNJHFKtKBZJBlD5YpucPh8c/aRLeeHSOK/vgFHzBak93bsgaY3ZIVUl+eQCgVdZPcTsE5RCJqs+/lSrSJUvrhFkBX+RkJdmBXCFr1bRA+drjpp52uS35fPPDWxYQnzFbuJo6zhPnIOt6g5s06QxEfN8PAPGytQUf0JbQRbK+x4YjlR9eDpg9dOdOFjEPv0hXiMgOoJXWe7rblnIbLuWms8mz+oX2kozqEOdrLC1hSpJWVjZB+HS1TSjbgDyWZALPmXXwhdNxOvhCWz20JVyluoIYQKiiyRhqNwG/RvLsiGdW18WI2chw2pEkpRWgLEUICk9V1zf6X56bMKMqz6s+s5QrpWuc2PIlQbBSogAO+XR1Ky6afvy0AuGKniXhPWIWI3U5vdRW4AcCkJArJN7d7SLtlx9VW8pXbdfN/6frfJPYUq58cqWivBpIlTrFRcJOObOe4SKx1Vsj20Cwjam01JODjiUpcbaE9jL4W9Hkla7tNgTI9XgxmtChiMie0F5G/930+vX6wOOsKvinKDlaFdrL4XOcipIACOpcxco820J7BfhsLH1F+jyUQxE2hvYqdEezo8lk8hQIavQFwiwN7ZV5Awa0+Mnh1nen/Z44BkLv9DljYHVorwbfgwGtf4iL2u+03weXYKJKi5pXE0J7FU5Bw8zz+N6Q0F4OD4EwvhWRJoX2UoZhUY9PZ2PYrNBewuAODLzDUMPjMQ8Kd6GIaMZaclxG8FfcIWsxGLkxGOzazl7AYKLn09idtd2qmP7ZiZsK24fHR20MLafPB6O2UTWAP1yGz7GpTmekAAAAAElFTkSuQmCC";
var phone = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAAClCAMAAADyFTYfAAAC+lBMVEUAAABISEhKSkpGRkZERERCQkJOTk45OTlBQUFQUFBSUlJUVFQ7OztYWFg/Pz8/Pz9aWlpkZGQ3NzdcXFxeXl5MTExHR0dhYWFJSUk9PT1WVlZMTEygoKBERERFRUVmZmZQUFA9PT1LS0tra2tPT09ubm5SUlI2NjZXV1czMzOpqalTU1O3t7dVVVVoaGhaWlpqamq1tbWhoaGenp6lpaWurq6ysrJZWVmjo6OgoKBUVFRdXV1cXFyvr6+0tLSwsLCrq6ubm5syMjKbm5twcHCQkJCLi4uGhobLy8uCgoJ9fX1ycnLPz894eHizs7NxcXFgYGCVlZWYmJh7e3umpqa3t7fOzs7JycnFxcWvr6+JiYl0dHRra2uSkpKNjY2IiIi4uLiUlJSsrKx3d3fDw8OHh4eQkJB9fX2dnZ2UlJR/f3++vr6RkZFzc3ODg4OioqKcnJyUlJSCgoJ4eHirq6u4uLh4eHiBgYF2dnaLi4uMjIyjo6OZmZm1tbWwsLCcnJyxsbF6enqAgICwsLC9vb26urqjo6OKioqsrKyWlpaoqKhbW1u2traCgoJ6enqZmZmbm5t+fn6JiYmgoKC0tLS4uLhmZma0tLSYmJhxcXF1dXWlpaWfn5+IiIicnJyzs7Ofn5+xsbGampq7u7vAwMCMjIxgYGChoaGgoKCQkJCOjo5vb2+RkZG1tbWOjo6Hh4d6enq1tbV8fHzGxsZubm5mZmanp6eZmZmvr6+Hh4eTk5Ojo6NwcHCenp6mpqZ6enqlpaWWlpaJiYmlpaVjY2OcnJyKiop9fX1/f3+CgoKlpaV4eHiUlJSIiIixsbGqqqqGhoZxcXGPj4+ysrK1tbWurq63t7eBgYG2tra2tralpaV+fn6enp6tra2EhISZmZmVlZWGhoZycnKhoaHV1dXX19fW1tbZ2dmrq6upqamwsLDa2trU1NSzs7Ovr6+ysrKurq6tra3S0tLGxsa9vb3Q0NDDw8PNzc3BwcG/v7/IyMi6urq4uLi1tbVYe8d+AAAA5HRSTlMA4+Pj4+Dj4OPj4+Pg4+Pg4+Pg4+Pj4OPg4OPg7+Dg4+Dj4OPg4+Dg4ODM4Mzg4+DjzPDwzMzM4MzM4ODgzMzMzMzg7uPMzMz+zMzM/swD4+DNzMz0/vz8+fXNzerMzAr58dPN9fLs7MzMzPn05My3j1w/Lff07+7MLRH77+7u7uVbJfr39PPr6eno6Ofn59W7jl9ZVxAK+ffr6dXVuHNAQCYm/Prx6uff3NLNuaePjX9zc/vq6d/f3NbUyK6rqaeNjXMR6ufc2tG9vLynp4xzWUnn0ry8t6WZemFLNxrRyMjIxGrWwvApAAASsUlEQVR42uzW12tTYRjH8aMQvLDiJDa2aimigqiQ3NjLIjVpTQutrba2FkupthXqIA6caNUaxYUXDlTcWhUVB+LeCxXUGy8EFxlocoxohokJ+Hvfk9Pn4q1By/EYwe9f8OHhd4b0P40qmXfm6vuJV8/Mk/6BVp19XD2Rd+Lq8xIprVu88kY1sEnuCYCltK1k3tbi+kXV8HLsgzpHIuFwnpHSMowA2EXVi7j2wYzA9/j3eLyioiL7lZRuYQTFxcX19fDiuNVtju+sOLio9ayUTmEERZO4lk9hoyUYDALburBXd8ORhkSF/DmN7osRTJoELcJtHzgrgqx43V1TRkYPtOFDQrZI6RFGAKuqrX9RFY1GgV2yYEgGsEqDErKcDs8bRtBcVFTEucDeXxv9FkWBhp4ZiLwNstwu6Z04gkdFPK59uDT+jRXccaG3KYntOK8sl0t/tcXPXhY2N6vahy9aw+EwsI4FRhNL4aoZZPmzpH80gtOFhdA2K9r75V+/htH0w4N6m3h0XF4/WQ5If6tVtx8VshTtpRWHvqJw1FJj6I0ELrT6c2kET1usHdqHzu2xGNNWzcwEFQlTgFb369II3lmtLS2Fire9PGaLgXvwcC9+WOLy6Li6cmkEe6ysFu69lB222aANm2sMLOISVkeuOALrVCsP2NfO6ZGIDbXOzDIoqVjUCTfwUdIvjGDCVGCTt22vskWQ7VBdL4OaOAXSMq5+18UIJkzo4B5fe85ut0cisbXnB6vW1FtAAb24i+c+hRVazp16b3UoZEfbF2YNNhCXsDQF3a+LEZyq5VjluBerQl9CqLKu/5DByEDcVMdFAR22e+D2ydraWlXbvn7Kly/Q2sp3GocIWuG4+nIxgicFKKk9fvSQy8+00xtygOXaX1+uyNV6BLcKOBbhsheX+T0uv99/bukAI7BMK16X3mLicUcEPv457oG9J6cV8Bj28rrJbrfH5Qo5dmUa0U+PS1hEWoGr9QiapqnaguNHK71uaD2rG0YZFWzqKZg61Y74+Ee4JftuvS2FVvHWXpzv9jHtlPEDM3FZgUta8UkjLbj96LpajmBLaWlTUxK7eZ3dh7wux67cTGjVJbB+TUveGs25d7Y9KS0rZdwmaC8frfR5YfXNahvNsHRc1m+9FtAYM8ag7QjelJVBq1z32Hw3qF7fZEvfXI6l4xpTLFf8Lef1mWHWlIsR5JexuHbzcrvPizxVm7JykcKlKYjeVJ+IHmOcZgSuViO4lp+fr2DR+kovuysbQZagRZ1gSStuoRsuqxkXI5jTmM/jXIzAi3w2S98sxLW5xE35iQA4Q3gtmOrMKveTFiNQsQgj4FaMIAfWJJe0qlc4boop1CS12XTdro8gr7ERXN7m9ZU4LJrVNnLYMEFLxyUvaVniFvqhNlA1GEPJvptX8vIa85K35SNANsvQnGGIYclLWjou1YGl1wJ5l2pwXYxgdh6PH3f3crsbny6vHyMAlrTCcUmb+rjEXZHUgvupqyO4Pm5cUgssRuCGFiMYm4NScVP+OIpbIG62mbi/PQIVC+6xNR4vw9osY4bDqnrFKSjRcAVvZw8acbt23f0/SLV7n6aiMAzg8SMkSkwkaPz+SPwqbbHcXAVjpRJ1cFIGAjJqTB1IR+IiyiDRBRZhkYGYuDK4ECb/AAcd/IgObscGk8YAf4Hve96ePj19r+e28eEf+OXJc889bfn04cqlK47LI+CYyYXc+dPCTRpu+uXmiNWq5XrcPx1yl169v0RhLVt5BJypcuE8x3VLSeOqbvVywWUtuO2PIHtJtMxdmzZMpREM5HLQppTLadHWvYlaxz3O+aO4wRFks1mnXX46bq10EvTnOJ2UywmUK1Rwb3bc7tLi+yzFlfuyPoLn5eLV3NVcR+WeONnBFITLWOFutjOClY8jI9kGd21ORjARn+nv7xcutLpcSYArCXAxBs3VI/g6cjlb12YxgkeZfqu1QbsWeza4XEon5V7gdsENj2D1MqVe7vLLxklQzGQyrKVAaxMqFw8a0g73OLjBEQxftrHaphFkBIt29RY4Spv25QK4wF5or903775eHx4erne7PDNe/UV/NIJCRsJY4upyj6XfHBH1imgEXJIKd3PrnyMYHCStlPuAR1C1IxgdGhpq1oIrWJu0m6OHDX25wPG4m8kjKA2SVrgja3O1KoVGcK4wREG5BGZs6BSTBMoVbahccDeJq0fwpVQi7KCdwgMaQZWq3Z6cL1BYK162SrfeoYtyrdfDhk4xlOtryeu1q0YQRYS15V6nEZgqZ6rcY7EFaDngkla3i49oTpv+iVKV67Xrb/fnj1I+KpWEO7xOI+BMxHevFSTYArR6C4JFuekXR30Xg7avL5m79COfz0d1rh2BqRoaQfEatF656lgIXcvDXH2KwZvMXfkWRaSNSHt99mGVsKb6vHyKsNDiQRMt2gUXWmA7vy645frtbjW4i9SslPt5ZrtqKBNxpVgkrea65bZebrxDt4Obo+ai3L5E7ru6NhqcZmqVR8C5xlFab7rhKegHLV2L6frtbglXtJa7fpu1U+WLo0UbT4stoNxcMtfXYrr6Z6kwty9pDIsRdcvaWW52en501Gk5oi0ka9X7V50LwVMsrFVj2LBvBrYSuDRD2tsvCKu4arl40Nq6iqX/zqMvN4q7JdxVovKxwNq5AWC1ViLDtd4WrXih/a+LrmjBjYW7mJfM1kxtsoewvle/Ijih96+N1qaXq7U+d4O4d77lbbfr28ZMVyqVu3eLo6FycYgprTrE2rvcHAl0q8awwlgS3zPm3gJhKbco5zhJZ24GN0fRSgJclNvJp4hWbiztfs/bdulQ2J7ncimMRc5w/Cl45QIradGCm/r61VpwY+EuUbXc7rgxYwR1adIiA5RD2IJg4YXWRbCdlKu3cKPB3SDuCmO53NptbhZSaIGlXOSc4hwIfhUiVl2u/hQRKBftxjIG90J7yOVSdLO+V7CSHpfe0/61HN0GD139UwS0/2r3u32jfTamtkBQR9Va1yv9OS1yyOWs0oa2EFgutMKN69xV+0ajLbxVxXqRZrUUWs6BQwc4vb29x/zLjY+FNjQFcNHuF7uFGdoCtOAOuFyEVheLkFa8kv2cw+Rt99tyF48rWOHaM5enW4ZUtJ5XqGJVWkiBFa5kXz3OG/jPQbXcFi5Z6W/CmHmxetQzVKp+wMLaXq1FjnK6u7t9beLlRrTCjcG1BxmduhW9WnFKUC7ScMpm1Q5IStZWbrfN3nr8LahyKU+auXLRNcYkvRRgBRRBraBKudB6te7rdlyA9+zdw+nq6iKtOhaEGzvub+JGFFNzXEyWmYob3KyTIl6tVgoruOJ1OXiwhRs3ceViLu1Ci6fLST2tgkILbwPqsNA6qkS04FJ22uzYDe4zx40oNeImnwXt70CCdvVeEXAhVVzyco6PjY097rpx5PXGb+JGBC7RzRxYHLHQpjQLK6T7odVQaD2oSKHl9Nx/tGcXx223xGMAF3sNbdZz+lxILfRvc2f2clMUhvGNkzFucOPOrTtD4kJcupArc8oQURQyJZI5U5nKzI1ZQiFTpkLxDyhxZZ91bHPmsbzvWmftd6/1rGWT4zjP58Plr6ffftdwPptHyylI0Al7FVQOkxrczLjLuC+clRZMiI/ZPPCE4dNleX1ne0qCsBVKu4qRodCuKdahDIogY6sQz1iNC8L+iratNNvWa7bCyTKWgS/x6FHTxfrbGAElVMaFXg0pzoOu8Hh5sFYAkTZPjkq/Ca1pV1/oUruwLyiZBdArLLc+p8MLukocDQyqtKuvn2mZcOdskFbW2hzTpxVnXVrsVXARVXBz2o4dO2pc2y6vYUAbecBCT5eHK6hxXk3q4BZBg7hsrsFFUhOcXPS7MRZmgQ1qEFjAfFCkzUk5BpfL5UctZoHg4sYAcB1UjxaXMNAAaAG3r22XUAO8uIShBbCbhUEA5cooAFyXlH5Z3DZZtjQh2rzdAmV40EoKuEIbHVtC6k8EwQzj2nTr1q1zlvVPBjLuUG438nAFaIWzWC5uuFxaO2froEhrFZDhJbCUo1k2RXBjswAONeEhS9+wj/Hi4DKpZkVcgXVwF2XZhIRoPdzQydZDRVyeswaUvrv4tIWHS6wFUEb1abvl6Tg7y7Yl5uNfcvcPDgpdveATBr06xmK1MGQtrgDTk5bNTwZKuxo0RGtIi7wwDNwDo88ptIEFoQ19wehymrUubEgSXa7gFijNX9ADKBZPX3k8VtjGwJAVWMHtzem4lF0wuEM0buR+QzyAjUFeLgsLWxigrcdwurA4DDSt4FK5SycRLtMyrmxiJNE5i4fFPMFezbqAtUpwzhpS+sXpROY+SDSuaVeqRVzoVWhttbKCAS3H2xigr4Y155VejQq7s2xZYnCHcLsKaC0qDFrvrAiPWM4JHuDk4oSc9XCn09Z8JeNyt0aGHl6gWLjf8EB9WpPgZlY4Jb4Gkm5MeyPhmJ+5SVUqkE7gMiZ2pEFnXVx8xAqkdnSBB5zKbLodu5zoEK2RAZ+uQoC2ZDebc3q0QupW6wwDD/f2UqFNzA80kQxQbWgWdI01i7QOKEjroIoH0GyHTVzt03tJPUzLuEpooyeFAmVx0KKySItLwi8esJy348Tdb+inGJaeTXzcVHCjqy1IAL2GN97uoaZQqkMLzW6a/vTVK/qpgBOrkjxsLuGq1HRqElEWeONDNu4Bbr2DyrZftPTZM6LN7jpvHCJYIwM8XRYXDouS6GERcUMS4OgSCV4+o7zqf2A+QyJu6gorEgCtkCItYMITJmMLcEWCZy9f0z/9y07yyhDBNajIG7mMKXMWUIUWQE2sBNlLerPBy2cbtu1MMJp2GLkbmAX0HTvSeLi4L4gfaULWigT0NiTCXWckwGjaYeRuoNnwaiuBBQx79QetA+rhbjrycjTlxxuRAHE1r0pTC+ntEb1eQ6Or3IKKJDYLOs1YoF819eMOSBBqNw19XNfrF8XSd6zYdh6uR4q7rsr5/of0m7FAgiBuH3LXoS2bBbkHfKAJWOClSGtJhfbo7NHfGHb1FZAAwrTa3RLa6NE2uB5gsRoXeiUJFq/WL/L6fucMSoBhWi2DsMIuJnKm4V+5tYCKHuCeq7Jn3Zf3nFEgQSTaBZah0G35p0q4mUXa+AJW33QfnX3oC9PuAgni0bR9VKry5cs5gQGog/uLYv2LLju3RILX+j1e74+BBCW4xEsyWFq49o59DOrhuq0WyoViWYKl9GYswl1wCiT4dZiWZaB2cdDG14Tf23hTKrgvODrls36R1+Qt25M/Dbug2xUFOLEjjaMBbLhKlgTG7Tx98rt3THvsNEpQHi5XP2qOsBxZwkqPto6uYIGwVvaO+qpf5DUeJPgjXJUqBxeURVy53wiLgLPr9u6PGvZQVILyMC3jmnbLP60TWtxwSWBykQSHvn5l2o0swV/ipkoFL2PgIC6o3vwC0CJuu0UL9Hu8vu4iCf4qxGrc7QwiiAW61PiaAFPLlfZC/7H6RV6H97MEDcFN1W9/WifBy0NcwDofmTXiE9NqCRqDO0CpFM40MV6oFou1C1ibRatHjGDahVtJgkZE0w5QqXJoQVko1y3Wpc0lGPOBaceJBA1ql93NSfHyCD9Uil512j97HfnM7/Ea8Wn96UkNQpV2U6V0tUAaXW7jNwYswYxdL94y7VqSoKFhWiMDXnUBaHBwoQT9Prx4Szm3TyRodLupoMJHH5LyK+9es8+l/CKvDytukQQND8FSlFIOreGM0/omiATVapVo12xd0jhExKW5294RAc40RVoftY47cd2LKtMOFwkajzuAeVOlIhfJeKahLyiWJRhLr3Ai2BVzQYKG4lLYXfg8HCSI33a2nTH5OaVWmzYHJGhsdLmDuN2exAonBTzZIuzEUS+ec0ZMBQn+Ea5KlXNI4C/UAO/k6hKwBptJgn8fgmVckgFXML9YEEFLUKMvlqAp0eWyDEAL65dLqyWo6RekTZ2XNCsD6rgpTK/4p3WcrrPH1ghWJGhONC3JoGAkRHH1JKjpNEcCxOV2I8MWyiUJqNVajSVodgiWcVMVLVeSS1ATCZoc88qjVKlSc3kSLJ5c5V6rTZQAcVkGbBeuOkgCgq2CBM3MoFwGr1tvim2aMpZZqyBBc3N1UF2GX90j9SQJKCBB83OfYAcNVjFcSrvzo95WOShB83Ody5V24fqzO0nAUSzB/89Nph38VqmuOa3gticJOP9fApuHTDt4nFJ7AXdPC0lg8/gq8y5XapSrgpUgbQ0JpF5u97hS1fOC26nlJJA8Yd41Sg3fU4dtRQkKeXSN3jo4Qqm0397OmyZOGatoDrScBIWM3DFn5kXi1ZyqRSUoZtKOa1vWKArztqgEnhIHty4f9/btuEstKwGkxf+XuCT5CbTFnFRuxktuAAAAAElFTkSuQmCC";
var _a;
var LOCALE = {
  zh: {
    TITLE: "",
    HIT: " VR "
  },
  en: {
    TITLE: "GLASSES MODE",
    HIT: "Please put the mobile phone horizontally into the VR glasses."
  },
  ja: {
    TITLE: "",
    HIT: "VR"
  }
};
var TEXT = typeof navigator != "undefined" && (_a = LOCALE[navigator.language.split("-")[0]]) !== null && _a !== void 0 ? _a : LOCALE.zh;
var CONTENTS = `
<style>
.$id {
  all: initial;
  position: absolute;
  overflow: hidden;
  display: none;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
.$id-modal {
  width: 100%;
  height: 332px;
  position: absolute;
  bottom: -2px;
  left: 0;
  right: 0;
  overflow: hidden;
  pointer-events: none;
  will-change: transform;
  animation: $id-modal-fade-in 0.3s ease 1;
}
.$id-modal-bg {
  background: rgba(0, 0, 0, 0.75);
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
}
.$id-modal-bg-line {
  height: 1px;
  background-image: linear-gradient(
    85deg,
    rgba(162, 177, 255, 0.3) 1%,
    rgba(120, 126, 255, 0.8) 30%,
    rgba(147, 218, 255, 0.8) 66%,
    rgba(250, 255, 184, 0.3) 92%
  );
}
.$id-modal-bg-wave svg {
  width: 375px;
  height: 61px;
  display: block;
}
.$id-modal-content {
  color: #ffffff;
  padding: 0 14px;
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  overflow: hidden;
}
.$id-modal-content-title {
  font-size: 17px;
  font-family: sans-serif;
  line-height: 18px;
  padding: 20px 0;
  font-weight: bold;
}
.$id-modal-content-hit {
  font-size: 14px;
  font-family: sans-serif;
  line-height: 24px;
  opacity: 0.85;
}
.$id-modal-content-guide {
  position: relative;
  width: 168px;
  height: 139px;
  margin: 36px auto 0;
}
.$id-modal-content-guide-cardboard {
  position: absolute;
  width: 100px;
  height: 82px;
  left: 68px;
  top: 57px;
}
.$id-modal-content-guide-cardboard-image {
  width: 100px;
  height: 82px;
  background-image: url(`.concat(cardboard, `);
  background-size: 100%;
  background-repeat: no-repeat;
}
.$id-modal-content-guide-phone {
  position: absolute;
  width: 58px;
  height: 56px;
  left: 0;
  top: 0;
}
.$id-modal-content-guide-phone-move-x {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  will-change: transform;
  animation: $id-guide-move-x 4s 0.5s infinite;
}
.$id-modal-content-guide-phone-move-y {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  will-change: transform;
  animation: $id-guide-move-y 4s cubic-bezier(0.42, 0, 0.23, 0.98) 0.5s infinite;
}
.$id-modal-content-guide-phone-blink {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  will-change: opacity;
  animation: $id-guide-blink 4s 0.5s infinite;
}
.$id-modal-content-guide-phone-image {
  width: 58px;
  height: 56px;
  background-image: url(`).concat(phone, `);
  background-size: 100%;
  background-repeat: no-repeat;
}
.$id-modal-close {
  position: absolute;
  top: 20px;
  right: 14px;
  width: 14px;
  height: 14px;
}
.$id-modal-close svg {
  width: 14px;
  height: 14px;
  display: block;
}

@keyframes $id-modal-fade-in {
  0% { transform: translate3d(0, 100%, 0); opacity: 0.5; }
  100% { transform: translate3d(0, 0, 0);  opacity: 1; }
}
@keyframes $id-guide-blink {
  0% { opacity: 0; }
  7% { opacity: 0; }
  12% { opacity: 1; }
  29% { opacity: 1; }
  34% { opacity: 0.3; }
  39% { opacity: 1; }
  44% { opacity: 0.3; }
  49% { opacity: 1; }
  80% { opacity: 1; }
  100% { opacity: 0; }
}
@keyframes $id-guide-move-x {
  0% { transform: translate3d(0, 0, 0); }
  57% { transform: translate3d(0, 0, 0); }
  80% { transform: translate3d(70px, 0, 0); }
  100% { transform: translate3d(70px, 0, 0); }
}
@keyframes $id-guide-move-y {
  0% { transform: translate3d(0, 0, 0); }
  57% { transform: translate3d(0, 0, 0); }
  80% { transform: translate3d(0, 58px, 0); }
  100% { transform: translate3d(0, 58px, 0); }
}
@media screen and (orientation: portrait) {
  .$id {
    display: block;
  }
}
</style>
<div class="$id-modal">
  <div class="$id-modal-bg">
    <div class="$id-modal-bg-line"></div>
    <div class="$id-modal-bg-wave">
      <svg width="375" height="61" viewBox="0 0 375 61" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient x1="0" y1="0%" x2="0" y2="100%" id="$id-2y6_dj_hgp">
            <stop stop-color="#8598FF" stop-opacity="0.15" offset="0%"></stop>
            <stop stop-color="#000" stop-opacity="0" offset="100%"></stop>
          </linearGradient>
        </defs>
        <path transform="translate(187.5, 30.5) scale(-1, 1) translate(-187.5, -30.5)" fill="url(#$id-2y6_dj_hgp)" d="
M0,1
C83.001,1.706 140.146,4.164 171.435,8.374
C218.369,14.688 253.467,26.308 273.002,33
C292.536,39.691323.501,51 343.709,56
C357.182,59.333 367.612,61 375,61
L375,0
L0,0
L0,1
Z
"></path>
      </svg>
    </div>
  </div>
  <div class="$id-modal-content">
    <div class="$id-modal-content-title">`).concat(TEXT.TITLE, `</div>
    <div class="$id-modal-content-hit">`).concat(TEXT.HIT, `</div>
    <div class="$id-modal-content-guide">
      <div class="$id-modal-content-guide-phone">
        <div class="$id-modal-content-guide-phone-move-x">
          <div class="$id-modal-content-guide-phone-move-y">
            <div class="$id-modal-content-guide-phone-blink">
              <div class="$id-modal-content-guide-phone-image"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="$id-modal-content-guide-cardboard">
        <div class="$id-modal-content-guide-cardboard-image"></div>
      </div>
    </div>
  </div>
  <div class="$id-modal-close">
    <svg width="14" height="14" viewBox="0 0 14 14" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <radialGradient cx="50%" cy="50%" fx="50%" fy="50%" r="70%" id="$id-ho0itsc4p9">
          <stop stop-color="#FFF" stop-opacity="0.75" offset="0%"></stop>
          <stop stop-color="#FFF" stop-opacity="0.22" offset="100%"></stop>
        </radialGradient>
      </defs>
      <path transform="translate(-3, -3)" fill="url(#$id-ho0itsc4p9)" fill-rule="nonzero" d="
M16.791,3.198
C17.044,3.438 17.067,3.814 16.860,4.080
L16.791,4.156
L12.144,9.331
C11.803,9.711 11.803,10.288 12.144,10.668
L16.791,15.843
C17.044,16.084 17.067,16.460 16.860,16.725
L16.791,16.801
C16.538,17.042 16.142,17.063 15.864,16.867
L15.784,16.801
L10.000,11.250
L4.215,16.801
L4.135,16.867
C3.857,17.063 3.461,17.042 3.208,16.801
L3.208,16.801
L3.139,16.725
C2.932,16.460 2.955,16.084 3.208,15.843
L3.208,15.843
L7.855,10.668
C8.196,10.288 8.196,9.711 7.855,9.331
L7.855,9.331
L3.208,4.156
L3.139,4.080
C2.932,3.814 2.955,3.438 3.208,3.198
C3.486,2.933 3.937,2.933 4.215,3.198
L4.215,3.198 L9.999,8.749
L15.784,3.198
C16.062,2.933 16.513,2.933 16.791,3.198
Z
"></path>
    </svg>
  </div>
</div>
`);
function createContents(n45) {
  for (var t = 1, e = document.getElementsByTagName("meta"), r = 0; r < e.length; r++) {
    var o = e[r];
    if (o.getAttribute("name") === "viewport") {
      var s = o.getAttribute("content") || "", u = s.match(/initial\-scale\=([\d|\.]+)/);
      u && (t = Number(u[1])), isNaN(t) && (t = 1);
    }
  }
  var l = function(c) {
    return Math.floor(c * t) + "px";
  };
  return CONTENTS.replace(/\n/g, " ").replace(/\ +/g, " ").replace(/\$id/g, n45).replace(/(\d+)px/g, function(c, f) {
    return l(Number(f));
  });
}
function createHelper() {
  var n45 = "five_vr_helper_" + createUuid(), t = createContents(n45), e = document.createElement("div");
  return e.className = n45, e.innerHTML = t, e;
}
var sharedGeometry = new CircleBufferGeometry(0.12, 16);
var vertexShader = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #include <logdepthbuf_vertex>
}
`;
var fragmentShader = `
uniform float circleScale;
uniform float circleFade;
uniform float circleOpacity;
uniform float loadingAngle;
uniform float loadingOpacity;
uniform float opacity;
uniform float disable;
varying vec2 vUv;

#include <common>
#include <logdepthbuf_pars_fragment>
#define SMOOTH_DIST 0.017
#define CENTER vec2(0.5, 0.5)

float inside(float innerDist) {
  float dist = length(CENTER - vUv);
  return smoothstep(innerDist, innerDist + SMOOTH_DIST, dist);
}
float outside(float outerDist) {
  float dist = length(CENTER - vUv);
  return 1.0 - smoothstep(outerDist - SMOOTH_DIST, outerDist, dist);
}

vec4 create_circle() {
  float dist = length(CENTER - vUv);
  float gradient = clamp(0.98 + abs(dot(normalize(vec2(1.0, -1.0)), vUv - CENTER)) * 2.0, 0.0, 1.0);
  vec3 color = mix(vec3(0.576, 0.635, 1.0), vec3(1.0, 1.0, 1.0), circleFade * 0.5);
  return vec4(color, 1.0 * gradient * circleOpacity * outside(0.3 * circleScale));
}

vec4 create_disable() {
  float dist = length(CENTER - vUv);
  return vec4(1.0, 1.0, 1.0, 0.5 * outside(0.32 * circleScale));
}

vec4 create_loading() {
  float angle = PI - atan(CENTER.x - vUv.x, CENTER.y - vUv.y);
  angle = mod(angle + loadingAngle, PI2);
  float gradient = (1.0 - smoothstep(0.0, PI2, angle)) * 0.9 + 0.1;
  return vec4(1.0, 1.0, 1.0, gradient * loadingOpacity * inside(0.2 * circleScale) * outside(0.25 * circleScale));
}

void main() {
  #include <logdepthbuf_fragment>
  gl_FragColor = vec4(1.0, 1.0, 1.0, 0);

  vec4 circleColor = create_circle();
  gl_FragColor = mix(gl_FragColor, circleColor, circleColor.a);

  vec4 loadingColor = create_loading();
  gl_FragColor = mix(gl_FragColor, loadingColor, loadingColor.a);

  gl_FragColor = mix(gl_FragColor, create_disable(), disable);

  gl_FragColor = vec4(gl_FragColor.rgb, gl_FragColor.a * opacity);
}
`;
var ringVertexShader = `
varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #include <logdepthbuf_vertex>
}
`;
var ringFragmentShader = `
varying vec2 vUv;
uniform float opacity;
#include <common>
#include <logdepthbuf_pars_fragment>

float smoothDist = 0.01;
void main() {
  #include <logdepthbuf_fragment>
  vec2 center = vec2(0.5, 0.5);
  float dist = length(center - vUv);
  float outerDist = 0.49;
  float innerDist = 0.29;

  float outside = 1.0 - smoothstep(outerDist - smoothDist, outerDist, dist);
  float inside = smoothstep(innerDist, innerDist + smoothDist, dist);

  vec4 bg = vec4(0.576, 0.635, 1.0, 0.3);
  float gradientAlpha = clamp(abs(dist - (outerDist + innerDist) / 2.0) / (outerDist - innerDist) * 1.5 + 0.1, 0.0, 1.0);
  vec4 gradient = vec4(1.0, 1.0, 1.0, gradientAlpha);

  gl_FragColor = mix(bg, gradient, gradient.a);

  gl_FragColor = vec4(gl_FragColor.rgb, gl_FragColor.a * opacity * outside * inside);
}
`;
var PanoSphereMesh = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      e.progress = 0, e.opacity = 0, e.loading = false, e.current = false, e.disabled = false, e.currentMotion = new Motion({
        ringScale: 1.1,
        ringOpacity: 0,
        circleFade: 0,
        circleOpacity: 0.85,
        circleScale: 1
      }), e.opacityMotion = new Motion({ opacity: 0 }), e.loadingMotion = new Motion({ opacity: 0 }), e.disableMotion = new Motion({ opacity: 0 });
      var r = {
        blending: CustomBlending,
        blendSrc: SrcAlphaFactor,
        blendDst: OneMinusSrcAlphaFactor,
        blendSrcAlpha: OneFactor,
        blendDstAlpha: OneMinusSrcAlphaFactor,
        depthWrite: false,
        transparent: true
      };
      return e.hitTestMesh = new Mesh(sharedGeometry, new MeshBasicMaterial(__assign(__assign({}, r), { color: 0, opacity: 0 }))), e.hitTestMesh.scale.set(1.5, 1.5, 1.5), e.ringMesh = new Mesh(sharedGeometry, new ShaderMaterial(__assign(__assign({}, r), { vertexShader: ringVertexShader, fragmentShader: ringFragmentShader, uniforms: {
        opacity: {
          value: 0
        }
      } }))), e.panoMesh = new Mesh(sharedGeometry, new ShaderMaterial(__assign(__assign({}, r), { vertexShader, fragmentShader, uniforms: {
        circleScale: {
          value: 1.1
        },
        circleFade: {
          value: 0
        },
        circleOpacity: {
          value: 0.5
        },
        loadingAngle: {
          value: 0
        },
        loadingOpacity: {
          value: 0
        },
        opacity: {
          value: 0
        },
        disable: {
          value: 0
        }
      } }))), e.add(e.hitTestMesh), e.add(e.ringMesh), e.add(e.panoMesh), e.renderOrder = 1e4, e.needsRender = true, e;
    }
    return t.prototype.setProgress = function(e) {
      this.progress = e, this.setLoading(e > 0);
    }, t.prototype.setOpacity = function(e) {
      this.opacity !== e && (this.opacity = e = clamp$1(e, 0, 1), this.opacityMotion.set({ opacity: e }, 30).catch(noop$1));
    }, t.prototype.setCurrent = function(e) {
      if (this.current !== e) {
        if (e) {
          var r = [
            { progress: 0, value: { ringScale: 2, ringOpacity: 0, circleFade: 0, circleOpacity: 0.85, circleScale: 1 } },
            { progress: 0.05, value: { ringScale: 1, ringOpacity: 1, circleFade: 0, circleOpacity: 0.85, circleScale: 1 } },
            { progress: 0.15, value: { ringScale: 1.2, ringOpacity: 1, circleFade: 0, circleOpacity: 0.85, circleScale: 1 } },
            { progress: 0.25, value: { ringScale: 1.1, ringOpacity: 1, circleFade: 0, circleOpacity: 0.85, circleScale: 1 } },
            { progress: 0.8, value: { ringScale: 1.1, ringOpacity: 1, circleFade: 1, circleOpacity: 0.85, circleScale: 1 } },
            { progress: 0.9, value: { ringScale: 1.1, ringOpacity: 1, circleFade: 1, circleOpacity: 0.65, circleScale: 0.8 } },
            { progress: 0.92, value: { ringScale: 1.1, ringOpacity: 1, circleFade: 1, circleOpacity: 0.65, circleScale: 0.8 } },
            { progress: 1, value: { ringScale: 1.1, ringOpacity: 1, circleFade: 1, circleOpacity: 0.85, circleScale: 1.1 } }
          ];
          this.currentMotion.setKeyframes(r, 1500).catch(noop$1);
        } else {
          var r = [
            { progress: 0, value: __assign({}, this.currentMotion.value) },
            { progress: 1, value: { ringScale: 1.1, ringOpacity: 0, circleFade: 0, circleOpacity: 0.85, circleScale: 1 } }
          ];
          this.currentMotion.setKeyframes(r, 200).catch(noop$1);
        }
        this.current = e;
      }
    }, t.prototype.setLoading = function(e) {
      this.loading !== e && (e ? this.loadingMotion.setKeyframes([
        { progress: 0, value: { opacity: 0 } },
        { progress: 0.3, value: { opacity: 0 } },
        { progress: 1, value: { opacity: 0.8 } }
      ], 500).catch(noop$1) : this.loadingMotion.set({ opacity: 0 }, 0).catch(noop$1), this.loading = e, this.disabled === true && this.setDisabled(false), this.needsRender = true);
    }, t.prototype.setDisabled = function(e) {
      this.disabled !== e && (this.disabled = e, this.loading === true && this.setLoading(false), this.disableMotion.set({ opacity: e ? 1 : 0 }, 300).catch(noop$1), this.needsRender = true);
    }, t.prototype.tap = function() {
      return Promise.resolve();
    }, t.prototype.updateTime = function(e, r) {
      this.opacityMotion.update(e), this.currentMotion.update(e), this.loadingMotion.update(e);
      var o = this.opacityMotion.value.opacity;
      this.visible = o !== 0;
      var s = this.currentMotion.value, u = s.ringScale, l = s.ringOpacity, c = s.circleFade, f = s.circleOpacity, d = s.circleScale;
      this.ringMesh.scale.set(u, 1, u), this.ringMesh.material.uniforms.opacity.value = l * o, this.panoMesh.material.uniforms.opacity.value = o, this.panoMesh.material.uniforms.circleOpacity.value = f, this.panoMesh.material.uniforms.circleScale.value = d, this.panoMesh.material.uniforms.circleFade.value = c, this.panoMesh.material.uniforms.loadingOpacity.value = this.loadingMotion.value.opacity, this.panoMesh.material.uniforms.disable.value = this.disableMotion.value.opacity, this.panoMesh.material.uniforms.loadingAngle.value = e / 120 % (Math.PI * 2), this.needsRender = true;
    }, t.prototype.dispose = function() {
      this.hitTestMesh.material.dispose(), this.ringMesh.material.dispose(), this.panoMesh.material.dispose();
    }, t;
  }(Object3D)
);
var ACTIVE_TO_CURRENT_DELAY = 1500;
var defaultVRPanoramaControllerCustomInitArgs = __assign({}, omit(defaultPanoramaControllerCustomInitArgs, ["maxLatitude", "minLatitude"]));
var VRPanoramaController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o = t.parseArgs(e);
      r = n45.call(this, o) || this, r.mode = "VRPanorama", r.cardboard = new Cardboard(r.renderer);
      var s = createHelper();
      r.helperElement = s;
      var u = new Hammer(s);
      return r.element.parentNode && (r.element.parentNode.insertBefore(s, r.element), r.setHelperElementSize(), u.on("tap", function() {
        return r.emit("vr.requestExit", createEvent("vr.requestExit", {}));
      })), r.destroyHelper = function() {
        u.destroy(), s.parentNode && s.parentNode.removeChild(s), delete r.helperElement;
      }, r;
    }
    return t.parseArgs = function(e) {
      if (e instanceof t)
        return e;
      var r = __assign(__assign({}, e), { maxLatitude: Math.PI / 2, minLatitude: -Math.PI / 2 });
      return n45.parseArgs.call(this, r);
    }, t.initAnimationEndState = function(e) {
      var r = this.parseArgs(e), o = n45.initAnimationEndState.call(this, r);
      return __assign(__assign({}, o), { mode: "VRPanorama" });
    }, t.prototype.updateConfiguration = function(e) {
      return n45.prototype.updateConfiguration.call(this, __assign(__assign({}, e), { maxLatitude: Math.PI / 2, minLatitude: -Math.PI / 2 }));
    }, t.prototype.destroy = function() {
      n45.prototype.destroy.call(this), this.cardboard.dispose(), this.destroyHelper();
      for (var e = Object.keys(this.panoMeshes), r = 0, o = e; r < o.length; r++) {
        var s = o[r], u = this.panoMeshes[s];
        this.helper.remove(u), u.dispose(), delete this.panoMeshes[s];
      }
    }, t.prototype.isReady = function() {
      return false;
    }, t.prototype.updateRenderSize = function() {
      this.needsRender = true, this.modelSceneNeedsRender = true, this.setHelperElementSize();
    }, t.prototype.updateCamera = function(e, r, o) {
      return Promise.resolve();
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      return Promise.resolve();
    }, t.prototype.updatePanoMeshesVisible = function() {
      for (var e = this.works.getResolvedObserver(this.currentPano), r = (e ? e.visibleIds : []).concat(panoStringify(this.currentPano)), o = 0, s = this.works.resolvedObservers; o < s.length; o++) {
        var u = s[o], l = this.panoMeshes[u.panoId];
        l && (r.indexOf(u.panoId) >= 0 ? l.parent !== this.helper && this.helper.add(l) : l.parent === this.helper && (this.helper.remove(l), l.setOpacity(0)));
      }
    }, t.prototype.updatePanoMeshes = function() {
      for (var e = Object.keys(this.panoMeshes), r = 0, o = e; r < o.length; r++) {
        var s = o[r], u = this.panoMeshes[s];
        this.helper.remove(u), u.dispose(), delete this.panoMeshes[s];
      }
      for (var l = 0, c = this.works.resolvedObservers; l < c.length; l++) {
        var f = c[l], d = f.panoId, h = new PanoSphereMesh();
        h.name = "panoSphere_".concat(d), h.position.copy(f.position), h.needsRender = true, this.panoMeshes[d] = h;
      }
      this.updatePanoMeshesVisible();
    }, t.prototype.updateTime = function(e, r) {
      var o = this, s, u, l, c, f, d, h, v, A, g;
      if (!this.destroyed) {
        var p = this.currentPano;
        this.userAction = true, this.needsRender = true, this.modelSceneNeedsRender = true;
        var y = {}, m = {}, E = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[0]), b = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[this.locationMotion.keyframes.length - 1]), T = false;
        if (this.modelAlphaMotion.ended === false && (this.modelAlphaMotion.update(e), y.modelAlpha = this.modelAlphaMotion.value.modelAlpha), this.perspToOrthoMotion.ended === false && (this.perspToOrthoMotion.update(e), this.camera.perspToOrtho.setScalar(clamp$1(this.perspToOrthoMotion.value.perspToOrtho, 0, 1))), this.locationMotion.ended === false) {
          this.locationMotion.update(e);
          var R = this.locationMotion.getKeyFrameSegment(e), S = R[0], M = R[1], w = this.panoResourceFromLocationMotionKeyframe(S), H = this.panoResourceFromLocationMotionKeyframe(M), L = w.position, C = H.position, I = this.locationMotion.value.count - M.value.count + 1;
          y.progress = I, H.panoPicture && (I < 1 ? w.panoPicture && (y.pano0 = w.panoPicture) : y.pano0 = H.panoPicture, y.pano1 = H.panoPicture), H.effect === "montage" ? y.transition = "BLACK" : H.effect === "spread" ? y.transition = "SPREAD" : y.transition = "FADE", (H.effect === "zoomin" || H.effect === "zoomout") && (y.progress = Math.pow(I, 3)), I < 1 && H.effect !== "fly" && (y.pano0 && w.panoPicture && (y.pano0 = {
            map: y.pano0.map,
            zoom: y.pano0.zoom,
            luminanceMap: y.pano0.luminanceMap,
            matrix: w.panoPicture.matrix.clone().premultiply(w.fixCameraTransform).setPosition(H.position)
          }), L.copy(C), T = true), m.distance = this.locationMotion.value.distance, m.offset = new Vector3(L.x + (C.x - L.x) * I, L.y + (C.y - L.y) * I, L.z + (C.z - L.z) * I);
          for (var _ = [], O = [], P = 0, N = this.locationMotion.keyframes; P < N.length; P++) {
            var k = N[P], U = k.key, D = k.progress;
            U !== void 0 && (_.push(U), D > this.locationMotion.progress && O.push(U));
          }
          for (var q = 0, z = Object.keys(this.panoResources); q < z.length; q++) {
            var Q = z[q];
            if (!(O.indexOf(Q) >= 0)) {
              var G = this.panoResources[Q];
              if (G.panoPicture) {
                var X = G.panoPicture.map, $ = G.panoPicture.luminanceMap;
                if (X) {
                  if (X === ((s = y.pano0) === null || s === void 0 ? void 0 : s.map) || X === ((u = y.pano1) === null || u === void 0 ? void 0 : u.map))
                    continue;
                  X instanceof TileCubeTextureTarget && X.cubeRenderTarget && this.colorCubeRenderTargetPool.push(X.cubeRenderTarget), X.dispose(), $ && ($ instanceof TileCubeTextureTarget && $.cubeRenderTarget && this.luminanceCubeRenderTargetPool.push($.cubeRenderTarget), $.dispose()), G.panoPicture = null;
                }
              }
              _.indexOf(Q) >= 0 || delete this.panoResources[Q];
            }
          }
          this.currentPano = panoParse(H.panoId), this.emit("pano.moving", createEvent("pano.moving", {
            userAction: this.userAction,
            prevPano: panoParse(E.panoId),
            state: __assign(__assign(__assign(__assign({}, panoParse(b.panoId)), { mode: this.mode }), clonePose(this.camera.pose)), m),
            options: {},
            progress: this.locationMotion.progress,
            error: null
          }));
        }
        isEmptyObject(y) === false && (!((l = y.pano0) === null || l === void 0) && l.map && y.pano0.map instanceof TileCubeTextureTarget && !y.pano0.map.cubeRenderTarget && (y.pano0.map.cubeRenderTarget = this.colorCubeRenderTargetPool.pop()), !((c = y.pano0) === null || c === void 0) && c.luminanceMap && y.pano0.luminanceMap instanceof TileCubeTextureTarget && !y.pano0.luminanceMap.cubeRenderTarget && (y.pano0.luminanceMap.cubeRenderTarget = this.luminanceCubeRenderTargetPool.pop()), !((f = y.pano1) === null || f === void 0) && f.map && y.pano1.map instanceof TileCubeTextureTarget && !y.pano1.map.cubeRenderTarget && (y.pano1.map.cubeRenderTarget = this.colorCubeRenderTargetPool.pop()), !((d = y.pano1) === null || d === void 0) && d.luminanceMap && y.pano1.luminanceMap instanceof TileCubeTextureTarget && !y.pano1.luminanceMap.cubeRenderTarget && (y.pano1.luminanceMap.cubeRenderTarget = this.luminanceCubeRenderTargetPool.pop()), this.models.setMaterial(y)), m.offset && this.camera.position.copy(m.offset), panoEqual(this.currentPano, p) && this.updatePanoMeshesVisible();
        var W = this.camera.pose.longitude, oe = this.camera.pose.latitude;
        this.camera.quaternion.fromArray(this.cardboard.sensor.getOrientation()), this.camera.computePose();
        var ie = this.works.getResolvedObserver(this.currentPano);
        if (this.camera.pose.distance > 0.1 || T)
          for (var re = 0, j = Object.keys(this.panoMeshes); re < j.length; re++) {
            var se = j[re], ae = this.panoMeshes[se];
            ae.setOpacity(0), ae.updateTime && ae.updateTime(e, r), ae.visible = false;
          }
        else if (ie)
          for (var ue = ie.visibleIds.concat(panoStringify(this.currentPano)), fe = 0, ne = ue; fe < ne.length; fe++) {
            var se = ne[fe], Te = panoParse(se), Re = this.works.getResolvedObserver(Te);
            if (Re) {
              var ae = this.panoMeshes[se];
              if (!Re.loadable && !Re.active) {
                ae.setOpacity(0);
                continue;
              }
              var ve = ae.position.clone().setY(this.camera.position.y).distanceTo(this.camera.position);
              ve < 0.05 ? ae.setOpacity(0) : ae.setOpacity(clamp$1(1.5 / ve, 0, 1)), panoEqual(this.currentPano, Te) && ae.setOpacity(0), ae.lookAt(this.camera.position);
            }
          }
        if (this.locationMotion.ended)
          for (var Ce = this.intersect(e), Z = 0, te = this.works.resolvedObservers; Z < te.length; Z++) {
            var Re = te[Z], ae = this.panoMeshes[Re.panoId];
            ae && (ae.setCurrent(ae === Ce), ae.updateTime && ae.updateTime(e, r));
          }
        (W !== this.camera.pose.longitude || oe !== this.camera.pose.latitude) && (this.cameraMotion.set(pick(this.camera.pose, ["longitude", "latitude"]), 0).catch(noop$1), this.emit("camera.update", createEvent("camera.update", {
          userAction: true,
          state: __assign(__assign(__assign({}, this.currentPano), { mode: this.mode }), clonePose(this.camera.pose))
        })));
        var K = this.tileLevel = function() {
          if (o.tileLevelForFov === false)
            return 0;
          var me = o.renderer.getDrawingBufferSize(new Vector2());
          me.width *= o.scissor.width, me.height *= o.scissor.height;
          var ce = b.panoId, pe = o.works.getResolvedObserver(ce), ee = o.imageOptions.size;
          if (typeof ee == "undefined" && pe) {
            var he = pe.images.up.match(/\/cube_(\d+)\//);
            he && (ee = Number(he[1]));
          }
          typeof ee == "undefined" && (ee = 2048);
          var Se = 0;
          ee >= 1024 && (Se = 1), ee >= 2048 && (Se = 2), ee >= 4096 && (Se = 3), ee >= 8192 && (Se = 4);
          var Ie = o.tileLevelForFov(o.camera.fov, me);
          return Ie > Se ? Ie : 0;
        }(), ye = function() {
          var me = o.camera.quaternion.clone(), ce = o.works.getResolvedObserver(b.panoId), pe = ce != null ? ce : ie;
          pe && me.premultiply(pe.quaternion.clone().inverse());
          var ee = new Matrix4().makeRotationFromQuaternion(me), he = new Matrix4().getInverse(ee), Se = new Frustum().setFromProjectionMatrix(new Matrix4().multiplyMatrices(o.camera.projectionMatrix, he));
          return Se;
        }();
        b.panoId === panoStringify(this.currentPano) && (((h = b.panoPicture) === null || h === void 0 ? void 0 : h.map) instanceof TileCubeTextureTarget && (b.panoPicture.map.maxRequest = this.tileMaxRequest, b.panoPicture.map.update(ye, K), b.panoPicture.map.needsRender === true && (b.panoPicture.map.needsRender = false, this.needsRender = true, this.modelSceneNeedsRender = true)), ((v = b.panoPicture) === null || v === void 0 ? void 0 : v.luminanceMap) instanceof TileCubeTextureTarget && (b.panoPicture.luminanceMap.maxRequest = this.tileMaxRequest, b.panoPicture.luminanceMap.update(ye, K), b.panoPicture.luminanceMap.needsRender === true && (b.panoPicture.luminanceMap.needsRender = false, this.needsRender = true, this.modelSceneNeedsRender = true)));
        {
          var de = this.tiling.object.visible;
          if (this.initAnimationed) {
            var xe = b.panoId, Ae = this.works.getResolvedObserver(xe);
            Ae ? isSimilarVector3(this.camera.position, Ae.position) && this.locationMotion.ended ? (this.tiling.object.visible = true, this.tiling.panoId !== xe && this.tiling.cleanup(), this.tiling.panoId = xe, this.tiling.setResource((g = (A = Ae.images) === null || A === void 0 ? void 0 : A.tiles) !== null && g !== void 0 ? g : [], this.enableIOSEDR && Ae.images.luminance ? Ae.images.luminance : null), this.tiling.setFetcher(getFetcher(Ae.work)), this.tiling.setRotation(Ae.quaternion), this.tiling.setPosition(Ae.position), this.tiling.maxRequest = this.tileMaxRequest, K > this.tiledCubeTextureLevel ? this.tiling.update(ye, K, e) : this.tiling.update(ye, 0, e)) : this.tiling.object.visible = false : this.tiling.object.visible = false;
          } else
            this.tiling.object.visible = false;
          de !== this.tiling.object.visible && (this.tiling.object.needsRender = true, this.modelSceneNeedsRender = true);
        }
        this.panoVideo.object.position.copy(this.camera.position), this.panoVideo.updateTime(e);
      }
    }, t.prototype.render = function() {
      this.cardboard.render(this.modelScene, this.camera), this.renderer.autoClear = false, this.cardboard.render(this.scene, this.camera), this.renderer.autoClear = true;
    }, t.prototype.setCamera = function(e) {
    }, t.prototype.destroyHelper = function() {
    }, t.prototype.setHelperElementSize = function() {
      if (this.helperElement) {
        var e = new Vector2(this.element.offsetWidth, this.element.offsetHeight), r = e.x * this.scissor.left, o = e.y * (1 - this.scissor.bottom - this.scissor.height), s = e.x * this.scissor.width, u = e.y * this.scissor.height;
        this.helperElement.style.marginLeft = r + "px", this.helperElement.style.marginTop = o + "px", this.helperElement.style.width = s + "px", this.helperElement.style.height = u + "px";
      }
    }, t.prototype.intersect = function(e) {
      var r, o;
      if (this.locationMotion.ended === false) {
        this.intersectMesh.visible = false, delete this.activePanoMesh, delete this.activeTime;
        return;
      }
      if (this.activePanoMesh && this.activeTime && e - this.activeTime > ACTIVE_TO_CURRENT_DELAY) {
        for (var s = this.activePanoMesh, u = Object.keys(this.panoMeshes), l = null, c = 0, f = u; c < f.length; c++) {
          var d = f[c];
          if (this.panoMeshes[d] === s) {
            l = d;
            break;
          }
        }
        return l !== null && this.moveToPano(panoParse(l), {}, true), delete this.activePanoMesh, delete this.activeTime, s;
      }
      var h = this.camera.getDirection(new Vector3()), v = new Raycaster(this.camera.position, h);
      v.params.Points = { threshold: 0.1 };
      for (var A = void 0, g = [], p = this.works.getResolvedObserver(this.currentPano), y = p ? p.visibleIds : [], m = 0, E = y; m < E.length; m++) {
        var l = E[m], b = this.panoMeshes[l], T = v.intersectObject((r = b.hitTestMesh) !== null && r !== void 0 ? r : b, true)[0];
        T && g.push({ panoMesh: b, intersection: __assign({ floor: (o = p == null ? void 0 : p.floorIndex) !== null && o !== void 0 ? o : 0 }, T) });
      }
      var R = g.sort(function(L, C) {
        return L.intersection.distance - C.intersection.distance;
      })[0];
      R ? (A = R.intersection, this.activePanoMesh !== R.panoMesh && (this.activePanoMesh = R.panoMesh, this.activeTime = e), this.intersectMesh.position.copy(R.panoMesh.position), this.intersectMesh.lookAt(this.camera.position)) : (this.activePanoMesh = void 0, this.activeTime = void 0), A || (A = this.models.intersectRaycaster(v)[0]);
      var S = createEvent("intersect.update", {
        raycaster: v,
        intersection: A != null ? A : null,
        object: this.intersectMesh
      });
      if (this.emit("intersect.update", S), S.defaultPrevented) {
        this.hideIntersectMesh();
        return;
      }
      if (A && A.face) {
        var M = A.face.normal, w = new Quaternion();
        w.setFromUnitVectors(new Vector3(0, 0, 1), M), this.intersectMesh.quaternion.copy(w);
        var H = A.point.clone();
        this.intersectMesh.position.copy(H), R ? this.intersectMesh.visible = false : this.intersectMesh.visible = true;
      } else
        this.intersectMesh.visible = false;
      return R == null ? void 0 : R.panoMesh;
    }, t.prototype.onPanGesture = function() {
    }, t.prototype.onTapGesture = function() {
    }, t.prototype.onPinchGesture = function() {
    }, t.prototype.onMouseMove = function() {
    }, t.prototype.onMouseOut = function() {
    }, t;
  }(PanoramaController)
);
var HUMAN_EYE_POSITION = new Vector3(0, 1.6, 0);
var defaultModelControllerCustomInitArgs = __assign({}, defaultPanoramaLikeControllerCustomInitArgs);
var ModelController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o, s = t.parseArgs(e);
      return r = n45.call(this, s) || this, r.mode = "Model", r.locationMotion = new Motion({
        x: r.camera.pose.offset.x,
        y: r.camera.pose.offset.y,
        z: r.camera.pose.offset.z,
        distance: r.camera.pose.distance
      }), r.modelAlphaMotion = new Motion({
        modelAlpha: (o = r.models.getMaterial().modelAlpha) !== null && o !== void 0 ? o : 0
      }), r.perspToOrthoMotion = new Motion({
        perspToOrtho: r.camera.perspToOrtho.x
      }), r;
    }
    return t.parseArgs = function(e) {
      return e instanceof t ? e : n45.parseArgs.call(this, e);
    }, t.initAnimationEndState = function(e) {
      var r, o, s, u, l, c, f = this.parseArgs(e), d = f.works, h = e.initial, v = h.state, A = h.currentState, g = typeof v.panoIndex == "number" ? {
        workCode: (s = (r = v.workCode) !== null && r !== void 0 ? r : (o = f.works[0]) === null || o === void 0 ? void 0 : o.workCode) !== null && s !== void 0 ? s : "",
        panoIndex: v.panoIndex
      } : {
        workCode: A.workCode,
        panoIndex: A.panoIndex
      }, p = d.getResolvedObserver(g), y = (u = v.longitude) !== null && u !== void 0 ? u : A.longitude, m = clamp$1((l = v.latitude) !== null && l !== void 0 ? l : !p || isFristPersonMode(A.mode) ? A.latitude : f.defaultLatitude, f.minLatitude, f.maxLatitude), E = clamp$1((c = v.fov) !== null && c !== void 0 ? c : !p || isFristPersonMode(A.mode) ? A.fov : f.defaultFov, f.minFov, f.maxFov), b = new Vector3();
      if (f.initial.state.offset)
        b.copy(f.initial.state.offset);
      else if (p)
        b.copy(p.position);
      else {
        var T = coordinatesToVector(A).setLength(A.distance);
        b.copy(f.initial.currentState.offset).sub(T);
      }
      return {
        workCode: g.workCode,
        panoIndex: g.panoIndex,
        mode: "Model",
        longitude: y,
        latitude: m,
        fov: E,
        offset: b,
        distance: 0
      };
    }, t.prototype.updateConfiguration = function(e) {
      return n45.prototype.updateConfiguration.call(this, e);
    }, t.prototype.destroy = function() {
      n45.prototype.destroy.call(this), this.locationMotion.dispose();
    }, t.prototype.isReady = function() {
      return this.locationMotion.ended === false ? false : n45.prototype.isReady.call(this);
    }, t.prototype.updateWork = function(e, r, o, s) {
      this.works = e;
      var u = t.initAnimationEndState(__assign(__assign({}, this), { initial: {
        currentState: __assign(__assign({}, this.currentPano), this.camera.pose),
        duration: o.duration,
        effect: o.effect,
        state: r,
        userAction: s
      } }));
      return this.hideIntersectMesh(), this.moveToPosition(u.offset, {
        duration: 0,
        longitude: u.longitude,
        latitude: u.latitude,
        fov: u.fov
      }, s), true;
    }, t.prototype.updateCamera = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        var u = {}, l = {};
        return u.distance = 0, e.offset !== void 0 && (u.x = e.offset.x, u.y = e.offset.y, u.z = e.offset.z), e.longitude !== void 0 && (l.longitude = e.longitude), e.latitude !== void 0 && (l.latitude = e.latitude), e.fov !== void 0 && (l.fov = e.fov), s.locationMotion.set(u, r).catch(noop$1), s.cameraMotion.set(l, r).catch(noop$1);
      });
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        for (var u = [], l = [], c = 0, f = e; c < f.length; c++) {
          var d = f[c];
          u.push({
            key: d.key,
            progress: d.progress,
            value: {
              distance: 0,
              x: d.value.offset.x,
              y: d.value.offset.x,
              z: d.value.offset.x
            }
          }), l.push({
            key: d.key,
            progress: d.progress,
            value: {
              longitude: d.value.longitude,
              latitude: d.value.latitude,
              fov: d.value.fov
            }
          });
        }
        return s.locationMotion.setKeyframes(u, r).catch(noop$1), s.cameraMotion.setKeyframes(e, r);
      });
    }, t.prototype.updateTime = function(e, r) {
      if (!this.destroyed) {
        var o = {}, s = {};
        if (this.modelAlphaMotion.ended || (this.modelAlphaMotion.update(e), o.modelAlpha = this.modelAlphaMotion.value.modelAlpha), this.perspToOrthoMotion.ended || (this.perspToOrthoMotion.update(e), this.camera.perspToOrtho.setScalar(clamp$1(this.perspToOrthoMotion.value.perspToOrtho, 0, 1))), !this.locationMotion.ended) {
          this.locationMotion.update(e), s.distance = this.locationMotion.value.distance, s.offset = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z);
          var u = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z), l = this.works.resolvedObservers, c = arrayMin(l, function(f) {
            return f.position.distanceTo(u);
          });
          this.currentPano = c ? {
            workCode: c.work.workCode,
            panoIndex: c.panoIndex
          } : {
            workCode: "",
            panoIndex: 0
          };
        }
        this.cameraMotion.ended || (this.cameraMotion.update(e), s.longitude = this.cameraMotion.value.longitude, s.latitude = this.cameraMotion.value.latitude, s.fov = this.cameraMotion.value.fov), isEmptyObject(o) || this.models.setMaterial(o), isEmptyObject(s) || this.setCamera(s);
      }
    }, t.prototype.initAnimation = function() {
      var e = this;
      return this.destroyed ? Promise.resolve() : new Promise(function(r) {
        var o = e.initial;
        o.state, o.currentState;
        var s = o.duration, u = o.userAction;
        e.userAction = u;
        var l = t.initAnimationEndState(e), c = {
          modelAlpha: 1
        }, f = {
          perspToOrtho: 0
        }, d = {
          longitude: l.longitude,
          latitude: l.latitude,
          fov: l.fov,
          duration: s,
          moveStartCallback: function(h) {
            e.perspToOrthoMotion.set(f, s).catch(noop$1), e.modelAlphaMotion.set(c, s).catch(noop$1), e.emit("initAnimation.start", createEvent("initAnimation.start", {
              state: h,
              userAction: e.userAction
            }));
          },
          moveEndCallback: function(h) {
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: h,
              userAction: e.userAction
            })), r();
          },
          moveCancelCallback: function() {
            var h = e.currentPano, v = __assign(__assign({}, h), { mode: e.mode, longitude: e.camera.pose.longitude, latitude: e.camera.pose.latitude, fov: e.camera.pose.fov, offset: e.camera.pose.offset.clone(), distance: e.camera.pose.distance });
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: v,
              userAction: e.userAction
            })), r();
          }
        };
        e.moveToPosition(l.offset, d, u);
      });
    }, t.prototype.getTargetState = function() {
      var e = this.cameraMotion.getKeyFrameSegment(now())[1], r = this.locationMotion.getKeyFrameSegment(now())[1];
      return __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: e.value.longitude, latitude: e.value.latitude, fov: e.value.fov, offset: new Vector3(r.value.x, r.value.y, r.value.z), distance: r.value.distance });
    }, t.prototype.moveToPano = function(e, r, o) {
      r === void 0 && (r = {});
      var s = this.works.getResolvedObserver(e);
      s && this.moveToPosition(s.position, r, o);
    }, t.prototype.moveToPosition = function(e, r, o) {
      var s = this, u, l, c;
      r === void 0 && (r = {}), this.userAction = o, this.stopMomentumMovement();
      for (var f = now(), d = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z), h = d.distanceTo(e), v = this.locationMotion.getProgressVelocity(f), A = 0, g = 1; g < this.locationMotion.keyframes.length; g++) {
        var p = this.locationMotion.keyframes[g - 1].value, y = p.x, m = p.y, E = p.z, b = this.locationMotion.keyframes[g].value, T = b.x, R = b.y, S = b.z;
        A += Math.sqrt(Math.pow(T - y, 2) + Math.pow(R - m, 2) + Math.pow(S - E, 2));
      }
      var M = h === 0 ? 0 : v * A / h, w = this.calculateMovingDuration(r.duration, h), H = {
        x: e.x,
        y: e.y,
        z: e.z,
        distance: 0
      }, L = {
        longitude: r.longitude,
        latitude: r.latitude,
        fov: r.fov
      }, C = this.works.resolvedObservers, I = arrayMin(C, function(N) {
        return N.position.distanceTo(d);
      }), _ = I ? {
        workCode: I.work.workCode,
        panoIndex: I.panoIndex
      } : {
        workCode: "",
        panoIndex: 0
      }, O = __assign(__assign({}, _), { mode: this.mode, longitude: (u = L.longitude) !== null && u !== void 0 ? u : this.camera.pose.longitude, latitude: (l = L.latitude) !== null && l !== void 0 ? l : this.camera.pose.latitude, fov: (c = L.fov) !== null && c !== void 0 ? c : this.camera.pose.fov, offset: e.clone(), distance: 0 }), P = this.currentPano;
      this.emit("pano.moveTo", createEvent("pano.moveTo", {
        options: r,
        prevPano: P,
        progress: 0,
        state: O,
        userAction: this.userAction,
        error: null
      })), r.moveStartCallback && r.moveStartCallback(O), this.cameraMotion.set(L, w).catch(noop$1), this.locationMotion.set(H, w, M).then(
        // resolve
        // 
        function() {
          for (var N = 0, k = s.models; N < k.length; N++) {
            var U = k[N];
            U.show();
          }
          var D = __assign(__assign(__assign({}, _), { mode: s.mode }), clonePose(s.camera.pose));
          s.emit("pano.arrived", createEvent("pano.arrived", {
            options: r,
            prevPano: P,
            progress: 0,
            state: D,
            userAction: s.userAction,
            error: null
          })), r.moveEndCallback && r.moveEndCallback(D);
        },
        // reject
        // 
        function() {
          r.moveCancelCallback && r.moveCancelCallback(), s.emit("pano.cancel", createEvent("pano.cancel", {
            options: r,
            prevPano: P,
            progress: 0,
            state: O,
            userAction: s.userAction,
            error: null
          }));
        }
      );
    }, t.prototype.onTapGesture = function(e) {
      var r = e.center.raycaster;
      this.stopMomentumMovement();
      var o = this.models.intersectRaycaster(r)[0];
      if (o && o.face) {
        var s = o.face.normal, u = o.point;
        if (new Vector3(0, 1, 0).angleTo(s) > Math.PI / 3) {
          var l = s.clone().setLength(0.3).add(u);
          r.set(l, new Vector3(0, -1, 0)), o = this.models.intersectRaycaster(r)[0];
        }
      }
      if (o) {
        var c = new Vector3().copy(o.point).add(HUMAN_EYE_POSITION), f = this.works.resolvedObservers, d = arrayMin(f, function(A) {
          return A.position.distanceTo(c);
        }, true), h = d[0], v = d[1];
        h && v < 5 && (c.y = h.position.y), e.state.offset.copy(c), e.state.distance = 0, this.emit("gesture.tap", e), e.defaultPrevented || this.moveToPosition(c, {}, true);
      } else
        this.emit("gesture.tap", e), e.defaultPrevented || this.cameraBounce();
    }, t;
  }(PanoramaLikeController)
);
var edlVertexShader = function n41() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}(`}rpvv|{-zrqvz}-sy|nH}rpvv|{-zrqvz}-v{Hnvor-rp@-}|vv|{Hnvor-rp?-H{vs|z-znA-}|wrpv|{Znv\x07H{vs|z-znA-z|qrycvrZnv\x07Hn\bv{t-rp?-bH|vq-znv{56-
b-J-HrpA-z]|vv|{-J-z|qrycvrZnv\x07-7-rpA5}|vv|{9>;=6Htyl]|vv|{-J-}|wrpv|{Znv\x07-7-z]|vv|{H\f`);
var edlFragmentShader = function n42() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}(`0r\x07r{v|{-TYlRealsntlqr}u-G-r{noyr<<<<-nqn}rq-s|z-ur-RQY-unqr-p|qr-s|z-Puvvn{-O|pur{\b-v{-py|q-p|z}nrG<<-u}G<<tvuo;p|z<py|qp|z}nr<{x<rr<znr<}ytv{<\0RQY<unqr<RQY<<}rpvv|{-zrqvz}-sy|nH}rpvv|{-zrqvz}-v{H{vs|z-sy|n-prr{dvquH{vs|z-sy|n-prr{UrvtuH{vs|z-rp?-{rvtuo|h[RVTUO\\b_lP\\b[ajH{vs|z-sy|n-rqy\`r{tuH{vs|z-sy|n-nqvH{vs|z-sy|n-|}npv\bH{vs|z-sy|n-[rnH{vs|z-sy|n-SnH{vs|z-znA-]|wH{vs|z-nz}yr?Q-RQYP|y|Hn\bv{t-rp?-bHsy|n-r}|{r5sy|n-qr}u6
--rp?-_nqv-J-nqv-<-rp?5prr{dvqu9-prr{Urvtu6H--sy|n-z-J-=;=H--s|5v{-v-J-=H-v-I-[RVTUO\\b_lP\\b[aH-v886
----rp?-[rvtuo|-J-b-8-_nqv-7-{rvtuo|hvjH----sy|n-{rvtuo|Qr}u-J-r\x07r?Q5RQYP|y|9-[rvtuo|6;nH----{rvtuo|Qr}u-J-5{rvtuo|Qr}u-JJ->;=6-L-=;=-G-{rvtuo|Qr}uH----vs5{rvtuo|Qr}u-.J-=;=6
------vs5qr}u-JJ-=;=6
--------z-8J->==;=H------\fryr
--------z-8J-zn\x075=;=9-qr}u-:-{rvtuo|Qr}u6H------\f----\f--\f--r{-z-<-sy|n5[RVTUO\\b_lP\\b[a6H\f|vq-znv{56
--rpA-pRQY-J-r\x07r?Q5RQYP|y|9-b6H--sy|n-qr}u-J-pRQY;nH--qr}u-J-5qr}u-JJ->;=6-L-=;=-G-qr}uH--sy|n-r-J-r}|{r5qr}u6H--sy|n-unqr-J-r\x07}5:r-7-@==;=-7-rqy\`r{tu6H--tylSntP|y|-J-rpA5pRQY;to-7-unqr9-|}npv\b6H--
-<<-vr-rtyn-u\b}ro|yvp-qr}u-nyr-|-qr}u-ossr----sy|n-qy-J-}|5?;=9-qr}u6H----rpA-q}-J-]|w-7-rpA5=;=9-=;=9-:qy9->;=6H----sy|n-}	-J-q};	-<-q};H----sy|n-sntQr}u-J-5}	-8->;=6-<-?;=H----<<-tylSntQr}uRea-J-sntQr}uH--\f--vs5qr}u-JJ-=;=6
----qvpnqH--\f\f`);
var EDLMaterial = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this) || this;
      return r.uniforms = {
        screenWidth: makeUniform$1("f", 0),
        screenHeight: makeUniform$1("f", 0),
        edlStrength: makeUniform$1("f", 1),
        uNear: makeUniform$1("f", 1),
        uFar: makeUniform$1("f", 1),
        radius: makeUniform$1("f", 1),
        neighbours: makeUniform$1("2fv", new Float32Array()),
        depthMap: makeUniform$1("t", new Texture()),
        uEDLColor: makeUniform$1("t", new Texture()),
        uEDLDepth: makeUniform$1("t", new Texture()),
        opacity: makeUniform$1("f", 1),
        uProj: makeUniform$1("Matrix4fv", new Float32Array())
      }, r.neighbourCount = 8, r.updateShaderSource(), r.transparent = true, r;
    }
    return t.prototype.getUniform = function(e) {
      return this.uniforms === void 0 ? void 0 : this.uniforms[e].value;
    }, t.prototype.setUniform = function(e, r) {
      if (this.uniforms !== void 0) {
        var o = this.uniforms[e];
        o.value = r;
      }
    }, t.prototype.getDefines = function() {
      var e = "";
      return e += "#define NEIGHBOUR_COUNT " + this.neighbourCount + `
`, e;
    }, t.prototype.updateShaderSource = function() {
      var e = this.getDefines() + edlVertexShader, r = this.getDefines() + edlFragmentShader;
      this.setValues({
        vertexShader: e,
        fragmentShader: r
      }), this.needsUpdate = true;
    }, __decorate([
      uniform$1("screenWidth"),
      __metadata("design:type", Number)
    ], t.prototype, "screenWidth", void 0), __decorate([
      uniform$1("screenHeight"),
      __metadata("design:type", Number)
    ], t.prototype, "screenHeight", void 0), __decorate([
      uniform$1("edlStrength"),
      __metadata("design:type", Number)
    ], t.prototype, "edlStrength", void 0), __decorate([
      uniform$1("uNear"),
      __metadata("design:type", Number)
    ], t.prototype, "uNear", void 0), __decorate([
      uniform$1("uFar"),
      __metadata("design:type", Number)
    ], t.prototype, "uFar", void 0), __decorate([
      uniform$1("radius"),
      __metadata("design:type", Number)
    ], t.prototype, "radius", void 0), __decorate([
      uniform$1("neighbours", true),
      __metadata("design:type", Float32Array)
    ], t.prototype, "neighbours", void 0), __decorate([
      uniform$1("depthMap"),
      __metadata("design:type", Texture)
    ], t.prototype, "depthMap", void 0), __decorate([
      uniform$1("uEDLColor"),
      __metadata("design:type", Texture)
    ], t.prototype, "uEDLColor", void 0), __decorate([
      uniform$1("uEDLDepth"),
      __metadata("design:type", Texture)
    ], t.prototype, "uEDLDepth", void 0), __decorate([
      uniform$1("uProj"),
      __metadata("design:type", Array)
    ], t.prototype, "uProj", void 0), t;
  }(RawShaderMaterial)
);
function makeUniform$1(n45, t) {
  return { type: n45, value: t };
}
function uniform$1(n45, t) {
  return t === void 0 && (t = false), function(e, r) {
    Object.defineProperty(e, r, {
      get: function() {
        return this.getUniform(n45);
      },
      set: function(o) {
        o !== this.getUniform(n45) && (this.setUniform(n45, o), t && this.updateShaderSource());
      }
    });
  };
}
var passCamera$1 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var geometry$2 = new BufferGeometry();
geometry$2.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
geometry$2.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var mesh$2 = new Mesh(geometry$2);
var edlEffectScene = new Scene();
edlEffectScene.add(mesh$2);
var EDLEffect = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o, s) {
      var u = n45.call(this, e, r, o, s) || this;
      return u.sharedV2 = new Vector2(), u.renderer = e, u.material = new EDLMaterial(), mesh$2.material = u.material, u.material.needsUpdate = true, u;
    }
    return t.prototype.render = function(e) {
      this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true, this.renderer.setRenderTarget(e[0]), this.renderer.render(this.scene, this.camera);
      var r = this.camera, o = this.material.uniforms, s = this.renderer.getSize(this.sharedV2);
      o.screenWidth.value = s.x, o.screenHeight.value = s.y;
      var u = r.projectionMatrix, l = new Float32Array(16);
      l.set(u.elements);
      for (var c = new Float32Array(this.material.neighbourCount * 2), f = 0; f < this.material.neighbourCount; f++)
        c[2 * f + 0] = Math.cos(2 * f * Math.PI / this.material.neighbourCount), c[2 * f + 1] = Math.sin(2 * f * Math.PI / this.material.neighbourCount);
      o.neighbours.value = c, o.uNear.value = r.near, o.uFar.value = r.far, o.uEDLColor.value = e[0].texture, o.uProj.value = l, o.edlStrength.value = 0.5, o.radius.value = 1, o.opacity.value = 1, this.renderer.setRenderTarget(e[1]), this.renderer.render(edlEffectScene, passCamera$1);
    }, t.prototype.dispose = function() {
      this.copyPass.dispose();
    }, t;
  }(Effect)
);
var fragment = function n43() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}(`}rpvv|{-zrqvz}-sy|nH}rpvv|{-zrqvz}-v{H{vs|z-nz}yr?Q-drvtuZn}H{vs|z-nz}yr?Q-Qr}uZn}Hn\bv{t-rp?-bH|vq-znv{56-
sy|n-qr}u-J-r\x07r?Q5Qr}uZn}9-b6;Hvs5qr}u-KJ->;=6
qvpnqH\frpA-p|y|-J-r\x07r?Q5drvtuZn}9-b6H-p|y|-J-p|y|-<-p|y|;HtylSntP|y|-J-rpA5p|y|;\x07\b	9->;=6H-\f`);
var vertex = function n44() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var r = 113, o = 126, s = 0, u = "";
  return t[s].split(u).map(function(l) {
    return l.charCodeAt(s) > o ? l : String.fromCharCode((l.charCodeAt(s) + r) % o);
  }).join(u);
}(`}rpvv|{-zrqvz}-sy|nH}rpvv|{-zrqvz}-v{Hnvor-rp@-}|vv|{Hnvor-rp?-H{vs|z-znA-}|wrpv|{Znv\x07H{vs|z-znA-z|qrycvrZnv\x07Hn\bv{t-rp?-bH|vq-znv{56-
b-J-Htyl]|vv|{-J-}|wrpv|{Znv\x07-7-z|qrycvrZnv\x07-7-rpA5}|vv|{9>;=6H\f`);
var HQMaterial = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, {
        vertexShader: vertex,
        fragmentShader: fragment
      }) || this;
      return r.uniforms = {
        uDepthMap: makeUniform("t", null),
        uWeightMap: makeUniform("t", null)
      }, r.depthTest = true, r.depthWrite = true, r.opacity = 1, r;
    }
    return t.prototype.getUniform = function(e) {
      return this.uniforms === void 0 ? void 0 : this.uniforms[e].value;
    }, t.prototype.setUniform = function(e, r) {
      if (this.uniforms !== void 0) {
        var o = this.uniforms[e];
        o.value = r;
      }
    }, __decorate([
      uniform("uDepthMap"),
      __metadata("design:type", Number)
    ], t.prototype, "uDepthMap", void 0), __decorate([
      uniform("uWeightMap"),
      __metadata("design:type", Number)
    ], t.prototype, "uWeightMap", void 0), t;
  }(RawShaderMaterial)
);
function makeUniform(n45, t) {
  return { type: n45, value: t };
}
function uniform(n45, t) {
  return t === void 0 && (t = false), function(e, r) {
    Object.defineProperty(e, r, {
      get: function() {
        return this.getUniform(n45);
      },
      set: function(o) {
        o !== this.getUniform(n45) && (this.setUniform(n45, o), t && this.updateShaderSource());
      }
    });
  };
}
var passCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var geometry$1 = new BufferGeometry();
geometry$1.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
geometry$1.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var mesh$1 = new Mesh(geometry$1);
var hqScene = new Scene();
hqScene.add(mesh$1);
var HQEffect = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r, o, s) {
      var u = n45.call(this, e, r, o, s) || this;
      return u.sharedV2 = new Vector2(), u.renderer = e, u.material = new HQMaterial(), u.camera = o, mesh$1.material = u.material, u;
    }
    return t.prototype.render = function(e) {
      this.models.setMaterial({
        useHQDepth: true,
        useHQWeight: false
      }), this.models.update(this.renderer, this.camera, "Mapview"), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true, this.renderer.setRenderTarget(e[0]), this.renderer.render(this.scene, this.camera), this.models.setMaterial({
        useHQWeight: true,
        useHQDepth: false
      }), this.models.update(this.renderer, this.camera, "Mapview"), this.renderer.autoClearDepth = false, this.renderer.autoClearColor = true, this.renderer.setClearColor(new Color(0, 0, 0)), this.renderer.setClearAlpha(0), this.renderer.setRenderTarget(e[1]), this.renderer.render(this.scene, this.camera), this.material.uniforms.uWeightMap.value = e[1].texture, this.material.uniforms.uDepthMap.value = e[0].depthTexture, this.renderer.autoClearDepth = true, this.renderer.autoClearColor = true, this.renderer.setClearColor(new Color(0, 0, 0)), this.renderer.setClearAlpha(1), this.renderer.setRenderTarget(e[2]), this.renderer.render(hqScene, passCamera);
    }, t.prototype.dispose = function() {
      this.copyPass.dispose();
    }, t;
  }(Effect)
);
var minDistance = 0.5;
var PANGESTURE_FORWARD_ANGLE = Math.PI / 7;
var defaultMapviewControllerCustomInitArgs = {
  defaultLongitude: Math.PI / 4,
  defaultLatitude: Math.PI / 4,
  defaultDistance: 150,
  maxLatitude: +Math.PI / 2,
  minLatitude: 0,
  cameraType: "auto",
  cameraFence: null,
  intersectMeshCreator: function() {
    return new IntersectMesh();
  }
};
var MapviewController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = this, o, s = t.parseArgs(e);
      return r = n45.call(this, s) || this, r.mode = "Mapview", r.defaultLongitude = s.defaultLongitude, r.defaultLatitude = s.defaultLatitude, r.defaultDistance = s.defaultDistance, r.maxLatitude = s.maxLatitude, r.minLatitude = s.minLatitude, r.cameraType = s.cameraType, r.cameraFence = s.cameraFence, r.locationMotion = new Motion({
        x: r.camera.pose.offset.x,
        y: r.camera.pose.offset.y,
        z: r.camera.pose.offset.z,
        distance: r.camera.pose.distance
      }), r.modelAlphaMotion = new Motion({
        modelAlpha: (o = r.models.getMaterial().modelAlpha) !== null && o !== void 0 ? o : 0
      }), r.perspToOrthoMotion = new Motion({
        perspToOrtho: r.camera.perspToOrtho.x
      }), r.intersectMeshCreator = s.intersectMeshCreator, r.intersectMesh = r.intersectMeshCreator(), r.intersectMesh.name = "intersect", r.intersectMesh.visible = false, r.currentTapId = null, r.helper.add(r.intersectMesh), r.edlTarget = new WebGLRenderTarget(1024, 1024, {
        generateMipmaps: false,
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        format: RGBAFormat,
        type: FloatType,
        depthTexture: new DepthTexture(1024, 1024, UnsignedIntType)
      }), r.edlEffect = new EDLEffect(r.renderer, r.modelScene, r.camera, r.models), r.hqEffect = new HQEffect(r.renderer, r.modelScene, r.camera, r.models), r;
    }
    return t.parseArgs = function(e) {
      var r, o, s, u, l, c, f, d;
      if (e instanceof t)
        return e;
      var h = n45.parseArgs.call(this, e);
      return __assign(__assign({}, h), { defaultLongitude: (r = e.defaultLongitude) !== null && r !== void 0 ? r : defaultMapviewControllerCustomInitArgs.defaultLongitude, defaultLatitude: (o = e.defaultLatitude) !== null && o !== void 0 ? o : defaultMapviewControllerCustomInitArgs.defaultLatitude, defaultDistance: (s = e.defaultDistance) !== null && s !== void 0 ? s : defaultMapviewControllerCustomInitArgs.defaultDistance, maxLatitude: (u = e.maxLatitude) !== null && u !== void 0 ? u : defaultMapviewControllerCustomInitArgs.maxLatitude, minLatitude: (l = e.minLatitude) !== null && l !== void 0 ? l : defaultMapviewControllerCustomInitArgs.minLatitude, cameraType: (c = e.cameraType) !== null && c !== void 0 ? c : defaultMapviewControllerCustomInitArgs.cameraType, cameraFence: (f = e.cameraFence) !== null && f !== void 0 ? f : defaultMapviewControllerCustomInitArgs.cameraFence, intersectMeshCreator: (d = e.intersectMeshCreator) !== null && d !== void 0 ? d : defaultMapviewControllerCustomInitArgs.intersectMeshCreator });
    }, t.distanceFromModel = function(e, r, o) {
      var s = e.bounding, u = Math.pow(Math.pow(s.max.x - s.min.x + 1, 2) + Math.pow(s.max.y - s.min.y + 1, 2) + Math.pow(s.max.z - s.min.z + 1, 2), 1 / 2), l = u / 2 / Math.tan(Math.PI * r / 360);
      return o < 1 && (l = l / o), isNaN(l) ? u : l;
    }, t.initAnimationEndState = function(e) {
      var r, o, s, u, l, c, f, d = this.parseArgs(e), h = d.works, v = d.models, A = e.initial, g = A.state, p = A.currentState, y = typeof g.panoIndex == "number" ? {
        workCode: (s = (r = g.workCode) !== null && r !== void 0 ? r : (o = d.works[0]) === null || o === void 0 ? void 0 : o.workCode) !== null && s !== void 0 ? s : "",
        panoIndex: g.panoIndex
      } : {
        workCode: p.workCode,
        panoIndex: p.panoIndex
      }, m = h.getResolvedObserver(y), E = (u = g.fov) !== null && u !== void 0 ? u : 60, b = clamp$1((l = g.latitude) !== null && l !== void 0 ? l : isThirdPersonMode(p.mode) ? p.latitude : d.defaultLatitude, d.minLatitude, d.maxLatitude), T = t.distanceFromModel(d.models, E, d.camera.aspect), R = new Vector3(), S = (c = g.distance) !== null && c !== void 0 ? c : Math.min(d.defaultDistance, T), M = (f = g.longitude) !== null && f !== void 0 ? f : isThirdPersonMode(p.mode) ? p.longitude : d.defaultLongitude;
      return g.offset ? R.copy(g.offset) : d.defaultDistance < T && m ? (R.copy(m.position), g.longitude === void 0 && (M = p.longitude)) : (v.bounding.getCenter(R), S = T), __assign(__assign({}, y), { mode: "Mapview", longitude: M, latitude: b, fov: E, offset: R, distance: S });
    }, t.prototype.updateConfiguration = function(e) {
      var r = n45.prototype.updateConfiguration.call(this, e);
      if (r === false)
        return false;
      if (e.defaultLongitude !== void 0 && this.defaultLongitude !== e.defaultLongitude && (this.defaultLongitude = e.defaultLongitude), e.defaultLatitude !== void 0 && this.defaultLatitude !== e.defaultLatitude && (this.defaultLatitude = e.defaultLatitude), e.defaultDistance !== void 0 && this.defaultDistance !== e.defaultDistance && (this.defaultDistance = e.defaultDistance), e.maxLatitude !== void 0 && this.maxLatitude !== e.maxLatitude && (this.maxLatitude = e.maxLatitude), e.minLatitude !== void 0 && this.minLatitude !== e.minLatitude && (this.minLatitude = e.minLatitude), e.cameraType !== void 0 && this.cameraType !== e.cameraType && (this.cameraType = e.cameraType), this.cameraFence instanceof Box3 && e.cameraFence instanceof Box3 ? this.cameraFence.equals(e.cameraFence) || (this.cameraFence = e.cameraFence) : this.cameraFence instanceof Sphere && e.cameraFence instanceof Sphere ? this.cameraFence.equals(e.cameraFence) || (this.cameraFence = e.cameraFence) : e.cameraFence !== void 0 && (this.cameraFence = e.cameraFence), e.intersectMeshCreator !== void 0 && this.intersectMeshCreator !== e.intersectMeshCreator) {
        this.intersectMeshCreator = e.intersectMeshCreator;
        var o = this.intersectMesh;
        this.intersectMesh = this.intersectMeshCreator(), this.intersectMesh.name = o.name, this.intersectMesh.visible = o.visible;
        var s = this.intersectMesh.parent;
        s && s.add(this.intersectMesh), o.dispose();
      }
      return true;
    }, t.prototype.destroy = function() {
      n45.prototype.destroy.call(this), this.locationMotion.dispose(), delete this.panState, this.intersectMesh.dispose(), this.helper.remove(this.intersectMesh);
    }, t.prototype.isReady = function() {
      return this.locationMotion.ended === false ? false : n45.prototype.isReady.call(this);
    }, t.prototype.updateWork = function(e, r, o, s) {
      this.userAction = s, this.works = e;
      var u = t.initAnimationEndState(__assign(__assign({}, this), { initial: {
        currentState: __assign(__assign({}, this.currentPano), this.camera.pose),
        duration: o.duration,
        effect: o.effect,
        state: r,
        userAction: s
      } }));
      this.currentPano = {
        workCode: u.workCode,
        panoIndex: u.panoIndex
      };
      var l = {
        longitude: u.longitude,
        latitude: u.latitude,
        fov: u.fov
      }, c = {
        x: u.offset.x,
        y: u.offset.y,
        z: u.offset.z,
        distance: u.distance,
        orthoDistance: u.distance
      };
      return this.locationMotion.set(c, o.duration).catch(noop$1), this.cameraMotion.set(l, o.duration).catch(noop$1), true;
    }, t.prototype.updateModel = function(e) {
      n45.prototype.updateModel.call(this, e);
      var r = e.bounding.getCenter(new Vector3()), o = t.distanceFromModel(e, this.cameraMotion.value.fov, this.camera.aspect);
      this.updateCamera({ offset: r, distance: o }, 0, true);
    }, t.prototype.updateCamera = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        var u = {}, l = {};
        return e.distance !== void 0 && (u.distance = e.distance), e.offset !== void 0 && (u.x = e.offset.x, u.y = e.offset.y, u.z = e.offset.z), e.longitude !== void 0 && (l.longitude = e.longitude), e.latitude !== void 0 && (l.latitude = e.latitude), e.fov !== void 0 && (l.fov = e.fov), s.locationMotion.set(u, r).catch(noop$1), s.cameraMotion.set(l, r).catch(noop$1);
      });
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      var s = this;
      return this.initAnimationReady.then(function() {
        s.userAction = o, s.stopMomentumMovement();
        for (var u = [], l = [], c = 0, f = e; c < f.length; c++) {
          var d = f[c];
          u.push({
            key: d.key,
            progress: d.progress,
            value: {
              distance: d.value.distance,
              x: d.value.offset.x,
              y: d.value.offset.x,
              z: d.value.offset.x
            }
          }), l.push({
            key: d.key,
            progress: d.progress,
            value: {
              longitude: d.value.longitude,
              latitude: d.value.latitude,
              fov: d.value.fov
            }
          });
        }
        return s.locationMotion.setKeyframes(u, r).catch(noop$1), s.cameraMotion.setKeyframes(e, r);
      });
    }, t.prototype.updateTime = function(e, r) {
      if (!this.destroyed) {
        var o = {}, s = {};
        this.locationMotion.ended || (this.locationMotion.update(e), s.distance = this.locationMotion.value.distance, s.offset = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z)), this.cameraMotion.ended || (this.cameraMotion.update(e), s.longitude = this.cameraMotion.value.longitude, s.latitude = this.cameraMotion.value.latitude, s.fov = this.cameraMotion.value.fov), this.modelAlphaMotion.ended || (this.modelAlphaMotion.update(e), o.modelAlpha = this.modelAlphaMotion.value.modelAlpha);
        var u = 0;
        if (this.cameraType === "auto" ? u = Math.abs(Math.PI / 2 - this.cameraMotion.value.latitude) < 0.02 || Math.abs(-Math.PI / 2 - this.cameraMotion.value.latitude) < 0.02 ? 1 : 0 : this.cameraType === "perspective" ? u = 0 : this.cameraType === "orthographic" && (u = 1), this.perspToOrthoMotion.getTargetKeyframe().value.perspToOrtho !== u && this.perspToOrthoMotion.set({ perspToOrtho: u }, 500).catch(noop$1), this.perspToOrthoMotion.ended || (this.perspToOrthoMotion.update(e), this.camera.perspToOrtho.setScalar(clamp$1(this.perspToOrthoMotion.value.perspToOrtho, 0, 1))), isEmptyObject(o) || this.models.setMaterial(o), isEmptyObject(s) || this.setCamera(s), this.cameraFence && !this.panState && !this.pinchState && !this.mouseWheelState && !this.inMomentumMovement && this.locationMotion.ended && this.perspToOrthoMotion.ended && this.cameraMotion.ended) {
          var l = coordinatesToVector(this.camera.pose, new Vector3()), c = new Vector3().copy(this.camera.pose.offset).sub(l.clone().multiplyScalar(this.camera.pose.distance));
          if (this.cameraFence.distanceToPoint(c) > 0.01) {
            var f = this.cameraFence.clampPoint(c, new Vector3()), d = this.camera.pose.offset.clone().add(f).sub(c), h = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: this.camera.pose.longitude, latitude: this.camera.pose.latitude, fov: this.camera.pose.fov, offset: d, distance: this.camera.pose.distance });
            this.fixFinalState(h), this.locationMotion.set({ x: h.offset.x, y: h.offset.y, z: h.offset.z, distance: h.distance }, 300).catch(noop$1);
          }
        }
        if (this.intersectMesh && this.intersectMesh.parent) {
          var v = this.camera.position.distanceTo(this.intersectMesh.position), A = 2 * Math.tan(0.5 * this.camera.fov / 180 * Math.PI), g = v * A / 5;
          this.intersectMesh.scale.setScalar(g);
        }
      }
    }, t.prototype.getTargetState = function() {
      var e = this.cameraMotion.getKeyFrameSegment(now())[1], r = this.locationMotion.getKeyFrameSegment(now())[1];
      return __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: e.value.longitude, latitude: e.value.latitude, fov: e.value.fov, distance: r.value.distance, offset: new Vector3(r.value.x, r.value.y, r.value.z) });
    }, t.prototype.initAnimation = function() {
      var e = this;
      return this.destroyed ? Promise.resolve() : new Promise(function(r) {
        var o = e.initial;
        o.state, o.currentState;
        var s = o.duration, u = o.userAction;
        e.userAction = u;
        var l = t.initAnimationEndState(e), c = {
          longitude: l.longitude,
          latitude: l.latitude,
          fov: l.fov
        }, f = {
          x: l.offset.x,
          y: l.offset.y,
          z: l.offset.z,
          distance: l.distance
        }, d = {
          modelAlpha: 1
        }, h = {
          perspToOrtho: 0
        };
        e.emit("initAnimation.start", createEvent("initAnimation.start", {
          state: l,
          userAction: e.userAction
        })), e.perspToOrthoMotion.set(h, s).catch(noop$1), e.modelAlphaMotion.set(d, s / 3).catch(noop$1), e.cameraMotion.set(c, s).catch(noop$1), e.locationMotion.set(f, s).then(
          /* resolve */
          function() {
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: l,
              userAction: e.userAction
            }));
          },
          /* reject */
          function(v) {
            var A = __assign(__assign(__assign({}, e.currentPano), { mode: e.mode }), clonePose(e.camera.pose));
            e.emit("initAnimation.end", createEvent("initAnimation.end", {
              state: A,
              userAction: e.userAction
            }));
          }
        ).then(function() {
          r();
        });
      });
    }, t.prototype.getForwardObserverOrNot = function(e) {
      var r = this, o = this.models.intersectRaycaster(e)[0];
      if (!o)
        return null;
      var s = this.works.resolvedObservers.filter(function(f) {
        for (var d, h = 0, v = r.models; h < v.length; h++) {
          var A = v[h];
          if (A.visible && ((d = A.work) === null || d === void 0 ? void 0 : d.workCode) === f.work.workCode)
            return true;
        }
        return false;
      }), u = arrayMin(s, function(f) {
        return f.standingPosition.distanceTo(o.point);
      }, true), l = u[0], c = u[1];
      return l && c < 10 ? l : null;
    }, t.prototype.coordinatesForOffset = function(e) {
      var r = this.renderer.getSize(new Vector2());
      return {
        longitude: -2 * e.x / (r.x * this.scissor.width),
        latitude: 2 * e.y / (r.y * this.scissor.height)
      };
    }, t.prototype.requestMomentumMovement = function(e, r, o, s) {
      var u = this;
      if (this.inMomentumMovement !== null) {
        for (var l = __assign({}, o), c = { longitude: 0, latitude: 0, x: 0, y: 0, z: 0 }, f = 0; f < s; f++)
          l.longitude *= 0.996, l.latitude *= 0.996 * 0.998, l.x *= 0.99, l.y *= 0.99, l.z *= 0.99, c.longitude += l.longitude, c.latitude += l.latitude, c.x += l.x, c.y += l.y, c.z += l.z;
        var d = formatRad(this.cameraMotion.value.longitude + c.longitude), h = clamp$1(this.cameraMotion.value.latitude + c.latitude, this.minLatitude, this.maxLatitude), v = new Vector3(this.locationMotion.value.x + c.x, this.locationMotion.value.y + c.y, this.locationMotion.value.z + c.z), A = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: d, latitude: h, offset: v, fov: this.cameraMotion.value.fov, distance: this.locationMotion.value.distance }), g = e.state.offset.clone().sub(coordinatesToVector(e.state).setLength(A.distance)), p = !(Math.abs(l.longitude) > 1e-4 || Math.abs(l.latitude) > 1e-4 || Math.abs(l.x) > 1e-4 || Math.abs(l.y) > 1e-4 || Math.abs(l.z) > 1e-4), y = this.cameraFence ? this.cameraFence.containsPoint(g) : true;
        y === false && (p = true);
        var m = createEvent("gesture.momentum", __assign(__assign({}, e), { isFirst: r, isFinal: p, state: A }));
        if (this.inMomentumMovement.event = m, this.emit("gesture.momentum", m), e.defaultPrevented) {
          this.inMomentumMovement = null;
          return;
        }
        this.inMomentumMovement && (this.cameraMotion.set({ longitude: d, latitude: h }, 0).catch(noop$1), this.locationMotion.set({ x: A.offset.x, y: A.offset.y, z: A.offset.z, distance: A.distance }, 0).catch(noop$1), p ? this.inMomentumMovement = null : AnimationFrameLoop.shared.add(function(E, b) {
          u.requestMomentumMovement(e, false, l, b | 0);
        }, true, 1));
      }
    }, t.prototype.fixFinalState = function(e) {
      if (this.perspToOrthoMotion.getTargetKeyframe().value.perspToOrtho !== 1) {
        var r = coordinatesToVector(e, new Vector3()), o = new Vector3().copy(e.offset).sub(r.clone().multiplyScalar(e.distance)), s = new Raycaster(o, r);
        s.params.Points = { threshold: 0.1 }, s.near = this.camera.near, s.far = this.camera.far;
        var u;
        if (u = this.models.intersectRaycaster(s).filter(function(h) {
          var v, A = (v = h.face) === null || v === void 0 ? void 0 : v.normal;
          return A && s.ray.direction.dot(A) >= 0 ? false : h.distance > minDistance + s.near;
        })[0], !u) {
          var l = new Plane(new Vector3(0, 1, 0), -this.models.bounding.min.y), c = s.ray.intersectPlane(l, new Vector3());
          if (c) {
            var f = c.distanceTo(s.ray.origin);
            f < 1e3 && f >= s.near && (u = {
              distance: f,
              floor: 0,
              point: c,
              object: this.scene,
              face: null
            });
          }
        }
        if (!u) {
          var d = Math.max(e.distance, 3);
          u = {
            distance: d,
            floor: 0,
            point: s.ray.direction.clone().setLength(d).add(s.ray.origin),
            object: this.scene,
            face: null
          };
        }
        u && (e.distance = clamp$1(u.distance, 0, 1 / 0), e.offset.copy(o).add(r.clone().multiplyScalar(e.distance)));
      }
    }, t.prototype.onPanGesture = function(e) {
      this.userAction = e.userAction, this.stopMomentumMovement(), this.hideIntersectMesh();
      var r = e.pointers.length, o = this.panState, s = 0, u = false;
      e.pointerType === "mouse" && (s = e.srcEvent.buttons, u = e.srcEvent.shiftKey), o && s === 0 && o.buttons !== 0 && (s = o.buttons);
      var l = o == null ? void 0 : o.target;
      if (!l) {
        var c = this.relativeClientPosition(e.center), f = new Raycaster();
        f.params.Points = { threshold: 0.1 }, f.setFromCamera(c, this.camera), f.near = this.camera.near, l = new Vector3().copy(f.ray.direction).multiplyScalar(3).add(f.ray.origin);
        var d = this.models.intersectRaycaster(f)[0];
        if (!d && f.ray.direction.y < -0.3) {
          var h = new Plane(new Vector3(0, 1, 0), 0), v = f.ray.intersectPlane(h, new Vector3());
          if (v) {
            var A = v.distanceTo(f.ray.origin);
            A < 1e4 && A >= f.near && (d = {
              distance: A,
              floor: 0,
              point: v,
              object: this.scene
            });
          }
        }
        if (d)
          l.copy(d.point);
        else {
          var g = new Vector3().copy(this.camera.pose.offset).sub(this.camera.position).normalize(), h = new Plane().setFromNormalAndCoplanarPoint(g, this.camera.pose.offset);
          f.ray.intersectPlane(h, l);
        }
      }
      if (e.isFinal ? delete this.panState : this.panState = {
        target: l,
        buttons: s,
        pointerLength: r,
        x: e.center.x,
        y: e.center.y
      }, !(typeof o == "undefined" || o.pointerLength !== r)) {
        var p = r > 1 || s === 2 || u;
        if (p) {
          var y = {
            x: e.center.x - o.x,
            y: e.center.y - o.y
          }, m = new Vector3(this.locationMotion.value.x, this.locationMotion.value.y, this.locationMotion.value.z), E = coordinatesToVector(this.cameraMotion.value).setLength(this.locationMotion.value.distance).add(m), b = new Vector3().copy(E).sub(o.target).length();
          b *= Math.tan(this.camera.pose.fov / 2 * Math.PI / 180);
          var T = this.renderer.getSize(new Vector2()), R = 2 * y.x * b / T.y, S = 2 * y.y * b / T.y, M = new Vector3();
          M.setFromMatrixColumn(this.camera.matrix, 0), M.multiplyScalar(-R), m.add(M), this.camera.pose.latitude < PANGESTURE_FORWARD_ANGLE ? M.setFromMatrixColumn(this.camera.matrix, 1) : (M.setFromMatrixColumn(this.camera.matrix, 0), M.crossVectors(this.camera.up, M)), M.multiplyScalar(S), m.add(M);
          var w = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: this.camera.pose.longitude, latitude: this.camera.pose.latitude, fov: this.camera.pose.fov, offset: m, distance: this.camera.pose.distance });
          if (e.state = w, this.emit("gesture.pan", e), e.defaultPrevented)
            return;
          if (this.locationMotion.set({
            x: w.offset.x,
            y: w.offset.y,
            z: w.offset.z
          }, 0).catch(noop$1), e.isFinal && (this.fixFinalState(w), Object.assign(e, { __fixFinalState: true }), this.locationMotion.set({
            distance: w.distance,
            x: w.offset.x,
            y: w.offset.y,
            z: w.offset.z
          }, 0).catch(noop$1)), e.isFinal) {
            var H = this.renderer.getSize(new Vector2()), L = 2 * e.velocityX * b / H.y, C = 2 * e.velocityY * b / H.y, I = new Vector3(), _ = new Vector3();
            I.setFromMatrixColumn(this.camera.matrix, 0), I.multiplyScalar(-L), _.add(I), this.camera.pose.latitude < PANGESTURE_FORWARD_ANGLE ? I.setFromMatrixColumn(this.camera.matrix, 1) : (I.setFromMatrixColumn(this.camera.matrix, 0), I.crossVectors(this.camera.up, I)), I.multiplyScalar(C), _.add(I), this.inMomentumMovement = {
              uuid: createUuid()
            }, this.requestMomentumMovement(e, true, { longitude: 0, latitude: 0, x: _.x, y: _.y, z: _.z }, 0);
          }
        } else {
          var y = {
            x: e.center.x - o.x,
            y: e.center.y - o.y
          }, O = this.coordinatesForOffset(y), P = formatRad(this.cameraMotion.value.longitude + O.longitude), N = clamp$1(this.cameraMotion.value.latitude + O.latitude, this.minLatitude, this.maxLatitude);
          this.camera.aspect < 1 && Math.abs(e.overallVelocityX) > 0.2 && Math.atan2(Math.abs(e.overallVelocityY), Math.abs(e.overallVelocityX)) < Math.PI / 6.923 && (N = this.cameraMotion.value.latitude);
          var w = __assign(__assign({}, this.currentPano), { mode: this.mode, longitude: P, latitude: N, fov: this.camera.pose.fov, offset: this.camera.pose.offset, distance: this.camera.pose.distance });
          if (e.isFinal && Object.assign(e, { __fixFinalState: true }), e.state = w, this.emit("gesture.pan", e), e.defaultPrevented)
            return;
          if (e.isFinal ? this.locationMotion.set({
            distance: w.distance,
            x: w.offset.x,
            y: w.offset.y,
            z: w.offset.z
          }, 0).catch(noop$1) : this.cameraMotion.set({
            longitude: w.longitude,
            latitude: w.latitude
          }, 0).catch(noop$1), e.isFinal) {
            var k = e.velocityX, U = e.velocityY;
            this.inMomentumMovement = {
              uuid: createUuid()
            }, this.requestMomentumMovement(e, true, __assign(__assign({}, this.coordinatesForOffset({ x: k, y: U })), { x: 0, y: 0, z: 0 }), 0);
          }
        }
      }
    }, t.prototype.onPinchGesture = function(e) {
      var r;
      if (this.initAnimationIsReady) {
        this.userAction = e.userAction, this.stopMomentumMovement(), this.hideIntersectMesh();
        var o = (r = this.pinchState) === null || r === void 0 ? void 0 : r.distance;
        if (e.isFirst) {
          this.pinchState = {
            x: e.center.x,
            y: e.center.y,
            scale: 1,
            distance: this.locationMotion.value.distance
          };
          return;
        }
        if (typeof o != "undefined") {
          var s = this.models.bounding.getCenter(new Vector3()), u = t.distanceFromModel(this.models, this.cameraMotion.value.fov, this.camera.aspect), l = clamp$1(o / e.scale, minDistance, 1 / 0), c = e.state.offset.clone().sub(coordinatesToVector(e.state).setLength(l)), f = this.models.bounding.containsPoint(c), d;
          if (!f && this.pinchState && this.pinchState.scale > e.scale && s.distanceTo(c) > u ? d = e.state.distance : (d = l, this.pinchState && (this.pinchState.scale = e.scale)), e.state.distance = d, this.emit("gesture.pinch", e), !e.defaultPrevented && (this.locationMotion.set({ distance: e.state.distance }, 0).catch(noop$1), e.pointerType !== "mouse" && (e.type = "gesture.pan", this.onPanGesture(e)), e.isFinal)) {
            if (!("__fixFinalState" in e)) {
              var h = e.state;
              this.fixFinalState(e.state);
              var v = {
                x: h.offset.x,
                y: h.offset.y,
                z: h.offset.z,
                distance: h.distance
              };
              this.locationMotion.set(v, 0).catch(noop$1);
            }
            delete this.panState, delete this.pinchState;
          }
        }
      }
    }, t.prototype.onMouseMove = function(e) {
      var r, o;
      if (this.intersectMesh.parent && !this.panState && !this.pinchState && !this.mouseWheelState && (this.emit("gesture.mousemove", e), !e.defaultPrevented)) {
        var s = e.center.raycaster;
        if (s.near = this.camera.near, s.far = this.camera.far, e.isFinal && this.intersectMesh.parent && this.intersectMesh.visible === true) {
          this.hideIntersectMesh();
          return;
        }
        var u = this.models.intersectRaycaster(s)[0], l = createEvent("intersect.update", {
          raycaster: s,
          intersection: u != null ? u : null,
          object: this.intersectMesh
        });
        if (this.emit("intersect.update", l), l.defaultPrevented) {
          this.hideIntersectMesh();
          return;
        }
        if (u) {
          var c = (o = (r = u.face) === null || r === void 0 ? void 0 : r.normal) !== null && o !== void 0 ? o : new Vector3().copy(s.ray.direction).multiplyScalar(-1), f = c.clone(), d = u.point.clone();
          this.intersectMesh.position.copy(d);
          var h = d.clone().add(f);
          if (this.intersectMesh.lookAt(h), Math.abs(c.y) > 0.99) {
            var v = this.camera.position.clone().sub(d);
            this.intersectMesh.rotation.z = -Math.atan2(v.z, v.x);
          }
          this.intersectMesh.visible = true, this.needsRender = true;
        } else
          this.hideIntersectMesh();
      }
    }, t.prototype.onMouseWheel = function(e) {
      if (this.initAnimationIsReady)
        if (this.userAction = e.userAction, this.stopMomentumMovement(), this.hideIntersectMesh(), e.isFinal) {
          var r = e.state;
          if (this.fixFinalState(r), this.emit("gesture.mousewheel", e), e.defaultPrevented)
            return;
          var o = {
            x: r.offset.x,
            y: r.offset.y,
            z: r.offset.z,
            distance: r.distance
          };
          this.locationMotion.set(o, 0).catch(noop$1);
        } else {
          var s = Math.max(this.locationMotion.value.distance - this.camera.near, 0), u = e.center.delta / 10 * Math.max(s / 5, 0.1);
          if (this.locationMotion.value.distance - u >= minDistance) {
            var l = this.locationMotion.value.distance - u;
            e.state.distance = l;
          } else {
            var c = coordinatesToVector(this.cameraMotion.value);
            c.setLength(u), e.state.offset.add(c);
          }
          if (this.emit("gesture.mousewheel", e), e.defaultPrevented)
            return;
          this.locationMotion.set({
            distance: e.state.distance,
            x: e.state.offset.x,
            y: e.state.offset.y,
            z: e.state.offset.z
          }, 0).catch(noop$1);
        }
    }, t.prototype.onTapGesture = function(e) {
      var r = this;
      this.userAction = e.userAction, this.stopMomentumMovement();
      var o = e.center.raycaster, s = this.getForwardObserverOrNot(o);
      if (!s)
        this.emit("gesture.tap", e);
      else {
        var u = {
          longitude: this.camera.pose.longitude,
          latitude: 0
        }, l = __assign(__assign({}, e.state), { mode: "Panorama", workCode: s.pano.workCode, panoIndex: s.pano.panoIndex, longitude: u.longitude, latitude: u.latitude, offset: s ? s.position.clone() : new Vector3(), distance: 0 });
        if (e.state = l, this.emit("gesture.tap", e), !e.defaultPrevented && (this.emit("pano.select", createEvent("pano.select", {
          prevPano: this.currentPano,
          state: l,
          userAction: e.userAction,
          options: u,
          progress: 0,
          error: null
        })), s && s.active)) {
          var c = this.currentTapId = createUuid();
          this.preloadPano(s.pano).then(function(f) {
            r.currentTapId === c && r.emit("pano.request", createEvent("pano.request", {
              userAction: true,
              prevPano: r.currentPano,
              progress: 0,
              state: l,
              options: u,
              error: null
            }));
          });
        }
      }
    }, t.prototype.onDblTapGesture = function(e) {
      if (this.initAnimationIsReady) {
        this.userAction = e.userAction, this.stopMomentumMovement(), this.hideIntersectMesh();
        var r = e.state, o = e.center.raycaster, s = o.ray.origin.clone().add(o.ray.direction.clone().setLength(3)), u = 1, l = 3, c = u, f = this.models.intersectRaycaster(o)[0];
        if (f && (s = f.point.clone(), f.distance > (u + l) / 2 ? c = u : c = l), e.state.distance = c, e.state.offset = s, this.emit("gesture.dbltap", e), !e.defaultPrevented) {
          var d = {
            x: r.offset.x,
            y: r.offset.y,
            z: r.offset.z,
            distance: r.distance
          };
          this.locationMotion.set(d, 360).catch(noop$1), this.hideIntersectMesh();
        }
      }
    }, t.prototype.hideIntersectMesh = function() {
      this.intersectMesh.visible = false, this.needsRender = true;
    }, t.prototype.render = function(e, r) {
      var o = this.renderer.getRenderTarget();
      this.updateScreenBuffer(r), this.enableFragDepth ? (e && (r === "edl" ? this.edlEffect.render(this.screenBuffers) : r === "hq" ? this.hqEffect.render(this.screenBuffers) : (this.renderer.setRenderTarget(this.modelRenderTarget), this.renderer.render(this.modelScene, this.camera))), this.depthCopyPass.render(this.modelRenderTarget.depthTexture, o), this.renderer.autoClearDepth = false, this.renderer.autoClearColor = true, this.copyPass.render(this.modelRenderTarget, o), this.renderer.setRenderTarget(o), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, this.camera), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true) : (r === "edl" ? this.edlEffect.render(this.screenBuffers) : r === "hq" ? this.hqEffect.render(this.screenBuffers) : this.renderer.render(this.modelScene, this.camera), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, this.camera), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true);
    }, t;
  }(BaseController)
);
function isNil(n45) {
  return n45 == null;
}
var _moveEvent = { type: "move" };
var XRController = (
  /** @class */
  function() {
    function n45() {
      this._targetRay = null, this._grip = null, this._hand = null, this._axes = [0, 0];
    }
    return n45.prototype.getHandSpace = function() {
      return this._hand === null && (this._hand = new Group(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }, n45.prototype.getTargetRaySpace = function() {
      return this._targetRay === null && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Vector3()), this._targetRay;
    }, n45.prototype.getGripSpace = function() {
      return this._grip === null && (this._grip = new Group(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Vector3()), this._grip;
    }, n45.prototype.dispatchEvent = function(t) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
    }, n45.prototype.disconnect = function(t) {
      return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }, n45.prototype.getAxes = function() {
      return this._axes;
    }, n45.prototype.update = function(t, e, r) {
      var o = null, s = null, u = null, l = this._targetRay, c = this._grip, f = this._hand;
      if (t && t.gamepad && t.gamepad.axes && (this._axes = [t.gamepad.axes[2], t.gamepad.axes[3]]), t && e.session.visibilityState !== "visible-blurred")
        if (l !== null && (o = e.getPose(t.targetRaySpace, r), o !== null && (l.matrix.fromArray(o.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), o.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(o.linearVelocity)) : l.hasLinearVelocity = false, o.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(o.angularVelocity)) : l.hasAngularVelocity = false, this.dispatchEvent(_moveEvent))), f && t.hand) {
          u = true;
          for (var d = 0, h = t.hand.values(); d < h.length; d++) {
            var v = h[d], A = e.getJointPose(v, r);
            if (f.joints[v.jointName] === void 0) {
              var g = new Group();
              g.matrixAutoUpdate = false, g.visible = false, f.joints[v.jointName] = g, f.add(g);
            }
            var p = f.joints[v.jointName];
            A !== null && (p.matrix.fromArray(A.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.jointRadius = A.radius), p.visible = A !== null;
          }
          var y = f.joints["index-finger-tip"], m = f.joints["thumb-tip"], E = y.position.distanceTo(m.position), b = 0.02, T = 5e-3;
          f.inputState.pinching && E > b + T ? (f.inputState.pinching = false, this.dispatchEvent({
            type: "pinchend",
            handedness: t.handedness,
            target: this
          })) : !f.inputState.pinching && E <= b - T && (f.inputState.pinching = true, this.dispatchEvent({
            type: "pinchstart",
            handedness: t.handedness,
            target: this
          }));
        } else
          c !== null && t.gripSpace && (s = e.getPose(t.gripSpace, r), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), s.linearVelocity ? (c.hasLinearVelocity = true, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = false, s.angularVelocity ? (c.hasAngularVelocity = true, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = false));
      return l !== null && (l.visible = o !== null), c !== null && (c.visible = s !== null), f !== null && (f.visible = u !== null), this;
    }, n45;
  }()
);
var framebufferScaleFactor = 1;
var XRManager = (
  /** @class */
  function() {
    function n45(t, e, r) {
      var o, s, u, l, c;
      this.isPanorama = (o = r == null ? void 0 : r.isPanorama) !== null && o !== void 0 ? o : true;
      var f = navigator.userAgent.toLowerCase(), d;
      f.includes("pico") ? d = "Pico" : f.includes("oculus") ? d = "Oculus" : d = "VP", this.machineType = (s = r == null ? void 0 : r.machineType) !== null && s !== void 0 ? s : d, this.renderer = t, this.gl = e, this.enabled = false, this.session = null, this.referenceSpaceType = (u = r == null ? void 0 : r.referenceSpaceType) !== null && u !== void 0 ? u : "local-floor", this.referenceSpace = null, this.onSessionStartCallback = (l = r == null ? void 0 : r.onSessionStart) !== null && l !== void 0 ? l : noop$1, this.onSessionEndCallback = (c = r == null ? void 0 : r.onSessionEnd) !== null && c !== void 0 ? c : noop$1, this.controllers = [new XRController(), new XRController()], this.inputSourcesMap = /* @__PURE__ */ new Map(), this.cameraVR = new ArrayCamera(), this.cameraL = new PerspectiveCamera(), this.cameraR = new PerspectiveCamera(), this.cameraL.viewport = new Vector4(), this.cameraR.viewport = new Vector4(), this.cameraL.layers.enable(1), this.cameraR.layers.enable(2), this.cameraVR.layers.enable(1), this.cameraVR.layers.enable(2), this.isPresenting = false, this.currentDepthNear = null, this.currentDepthFar = null, this.cameraLPos = new Vector3(), this.cameraRPos = new Vector3();
    }
    return n45.prototype.getController = function(t) {
      var e = this.controllers[t];
      return e || console.warn("no controller find"), e.getTargetRaySpace();
    }, n45.prototype.getRightController = function() {
      if (!this.session)
        return null;
      var t = this.session.inputSources[0].handedness === "right" ? 0 : 1, e = this.controllers[t];
      return e || console.warn("no controller find"), e.getTargetRaySpace();
    }, n45.prototype.getLeftController = function() {
      if (!this.session)
        return null;
      var t = this.session.inputSources[0].handedness === "left" ? 0 : 1, e = this.controllers[t];
      return e || console.warn("no controller find"), e.getTargetRaySpace();
    }, n45.prototype.getControllerGrip = function(t) {
      var e = this.controllers[t];
      return e || console.warn("no controller find"), e.getGripSpace();
    }, n45.prototype.getCameras = function() {
      return {
        cameraL: this.cameraL,
        cameraR: this.cameraR,
        cameraVR: this.cameraVR
      };
    }, n45.prototype.updateCamera = function(t, e) {
      e === null ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld);
    }, n45.prototype.setProjectionFromUnion = function(t, e, r) {
      this.cameraLPos.setFromMatrixPosition(e.matrixWorld), this.cameraRPos.setFromMatrixPosition(r.matrixWorld);
      var o = this.cameraLPos.distanceTo(this.cameraRPos), s = e.projectionMatrix.elements, u = r.projectionMatrix.elements, l = s[14] / (s[10] - 1), c = s[14] / (s[10] + 1), f = (s[9] + 1) / s[5], d = (s[9] - 1) / s[5], h = (s[8] - 1) / s[0], v = (u[8] + 1) / u[0], A = l * h, g = l * v, p = o / (-h + v), y = p * -h;
      e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(y), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
      var m = l + p, E = c + p, b = A - y, T = g + (o - y), R = f * c / E * m, S = d * c / E * m;
      t.projectionMatrix.makePerspective(b, T, R, S, m, E);
    }, n45.prototype.getCamera = function(t) {
      this.cameraVR.near = this.cameraR.near = this.cameraL.near = t.near, this.cameraVR.far = this.cameraR.far = this.cameraL.far = t.far, this.session && (this.currentDepthNear !== this.cameraVR.near || this.currentDepthFar !== this.cameraVR.far) && (this.session.updateRenderState({
        depthNear: this.cameraVR.near,
        depthFar: this.cameraVR.far
      }), this.currentDepthNear = this.cameraVR.near, this.currentDepthFar = this.cameraVR.far);
      var e = t.parent, r = this.cameraVR.cameras;
      this.updateCamera(this.cameraVR, e);
      for (var o = 0; o < r.length; o++)
        this.updateCamera(r[o], e);
      t.matrixWorld.copy(this.cameraVR.matrixWorld);
      for (var s = t.children, o = 0, u = s.length; o < u; o++)
        s[o].updateMatrixWorld(true);
      return r.length === 2 ? this.setProjectionFromUnion(this.cameraVR, this.cameraL, this.cameraR) : this.cameraVR.projectionMatrix.copy(this.cameraL.projectionMatrix), this.cameraVR;
    }, n45.prototype.updateInputSources = function(t) {
      if (!this.session) {
        console.warn("session is lose!");
        return;
      }
      for (var e = this.session.inputSources, r = 0; r < this.controllers.length; r++)
        this.inputSourcesMap.set(e[r], this.controllers[r]);
      for (var r = 0; r < t.removed.length; r++) {
        var o = t.removed[r], s = this.inputSourcesMap.get(o);
        s && (s.dispatchEvent({ type: "disconnected", data: o }), this.inputSourcesMap.delete(o));
      }
      for (var r = 0; r < t.added.length; r++) {
        var o = t.added[r], s = this.inputSourcesMap.get(o);
        s && s.dispatchEvent({ type: "connected", data: o });
      }
    }, n45.prototype.onSessionEvent = function(t) {
      var e = this.inputSourcesMap.get(t.inputSource);
      e && e.dispatchEvent({ type: t.type });
    }, n45.prototype.onSessionEnd = function() {
      this.inputSourcesMap.forEach(function(t, e) {
        t.disconnect(e);
      }), this.inputSourcesMap.clear(), this.renderer.setFramebuffer(null), this.renderer.setRenderTarget(this.renderer.getRenderTarget()), this.isPresenting = false, this.session = null, AnimationFrameLoop.shared.setContext(null), this.onSessionEndCallback();
    }, n45.prototype.onRequestReferenceSpace = function(t) {
      this.referenceSpace = t, this.isPresenting = true, this.session && this.onSessionStartCallback(this.session);
    }, n45.prototype.setSession = function(t) {
      var e = this;
      if (this.session = t, this.session) {
        this.session.addEventListener("select", function(o) {
          e.onSessionEvent(o);
        }), this.session.addEventListener("selectstart", function(o) {
          e.onSessionEvent(o);
        }), this.session.addEventListener("selectend", function(o) {
          e.onSessionEvent(o);
        }), this.session.addEventListener("squeeze", function(o) {
          e.onSessionEvent(o);
        }), this.session.addEventListener("squeezestart", function(o) {
          e.onSessionEvent(o);
        }), this.session.addEventListener("squeezeend", function(o) {
          e.onSessionEvent(o);
        }), this.session.addEventListener("end", function(o) {
          e.onSessionEnd();
        });
        var r = this.gl.getContextAttributes();
        this.gl.makeXRCompatible().then(function() {
          var o = {
            antialias: r == null ? void 0 : r.antialias,
            alpha: r == null ? void 0 : r.alpha,
            depth: r == null ? void 0 : r.depth,
            stencil: r == null ? void 0 : r.stencil,
            framebufferScaleFactor
          };
          if (!e.session) {
            console.error("session is lose while set session!");
            return;
          }
          switch (e.machineType) {
            case "Pico":
            case "VP":
              e.session.updateRenderState({ baseLayer: new XRWebGLLayer(e.session, e.gl, o) });
              break;
            case "Oculus":
              e.session.updateRenderState({ baseLayer: new XRWebGLLayer(e.session, e.gl, o) });
              break;
            default:
              e.machineType;
              break;
          }
          e.session.requestReferenceSpace(e.referenceSpaceType).then(function(s) {
            e.onRequestReferenceSpace(s);
          }), e.session.addEventListener("inputsourceschange", function(s) {
            e.updateInputSources(s);
          });
        });
      }
    }, n45;
  }()
);
var LineSegmentsGeometry = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      e.type = "LineSegmentsGeometry";
      var r = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], o = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], s = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
      return e.setIndex(s), e.setAttribute("position", new Float32BufferAttribute(r, 3)), e.setAttribute("uv", new Float32BufferAttribute(o, 2)), e;
    }
    return t.prototype.applyMatrix4 = function(e) {
      var r = this.attributes.instanceStart, o = this.attributes.instanceEnd;
      return r !== void 0 && (r.applyMatrix4(e), o.applyMatrix4(e), r.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }, t.prototype.setPositions = function(e) {
      var r;
      e instanceof Float32Array ? r = e : Array.isArray(e) ? r = new Float32Array(e) : r = new Float32Array();
      var o = new InstancedInterleavedBuffer(r, 6, 1);
      return this.setAttribute("instanceStart", new InterleavedBufferAttribute(o, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(o, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
    }, t.prototype.setColors = function(e) {
      var r;
      e instanceof Float32Array ? r = e : Array.isArray(e) ? r = new Float32Array(e) : r = new Float32Array();
      var o = new InstancedInterleavedBuffer(r, 6, 1);
      return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(o, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(o, 3, 3)), this;
    }, t.prototype.fromWireframeGeometry = function(e) {
      return this.setPositions(e.attributes.position.array), this;
    }, t.prototype.fromEdgesGeometry = function(e) {
      return this.setPositions(e.attributes.position.array), this;
    }, t.prototype.fromMesh = function(e) {
      return this.fromWireframeGeometry(new WireframeGeometry(e.geometry)), this;
    }, t.prototype.fromLineSegments = function(e) {
      var r = e.geometry;
      if (r instanceof Geometry) {
        var o = new BufferGeometry().fromGeometry(r);
        this.setPositions(o.attributes.position.array);
      } else r instanceof BufferGeometry && this.setPositions(r.attributes.position.array);
      return this;
    }, t.prototype.computeBoundingBox = function() {
      this.boundingBox === null && (this.boundingBox = new Box3());
      var e = this.attributes.instanceStart, r = this.attributes.instanceEnd;
      if (e !== void 0 && r !== void 0) {
        var o = new Box3();
        this.boundingBox.setFromBufferAttribute(e), o.setFromBufferAttribute(r), this.boundingBox.union(o);
      }
    }, t.prototype.computeBoundingSphere = function() {
      this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingBox === null && this.computeBoundingBox();
      var e = this.attributes.instanceStart, r = this.attributes.instanceEnd;
      if (e !== void 0 && r !== void 0) {
        var o = this.boundingSphere.center;
        this.boundingBox.getCenter(o);
        for (var s = 0, u = new Vector3(), l = 0, c = e.count; l < c; l++)
          u.fromBufferAttribute(e, l), s = Math.max(s, o.distanceToSquared(u)), u.fromBufferAttribute(r, l), s = Math.max(s, o.distanceToSquared(u));
        this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }, t.prototype.toJSON = function() {
    }, t;
  }(InstancedBufferGeometry)
);
Object.assign(LineSegmentsGeometry.prototype, { isLineSegmentsGeometry: true });
var lineShader = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    {
      linewidth: { value: 1 },
      resolution: { value: new Vector2(1, 1) },
      dashScale: { value: 1 },
      dashSize: { value: 1 },
      gapSize: { value: 1 },
      // todo FIX - maybe change to totalSize
      opacity: { value: 1 }
    }
  ]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
var LineMaterial = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, {
        uniforms: UniformsUtils.clone(lineShader.uniforms),
        vertexShader: lineShader.vertexShader,
        fragmentShader: lineShader.fragmentShader,
        clipping: true
        // required for clipping support
      }) || this;
      return r.type = "LineMaterial", r.dashed = false, Object.defineProperties(r, {
        color: {
          enumerable: true,
          get: function() {
            return this.uniforms.diffuse.value;
          },
          set: function(o) {
            this.uniforms.diffuse.value = o;
          }
        },
        linewidth: {
          enumerable: true,
          get: function() {
            return this.uniforms.linewidth.value;
          },
          set: function(o) {
            this.uniforms.linewidth.value = o;
          }
        },
        dashScale: {
          enumerable: true,
          get: function() {
            return this.uniforms.dashScale.value;
          },
          set: function(o) {
            this.uniforms.dashScale.value = o;
          }
        },
        dashSize: {
          enumerable: true,
          get: function() {
            return this.uniforms.dashSize.value;
          },
          set: function(o) {
            this.uniforms.dashSize.value = o;
          }
        },
        gapSize: {
          enumerable: true,
          get: function() {
            return this.uniforms.gapSize.value;
          },
          set: function(o) {
            this.uniforms.gapSize.value = o;
          }
        },
        opacity: {
          enumerable: true,
          get: function() {
            return this.uniforms.opacity.value;
          },
          set: function(o) {
            this.uniforms.opacity.value = o;
          }
        },
        resolution: {
          enumerable: true,
          get: function() {
            return this.uniforms.resolution.value;
          },
          set: function(o) {
            this.uniforms.resolution.value.copy(o);
          }
        }
      }), r.setValues(e), r;
    }
    return t;
  }(ShaderMaterial)
);
Object.assign(LineMaterial.prototype, { isLineMaterial: true });
var LineSegments2 = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      var o = n45.call(this) || this;
      return o.type = "LineSegments2", o.geometry = e !== void 0 ? e : new LineSegmentsGeometry(), o.material = r !== void 0 ? r : new LineMaterial({ color: Math.random() * 16777215 }), o;
    }
    return t.prototype.computeLineDistances = function() {
      for (var e = this.geometry, r = e.attributes.instanceStart, o = e.attributes.instanceEnd, s = new Float32Array(2 * r.count), u = new Vector3(), l = new Vector3(), c = 0, f = 0, d = r.count; c < d; c++, f += 2)
        u.fromBufferAttribute(r, c), l.fromBufferAttribute(o, c), s[f] = f === 0 ? 0 : s[f - 1], s[f + 1] = s[f] + u.distanceTo(l);
      var h = new InstancedInterleavedBuffer(s, 2, 1);
      return e.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(h, 1, 0)), e.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(h, 1, 1)), this;
    }, t.prototype.raycast = function(e, r) {
      e.camera === null && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
      var o = e.ray, s = e.camera, u = s.projectionMatrix, l = this.geometry, c = this.material, f = c.resolution, d = c.linewidth, h = l.attributes.instanceStart, v = l.attributes.instanceEnd, A = new Vector4(), g = new Vector4(), p = new Vector4(), y = new Vector3(), m = new Matrix4(), E = new Line3(), b = new Vector3();
      o.at(1, p), p.w = 1, p.applyMatrix4(s.matrixWorldInverse), p.applyMatrix4(u), p.multiplyScalar(1 / p.w), p.x *= f.x / 2, p.y *= f.y / 2, p.z = 0, y.copy(p);
      var T = this.matrixWorld;
      m.multiplyMatrices(s.matrixWorldInverse, T);
      for (var R = 0, S = h.count; R < S; R++) {
        A.fromBufferAttribute(h, R), g.fromBufferAttribute(v, R), A.w = 1, g.w = 1, A.applyMatrix4(m), g.applyMatrix4(m), A.applyMatrix4(u), g.applyMatrix4(u), A.multiplyScalar(1 / A.w), g.multiplyScalar(1 / g.w);
        var M = A.z < -1 && g.z < -1, w = A.z > 1 && g.z > 1;
        if (!(M || w)) {
          A.x *= f.x / 2, A.y *= f.y / 2, g.x *= f.x / 2, g.y *= f.y / 2, E.start.copy(A), E.start.z = 0, E.end.copy(g), E.end.z = 0;
          var H = E.closestPointToPointParameter(y, true);
          E.at(H, b);
          var L = MathUtils.lerp(A.z, g.z, H), C = L >= -1 && L <= 1, I = y.distanceTo(b) < d * 0.5;
          if (C && I) {
            E.start.fromBufferAttribute(h, R), E.end.fromBufferAttribute(v, R), E.start.applyMatrix4(T), E.end.applyMatrix4(T);
            var _ = new Vector3(), O = new Vector3();
            o.distanceSqToSegment(E.start, E.end, O, _), r.push({
              point: O,
              pointOnLine: _,
              distance: o.origin.distanceTo(O),
              object: this,
              faceIndex: R
            });
          }
        }
      }
    }, t;
  }(Mesh)
);
Object.assign(LineSegments2.prototype, { isLineSegments2: true });
var Line2 = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      var o = n45.call(this, e, r) || this;
      return o.type = "Line2", o;
    }
    return t;
  }(LineSegments2)
);
Object.assign(Line2.prototype, { isLine2: true });
var LineGeometry = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      return e.type = "LineGeometry", e;
    }
    return t.prototype.setPositions = function(e) {
      for (var r = e.length - 3, o = new Float32Array(2 * r), s = 0; s < r; s += 3)
        o[2 * s] = e[s], o[2 * s + 1] = e[s + 1], o[2 * s + 2] = e[s + 2], o[2 * s + 3] = e[s + 3], o[2 * s + 4] = e[s + 4], o[2 * s + 5] = e[s + 5];
      return n45.prototype.setPositions.call(this, o), this;
    }, t.prototype.setColors = function(e) {
      for (var r = e.length - 3, o = new Float32Array(2 * r), s = 0; s < r; s += 3)
        o[2 * s] = e[s], o[2 * s + 1] = e[s + 1], o[2 * s + 2] = e[s + 2], o[2 * s + 3] = e[s + 3], o[2 * s + 4] = e[s + 4], o[2 * s + 5] = e[s + 5];
      return n45.prototype.setColors.call(this, o), this;
    }, t.prototype.fromLine = function(e) {
      var r = e.geometry;
      if (r instanceof Geometry) {
        var o = new BufferGeometry().fromGeometry(r);
        this.setPositions(o.attributes.position.array);
      } else r instanceof BufferGeometry && this.setPositions(r.attributes.position.array);
      return this;
    }, t.prototype.copy = function() {
      return this;
    }, t;
  }(LineSegmentsGeometry)
);
Object.assign(LineGeometry.prototype, { isLineGeometry: true });
var circleImageURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sHDgwCEMBJZu0AAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAABM5JREFUWMO1V0tPG2cUPZ4Hxh6DazIOrjFNqJs0FIMqWFgWQkatsmvVbtggKlSVRVf5AWz4AWz4AUSKEChll19QJYSXkECuhFxsHjEhxCYm+DWGMZ5HF72DJq4bAzFXurI0M/I5997v3u9cC65vTJVn2lX/xHINQOYSBLTLEuIuCWw4Z3IGAEvf6ASmVHjNzHCXBG4A0AjACsAOwEbO0nsFQBnAGYASAIl+ZRMR7SolMEdsByD09fV5R0ZGgg8ePPjW5/N1iqLYpuu6RZblciKR2I9Go69evnwZnZ+fjwI4IS8AKBIRzeQfJWCANwKwh0KhtrGxsYehUOin1tbW+zzP23ietzY2NnIAoGmaLsuyUiqVyvl8XtrY2NiamZn589mzZxsAUgCOAeQAnFI2tI+VxIjaAeDzoaGh7xYWFuZOTk6OZVk+12uYqqq6JEnn0Wg0OT4+/geAXwGEAdwDIFJQXC1wO4DWR48e/RCPxxclSSroVzRFUbSDg4P848ePFwH8DuAhkWih83TRQWxFOXgAwvDwcOfo6OhvXV1d39tsNtuVBwTDWBwOh1UUxVsMw1hXVlbSdCgNV43uYSvrHg6H24aHh38eHBz85TrgF9FYLHA4HLzH43FvbW2d7u/vG+dANp8FpqIlbd3d3V8Fg8EfBUFw4BONZVmL3+9vHhkZCQL4AoAHgJPK8G+yzC0XDofdoVAo5PP5vkadTBAEtr+/39ff3x8gAp/RPOEqx2qjx+NpvXv3bk9DQ0NDvQgwDIOWlhZrMBj8kgi0UJdxRgYMArzL5XJ7vd57qLPZ7Xamp6fnNgBXtQxcjFuHw+Hyer3t9SYgCAITCAScAJoBNNEY/08GOFVVrfVMv7kMNDntFD1vjIAPrlRN0xjckOm6biFQ3jwNPwDMZrOnqVTqfb3Bi8Wivru7W/VCYkwPlKOjo0IikXh7EwQikYgE4Nw0CfXKDCipVCoTj8df3QABbW1tLUc6oUgkFPMkVACUNjc337148eKvw8PDbJ2jP1taWkoCyNDVXDSECmNSK4qiKNLq6urW8+fPI/UicHx8rD59+jSVy+WOAKSJhKENwFItLtoxk8mwsixzHR0dHe3t7c5PAU+n09rs7OzJkydPYqVSaQfANoDXALIk31S2smU1TWMPDg7K5XKZ7+3t9TudTut1U7+wsFCcmJiIpdPpbQBxADsAknQWymYCOukBHYCuKApisdhpMpnURFEU79y503TVyKenpzOTk5M7e3t7MQKPV0Zv1gNm+awB0MvlshqLxfLb29uyJElWURSbXC4XXyvqxcXFs6mpqeTc3Nzu3t7e3wQcA7BPZ8Cov1pNlJplmQtAG8MwHV6v95tAINA5MDBwPxAIuLu6upr8fr/VAN3c3JQjkcjZ+vp6fnl5+d2bN29SuVzuNYAEpf01CdRChUL+X1VskHACuA3Ay3Fcu9vt7nA6nZ7m5uYWQRCaNE3jVVW15PP580KhIGUymWw2m00DOAJwSP4WwPtq4LX2Ao6USxNlQyS/RcQcdLGwlNIz6vEMAaZpNzCk2Pll94LK/cDYimxERiBwG10sxjgvEZBE0UpE6vxj+0Ct5bTaXthgEhRmja8QWNkkPGsuIpfdjpkK+cZUWTC0KredVmtD/gdlSl6EG4AMvQAAAABJRU5ErkJggg==";
var DEFAULT_COLOR = 14467195;
var POINT_SIZE = 8;
var DEFAULT_LINEWIDTH = 2;
var DEFAULT_DASHSCALE = 20;
var sharedCircleTexture = null;
var FiveLine = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e, r) {
      e === void 0 && (e = new Vector3()), r === void 0 && (r = new Vector3());
      var o = n45.call(this) || this;
      o.type = "FiveLine", o.needsRender = true;
      var s = new LineGeometry(), u = new LineMaterial({
        color: DEFAULT_COLOR,
        linewidth: DEFAULT_LINEWIDTH,
        dashScale: DEFAULT_DASHSCALE,
        dashed: false
      });
      o.line = new Line2(s, u);
      var l = new BufferGeometry(), c = new PointsMaterial({
        color: DEFAULT_COLOR,
        size: POINT_SIZE,
        map: sharedCircleTexture || (sharedCircleTexture = new TextureLoader().load(circleImageURL)),
        sizeAttenuation: false,
        transparent: true
      });
      return o.points = new Points(l, c), o.points.renderOrder = 11, o.points.frustumCulled = false, o.setPoints(e, r), o.add(o.line, o.points), o;
    }
    return Object.defineProperty(t, "version", {
      get: function() {
        return "6.4.0-alpha.40";
      },
      enumerable: false,
      configurable: true
    }), t.prototype.setPoints = function(e, r) {
      var o = [].concat(e.toArray(), r.toArray());
      this.points.geometry.setAttribute("position", new BufferAttribute(new Float32Array(o), 3)), this.line.geometry.setPositions(o), this.line.computeLineDistances(), this.needsRender = true;
    }, t.prototype.getPoints = function() {
      var e = this.points.geometry.attributes.position.array;
      return [
        new Vector3(e[0], e[1], e[2]),
        new Vector3(e[3], e[4], e[5])
      ];
    }, t.prototype.setMaterial = function(e) {
      var r = this.line.material;
      for (var o in e)
        if (e.hasOwnProperty(o)) {
          var s = e[o];
          o === "dashed" ? (r.dashed = s, s ? r.defines.USE_DASH = "" : delete r.defines.USE_DASH, r.needsUpdate = true) : r[o] = e[o];
        }
      this.needsRender = true;
    }, t.prototype.setResolution = function(e, r) {
      var o = this.line.material.resolution;
      (o.x !== e || o.y !== r) && (o.set(e, r), this.needsRender = true);
    }, t;
  }(Object3D)
);
Object.assign(FiveLine.prototype, { isFiveLine: true });
var Constants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
function fetchJsonFile(n45) {
  return __awaiter(this, void 0, void 0, function() {
    var t;
    return __generator(this, function(e) {
      switch (e.label) {
        case 0:
          return [4, fetch(n45)];
        case 1:
          if (t = e.sent(), t.ok)
            return [2, t.json()];
          throw new Error(t.statusText);
      }
    });
  });
}
function fetchProfilesList(n45) {
  return __awaiter(this, void 0, void 0, function() {
    var t, e;
    return __generator(this, function(r) {
      switch (r.label) {
        case 0:
          if (!n45)
            throw new Error("No basePath supplied");
          return t = "profilesList.json", [4, fetchJsonFile("".concat(n45, "/").concat(t))];
        case 1:
          return e = r.sent(), [2, e];
      }
    });
  });
}
function fetchProfile(n45, t) {
  return __awaiter(this, arguments, void 0, function(e, r, o, s) {
    var u, l, c, f, d, h;
    return o === void 0 && (o = null), s === void 0 && (s = true), __generator(this, function(v) {
      switch (v.label) {
        case 0:
          if (!e)
            throw new Error("No xrInputSource supplied");
          if (!r)
            throw new Error("No basePath supplied");
          return [4, fetchProfilesList(r)];
        case 1:
          if (u = v.sent(), e.profiles.some(function(A) {
            var g = u[A];
            return g && (l = {
              profileId: A,
              profilePath: "".concat(r, "/").concat(g.path),
              deprecated: !!g.deprecated
            }), !!l;
          }), !l) {
            if (!o)
              throw new Error("No matching profile name found");
            if (c = u[o], !c)
              throw new Error('No matching profile name found and default profile "'.concat(o, '" missing.'));
            l = {
              profileId: o,
              profilePath: "".concat(r, "/").concat(c.path),
              deprecated: !!c.deprecated
            };
          }
          return [4, fetchJsonFile(l.profilePath)];
        case 2:
          if (f = v.sent(), s) {
            if (h = void 0, h = f.layouts[e.handedness], !h)
              throw new Error("No matching handedness, ".concat(e.handedness, ", in profile ").concat(l.profileId));
            h.assetPath && (d = l.profilePath.replace("profile.json", h.assetPath));
          }
          return [2, { profile: f, assetPath: d }];
      }
    });
  });
}
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
function normalizeAxes(n45, t) {
  n45 === void 0 && (n45 = 0), t === void 0 && (t = 0);
  var e = n45, r = t, o = Math.sqrt(n45 * n45 + t * t);
  if (o > 1) {
    var s = Math.atan2(t, n45);
    e = Math.cos(s), r = Math.sin(s);
  }
  var u = {
    normalizedXAxis: e * 0.5 + 0.5,
    normalizedYAxis: r * 0.5 + 0.5
  };
  return u;
}
var VisualResponse = (
  /** @class */
  function() {
    function n45(t) {
      this.componentProperty = t.componentProperty, this.states = t.states, this.valueNodeName = t.valueNodeName, this.valueNodeProperty = t.valueNodeProperty, this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM && (this.minNodeName = t.minNodeName, this.maxNodeName = t.maxNodeName), this.value = 0, this.updateFromComponent(defaultComponentValues);
    }
    return n45.prototype.updateFromComponent = function(t) {
      var e = t.xAxis, r = t.yAxis, o = t.button, s = t.state, u = normalizeAxes(e, r), l = u.normalizedXAxis, c = u.normalizedYAxis;
      switch (this.componentProperty) {
        case Constants.ComponentProperty.X_AXIS:
          this.value = this.states.includes(s) ? l : 0.5;
          break;
        case Constants.ComponentProperty.Y_AXIS:
          this.value = this.states.includes(s) ? c : 0.5;
          break;
        case Constants.ComponentProperty.BUTTON:
          this.value = this.states.includes(s) ? o : 0;
          break;
        case Constants.ComponentProperty.STATE:
          this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(s) : this.value = this.states.includes(s) ? 1 : 0;
          break;
        default:
          throw new Error("Unexpected visualResponse componentProperty ".concat(this.componentProperty));
      }
    }, n45;
  }()
);
var Component = (
  /** @class */
  function() {
    function n45(t, e) {
      var r = this;
      if (!t || !e || !e.visualResponses || !e.gamepadIndices || Object.keys(e.gamepadIndices).length === 0)
        throw new Error("Invalid arguments supplied");
      this.id = t, this.type = e.type, this.rootNodeName = e.rootNodeName, this.touchPointNodeName = e.touchPointNodeName, this.visualResponses = {}, Object.keys(e.visualResponses).forEach(function(o) {
        var s = new VisualResponse(e.visualResponses[o]);
        r.visualResponses[o] = s;
      }), this.gamepadIndices = Object.assign({}, e.gamepadIndices), this.values = {
        state: Constants.ComponentState.DEFAULT,
        button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
        xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
        yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
      };
    }
    return Object.defineProperty(n45.prototype, "data", {
      get: function() {
        var t = __assign({ id: this.id }, this.values);
        return t;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.updateFromGamepad = function(t) {
      var e = this;
      if (this.values.state = Constants.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && t.buttons.length > this.gamepadIndices.button) {
        var r = t.buttons[this.gamepadIndices.button];
        this.values.button = r.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, r.pressed || this.values.button === 1 ? this.values.state = Constants.ComponentState.PRESSED : (r.touched || this.values.button > Constants.ButtonTouchThreshold) && (this.values.state = Constants.ComponentState.TOUCHED);
      }
      this.gamepadIndices.xAxis !== void 0 && t.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = t.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && t.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = t.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach(function(o) {
        o.updateFromComponent(e.values);
      });
    }, n45;
  }()
);
var MotionController = (
  /** @class */
  function() {
    function n45(t, e, r) {
      var o = this;
      if (!t)
        throw new Error("No xrInputSource supplied");
      if (!e)
        throw new Error("No profile supplied");
      this.xrInputSource = t, this.assetUrl = r, this.id = e.profileId, this.layoutDescription = e.layouts[t.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach(function(s) {
        var u = o.layoutDescription.components[s];
        o.components[s] = new Component(s, u);
      }), this.updateFromGamepad();
    }
    return Object.defineProperty(n45.prototype, "gripSpace", {
      get: function() {
        return this.xrInputSource.gripSpace;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "targetRaySpace", {
      get: function() {
        return this.xrInputSource.targetRaySpace;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(n45.prototype, "data", {
      /**
       * @description Returns a subset of component data for simplified debugging
       */
      get: function() {
        var t = [];
        return Object.values(this.components).forEach(function(e) {
          t.push(e.data);
        }), t;
      },
      enumerable: false,
      configurable: true
    }), n45.prototype.updateFromGamepad = function() {
      var t = this;
      Object.values(this.components).forEach(function(e) {
        e.updateFromGamepad(t.xrInputSource.gamepad);
      });
    }, n45;
  }()
);
var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE = "generic-trigger";
var XRControllerModel = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t() {
      var e = n45.call(this) || this;
      return e.motionController = null, e.envMap = null, e;
    }
    return t.prototype.setEnvironmentMap = function(e) {
      var r = this;
      return this.envMap == e ? this : (this.envMap = e, this.traverse(function(o) {
        o instanceof Mesh && o.isMesh && (o.material.envMap = r.envMap, o.material.needsUpdate = true);
      }), this);
    }, t.prototype.updateMatrixWorld = function(e) {
      n45.prototype.updateMatrixWorld.call(this, e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach(function(r) {
        Object.values(r.visualResponses).forEach(function(o) {
          var s = o.valueNode, u = o.minNode, l = o.maxNode, c = o.value, f = o.valueNodeProperty;
          s && (f === Constants.VisualResponseProperty.VISIBILITY ? s.visible = c : f === Constants.VisualResponseProperty.TRANSFORM && (s.quaternion.copy(u.quaternion).slerp(l.quaternion, c), s.position.lerpVectors(u.position, l.position, c)));
        });
      }));
    }, t;
  }(Object3D)
);
function findNodes(n45, t) {
  Object.values(n45.components).forEach(function(e) {
    var r = e.type, o = e.touchPointNodeName, s = e.visualResponses;
    if (r === Constants.ComponentType.TOUCHPAD)
      if (e.touchPointNode = t.getObjectByName(o), e.touchPointNode) {
        var u = new SphereGeometry(1e-3), l = new MeshBasicMaterial({ color: 255 }), c = new Mesh(u, l);
        e.touchPointNode.add(c);
      } else
        console.warn("Could not find touch dot, ".concat(e.touchPointNodeName, ", in touchpad component ").concat(e.id));
    Object.values(s).forEach(function(f) {
      var d = f.valueNodeName, h = f.minNodeName, v = f.maxNodeName, A = f.valueNodeProperty;
      if (A === Constants.VisualResponseProperty.TRANSFORM) {
        if (f.minNode = t.getObjectByName(h), f.maxNode = t.getObjectByName(v), !f.minNode) {
          console.warn("Could not find ".concat(h, " in the model"));
          return;
        }
        if (!f.maxNode) {
          console.warn("Could not find ".concat(v, " in the model"));
          return;
        }
      }
      f.valueNode = t.getObjectByName(d), f.valueNode || console.warn("Could not find ".concat(d, " in the model"));
    });
  });
}
function addAssetSceneToControllerModel(n45, t) {
  findNodes(n45.motionController, t), n45.envMap && t.traverse(function(e) {
    e instanceof Mesh && e.isMesh && (e.material.envMap = n45.envMap, e.material.needsUpdate = true);
  }), n45.add(t);
}
var XRControllerModelFactory = (
  /** @class */
  function() {
    function n45(t) {
      t === void 0 && (t = null), this.gltfLoader = t, this.path = DEFAULT_PROFILES_PATH, this._assetCache = {};
    }
    return n45.prototype.createControllerModel = function(t) {
      var e = this, r = new XRControllerModel(), o = null;
      return t.addEventListener("connected", function(s) {
        var u = s.data;
        u.targetRayMode !== "tracked-pointer" || !u.gamepad || fetchProfile(u, e.path, DEFAULT_PROFILE).then(function(l) {
          var c = l.profile, f = l.assetPath;
          r.motionController = new MotionController(u, c, f);
          var d = e._assetCache[r.motionController.assetUrl];
          if (d)
            o = d.scene.clone(), addAssetSceneToControllerModel(r, o);
          else {
            if (!e.gltfLoader)
              throw new Error("GLTFLoader not set.");
            e.gltfLoader.load(r.motionController.assetUrl, function(h) {
              e._assetCache[r.motionController.assetUrl] = h, o = h.scene.clone(), addAssetSceneToControllerModel(r, o);
            });
          }
        }).catch(function(l) {
          console.warn(l);
        });
      }), t.addEventListener("disconnected", function() {
        r.motionController = null, r.remove(o), o = null;
      }), r;
    }, n45;
  }()
);
var defaultXRPanoramaControllerInitArgs = __assign({}, omit(defaultPanoramaControllerCustomInitArgs, ["maxLatitude", "minLatitude"]));
function mapPanoResource(n45, t) {
  return n45;
}
var CONTROLLER_EVNET_DELTA_TIME = 300;
var ROTATE_Y_PI_MATRIX = new Matrix4().makeRotationAxis(new Vector3(0, 1, 0), Math.PI);
var PANO_TEXTURE_SCALE = new Vector3(-1, 1, 1);
var XRPanoramaController = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      var r = n45.call(this, e) || this;
      r.xrManager = new XRManager(r.renderer, r.renderer.getContext(), {
        onSessionStart: function(c) {
          r.emit("xr.session.start", createEvent("xr.session.start", {
            session: c,
            machineType: r.xrManager.machineType
          }));
        },
        onSessionEnd: function() {
          r.emit("xr.session.end", createEvent("xr.session.end", {
            session: null,
            machineType: r.xrManager.machineType
          }));
        }
      }), r.xrControllerRay = {
        left: new Raycaster(),
        right: new Raycaster()
      }, r.xrControllerRay.left.params.Points = { threshold: 0.1 }, r.xrControllerRay.right.params.Points = { threshold: 0.1 }, r.gazeRay = null, r.pointerLines = {
        left: new FiveLine(),
        right: new FiveLine()
      }, r.pointerLines.left.visible = false, r.pointerLines.right.visible = true, r.pointerLines.left.setMaterial({
        color: new Vector3(1, 1, 1)
      }), r.pointerLines.left.points.material.depthTest = false, r.pointerLines.right.setMaterial({
        color: new Vector3(1, 1, 1)
      }), r.pointerLines.right.points.material.depthTest = false, r.controllerWrappers = [new Group(), new Group()];
      var o = r.xrManager.getController(0);
      r.controllerWrappers[0].add(o);
      var s = r.xrManager.getController(1);
      r.controllerWrappers[1].add(s);
      var u = new XRControllerModelFactory();
      u.gltfLoader = {
        load: function(c, f) {
          internalFetcher.ajax(c, { responseType: "arraybuffer" }).then(function(d) {
            var h;
            return parseGltf(d.body, {
              resourcePath: c.slice(0, c.lastIndexOf("/") + 1),
              search: (h = c.split("?")[1]) !== null && h !== void 0 ? h : "",
              fetcher: internalFetcher
            });
          }).then(function(d) {
            return f(d);
          });
        }
      }, (r.xrManager.machineType === "Oculus" || r.xrManager.machineType === "Pico") && r.scene.add(r.pointerLines.left, r.pointerLines.right, r.controllerWrappers[0], r.controllerWrappers[1]), r.panoResources = {}, r.panoResources[r.locationMotion.keyframes[0].key = r.locationMotion.keyframes[1].key = createUuid()] = {
        panoId: panoStringify(r.currentPano),
        leftPanoPicture: null,
        position: r.camera.pose.offset.clone(),
        effect: "fade",
        fixCameraTransform: new Matrix4()
      }, r.parallaxCameraMatrixs = [];
      var l = AnimationFrameLoop.shared.getContext();
      return l ? (r.on("xr.session.end", function() {
        r.scene.remove(r.pointerLines.left, r.pointerLines.right);
      }), r.xrManager.setSession(l), r.on("xr.session.start", function() {
        var c = r.xrManager.getControllerGrip(0);
        c.add(u.createControllerModel(c)), r.controllerWrappers[0].add(c);
        var f = r.xrManager.getControllerGrip(1);
        f.add(u.createControllerModel(f)), r.controllerWrappers[1].add(f);
      }), r.xrHandleState = {
        LeftAxesUp: {
          touchStartTime: 0,
          touchStart: false
        },
        LeftAxesDown: {
          touchStartTime: 0,
          touchStart: false
        },
        LeftAxesLeft: {
          touchStartTime: 0,
          touchStart: false
        },
        LeftAxesRight: {
          touchStartTime: 0,
          touchStart: false
        },
        LeftTrigger: {
          touchStartTime: 0,
          touchStart: false
        },
        LeftPinch: {
          touchStartTime: 0,
          touchStart: false
        },
        RightAxesUp: {
          touchStartTime: 0,
          touchStart: false
        },
        RightAxesDown: {
          touchStartTime: 0,
          touchStart: false
        },
        RightAxesLeft: {
          touchStartTime: 0,
          touchStart: false
        },
        RightAxesRight: {
          touchStartTime: 0,
          touchStart: false
        },
        RightTrigger: {
          touchStartTime: 0,
          touchStart: false
        },
        RightPinch: {
          touchStartTime: 0,
          touchStart: false
        },
        Y: {
          touchStartTime: 0,
          touchStart: false
        },
        X: {
          touchStartTime: 0,
          touchStart: false
        },
        A: {
          touchStartTime: 0,
          touchStart: false
        },
        B: {
          touchStartTime: 0,
          touchStart: false
        }
      }, r.xrManager.machineType === "VP" && r.initHandEvent(), r) : (console.error("session"), r);
    }
    return t.parseArgs = function(e) {
      if (e instanceof t)
        return e;
      var r = __assign(__assign({}, e), { maxLatitude: Math.PI / 2, minLatitude: -Math.PI / 2 });
      return n45.parseArgs.call(this, r);
    }, t.initAnimationEndState = function(e) {
      var r = this.parseArgs(e), o = n45.initAnimationEndState.call(this, r);
      return __assign(__assign({}, o), { mode: "XRPanorama" });
    }, t.prototype.updateConfiguration = function(e) {
      return n45.prototype.updateConfiguration.call(this, __assign(__assign({}, e), { maxLatitude: Math.PI / 2, minLatitude: -Math.PI / 2 }));
    }, t.prototype.moveToPano = function(e, r, o) {
      var s = this, u, l, c, f, d = (u = r.effect) !== null && u !== void 0 ? u : "fade";
      this.userAction = o, this.stopMomentumMovement();
      var h = this.works.getResolvedObserver(e);
      if (!h)
        throw new Error("Invalid PanoIndex");
      var v = getImageSizeFromURL(h.images.up), A = this.imageOptions.size;
      typeof A == "undefined" && h && v && (A = Number(v)), typeof A == "undefined" && (A = 2048);
      var g = this.imageOptions.transform, p = function(C, I) {
        return mapPanoResource(applyImageURLOptions(C, g, I));
      }, y = __assign({ key: "pano.".concat(h.panoId) }, pick(this.imageOptions, ["format", "size", "quality"])), m = h.images, E = (c = (l = h.images.tiles) === null || l === void 0 ? void 0 : l.filter(function(C) {
        return C.size > A;
      })) !== null && c !== void 0 ? c : null, b = "pano:" + jsonHash([m, y, g]);
      if (this.pendingTextureTask) {
        if (this.pendingTextureTask.hash === b)
          return;
        var T = this.pendingTextureTask.panoId;
        (f = this.panoMeshes[T]) === null || f === void 0 || f.setProgress(0), this.emit("pano.texture.abort", createEvent("pano.texture.abort", {
          error: null,
          progress: 0,
          meta: null,
          pano: h.pano
        }));
      }
      var R = this.models.getMaterial() || {}, S = R.pano0, M = R.pano1, w;
      if ((S == null ? void 0 : S.map.name) === b ? w = S : (M == null ? void 0 : M.map.name) === b && (w = M), w) {
        var H = {
          panoId: h.panoId,
          effect: d,
          leftPanoPicture: {
            zoom: 1,
            map: w.map,
            luminanceMap: w.luminanceMap,
            matrix: new Matrix4().compose(h.position, h.quaternion, PANO_TEXTURE_SCALE)
          },
          position: h.position.clone(),
          fixCameraTransform: new Matrix4()
        };
        this.doMoveToPano(h.pano, H, r);
        return;
      }
      var L = "move-to-pano-" + h.panoId;
      this.pending.add(L), this.pendingTextureTask = {
        panoId: h.panoId,
        hash: b,
        onLoad: function(C) {
          if (s.pending.delete(L), s.destroyed)
            C.body.dispose();
          else {
            C.body.name = b;
            var I = {
              panoId: h.panoId,
              effect: d,
              leftPanoPicture: {
                zoom: 1,
                map: C.body,
                luminanceMap: null,
                matrix: new Matrix4().compose(h.position, h.quaternion, PANO_TEXTURE_SCALE)
              },
              position: h.position.clone(),
              fixCameraTransform: new Matrix4()
            };
            s.doMoveToPano(h.pano, I, r);
          }
        },
        onError: function(C) {
          s.pending.delete(L);
          var I = __assign(__assign(__assign({}, h.pano), { mode: s.mode }), clonePose(s.camera.pose));
          s.emit("pano.error", createEvent("pano.error", {
            error: C,
            userAction: s.userAction,
            options: r,
            prevPano: s.currentPano,
            progress: 0,
            state: I
          })), s.emit("pano.cancel", createEvent("pano.cancel", {
            error: null,
            userAction: s.userAction,
            options: r,
            prevPano: s.currentPano,
            progress: 0,
            state: I
          })), r.moveCancelCallback && r.moveCancelCallback();
        }
      }, Promise.all([
        this.tileLevelForFov && E && E.length ? this.textureLoader.loadTiledCubeTexture(m, E, {
          tileMaxLevel: this.tiledCubeTextureLevel,
          imageURL: {
            transform: p,
            options: y
          },
          format: RGBAFormat,
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          generateMipmaps: false,
          viaAjax: true,
          fetcher: getFetcher(h.work)
        }, void 0, void 0, function(C) {
          var I, _;
          s.emit("pano.texture.progress", createEvent("pano.texture.progress", {
            error: null,
            progress: C,
            meta: null,
            pano: h.pano
          })), ((I = s.pendingTextureTask) === null || I === void 0 ? void 0 : I.hash) === b && ((_ = s.panoMeshes[h.panoId]) === null || _ === void 0 || _.setProgress(C));
        }, this.renderer) : this.textureLoader.loadCubeTexture(m, {
          imageURL: {
            transform: p,
            options: y
          },
          format: RGBAFormat,
          fetcher: getFetcher(h.work)
        }, void 0, void 0, function(C) {
          var I, _;
          ((I = s.pendingTextureTask) === null || I === void 0 ? void 0 : I.hash) === b && ((_ = s.panoMeshes[h.panoId]) === null || _ === void 0 || _.setProgress(C)), s.emit("pano.texture.progress", createEvent("pano.texture.progress", {
            error: null,
            progress: C,
            meta: null,
            pano: h.pano
          }));
        }, this.renderer)
      ]).then(function(C) {
        var I, _, O = C[0];
        ((I = s.pendingTextureTask) === null || I === void 0 ? void 0 : I.hash) === b ? (s.pendingTextureTask.onLoad(O), (_ = s.panoMeshes[h.panoId]) === null || _ === void 0 || _.setProgress(0), delete s.pendingTextureTask, s.emit("pano.texture.success", createEvent("pano.texture.success", {
          error: null,
          progress: 1,
          meta: O.meta,
          pano: h.pano
        }))) : O.body.dispose();
      }).catch(function(C) {
        var I, _;
        ((I = s.pendingTextureTask) === null || I === void 0 ? void 0 : I.hash) === b && (s.pendingTextureTask.onError(C), (_ = s.panoMeshes[h.panoId]) === null || _ === void 0 || _.setProgress(0), delete s.pendingTextureTask, s.emit("pano.texture.error", createEvent("pano.texture.error", {
          error: C,
          progress: 0,
          meta: null,
          pano: h.pano
        })), s.emit("error", C));
      }), this.emit("pano.texture.load", createEvent("pano.texture.load", {
        error: null,
        progress: 0,
        meta: null,
        pano: h.pano
      }));
    }, t.prototype.doMoveToPano = function(e, r, o) {
      var s = this, u, l, c, f, d, h, v, A, g, p;
      o === void 0 && (o = {});
      var y = now(), m = createUuid();
      this.panoResources[m] = r;
      var E = 1, b, T, R;
      if (this.locationMotion.ended) {
        var S = this.locationMotion.getKeyFrameSegment(y);
        S[0];
        var M = S[1], w = this.locationMotion.value, H = this.panoResourceFromLocationMotionKeyframe(M).position, L = r.position;
        b = Math.max(H.distanceTo(L), E), T = [
          { key: M.key, progress: 0, value: __assign(__assign({}, w), { count: 0 }) },
          { key: m, progress: 1, value: { distance: 0, count: 1 } }
        ], R = 0;
      } else {
        var C = this.locationMotion.getKeyFrameSegment(y), I = C[0], M = C[1], w = this.locationMotion.value, _ = this.panoResourceFromLocationMotionKeyframe(I).position, H = this.panoResourceFromLocationMotionKeyframe(M).position, L = r.position, O = M.value.count - w.count, P = Math.max(_.distanceTo(H), E) * O, N = Math.max(H.distanceTo(L), E);
        b = P + N, T = [
          { key: I.key, progress: 0, value: __assign({}, w) },
          { key: M.key, progress: P / b, value: M.value },
          { key: m, progress: 1, value: { count: M.value.count + 1, distance: 0 } }
        ];
        var k = this.locationMotionKeyframesLength(this.locationMotion.keyframes), U = this.locationMotionKeyframesLength(T);
        R = this.locationMotion.getProgressVelocity(y) * k / U;
      }
      var D = r.effect === "instant" ? 0 : this.calculateMovingDuration(o.duration, r.effect === "fly" ? b : 0), q = {
        longitude: o.longitude,
        latitude: o.latitude,
        fov: o.fov
      }, z = __assign(__assign({}, e), { mode: this.mode, longitude: (u = q.longitude) !== null && u !== void 0 ? u : this.camera.pose.longitude, latitude: (l = q.latitude) !== null && l !== void 0 ? l : this.camera.pose.latitude, fov: (c = q.fov) !== null && c !== void 0 ? c : this.camera.pose.fov, offset: r.position.clone(), distance: 0 }), Q = this.currentPano;
      if (this.emit("pano.moveTo", createEvent("pano.moveTo", {
        options: o,
        prevPano: Q,
        progress: 0,
        state: z,
        userAction: this.userAction,
        error: null
      })), o.moveStartCallback && o.moveStartCallback(z), this.videoTexture && this.videoTexture.image instanceof HTMLVideoElement && this.videoTexture.image.getAttribute("src") && (this.videoTexture.image.pause(), this.videoTexture.image.removeAttribute("uuid"), this.videoTexture.image.removeAttribute("src"), this.videoTexture.image.oncanplay = noop$1, this.videoTexture.needsUpdate = true), this.panoVideo.setMaterial(null), r.effect === "fly")
        this.cameraMotion.set(q, D).catch(noop$1);
      else {
        var G = coordinatesToVector({
          longitude: this.cameraMotion.value.longitude,
          latitude: this.cameraMotion.value.latitude
        }), X = coordinatesToVector({
          longitude: (f = q.longitude) !== null && f !== void 0 ? f : this.cameraMotion.value.longitude,
          latitude: (d = q.latitude) !== null && d !== void 0 ? d : this.cameraMotion.value.latitude
        }), $ = new Object3D();
        $.lookAt(G);
        var W = new Matrix4().makeRotationFromQuaternion($.quaternion);
        $.lookAt(X);
        var oe = new Matrix4().makeRotationFromQuaternion($.quaternion), ie = new Matrix4().getInverse(W).premultiply(oe), re = this.cameraMotion.value.fov, j = (h = q.fov) !== null && h !== void 0 ? h : this.cameraMotion.value.fov, se = 1;
        r.effect === "zoomin" ? se = 1.5 : r.effect === "zoomout" && (se = 0.4);
        for (var ae = j * se, ue = 0; ue < T.length - 1; ue++) {
          var fe = T[ue].key;
          if (fe) {
            var ne = this.panoResources[fe];
            ne && (ne.fixCameraTransform.copy(ie), ne.leftPanoPicture && (ne.leftPanoPicture.zoom = Math.tan(re / 2 / 180 * Math.PI) / Math.tan(ae / 2 / 180 * Math.PI)));
          }
        }
        this.cameraMotion.setKeyframes([
          {
            progress: 0,
            value: {
              longitude: this.cameraMotion.value.longitude,
              latitude: this.cameraMotion.value.latitude,
              fov: this.cameraMotion.value.fov
            }
          },
          {
            progress: 0,
            value: {
              longitude: (v = q.longitude) !== null && v !== void 0 ? v : this.cameraMotion.value.longitude,
              latitude: (A = q.latitude) !== null && A !== void 0 ? A : this.cameraMotion.value.latitude,
              fov: ae
            }
          },
          {
            progress: 1,
            value: {
              longitude: (g = q.longitude) !== null && g !== void 0 ? g : this.cameraMotion.value.longitude,
              latitude: (p = q.latitude) !== null && p !== void 0 ? p : this.cameraMotion.value.latitude,
              fov: j
            }
          }
        ], D).catch(noop$1);
      }
      var Te = this.locationMotion.setKeyframes(T, D, R);
      Te.then(
        // resolve
        // 
        function() {
          for (var Re, ve, Ce, Z = 0, te = s.models; Z < te.length; Z++) {
            var K = te[Z];
            K.show();
          }
          var ye = __assign(__assign({}, e), { mode: s.mode, longitude: s.camera.pose.longitude, latitude: s.camera.pose.latitude, fov: s.camera.pose.fov, offset: s.camera.pose.offset.clone(), distance: 0 });
          s.emit("pano.arrived", createEvent("pano.arrived", {
            options: o,
            prevPano: Q,
            progress: 1,
            state: ye,
            userAction: s.userAction,
            error: null
          })), o.moveEndCallback && o.moveEndCallback(ye);
          var de = s.works.getResolvedObserver(s.currentPano);
          if (de && de.video && s.videoTexture && s.videoTexture.image instanceof HTMLVideoElement) {
            var xe = ROTATE_Y_PI_MATRIX.clone().multiply((Ce = (ve = (Re = s.models.getMaterial()) === null || Re === void 0 ? void 0 : Re.pano1) === null || ve === void 0 ? void 0 : ve.matrix) !== null && Ce !== void 0 ? Ce : new Matrix4()).multiply(de.video.matrix), Ae = {
              map: s.videoTexture,
              size: de.video.size,
              matrix: xe,
              alpha: 1
            }, me = createUuid(), ce = s.videoTexture.image;
            ce.setAttribute("uuid", me), canplayVideo().then(function(pe) {
              pe && de.video && ce.getAttribute("uuid") === me && (ce.oncanplay = function() {
                ce.oncanplay = noop$1, ce.play();
              }, ce.ontimeupdate = function() {
                ce.currentTime > 0.5 && (ce.ontimeupdate = noop$1, s.panoVideo.setMaterial(Ae));
              }, ce.src = de.video.source);
            }).catch(function() {
              ce.removeAttribute("uuid");
            });
          }
        },
        // reject
        // 
        function() {
          s.emit("pano.cancel", createEvent("pano.cancel", {
            options: o,
            prevPano: Q,
            progress: 0,
            state: z,
            userAction: s.userAction,
            error: null
          })), o.moveCancelCallback && o.moveCancelCallback();
        }
      );
    }, t.prototype.checkSelectedPano = function(e) {
      var r = this, o, s, u, l;
      this.stopMomentumMovement();
      var c = this.camera.getDirection(new Vector3()).setY(0), f = null, d = this.works.getResolvedObserver(this.currentPano);
      if (!d)
        return null;
      var h = d.accessibleIds.filter(function(X) {
        var $ = panoParse(X);
        if (panoEqual($, r.currentPano))
          return false;
        var W = r.works.getResolvedObserver($);
        return !W || W.position.distanceTo(r.camera.position) > r.maxAccessibleDistance ? false : W.loadable || W.active;
      }), v = this.models.intersectRaycaster(e)[0];
      if (v) {
        var A = arrayMin(h, function(X) {
          var $ = r.works.getResolvedObserver(X);
          if (!$)
            return 1 / 0;
          var W = $.standingPosition.clone();
          return W.distanceTo(v.point);
        }, true), g = A[0], p = A[1];
        g && p < this.panoTapTriggerRadius && (f = (o = this.works.getResolvedObserver(g)) !== null && o !== void 0 ? o : null);
      }
      if (isNil(f)) {
        var y = this.getForwardObserverOrNot(e);
        y && (f = y);
      }
      for (var m = 0, E = this.locationMotion.keyframes; m < E.length; m++) {
        var b = E[m], T = this.panoResourceFromLocationMotionKeyframe(b);
        if (!(b.progress < this.locationMotion.progress) && f && T.panoId === f.panoId) {
          f = null;
          break;
        }
      }
      if (isNil(f))
        return this.locationMotion.ended === true && this.cameraBounce(), null;
      if (f && !f.active) {
        var R = f.panoId;
        this.panoMeshes[R] && (this.panoMeshes[R].setDisabled(false), this.panoMeshes[R].setLoading(true));
      }
      var S = {};
      if (f) {
        for (var M = Math.PI / 6, w = Math.PI / 12, H = new Vector3(0, 1, 0), L = f.position.clone().setY(0).sub(d.position.clone().setY(0)).normalize(), C = L.clone().applyAxisAngle(H, M), I = L.clone().applyAxisAngle(H, -M), _ = [], O = [], P = [], N = 0, k = f.accessibleIds; N < k.length; N++) {
          var g = k[N], U = panoParse(g);
          if (!(panoEqual(U, this.currentPano) || panoEqual(U, f.pano))) {
            var D = this.works.getResolvedObserver(g);
            if (D) {
              var q = D.position.clone().sub(f.position).setY(0);
              L.angleTo(q) < M ? P.push(q) : C.angleTo(q) < M ? _.push(q) : I.angleTo(q) < M && O.push(q);
            }
          }
        }
        var z = P.length > 0 ? P : __spreadArray(__spreadArray([], _, true), O, true), Q = z.slice().sort(function(X, $) {
          return X.angleTo(L) - $.angleTo(L);
        })[0];
        Q && Q.angleTo(c) > w && (S.longitude = Math.atan2(-Q.x, -Q.z));
      }
      this.cameraMotion.value.latitude < -Math.PI / 4 && (S.latitude = clamp$1(0, this.minLatitude, this.maxLatitude)), this.cameraMotion.value.fov < 60 && (S.fov = this.defaultFov);
      var G = {
        workCode: f.pano.workCode,
        panoIndex: f.pano.panoIndex,
        mode: this.mode,
        longitude: (s = S.longitude) !== null && s !== void 0 ? s : this.camera.pose.longitude,
        latitude: (u = S.latitude) !== null && u !== void 0 ? u : this.camera.pose.latitude,
        fov: (l = S.fov) !== null && l !== void 0 ? l : this.camera.pose.fov,
        distance: 0,
        offset: f ? f.position.clone() : new Vector3()
      };
      return this.emit("pano.select", createEvent("pano.select", {
        prevPano: this.currentPano,
        state: G,
        userAction: true,
        options: S,
        progress: 0,
        error: null
      })), f && f.active ? (this.emit("pano.request", createEvent("pano.request", {
        userAction: true,
        prevPano: this.currentPano,
        progress: 0,
        state: G,
        options: S,
        error: null
      })), f.pano) : null;
    }, t.prototype.destroy = function() {
      n45.prototype.destroy.call(this);
    }, t.prototype.isReady = function() {
      return false;
    }, t.prototype.updateCamera = function(e, r, o) {
      return Promise.resolve();
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      return Promise.resolve();
    }, t.prototype.updateTime = function(e, r) {
      for (var o = this, s, u, l, c, f, d, h, v, A = [], g = 2; g < arguments.length; g++)
        A[g - 2] = arguments[g];
      this.userAction = true;
      var p = {}, y = {}, m = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[0]), E = this.panoResourceFromLocationMotionKeyframe(this.locationMotion.keyframes[this.locationMotion.keyframes.length - 1]), b = false;
      if (this.cameraMotion.ended === false && (this.cameraMotion.update(e), y.longitude = this.cameraMotion.value.longitude, y.latitude = this.cameraMotion.value.latitude, y.fov = this.cameraMotion.value.fov), this.modelAlphaMotion.ended === false && (this.modelAlphaMotion.update(e), p.modelAlpha = this.modelAlphaMotion.value.modelAlpha), this.perspToOrthoMotion.ended === false && (this.perspToOrthoMotion.update(e), this.camera.perspToOrtho.setScalar(clamp$1(this.perspToOrthoMotion.value.perspToOrtho, 0, 1))), this.locationMotion.ended === false) {
        this.locationMotion.update(e);
        var T = this.locationMotion.getKeyFrameSegment(e), R = T[0], S = T[1], M = this.panoResourceFromLocationMotionKeyframe(R), w = this.panoResourceFromLocationMotionKeyframe(S), H = new Vector3().copy(M.position), L = new Vector3().copy(w.position), C = this.locationMotion.value.count - S.value.count + 1;
        p.progress = C, w.leftPanoPicture && (C < 1 ? M.leftPanoPicture && (p.pano0 = M.leftPanoPicture) : p.pano0 = w.leftPanoPicture, p.pano1 = w.leftPanoPicture), w.effect === "montage" ? p.transition = "BLACK" : w.effect === "spread" ? p.transition = "SPREAD" : p.transition = "FADE", (w.effect === "zoomin" || w.effect === "zoomout") && (p.progress = Math.pow(C, 3)), C < 1 && w.effect !== "fly" && (p.pano0 && M.leftPanoPicture && (p.pano0 = {
          map: p.pano0.map,
          zoom: p.pano0.zoom,
          luminanceMap: p.pano0.luminanceMap,
          matrix: M.leftPanoPicture.matrix.clone().setPosition(w.position)
        }), H.copy(L), b = true), y.distance = this.locationMotion.value.distance, y.offset = new Vector3(H.x + (L.x - H.x) * C, H.y + (L.y - H.y) * C, H.z + (L.z - H.z) * C);
        for (var I = [], _ = [], O = 0, P = this.locationMotion.keyframes; O < P.length; O++) {
          var N = P[O], k = N.key, U = N.progress;
          k !== void 0 && (I.push(k), U > this.locationMotion.progress && _.push(k));
        }
        for (var D = 0, q = Object.keys(this.panoResources); D < q.length; D++) {
          var z = q[D];
          if (!(_.indexOf(z) >= 0)) {
            var Q = this.panoResources[z];
            if (Q.leftPanoPicture) {
              var G = Q.leftPanoPicture.map;
              if (G) {
                if (G === ((s = p.pano0) === null || s === void 0 ? void 0 : s.map) || G === ((u = p.pano1) === null || u === void 0 ? void 0 : u.map))
                  continue;
                G instanceof TileCubeTextureTarget && G.cubeRenderTarget && this.colorCubeRenderTargetPool.push(G.cubeRenderTarget), G.dispose(), Q.leftPanoPicture = null;
              }
            }
            I.indexOf(z) >= 0 || delete this.panoResources[z];
          }
        }
        this.currentPano = panoParse(w.panoId), this.emit("pano.moving", createEvent("pano.moving", {
          userAction: this.userAction,
          prevPano: panoParse(m.panoId),
          state: __assign(__assign(__assign(__assign({}, panoParse(E.panoId)), { mode: this.mode }), clonePose(this.camera.pose)), y),
          options: {},
          progress: this.locationMotion.progress,
          error: null
        }));
      }
      isEmptyObject(p) === false && (!((l = p.pano0) === null || l === void 0) && l.map && p.pano0.map instanceof TileCubeTextureTarget && !p.pano0.map.cubeRenderTarget && (p.pano0.map.cubeRenderTarget = this.colorCubeRenderTargetPool.pop()), !((c = p.pano1) === null || c === void 0) && c.map && p.pano1.map instanceof TileCubeTextureTarget && !p.pano1.map.cubeRenderTarget && (p.pano1.map.cubeRenderTarget = this.colorCubeRenderTargetPool.pop()), this.models.setMaterial(p)), isEmptyObject(y) === false && this.setCamera(y);
      var X = this.works.getResolvedObserver(this.currentPano), $ = A[1];
      if (!$) {
        console.error("xrFrame");
        return;
      }
      if (!this.xrManager.session) {
        console.error("session");
        return;
      }
      var W = this.xrManager.referenceSpace;
      if (W) {
        var oe = this.xrManager.cameraVR, ie = this.xrManager.cameraL, re = this.xrManager.cameraR, j = [ie, re], se = $.getViewerPose(W), ae = new Vector3(0, 0, 0);
        if (se) {
          var ue;
          ue = this.xrManager.session.renderState.baseLayer;
          var fe = se.views;
          if (!ue) {
            console.error("no layer found");
            return;
          }
          this.renderer.setFramebuffer(ue.framebuffer);
          var ne = false;
          fe.length !== oe.cameras.length && (oe.cameras.length = 0, ne = true), this.parallaxCameraMatrixs = [];
          var Te = new Vector3(), Re = new Vector3();
          new Matrix4().fromArray(fe[0].transform.matrix).decompose(Te, new Quaternion(), new Vector3()), new Matrix4().fromArray(fe[1].transform.matrix).decompose(Re, new Quaternion(), new Vector3()), Re.clone().sub(Te).normalize();
          var ve = new Vector3(), Ce = new Quaternion(), Z = new Vector3();
          this.camera.matrix.decompose(ve, Ce, Z);
          for (var te = 0; te < fe.length; te++) {
            var K = fe[te], ye = ue.getViewport(K), de = j[te];
            de.matrix.fromArray(K.transform.matrix);
            var xe = new Vector3(), Ae = new Quaternion(), me = new Vector3();
            de.matrix.decompose(xe, Ae, me), ae.copy(ve), de.position.copy(ve), de.quaternion.copy(Ae), de.scale.copy(me), de.updateMatrix(), de.projectionMatrix.fromArray(K.projectionMatrix), de.viewport.set(ye.x, ye.y, ye.width, ye.height), ne === true && oe.cameras.push(de);
          }
          if (this.xrManager.session && this.xrManager.session.inputSources) {
            for (var te = 0; te < this.xrManager.session.inputSources.length; te++)
              if (this.xrManager.session.inputSources[te] && this.xrManager.session.inputSources[te].targetRayMode === "transient-pointer") {
                var ce = $.getPose(this.xrManager.session.inputSources[te].targetRaySpace, W);
                if (ce) {
                  var pe = new Vector3(0, 0, -1).applyQuaternion(ce.transform.orientation), ee = new Raycaster(this.camera.position, pe);
                  this.gazeRay = ee;
                }
              }
          }
          if (this.xrManager.machineType === "Oculus" || this.xrManager.machineType === "Pico") {
            for (var he = this.xrManager.session.inputSources, te = 0; te < he.length; te++) {
              var Se = this.xrManager.controllers[te], Ie = he[te];
              if (Ie) {
                Se && Se.update(Ie, $, W);
                var ee = this.xrManager.getController(te), Ue = new Vector3(0, 1.2, 0), be = ee.position.clone().add(ae).sub(Ue);
                Ie.handedness === "left" ? this.xrControllerRay.left.set(be, new Vector3(0, 0, -1).applyEuler(ee.rotation)) : Ie.handedness === "right" && this.xrControllerRay.right.set(be, new Vector3(0, 0, -1).applyEuler(ee.rotation)), this.controllerWrappers[te].position.copy(new Vector3(0, 0, 0).add(ae).sub(Ue));
                var ge = this.models.intersectRaycaster(this.xrControllerRay.right);
                if (ge.length === 0 && (ge = this.xrControllerRay.right.intersectObject(this.boundingMesh, true).map(function(vt) {
                  var At;
                  return __assign({ floor: (At = X == null ? void 0 : X.floorIndex) !== null && At !== void 0 ? At : 0 }, vt);
                })), ge.length >= 1 && ge[0].face)
                  if (Ie.handedness === "right") {
                    var ze = this.xrControllerRay.right.intersectObject(this.xrCustomObjectsScene, true), Ne = ge[0].face.normal, Je = Ne.clone(), Ke = ge[0].point.clone();
                    this.intersectMesh.position.copy(Ke);
                    var De = Ke.clone().add(Je);
                    if (this.intersectMesh.lookAt(De), Math.abs(Ne.y) > 0.99) {
                      var Ye = this.camera.position.clone().sub(Ke);
                      this.intersectMesh.rotation.z = -Math.atan2(Ye.z, Ye.x);
                    }
                    this.intersectMesh.visible = true, this.needsRender = true, ze.length > 0 ? (this.pointerLines.right.setPoints(be, ze[0].point), this.pointerLines.right.points.visible = true, this.intersectMesh.visible = false) : (this.pointerLines.right.points.visible = false, this.pointerLines.right.setPoints(be, ge[0].point));
                    var Ve = ge[0], nt = createEvent("intersect.update", {
                      raycaster: (f = this.xrControllerRay.right) !== null && f !== void 0 ? f : null,
                      intersection: Ve != null ? Ve : null,
                      object: this.intersectMesh
                    });
                    if (this.emit("intersect.update", nt), nt.defaultPrevented) {
                      this.hideIntersectMesh();
                      return;
                    }
                  } else
                    this.pointerLines.left.setPoints(be, ge[0].point);
              }
            }
            this.updateControllerHelper(he, e, r);
          }
          if (this.camera.pose.distance > 0.1 || b)
            for (var qe = 0, Qe = Object.keys(this.panoMeshes); qe < Qe.length; qe++) {
              var Pe = Qe[qe], Me = this.panoMeshes[Pe];
              Me.setOpacity(0), Me.setCurrent(false), Me.updateTime && Me.updateTime(e, r), Me.visible = false;
            }
          else if (X) {
            var He = arrayMin(X.visibleIds, function(Oe) {
              var ut = o.works.getResolvedObserver(Oe);
              return ut ? X.standingPosition.distanceTo(ut.standingPosition) : 1 / 0;
            }, true), Le = He[1];
            Le = clamp$1(Le, 2.5, 1 / 0);
            for (var ot = X.visibleIds.concat(panoStringify(this.currentPano)), $e = this.getForwardObserverOrNot(), tt = this.camera.getDirection(new Vector3()), Xe = 0, rt = Object.keys(this.panoMeshes); Xe < rt.length; Xe++) {
              var Pe = rt[Xe], Me = this.panoMeshes[Pe], Ge = this.works.getResolvedObserver(Pe);
              if (ot.indexOf(Pe) === -1)
                Me.setCurrent(false), Me.setOpacity(0);
              else if (!Ge)
                Me.setCurrent(false), Me.setOpacity(0);
              else if (!Ge.loadable && !Ge.active)
                Me.setCurrent(false), Me.setOpacity(0);
              else {
                var st = Me.position.clone().setY(this.camera.position.y).distanceTo(this.camera.position);
                Me.setCurrent(!Me.loading && Me.progress === 0 && $e !== null && $e.panoId === Pe), Me.setOpacity(st < 0.01 ? 0 : clamp$1(Le / st * 1.2, 0.65, 0.98));
                var ct = this.camera.position.clone().setY(Me.position.y), pe = new Vector3().copy(Me.position).sub(ct).normalize();
                if (Pe === panoStringify(this.currentPano)) {
                  var je = clamp$1((0.5 - ct.distanceTo(Me.position)) / 0.5, 0, 1);
                  pe.multiplyScalar(1 - je).add(tt.clone().multiplyScalar(je));
                }
                pe.length() > 0 && Me.quaternion.setFromEuler(new Euler(0, Math.atan2(pe.x, pe.z), 0));
              }
              Me.updateTime && Me.updateTime(e, r);
            }
          }
          var Fe = /* @__PURE__ */ function() {
            return 4;
          }(), We = function() {
            var Oe = new PerspectiveCamera();
            Oe.applyMatrix4(oe.matrix), Oe.position.set(0, 0, 0);
            var ut = o.works.getResolvedObserver(E.panoId), vt = ut != null ? ut : X;
            vt && Oe.quaternion.premultiply(vt.quaternion.clone().inverse()), Oe.updateProjectionMatrix(), Oe.updateMatrixWorld(true);
            var At = new Frustum().setFromProjectionMatrix(new Matrix4().multiplyMatrices(Oe.projectionMatrix, Oe.matrixWorldInverse));
            return At;
          }();
          E.panoId === panoStringify(this.currentPano) && ((d = E.leftPanoPicture) === null || d === void 0 ? void 0 : d.map) instanceof TileCubeTextureTarget && (E.leftPanoPicture.map.maxRequest = this.tileMaxRequest, E.leftPanoPicture.map.update(We, Fe), E.leftPanoPicture.map.needsRender === true && (this.needsRender = true, this.modelSceneNeedsRender = true));
          {
            var it = this.tiling.object.visible;
            if (this.initAnimationed) {
              var Be = E.panoId, we = this.works.getResolvedObserver(Be);
              we ? isSimilarVector3(this.camera.position, we.position) && this.locationMotion.ended ? (this.tiling.object.visible = true, this.tiling.panoId !== Be && this.tiling.cleanup(), this.tiling.panoId = Be, this.tiling.setResource((v = (h = we.images) === null || h === void 0 ? void 0 : h.tiles) !== null && v !== void 0 ? v : [], this.enableIOSEDR && we.images.luminance ? we.images.luminance : null), this.tiling.setFetcher(getFetcher(we.work)), this.tiling.setRotation(we.quaternion), this.tiling.setPosition(we.position), this.tiling.maxRequest = this.tileMaxRequest, Fe > this.tiledCubeTextureLevel ? this.tiling.update(We, Fe, e) : this.tiling.update(We, 0, e)) : this.tiling.object.visible = false : this.tiling.object.visible = false;
            } else
              this.tiling.object.visible = false;
            it !== this.tiling.object.visible && (this.tiling.object.needsRender = true, this.modelSceneNeedsRender = true);
          }
          this.panoVideo.object.position.copy(this.camera.position), this.panoVideo.updateTime(e);
        }
      }
    }, t.prototype.render = function() {
      var e = this.xrManager.getCamera(this.camera);
      this.renderer.render(this.modelScene, e), this.renderer.autoClearColor = false, this.renderer.autoClearDepth = false, this.renderer.render(this.scene, e), this.renderer.autoClearColor = true, this.renderer.autoClearDepth = true;
    }, t.prototype.onPanGesture = function() {
    }, t.prototype.onTapGesture = function() {
    }, t.prototype.onPinchGesture = function() {
    }, t.prototype.onMouseMove = function() {
    }, t.prototype.onMouseOut = function() {
    }, t.prototype.panoResourceFromLocationMotionKeyframe = function(e) {
      return this.panoResources[e.key];
    }, t.prototype.updateControllerHelper = function(e, r, o) {
      var s = this.xrControllerRay.left, u = this.xrControllerRay.right;
      if (!(!e || e.length === 0)) {
        for (var l = {
          buttons: {
            X: false,
            Y: false,
            LeftTrigger: false,
            LeftPinch: false,
            A: false,
            B: false,
            RightTrigger: false,
            RightPinch: false
          }
        }, c = 0; c < e.length; c++) {
          var f = e[c].handedness, d = e[c].gamepad;
          switch (f) {
            case "left":
              d.axes && (this.emitHandleEvent(d.axes[2] === -1, "LeftAxesLeft", r), this.emitHandleEvent(d.axes[2] === 1, "LeftAxesRight", r), this.emitHandleEvent(d.axes[3] === -1, "LeftAxesUp", r), this.emitHandleEvent(d.axes[3] === 1, "LeftAxesDown", r)), d != null && d.buttons && (d.buttons[4] && this.emitHandleEvent(d.buttons[4].pressed, "X", r), d.buttons[5] && this.emitHandleEvent(d.buttons[5].pressed, "Y", r), d.buttons[0] && this.emitHandleEvent(d.buttons[0].pressed, "LeftTrigger", r), d.buttons[1] && this.emitHandleEvent(d.buttons[1].pressed, "LeftPinch", r));
              var h = {
                raycaster: s,
                axes: {
                  up: d.axes && d.axes[3] < 0 ? Math.abs(d.axes[3]) : 0,
                  down: d.axes && d.axes[3] < 0 ? 0 : Math.abs(d.axes[3]),
                  left: d.axes && d.axes[2] < 0 ? Math.abs(d.axes[2]) : 0,
                  right: d.axes && d.axes[2] < 0 ? 0 : Math.abs(d.axes[2])
                },
                deltaTime: o
              };
              l.buttons.X = d.buttons && d.buttons[4] ? d.buttons[4].pressed : false, l.buttons.Y = d.buttons && d.buttons[5] ? d == null ? void 0 : d.buttons[5].pressed : false, l.buttons.LeftTrigger = d.buttons && d.buttons[0] ? d == null ? void 0 : d.buttons[0].pressed : false, l.buttons.LeftPinch = d.buttons && d.buttons[1] ? d == null ? void 0 : d.buttons[1].pressed : false, l.left = h;
              break;
            case "right":
              d.axes && (this.emitHandleEvent(d.axes[2] === -1, "RightAxesLeft", r), this.emitHandleEvent(d.axes[2] === 1, "RightAxesRight", r), this.emitHandleEvent(d.axes[3] === -1, "RightAxesUp", r), this.emitHandleEvent(d.axes[3] === 1, "RightAxesDown", r)), d.buttons && (d.buttons[4] && this.emitHandleEvent(d.buttons[4].pressed, "A", r), d.buttons[5] && this.emitHandleEvent(d.buttons[5].pressed, "B", r), d.buttons[0] && this.emitHandleEvent(d.buttons[0].pressed, "RightTrigger", r), d.buttons[1] && this.emitHandleEvent(d.buttons[1].pressed, "RightPinch", r));
              var v = {
                raycaster: u,
                axes: {
                  up: d.axes && d.axes[3] < 0 ? Math.abs(d.axes[3]) : 0,
                  down: d.axes && d.axes[3] < 0 ? 0 : Math.abs(d.axes[3]),
                  left: d.axes && d.axes[2] < 0 ? Math.abs(d.axes[2]) : 0,
                  right: d.axes && d.axes[2] < 0 ? 0 : Math.abs(d.axes[2])
                },
                deltaTime: o
              };
              l.right = v, l.buttons.A = d.buttons && d.buttons[4] ? d == null ? void 0 : d.buttons[4].pressed : false, l.buttons.B = d.buttons && d.buttons[5] ? d == null ? void 0 : d.buttons[5].pressed : false, l.buttons.RightTrigger = d.buttons && d.buttons[0] ? d == null ? void 0 : d.buttons[0].pressed : false, l.buttons.RightPinch = d.buttons && d.buttons[1] ? d == null ? void 0 : d.buttons[1].pressed : false;
              break;
          }
        }
        this.emit("xr.controller.update", createEvent("xr.controller.update", l));
      }
    }, t.prototype.emitHandleEvent = function(e, r, o) {
      var s = this.xrControllerRay.left, u = this.xrControllerRay.right;
      if (e)
        if (this.xrHandleState[r].touchStart === false)
          this.xrHandleState[r].touchStartTime = o, this.xrHandleState[r].touchStart = true, this.emit("xr.gesture.buttonDown", createEvent("xr.gesture.buttonDown", {
            session: this.xrManager.session,
            machineType: this.xrManager.machineType,
            buttons: r,
            isFinal: false,
            isFirst: true,
            controllers: {
              raycaster: {
                leftRay: s,
                rightRay: u
              }
            }
          }));
        else {
          var l = o - this.xrHandleState[r].touchStartTime;
          l > CONTROLLER_EVNET_DELTA_TIME && this.emit("xr.gesture.press", createEvent("xr.gesture.tap", {
            session: this.xrManager.session,
            machineType: this.xrManager.machineType,
            buttons: r,
            isFinal: true,
            isFirst: true,
            controllers: {
              raycaster: {
                leftRay: s,
                rightRay: u
              }
            }
          }));
        }
      else if (this.xrHandleState[r].touchStart === true) {
        this.emit("xr.gesture.buttonUp", createEvent("xr.gesture.buttonUp", {
          session: this.xrManager.session,
          machineType: this.xrManager.machineType,
          buttons: r,
          isFinal: true,
          isFirst: false,
          controllers: {
            raycaster: {
              leftRay: s,
              rightRay: u
            }
          }
        }));
        var l = o - this.xrHandleState[r].touchStartTime;
        if (l <= CONTROLLER_EVNET_DELTA_TIME) {
          var c = createEvent("xr.gesture.tap", {
            session: this.xrManager.session,
            machineType: this.xrManager.machineType,
            buttons: r,
            isFinal: true,
            isFirst: false,
            controllers: {
              raycaster: {
                leftRay: s,
                rightRay: u
              }
            }
          }), f = this.emit("xr.gesture.tap", c);
          !f && !c.defaultPrevented && r === "RightTrigger" && this.checkSelectedPano(this.xrControllerRay.right);
        }
        this.xrHandleState[r].touchStart = false, this.xrHandleState[r].touchStartTime = 0;
      }
    }, t.prototype.initHandEvent = function() {
      var e = this;
      if (!this.xrManager.session)
        throw new Error("");
      this.xrManager.session.addEventListener("select", function(r) {
        e.gazeRay && e.checkSelectedPano(e.gazeRay);
      });
    }, t;
  }(PanoramaController)
);
var Controllers = {
  Floorplan: FloorplanController,
  Topview: TopviewController,
  Panorama: PanoramaController,
  VRPanorama: VRPanoramaController,
  Model: ModelController,
  Mapview: MapviewController,
  XRPanorama: XRPanoramaController
};
var controllersDefaultInitArgs = {
  Floorplan: defaultFloorplanControllerCustomInitArgs,
  Topview: defaultTopviewControllerCustomInitArgs,
  Panorama: defaultPanoramaControllerCustomInitArgs,
  VRPanorama: defaultVRPanoramaControllerCustomInitArgs,
  Model: defaultModelControllerCustomInitArgs,
  Mapview: defaultMapviewControllerCustomInitArgs,
  XRPanorama: defaultXRPanoramaControllerInitArgs
};
var PROXY_CONTROLLER_EVENT_NAMES = [
  "gesture.pan",
  "gesture.tap",
  "gesture.dbltap",
  "gesture.press",
  "gesture.pinch",
  "gesture.mousewheel",
  "gesture.mousemove",
  "gesture.momentum",
  "initAnimation.start",
  "initAnimation.end",
  "camera.update",
  "intersect.update",
  "pano.select",
  "pano.moveTo",
  "pano.moving",
  "pano.arrived",
  "pano.cancel",
  "pano.error",
  "pano.texture.load",
  "pano.texture.progress",
  "pano.texture.success",
  "pano.texture.error",
  "pano.texture.abort",
  "xr.session.start",
  "xr.session.end",
  "xr.gesture.tap",
  "xr.gesture.press",
  "xr.gesture.buttonUp",
  "xr.gesture.buttonDown",
  "xr.controller.update"
];
function initLegacyEvent(n45) {
  n45.on("initAnimation.start", function(t) {
    n45.emit("initAnimationWillStart", t.state.panoIndex, t.state, t.userAction);
  }), n45.on("initAnimation.end", function(t) {
    n45.emit("initAnimationEnded", t.state.panoIndex, t.state, t.userAction);
  }), n45.on("gesture.pan", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "pan", t.pointers, t.isFinal), e && t.preventDefault(), e = n45.emit("wantsPanGesture", t.state, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "pan", t.pointers, t.isFinal), n45.emit("panGesture", t.state, t.isFinal));
  }), n45.on("gesture.tap", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "tap", t.pointers, t.isFinal), e && t.preventDefault(), e = n45.emit("wantsTapGesture", t.center.raycaster, t.center.coords, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "tap", t.pointers, t.isFinal), n45.emit("tapGesture", t.center.raycaster, t.center.coords, t.isFinal));
  }), n45.on("gesture.dbltap", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "dbltap", t.pointers, t.isFinal), e && t.preventDefault(), e = n45.emit("wantsDblTapGesture", t.center.raycaster, t.center.coords, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "dbltap", t.pointers, t.isFinal), n45.emit("dblTapGesture", t.center.raycaster, t.center.coords, t.isFinal));
  }), n45.on("gesture.press", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "press", t.pointers, t.isFinal), e && t.preventDefault(), e = n45.emit("wantsPressGesture", t.center.raycaster, t.center.coords, t.center.delta, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "press", t.pointers, t.isFinal), n45.emit("pressGesture", t.center.raycaster, t.center.coords, t.center.delta, t.isFinal));
  }), n45.on("gesture.pinch", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "pinch", t.pointers, t.isFinal), e && t.preventDefault(), e = n45.emit("wantsPinchGesture", t.scale, t.state.fov, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "pinch", t.pointers, t.isFinal), n45.emit("pinchGesture", t.scale, t.state.fov, t.isFinal));
  }), n45.on("gesture.mousewheel", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "mouseWheel", t.pointers, t.isFinal), e && t.preventDefault(), e = n45.emit("wantsMouseWheel", t.center.delta, t.state.fov, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "mouseWheel", t.pointers, t.isFinal), n45.emit("mouseWheel", t.center.delta, t.state.fov, t.isFinal));
  }), n45.on("gesture.mousemove", function(t) {
    var e = false;
    e = n45.emit("wantsGesture", "mouseMove", t.pointers, t.isFinal), e && t.preventDefault(), t.defaultPrevented || (n45.emit("gesture", "mouseMove", t.pointers, t.isFinal), e = n45.emit("wantsChangeCameraFov", t.state.fov), e && t.preventDefault());
  }), n45.on("gesture.momentum", function(t) {
    var e = false;
    e = n45.emit("wantsInteriaPan", t.state), e && t.preventDefault(), t.defaultPrevented || n45.emit("interiaPan", t.state, t.isFinal);
  }), n45.on("camera.update", function(t) {
    n45.emit("cameraFovUpdate", t.state.fov, t.userAction), n45.emit("cameraDirectionUpdate", t.state, t.userAction);
    var e = coordinatesToVector(t.state);
    e.setLength(t.state.distance);
    var r = t.state.offset.clone().sub(e);
    n45.emit("cameraPositionUpdate", r, t.userAction), n45.emit("cameraUpdate", t.state, t.userAction);
  }), n45.on("intersect.update", function(t) {
    if (t.intersection) {
      var e = false;
      e = n45.emit("wantsShowIntersectionOnModel", t.raycaster), e && t.preventDefault(), t.defaultPrevented || n45.emit("intersectionOnModelUpdate", t.intersection, t.object);
    } else
      n45.emit("intersectionHidden");
  }), n45.on("pano.request", function(t) {
    var e = n45.emit("wantsMoveToPano", t.state.panoIndex, t.options, t.userAction);
    e || (e = n45.emit("wantsToMoveToPano", t.state.panoIndex, t.options, t.userAction)), e && t.preventDefault(), t.defaultPrevented || n45.emit("panoWillLoad", t.state.panoIndex);
  }), n45.on("pano.select", function(t) {
    n45.emit("panoSelected", t.state.panoIndex);
  }), n45.on("pano.moveTo", function(t) {
    n45.emit("panoLoaded", t.state.panoIndex), n45.emit("moveToPano", t.state.panoIndex, t.userAction), n45.emit("panoWillArrive", t.state.panoIndex, t.state, t.userAction);
  }), n45.on("pano.moving", function(t) {
    n45.emit("movingToPano", t.state.panoIndex, t.prevPano.panoIndex, t.progress);
  }), n45.on("pano.arrived", function(t) {
    n45.emit("panoArrived", t.state.panoIndex, t.state, t.userAction);
  }), n45.on("pano.cancel", function(t) {
    n45.emit("moveToPanoCanceled", t.state.panoIndex);
  }), n45.on("pano.error", function(t) {
    n45.emit("panoLoadError", t.error, t.state.panoIndex);
  }), n45.on("pano.texture.load", function(t) {
    n45.emit("textureStartLoad", t.pano.panoIndex);
  }), n45.on("pano.texture.success", function(t) {
    n45.emit("textureLoaded", t.pano.panoIndex, t.meta);
  }), n45.on("pano.texture.error", function(t) {
    n45.emit("textureError", t.error, t.pano.panoIndex);
  }), n45.on("pano.texture.abort", function(t) {
    n45.emit("textureAbort", t.pano.panoIndex);
  }), n45.on("pano.texture.progress", function(t) {
    n45.emit("textureLoading", t.progress, t.pano.panoIndex);
  }), n45.on("xr.session.start", function(t) {
    n45.emit("webXRSessionStart");
  }), n45.on("xr.session.end", function(t) {
    n45.emit("webXRSessionEnd");
  }), n45.on("xr.gesture.tap", function(t) {
    n45.emit("webXRControllerEvent", "tap", t.buttons, {
      raycaster: t.controllers.raycaster
    });
  }), n45.on("xr.gesture.press", function(t) {
    n45.emit("webXRControllerEvent", "press", t.buttons, {
      raycaster: t.controllers.raycaster
    });
  }), n45.on("xr.gesture.buttonUp", function(t) {
    n45.emit("webXRControllerEvent", "buttonUp", t.buttons, {
      raycaster: t.controllers.raycaster
    });
  }), n45.on("xr.gesture.buttonDown", function(t) {
    n45.emit("webXRControllerEvent", "buttonDown", t.buttons, {
      raycaster: t.controllers.raycaster
    });
  }), n45.on("xr.controller.update", function(t) {
    n45.emit("webXRControllerRayUpdate", {
      leftRay: t.left ? t.left.raycaster : void 0,
      rightRay: t.right ? t.right.raycaster : void 0
    }), t.left && n45.emit("webXRAxesUpdate", "left", {
      raycaster: {
        leftRay: t.left ? t.left.raycaster : void 0,
        rightRay: t.right ? t.right.raycaster : void 0
      },
      axesState: {
        up: t.left.axes.up,
        down: t.left.axes.down,
        left: t.left.axes.left,
        right: t.left.axes.right
      },
      deltaTime: t.left.deltaTime
    }), t.right && n45.emit("webXRAxesUpdate", "right", {
      raycaster: {
        leftRay: t.left ? t.left.raycaster : void 0,
        rightRay: t.right ? t.right.raycaster : void 0
      },
      axesState: {
        up: t.right.axes.up,
        down: t.right.axes.down,
        left: t.right.axes.left,
        right: t.right.axes.right
      },
      deltaTime: t.right.deltaTime
    });
  }), n45.on("works.request", function(t) {
    n45.emit("willLoad", t.input, t.works[0], t.state);
  }), n45.on("works.load", function(t) {
    n45.emit("load", t.input, t.works[0], t.state);
  }), n45.on("works.ready", function(t) {
    n45.emit("loaded", t.input, t.works[0]);
  }), n45.on("state.change", function(t) {
    n45.emit("stateChange", t.state, t.userAction);
  }), n45.on("currentState.change", function(t) {
    n45.emit("currentStateChange", t.state, t.userAction);
  }), n45.on("state.set", function(t) {
    n45.emit("setState", t.state);
  }), n45.on("state.synced", function(t) {
    n45.emit("stateSynced", t.state);
  }), n45.on("model.request", function(t) {
    n45.emit("modelWillLoad", t.work.model);
  }), n45.on("model.error", function(t) {
    n45.emit("modelLoadError", t.error, t.model);
  }), n45.on("model.load", function(t) {
    n45.emit("modelLoaded", t.model);
  }), n45.on("model.changeShownFloor", function(t) {
    n45.emit("modelShownFloorChange", t.model.shownFloor, t.model.floorLength);
  }), n45.on("render", function(t) {
    n45.emit("renderFrame", t.needsRender);
  }), n45.on("mode.change.request", function(t) {
    n45.emit("wantsChangeMode", t.mode, t.prevMode);
  }), n45.on("mode.change", function(t) {
    n45.emit("modeChange", t.mode, t.prevMode, t.state.panoIndex, t.state, t.userAction);
  }), n45.on("helpers.visible", function(t) {
    n45.emit("helpersVisibleChange", t.object.visible);
  }), n45.on("network.resource", function(t) {
    n45.emit("network", t.source, t.requestType, t.requestState, t.detail);
  });
}
function generateDefaultVideoElement() {
  if (typeof window != "undefined") {
    var n45 = document.createElement("video");
    n45.loop = true, n45.autoplay = true, n45.playsInline = true, n45.muted = true, n45.crossOrigin = "";
    var t = function() {
      document.removeEventListener("touchstart", t, false), document.removeEventListener("mousedown", t, false), n45.muted = false;
    };
    return document.addEventListener("touchstart", t, false), document.addEventListener("mousedown", t, false), n45;
  } else
    return {};
}
function initLights(n45) {
  var t = new Group();
  t.name = "internalLights";
  {
    var e = new DirectionalLight(16777215, 0.3);
    e.position.copy(new Vector3(1, 1, 1)), t.add(e);
  }
  {
    var e = new DirectionalLight(16777215, 0.1);
    e.position.copy(new Vector3(-1, -1, -1)), t.add(e);
  }
  {
    var e = new DirectionalLight(16777215, 0.1);
    t.add(e);
  }
  {
    var e = new AmbientLight(16777215, 0.6);
    t.add(e);
  }
  n45.add(t);
}
function parseKeyValue(n45) {
  for (var t, e, r = {}, o = n45.split(/(\;|\,)/), s = 0, u = o; s < u.length; s++) {
    var l = u[s], c = l.split("="), f = (t = c[0]) === null || t === void 0 ? void 0 : t.trim(), d = (e = c[1]) === null || e === void 0 ? void 0 : e.trim();
    f && d && (r[f] = d);
  }
  return r;
}
function getViewportScale() {
  var n45;
  if (typeof document != "undefined")
    for (var t = document.getElementsByTagName("meta"), e = 0; e < t.length; e++) {
      var r = t[e];
      if (r.getAttribute("name") === "viewport") {
        var o = parseKeyValue((n45 = r.getAttribute("content")) !== null && n45 !== void 0 ? n45 : ""), s = Number(o["initial-scale"]);
        if (!isNaN(s))
          return s;
      }
    }
  return 1;
}
var textureURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV8AAAA/CAQAAADtPwPkAAAR+0lEQVR4AezYg3LEQACH8d1cbdu23Q5qG9G47z/TN/h6tn2b/H+TUTLc7yjcOXV46OUAnUs6EbUp022ZBXc1NhoZYYd7fjDRvdcHAwrlK2QBVJ4sgoqONmY45RUT23sZ6H42F2hK5CtkMbjhZlDmUUcvq1zyieUVyjbE4I1GBfItwxG56YaUZTQwyh4P6NgJ4YYYvCuQb5kOyI03pORjiqe4Lwpq5pt1vJqfUwKWJVbSMYfppYconG+maNNQOWBZuwHTzicGel75NtFOkxr5apmV8cikcko0DrDQs863AeGl0cE0+1xy573m0/wf0cEKW6H7BWtggiMG8sy3oHRDpJMw4NWb6am/bv9znkqEzjd61t5oo5clTrjhwevO75EJRBKSRt745Z16ZEjcM73sccZplBPm8PyTcxZAkSRdHm/acJ0Z3JZhHB0BxqDHgWFZFmm0ZbCw87twI/zc3e/Cz93vPneXtU/WdQS3oTviXdY/q5PsJKfoGuQjZuO/0in1qsj85cuXrxqeAOJpGqdJOqrUutgVl2Qb0BWqp/RE8AWWVB7t2KrIzY2Wx2fWKl7yfswgxqj8lYummYa3hfwF9MuQRmbfQE4ocPDjtUWQ6Tq1M2w7gC2EcrMGtWS6xlpGKEDDcb1vUQ25zT4lrC2s0dU4gFPppKkbeIYr7NMpqjStuFg5rNU9epGyt8PXyfX4DE1bKLhR/1XPxwJhp5DAV67T9ZPwFdovhBMIGUYoRBN4wim6S3eoXVEHXdLgmwY0x6BQnO4xPJ0Ar5OVxhQF0L9UslRM4yaQQfQImnBegi8vhY2A1k6YLlrj61TwDdNQnIISwiPvpD7TwYQTssZXK47vg8y9Gp2nxRcATkozOEmdCeObSt3IIo+xf/00IDRKAaZ89PBTkHqpkA5LagKeNZKlIhqX8RcQ95GHtdYA62Y6rOg5LLsOSnoyvk4V38hFhytef+V9/3DER1P48W89o1GxE9o5vns2Mk+F7yiftafEN4nhmUv9DKEeyqI0U+l0CQg+B//sZ5+6lOuqKaTgm0LH41RHw/CsLZRk4huiYxrvP2SNr1OSS+Dr1ulBMR+K9SqHa58Oec49VgL3mXHvDr7QfuM7LMNrH1/IS30Moe64SLYBuFVJ+MbnJY7L+GrVQkFcl4ISx/fEll4ZWnz18DpcSzUCX602LqD9svDLzmdaLkP28P1+VsJjsx/4hmh6x/gmm/i6pbrGneCL9iCOg0dQUvF1UwEdVvG19r2uTXxXLz0J37eLjfZoF++tTtPnU/cWp5e8n3An0m/G+U7qjiy4PpHyV16HKx5flCxAV/H9A88nUnZ7l7KN78SBxPcQgzLAepxEScU3l7pZ6fL2+Dot8fXECfj+QRoGYAwlAfBSPrXQXQri0Pd85NJKcVw8XUdt1LZapk7YRhO1RdpmFJwW8ozekYvx2/fjM5Hr5MfQ95HvcY2a/9hoNK4yEntL+dEuGseTdNmxIPqd5v2YRjeaX8pQ8IW2ohuP7+dTN87RMK4aitx8XPsH0r2oBqNRqrv7+gmjjY7uIr6TBxBfL2MlxNRKSVp8S5CTuGgHXxfkFvh69Pq3LD4pkkd2bdRvHaSNC3/l2sQXAccdlIS+lc57qhPJwxPybT7XSxnUrdqnXuHlJHS+mjZfJfUZR9s2FuQR+EQKdSi9Am8UTnsEvlYS+L6TFwW6kl74Vjr6AFHsX89rgg8njRltK0XPOL7NyDL0IurV4VtMwafB1709vu9X4OjWHoP3z1Ii7eaQdG00Lx5n8HXyDSva/dU0Pq2vZnKYxHYMYRo1WY5ov1G7Vh4r3y+kMdgbilxeOrV0aqOFenFl8GGJig7rG0bbPRqiSRpP2AL0w+yon9dHbi43zFetnKcuw9ZLeSa+7kTw/TDfuFu0Z7Vp/uhyHfPkAZ5ufP9wLIfD49E3clR818rR089Lzyy+VRREPneICnYLX9cT8PVKQs36TbQ3i6NcCwYkxEAQ3phN4CjAvC4mFr5vrlKe7AizBKj8cu33s7i9GbeY7BHYujTjjd3Bx54SSyT4m8mxOoYOAGX/DtwvnGE1M+5v5Bgt1hbkJRW9Cxv9X81GL2i5jqaoJ4avBcCsLYp+Ru+VC5sWPpFhXt8/EPvJL2F/alJDEeIjUhcrP5P45rDeATPj+wKl7gBf1fcq+HpVnfHO1vEf//UCHgt/OxfDE3onj5UkfTaThrg3NCGoBUCtZjvgMnwQB0bG5XENeraJ5XEWvtiHkqSVRqN+uQ4lEx2o+69SeY1dC++Wcsj+LCW+H0ZE4KtDWHkGwCtrxstbFqr51e9wbz42E2fpjRQsqEn50PnM4eumO9IbujCi393Hd+3q72TI+p9DPyyfraF+c3rOx0KJyB2z7Fa1yCO8HoHzlDFhPiWD8XoB3aPppRrUQdRp1D8qE9exdgr+Zbpqf8BLfmZ/bMYbh87k58VCSswCjQoLPPw4Jnp4uFi/YQlfKB5eBd/gr6aqB973zbDAF+v5PN+NZEvm+84bSkhxUPE9C9wqbeJ7Hi+gA9Jr5ZM7x9el4mulyK0Bb2xiMTj3/iBtK77Tnii27H/MlCfsjcJY+2oTg2/U4TYWQERE0r+aCouBcx5zEZzEYrqui8JXsQW/X8FLHJ3IVbWXhQV3zAJCjFQst1F25y1arlXwhRR4Bb4rZ3VPy5d+bHEtHIPF27K16ItYuKXM5kHD10M9DKFeSpbqLlOYAlRiC99yCiDmbUf0206jPPO7b/iud71avBkHf+kQP0OrWHBFrhmt75ZyPzbLg5KmWK9oH4Oq1eFZOm0c6n48mdfer46HcLUZU3pGB8R9IDBbJ+N7v1q0J2xhudZ45tcL8PN16vq9WizwtRLwFQtKER+NDypj4QQOdJNY3NC7GEsaGtiSmDsA+CZhyx+hXFHjYrgGGXpZNvDNpn5gWWuiWkUtyEB0UcrO8Y2L9KI9K+cXLmxqruGd6pcKfycj/ij3URVgu6bPUaycN1qXTHD+KoOmjGORnH57q8rh+e9sTHk5r1+7zpEXk36bp7iiXRrBW61e5k/D0fn+EXF/OxYEypFW3ZH1HzPt4Pv5PN2Rd7VJLDZeboGnbpSPwPDcBw5f6AIysadFOR9Hr7vksoFvE91jdbdYvzpYqyIvdQPU87uKL45u3u213CA8qkYPT6H1YgwIfkz7RI5xJdomfjoV4PXjfjgaRkNGhHwG1mNt1oq0y/j+SaZ5pV0LnrlG89Dl1YkmEsc3nKKzMKskJD+fx6NhlFiohdTe5EsZIig5WPgWUYCC9Dx5TG/sA5x15LCBbzXDtx/+uh74VmMZjLDamh8JvhzQtSsoeVTNNXB/Euv96LRR/qjO+By5xTxxJ683/FB00Pj0fZz9F2GPa70Ld2hbbVptWmjWabbGCl/ZAiTsbJa5hQ9OK/eWFE4xva9nG3z1zwCtnFXjYr6c3ykxPn9QiYWEWPhA4uuiDnzBpt4EMcg0QOm28M0gP76hJuELbIdZi4PqaILpJI+RYz4ZV42y+q49wBcxIbyXTmtXgevRWPl3MmjSSJU5vB3J0TA2Uu8mtP+R5/Au4iiF6NrUUiuCieOiJpnJq8gSXzwFLFiLP8X6bV0bYvzt8TXj75eLtKPRauY1RM1HR7GwEHpFbonIWAPwjxpfqJSCyBVUsk/DFOChhC18kyiPHFvwdVGh6XFbmfLx+RRi4jaqYiCnUDO1wc4u4ovo7pfS+XFD32e9GzndwxJiHcbQ/Vz6JrBMDGYyYK5l7YOsfkS2MVePfGkLsNXLGl9hIVbWXAv9fQ5i/j6UFL1RaQffB9qlwn3tS4WxMhaxETCMz6T9ZTqCk5FznoOKL9SEXMMIUwAZW6dNfCEVX61azdxwmIbg4aHdwtcj5KVBeNiqrb2+g5M8hTskSB6exHZ5bMEIF/wCoOT128zvdXziMLbvuDu/Usmh0oG7doMmafKNSmt8hQWUnmzhjJf/RskXCzQL8aYNfLG/QPGLY5KjKtcuNPGsyGytmj0/kPi6qdXwwJCPvOTYI3zTaICCNEh9FGSWM54OX4+A1UI80RV98czWKceJf65ervsleJm164/7ganACHHn+IPz8Nby1ptcnRztRWbipArvp4/gRchodbIFvsBSWPBaW+CHtzWfauFfcmnKRuyr+Fiu1WbzGKtCPWWMHjIgU1/Mgn2B74GKfbkajHwtVIHy3uBbh0Ocj9oplCC+kIJvYuKvI9bbkUUQ2+JaG7AeknwvhLd0YUxx+SZIf4XkGeqHUCNt9N8sQdvYlwtl9H4hMzqI5dHosMIX2taCl2s6LRowaubPyld/IgcvHBJPnKGnHDLh0ArfqzlYtkv5D8++4RsAvPbwTaJzgDcIDzxIRXuEbx4NIsYupjt7gi/6idL3j1AIqPY+OPH5PGO67x/jUS9NvF6hTte7x2kaCvtSZJiMlxjxMSqEtqXr3GPMn/9y4cXUypS/ymPxbIAvmurtYl9o7dqmBV9KdbLOgsik4B3d6xW/lO7w/kfe+yfx7bFuGkwY3/C6sURDj8584rCxJH5QtnYFVrFQVL35HNoQgO0jvt228XVRC4WQPLtANyiEzb1gD/BNoy5kHa5QEnUmiq/uG2fubeXh+kwuNj8IRxAoOqiLIqfTaNw84SfLWsDmqo08k30prHVKbHuYDo7ez6U7EsLX0oJX1ltV2AOg2KfoMPPA/sTx/ZPMqF9YiN11AsHLFrHgaAT3GBvw7hO+U9TH4bX10rgVx7YgMr0p7Pow4tL8XcY3l1kJMfVQmsA3fa/wFQh3JK9eivtV+tCaD4cUjdZvIRI9BfDUDd6PkkbfKhVbOJf/jUpuQcXXlgVNv68ejr4gTflk5AZ71+jR4AvEdPg6PDNpaz6a2AQm2otoWKvVS+LVTyL4OnaE7wSNUjfdpnZb+KbQdcA7Jr5ek0od8MD9dNjiN43t4etk1v0ITfyw6gS+Q4l5XwGwbXli+u/sj6pWGu9XfyYXx75d18+lf6t0tnau/pXKv8+xzorIkltn0l4r2dYCXlO8XDRbu9xw/9g/Zko2FXSFtKPxOxn3q+caluteK5lJsboXwVP/S27cPVz28X3i3/Ll/v8eDVMPDmzwvDbwddMt+NoROhq3yXcC4D7KpmTyA+XnqEzSFQrawDeLrsNemHrEL2+24r7NlENZUMa2vyxkH2DIs628e669ubdsR4VXC7C9u79eIVJtOwgdgO/dOICHGK6jQHaIwdXN4Lwt0LWHr4d6kX8tV+ozqAs+uYCSmO2w+jd4zGNeUYL4nqZxeN5WKVgooSAClmEaYhqhdit89QC7niSbCEM2sdkBuHYxQg9ri5ZjkuhI6DMP+J7cTvEtokEx0aPscyddoFJKpSZqV7G1GTxcpmEthpnw5058c6GfwqpwzGOtGjXSJI3FLYhc+O+jSr9aGhPWQlRshS8AticLX7wnsgbXxt6gsWCpRBa0vRGQM8oB9dhmP3QAwFX4c079dJNq6Qi5xbuyTmpPSJ1Ur4UtF7GoTtmUL3zxaWqMU8P/k3cXSQ1EQRjHGdzdHTa4u7tzBs7CedhykNwF2/5jq56iU11db6Lv2yTj8hs3JoiU9sZZp5/62J5v1z9NjrDHaSbnbFMf52sHrDUVaidDxNG0o9+uLjfosfdb3jT5d5j757riJgst9NIZQ2Pn+ySZll80vjI6Wz/hQJG4vPG0L/H6poQch/dW3vL3B0u8jl0HvVj5PvHCElEF8DUAFikVYTcvmfBdDzQlvvMXSV5lP5zrXj/fJ54zuWaeeuoqkW8AwCIaqeTZKkmYrpPwR2eqN9X72W7EG57vU67OBeuMV8KXLUzv93UTTj42tvaFS++GVsc5JRyLSLJ8nzO555hFBmiSRCqMr4GwrcmGkib5xSvcwmzFK6e8s7DMa2xH4YZdZumSOwsVzFeBWdr37tpIhOpSwXqONNgZq/2KgvBt54znHN1HzlljTO4oVD5fb+prNIJXQNL1ofDKQisbPLJDv3jNSLq9OkYBEIihKIj3v7S1TRQCX5Kdl1ZQlol7LF+E++fwirfiq2sf4cTXxc6hzxffPuLEeqSWrPGWMF58TWr5viyJAP5/4EV4KePiaSE8eNRgjDy8/tyRW+FZjhS+2tlovNJovtJovNJ0uhK6Wo64SDdxEbM//KesjwAAAABJRU5ErkJggg==";
var imageSize = [351, 63];
var imageOffset = [20, 20];
var vertices = new Float32Array([
  -0.5,
  -0.5,
  0,
  0.5,
  -0.5,
  0,
  -0.5,
  0.5,
  0,
  0.5,
  0.5,
  0
]);
var uvs = new Float32Array([
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  1
]);
var index = new Uint8Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var geometry = new BufferGeometry();
geometry.setAttribute("position", new BufferAttribute(vertices, 3));
geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
geometry.setIndex(new BufferAttribute(index, 1));
var material = new MeshBasicMaterial({
  transparent: true,
  depthTest: false,
  depthWrite: false,
  stencilWrite: false,
  fog: false
});
var mesh = new Mesh(geometry, material);
mesh.matrixAutoUpdate = false;
var scene = new Scene();
scene.add(mesh);
scene.matrixAutoUpdate = false;
var camera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 1);
camera.position.set(0, 0, 0.5);
camera.lookAt(0, 0, 0);
camera.updateMatrixWorld(true);
camera.matrixAutoUpdate = false;
var prevViewport = new Vector4();
var prevScissor = new Vector4();
function renderPoweredByRealsee(n45) {
  if (material.map) {
    var r = n45.getViewport(prevViewport), o = n45.getScissor(prevScissor), s = n45.getScissorTest(), u = n45.autoClear, l = o.x + imageOffset[0] / 3, c = o.y + imageOffset[1] / 3, f = imageSize[0] / 3, d = imageSize[1] / 3;
    n45.setViewport(l, c, f, d), n45.setScissor(l, c, f, d), n45.setScissorTest(true), n45.autoClear = false, n45.render(scene, camera), n45.setViewport(r), n45.setScissor(o), n45.setScissorTest(s), n45.autoClear = u;
  } else {
    var t = new Texture(), e = new Image();
    e.onload = function() {
      t.image = e, t.wrapS = ClampToEdgeWrapping, t.wrapT = ClampToEdgeWrapping, t.minFilter = LinearFilter, t.needsUpdate = true, t.generateMipmaps = false, material.needsUpdate = true, e.onload = noop$1;
    }, e.src = textureURL, material.map = t;
  }
}
var DEFAULT_MODE_CHANGE_DURATION = 800;
var DEFAULT_CAMERA_FOV = 90;
var DEFAULT_REQUEST_PROXY = function(n45) {
  return n45.replace("//vrlab-public.ljcdn.com/", "//vr-public.realsee-cdn.cn/").replace("//vrlab-image4.ljcdn.com/", "//vr-image-4.realsee-cdn.cn/").replace("//vrlab-image3.ljcdn.com/", "//vr-image-3.realsee-cdn.cn/").replace("//vrlab-image2.ljcdn.com/", "//vr-image-2.realsee-cdn.cn/").replace("//vrlab-image1.ljcdn.com/", "//vr-image-1.realsee-cdn.cn/");
};
var sharedVector2 = new Vector2();
var sharedSphere = new Sphere();
var sharedFrustum = new Frustum();
var sharedProjScreenMatrix = new Matrix4();
var clockForMixer = /* @__PURE__ */ new WeakMap();
var worksMap = /* @__PURE__ */ new WeakMap();
var emptyWorks = createWorks([]);
new Scene2();
var Five = (
  /** @class */
  function(n45) {
    __extends(t, n45);
    function t(e) {
      e === void 0 && (e = {});
      var r, o, s, u, l, c, f, d, h, v, A, g, p = n45.call(this) || this;
      if (p.ident = createUuid(), typeof window != "undefined" && (__FIVE_DEBUG__.instances[p.ident] = p), p.renderSwitch01 = 0, p.currentMode = "Panorama", p.pano = {
        workCode: "",
        panoIndex: 0
      }, p.needsRender = false, p.modelSceneNeedsRender = false, p.onlyRenderIfNeeds = (r = e.onlyRenderIfNeeds) !== null && r !== void 0 ? r : true, p.imageOptions = __assign({}, (o = e.imageOptions) !== null && o !== void 0 ? o : {}), p.textureOptions = __assign({}, (s = e.textureOptions) !== null && s !== void 0 ? s : {}), p.poweredByRealsee = (u = e.poweredByRealsee) !== null && u !== void 0 ? u : true, p.extraElements = [], p.controllerInits = {
        Panorama: Object.assign({}, e.panorama),
        Model: Object.assign({}, e.model),
        Floorplan: Object.assign({}, e.floorplan),
        Topview: Object.assign({}, e.topview),
        Mapview: Object.assign({}, e.mapview),
        VRPanorama: Object.assign({}, e.vrPanorama),
        XRPanorama: Object.assign({}, e.xrPanorama)
      }, p.fps = { testCount: 0, testTime: now() }, p.info = null, p.modeChangeDuration = (l = e.modeChangeDuration) !== null && l !== void 0 ? l : DEFAULT_MODE_CHANGE_DURATION, p.enableWheel = (c = e.enableWheel) !== null && c !== void 0 ? c : true, typeof window != "undefined")
        if ("renderer" in e)
          e.renderer instanceof InternalWebGLRenderer && p.throwError(new Error("cannot render a internal renderer")), p.renderer = e.renderer;
        else
          try {
            p.renderer = new InternalWebGLRenderer({
              preserveDrawingBuffer: e.preserveDrawingBuffer,
              backgroundColor: e.backgroundColor,
              backgroundAlpha: e.backgroundAlpha,
              antialias: e.antialias,
              webgl2: e.webgl2,
              logarithmicDepthBuffer: e.logarithmicDepthBuffer,
              precision: e.precision,
              powerPreference: e.powerPreference
            });
            var y = getViewportScale();
            p.renderer.setPixelRatio(y === 1 ? window.devicePixelRatio : 1), p.renderer.setSize(512, 512);
          } catch (C) {
            C instanceof Error && p.throwError(C);
          }
      p.getPixelsRenderTarget = new WebGLRenderTarget(1, 1, {
        encoding: (d = (f = p.renderer) === null || f === void 0 ? void 0 : f.outputEncoding) !== null && d !== void 0 ? d : sRGBEncoding,
        generateMipmaps: false
      });
      var m = new DepthTexture(1, 1);
      m.generateMipmaps = false, m.format = DepthStencilFormat, m.type = UnsignedInt248Type, p.modelRenderTarget = new WebGLRenderTarget(1, 1, {
        encoding: (v = (h = p.renderer) === null || h === void 0 ? void 0 : h.outputEncoding) !== null && v !== void 0 ? v : sRGBEncoding,
        depthTexture: m,
        generateMipmaps: false,
        depthBuffer: true,
        stencilBuffer: true
      }), p.scissor = Object.assign({ left: 0, bottom: 0, width: 1, height: 1 }, e.scissor), p.camera = new Camera2(DEFAULT_CAMERA_FOV), p.scene = new Scene2(), p.xrCustomObjectsScene = new Scene(), p.scene.add(p.xrCustomObjectsScene), p.scene.matrixAutoUpdate = false, p.lastLoadWorkTask = Promise.resolve(), p.requestProxy = (A = e.requestProxy) !== null && A !== void 0 ? A : DEFAULT_REQUEST_PROXY, p.networkSubscribe = new NetworkSubscribe(), p.networkSubscribe.on("network", function(C, I, _, O) {
        var P;
        p.emit("network.resource", createEvent("network.resource", {
          source: C,
          requestType: I,
          requestState: _,
          detail: O
        })), (P = p.analysis) === null || P === void 0 || P.network(p.works, C, I, _, O);
      }), p.boundingMesh = generateBoundingMesh(new Box3(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5))), p.boundingMesh.name = "bounding", p.models = createModels(), p.models.push(new Model()), p.lastModels = createModels(), p.lastWorks = createWorks([]), p.readyCallbacks = [], p.syncingState = false, p.helperGroup = new Group(), p.helperGroup.name = "helper", p.helperGroup.matrixAutoUpdate = false, p.scene.add(p.helperGroup), p.modelGroup = new Group(), p.modelGroup.visible = false, p.modelGroup.name = "model", p.modelGroup.matrixAutoUpdate = false, p.modelScene = new Scene(), p.modelScene.add(p.modelGroup), p.modelScene.add(p.boundingMesh), p.modelScene.matrixAutoUpdate = false, p.videoTexture = new VideoTexture(e.videoInstance || generateDefaultVideoElement()), initLights(p.scene), initLights(p.modelScene), p.state = {
        mode: p.currentMode,
        workCode: p.pano.workCode,
        panoIndex: p.pano.panoIndex,
        longitude: p.camera.pose.longitude,
        latitude: p.camera.pose.latitude,
        fov: p.camera.pose.fov,
        offset: p.camera.pose.offset.clone(),
        distance: p.camera.pose.distance
      }, p.stateSynced = false, p._enablePostProcessing = false, p._enableIOSEDR = false, p._enableEDL = false, p._enableHQ = false, p.destroyed = false, p.paused = true, typeof window != "undefined" && (e.play !== false && p.play(), p.stopAnimationLoop = AnimationFrameLoop.shared.add(function(C, I) {
        for (var _ = [], O = 2; O < arguments.length; O++)
          _[O - 2] = arguments[O];
        p.updateTime.apply(p, __spreadArray([C, I], _, false));
      }, false, 0, 10));
      var E = function() {
        typeof document != "undefined" && document.fullscreenElement === null && p.currentMode === "VRPanorama" && p.controller.emit("vr.requestExit", createEvent("vr.requestExit", {}));
      }, b = function() {
        p.needsRender = true, p.modelSceneNeedsRender = true;
      };
      if (typeof document != "undefined" && document.addEventListener("fullscreenchange", E, false), p.renderer && p.renderer.domElement.addEventListener("webglcontextrestored", b, false), p.removeEventListeners = function() {
        typeof document != "undefined" && document.removeEventListener("fullscreenchange", E, false), p.renderer && p.renderer.domElement.removeEventListener("webglcontextrestored", b, false);
      }, p.plugins = {}, e.plugins && e.plugins.length)
        for (var T = 0, R = e.plugins; T < R.length; T++) {
          var S = R[T];
          if (typeof S == "function")
            S(p);
          else if (Array.isArray(S)) {
            var M = S[0], w = S[1], H = S[2];
            if (typeof M == "function") {
              var L = M(p, H);
              typeof w == "string" && (p.plugins[w] ? p.throwError(new Error("plugin name ".concat(w, " is exists."))) : p.plugins[w] = L);
            }
          }
        }
      return p.gpuPickingRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: false
      }), p.meshReplaceMaterialMap = /* @__PURE__ */ new Map(), p.meshOriginMaterialMap = /* @__PURE__ */ new Map(), initLegacyEvent(p), p.enableLayeringRendering = (g = e.enableLayeringRendering) !== null && g !== void 0 ? g : false, p;
    }
    return Object.defineProperty(t, "version", {
      get: function() {
        return "6.4.0-alpha.40";
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t, "dracoPath", {
      get: function() {
        return draco.decoderPath;
      },
      set: function(e) {
        draco.setDecoderPath(e);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t, "ktx2Path", {
      get: function() {
        return ktx2.transcoderPath;
      },
      set: function(e) {
        ktx2.setTranscoderPath(e);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "panoIndex", {
      get: function() {
        return this.pano.panoIndex;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.getGPUPicking = function(e, r, o, s, u) {
      var l = this;
      if (s === void 0 && (s = 1), u === void 0 && (u = new Vector3(0, 0, 0)), !this.renderer)
        throw new Error("renderer is not initialized.");
      var c = this.models.getMaterial(), f = c.constantColor, d = c.colorStyle;
      this.models.setMaterial({
        colorStyle: "CONSTANT",
        constantColor: u
      }), this.scene.traverse(function(g) {
        if (!(!(g instanceof Mesh) || g instanceof PBMMesh || g instanceof PBMSkinnedMesh)) {
          var p = Object.keys(o).filter(function(m) {
            return m === g.uuid;
          })[0];
          if (p)
            if (l.meshOriginMaterialMap.set(p, g.material), l.meshReplaceMaterialMap.get(p))
              g.material = l.meshReplaceMaterialMap.get(p);
            else {
              var y = new ShaderMaterial({
                uniforms: {
                  color: {
                    value: o[p]
                  }
                },
                vertexShader: `
          void main() {
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
          }
          `,
                fragmentShader: `
          uniform vec3 color;
          void main() {
            gl_FragColor = vec4( color, 1.0 );
          }
          `
              });
              y.depthTest = g.material.depthTest, y.side = g.material.side, l.meshReplaceMaterialMap.set(p, y), g.material = y;
            }
        }
      });
      var h = this.renderer.getSize(new Vector2());
      this.camera.setViewOffset(h.width, h.height, e * s, r * s, 1, 1), this.renderer.setRenderTarget(this.gpuPickingRenderTarget), this.render();
      var v = new Uint8Array(4);
      this.renderer.readRenderTargetPixels(this.gpuPickingRenderTarget, 0, 0, 1, 1, v), this.renderer.setRenderTarget(null), this.camera.clearViewOffset(), this.scene.traverse(function(g) {
        !(g instanceof Mesh) || g instanceof PBMMesh || g instanceof PBMSkinnedMesh || l.meshOriginMaterialMap.get(g.uuid) && (g.material = l.meshOriginMaterialMap.get(g.uuid));
      }), this.models.setMaterial({ colorStyle: d, constantColor: f });
      var A = Object.keys(o).filter(function(g) {
        return o[g].equals(new Color().setRGB(v[0] / 255, v[1] / 255, v[2] / 255));
      })[0];
      return A || false;
    }, t.prototype.dispose = function() {
      var e, r;
      if (this.destroyed !== true) {
        delete __FIVE_DEBUG__.instances[this.ident], this.emit("dispose"), this.destroyed = true, this.pause(), this.stopAnimationLoop && (this.stopAnimationLoop(), delete this.stopAnimationLoop), (e = this.renderer) === null || e === void 0 || e.setAnimationLoop(null), this.off(), this.networkSubscribe.off(), this.controller && (this.controller.destroy(), this.controller = void 0);
        var o = this.getElement();
        o && o.parentNode && o.parentNode.removeChild(o);
        var s = this.models.getMaterial();
        s && (s.pano0 && s.pano0.map.dispose(), s.pano1 && s.pano1.map !== ((r = s.pano0) === null || r === void 0 ? void 0 : r.map) && s.pano1.map.dispose());
        for (var u = 0, l = this.models; u < l.length; u++) {
          var c = l[u];
          c.dispose();
        }
        this.models.length = 0, this.models.setMaterial({ pano0: null, pano1: null }), this.meshReplaceMaterialMap.forEach(function(f) {
          f.dispose();
        }), this.meshOriginMaterialMap.forEach(function(f) {
          f.dispose();
        }), this.renderer instanceof InternalWebGLRenderer && this.renderer.forceContextLoss && this.renderer.forceContextLoss();
      }
    }, t.prototype.setScissor = function(e) {
      var r;
      if (Object.assign(this.scissor, e), this.controller && this.controller.updateRenderSize) {
        var o = new Vector2();
        (r = this.renderer) === null || r === void 0 || r.getDrawingBufferSize(o), this.controller.updateRenderSize(o);
      }
    }, Object.defineProperty(t.prototype, "helperVisible", {
      /**
       * /
       */
      get: function() {
        return this.helperGroup.visible;
      },
      set: function(e) {
        this.helperGroup.visible !== e && (this.helperGroup.visible = e, this.emit("helpers.visible", createEvent("helpers.visible", {
          object: this.helperGroup
        })), this.needsRender = true);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "enableIOSEDR", {
      /**
       *  IOS EDR 
       * 
       *  five.enablepostProcessing = true
       */
      get: function() {
        return this._enableIOSEDR;
      },
      set: function(e) {
        this._enableIOSEDR !== e && (this._enableIOSEDR = e, this.currentMode && this.currentMode === "Panorama" && this.changeMode(this.currentMode, this.getCurrentState(), 0, false, true));
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "postProcessingType", {
      /**
       * 
      */
      get: function() {
        return this.currentMode === "Panorama" && this.enableIOSEDR && this.enablePostProcessing ? "luminance" : this.currentMode === "Mapview" && this.enableEDL ? "edl" : this.currentMode === "Mapview" && this.enableHQ ? "hq" : null;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "enableEDL", {
      /**
       * EDL
      */
      get: function() {
        return this._enableEDL;
      },
      set: function(e) {
        if (e === true && this.currentMode !== t.Mode.Mapview)
          throw new Error("MapviewEDL");
        this._enableEDL !== e && (this._enableEDL = e, this.boundingMesh.visible = !e, this.needsRender = true, this.modelSceneNeedsRender = true);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "enableHQ", {
      get: function() {
        return this._enableHQ;
      },
      // HQ
      set: function(e) {
        if (e === true && this.currentMode !== t.Mode.Mapview)
          throw new Error("MapviewHQ");
        this._enableHQ !== e && (this._enableHQ = e, this.boundingMesh.visible = !e, this.needsRender = true, this.modelSceneNeedsRender = true);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "enablePostProcessing", {
      /**
       * 
       */
      get: function() {
        return this._enablePostProcessing;
      },
      set: function(e) {
        this._enablePostProcessing !== e && (this._enablePostProcessing = e), this.needsRender = true, this.modelSceneNeedsRender = true;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.updateConfiguration = function(e, r) {
      r === void 0 && (r = true);
      var o = false;
      if (e.panorama && (Object.assign(this.controllerInits.Panorama, omitUndefinedFields(e.panorama)), this.currentMode === "Panorama" && (o = true)), e.model && (Object.assign(this.controllerInits.Model, omitUndefinedFields(e.model)), this.currentMode === "Model" && (o = true)), e.floorplan && (Object.assign(this.controllerInits.Floorplan, omitUndefinedFields(e.floorplan)), this.currentMode === "Floorplan" && (o = true)), e.topview && (Object.assign(this.controllerInits.Topview, omitUndefinedFields(e.topview)), this.currentMode === "Topview" && (o = true)), e.mapview && (Object.assign(this.controllerInits.Mapview, omitUndefinedFields(e.mapview)), this.currentMode === "Mapview" && (o = true)), e.vrPanorama && (Object.assign(this.controllerInits.VRPanorama, omitUndefinedFields(e.vrPanorama)), this.currentMode === "VRPanorama" && (o = true)), e.imageOptions && (Object.assign(this.imageOptions, e.imageOptions), (this.currentMode === "Panorama" || this.currentMode === "VRPanorama") && (o = true)), e.textureOptions && Object.assign(this.textureOptions, e.textureOptions), r && o && this.controller && this.currentMode) {
        var s = this.controller.updateConfiguration(this.controllerInits[this.currentMode]);
        s || this.changeMode(this.currentMode, this.getCurrentState(), 0, false, true);
      }
    }, t.prototype.appendTo = function(e, r) {
      if (r === void 0 && (r = {}), !!this.renderer) {
        if (!(this.renderer instanceof InternalWebGLRenderer)) {
          this.throwError(new Error("cannot call appendTo method when render a external renderer"));
          return;
        }
        var o = this.getElement();
        if (o) {
          e.appendChild(o), this.refresh(r);
          var s = window.getComputedStyle(e).position;
          s !== "relative" && s !== "absolute" && s !== "fixed" && s !== "sticky" && (e.style.position = "relative");
        }
      }
    }, t.prototype.refresh = function(e, r) {
      if (e === void 0 && (e = {}), !!this.renderer) {
        var o = this.getElement();
        if (o) {
          var s = o.parentNode;
          if (s && s.nodeName) {
            var u = e.width, l = u === void 0 ? s.offsetWidth : u, c = e.height, f = c === void 0 ? s.offsetHeight : c;
            this.renderer instanceof InternalWebGLRenderer && (r && this.renderer.setPixelRatio(r), this.renderer.setSize(l, f));
          }
          var d = new Vector2();
          if (this.renderer.getDrawingBufferSize(d), this.controller && this.controller.updateRenderSize && this.controller.updateRenderSize(d), this.modelRenderTarget.width !== d.x || this.modelRenderTarget.height !== d.y) {
            this.modelRenderTarget.setSize(d.x, d.y), this.modelRenderTarget.depthTexture.dispose();
            var h = new DepthTexture(d.x, d.y);
            h.generateMipmaps = false, h.format = DepthStencilFormat, h.type = UnsignedInt248Type, this.modelRenderTarget.depthTexture = h, this.modelRenderTarget.depthTexture.needsUpdate = true;
          }
          this.needsRender = true, this.modelSceneNeedsRender = true, this.render(noop$1, true);
        }
      }
    }, t.prototype.addExtraElement = function(e) {
      var r = this;
      return this.extraElements.indexOf(e) === -1 && (this.extraElements.push(e), this.controller && this.controller.bindExtraElement(e)), function() {
        return r.removeExtraElement(e);
      };
    }, t.prototype.removeExtraElement = function(e) {
      var r = this.extraElements.indexOf(e);
      r !== -1 && (this.extraElements.splice(r, 1), this.controller && this.controller.unbindExtraElement(e));
    }, t.prototype.getPose = function() {
      var e = this.camera.copyPose(), r = e.longitude, o = e.latitude, s = e.fov, u = e.offset, l = e.distance;
      return { longitude: r, latitude: o, fov: s, offset: u.clone(), distance: l };
    }, t.prototype.getSize = function(e) {
      if (!this.renderer)
        throw new Error("renderer is not initialized");
      return this.renderer.getSize(e), e.x *= this.scissor.width, e.y *= this.scissor.height, e;
    }, t.prototype.getDrawingBufferSize = function(e) {
      if (!this.renderer)
        throw new Error("renderer is not initialized");
      return this.renderer.getDrawingBufferSize(e), e.x *= this.scissor.width, e.y *= this.scissor.height, e;
    }, t.prototype.updateCamera = function(e, r, o) {
      if (o === void 0 && (o = true), !this.controller)
        throw new Error("controller is not initialized.");
      return this.controller.updateCamera(e, r, o);
    }, t.prototype.updateCameraWithKeyframes = function(e, r, o) {
      if (o === void 0 && (o = true), !this.controller)
        throw new Error("controller is not initialized.");
      return this.controller.updateCameraWithKeyframes(e, r, o);
    }, t.prototype.getLongitudeAndLatitude = function() {
      var e = this.getPose(), r = e.longitude, o = e.latitude;
      return { longitude: r, latitude: o };
    }, t.prototype.getOffset = function() {
      return this.getPose().offset;
    }, t.prototype.getCameraLocal = function() {
      if (this.pano.workCode && this.controller && this.works) {
        var e = this.works.getResolvedObserver(this.pano);
        if (e) {
          var r = new Object3D();
          return r.position.copy(e.position), r.quaternion.copy(e.quaternion), r.scale.set(1, 1, 1), r.matrix.compose(r.position, r.quaternion, r.scale), r.matrixAutoUpdate = false, cameraWorldToLocal(this.camera, r);
        }
      }
      return null;
    }, Object.defineProperty(t.prototype, "works", {
      /**  work  */
      get: function() {
        var e = worksMap.get(this);
        if (!e)
          return emptyWorks;
        for (var r = 0, o = e; r < o.length; r++) {
          var s = o[r];
          if (!workRawMapping.has(s))
            return emptyWorks;
        }
        return e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "work", {
      get: function() {
        return this.works[0];
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "model", {
      get: function() {
        return this.models[0];
      },
      enumerable: false,
      configurable: true
    }), t.prototype.load = function(e, r, o, s) {
      var u = this;
      if (s === void 0 && (s = true), !this.renderer)
        throw new Error("renderer is not initialized");
      var l = this.lastLoadWorkTask.then(function() {
        return isPromise(e) ? e.then(function(c) {
          return u.load_(c, r, o, s);
        }) : u.load_(e, r, o, s);
      });
      return this.lastLoadWorkTask = l.catch(function(c) {
        u.throwError(c);
      }), l;
    }, t.prototype.load_ = function(e, r, o, s) {
      var u = this, l, c, f, d, h, v, A, g;
      s === void 0 && (s = true);
      var p = {};
      typeof o == "number" ? p.duration = o : typeof o == "object" && Object.assign(p, o), this.works === emptyWorks && (p.duration === void 0 && (p.duration = 0), p.effect === void 0 && (p.effect = "instant"));
      var y = [];
      if (Array.isArray(e))
        for (var m = 0, E = e; m < E.length; m++) {
          var b = E[m];
          typeof b != "string" && "work" in b ? y.push(parseWork(b.work, b)) : y.push(parseWork(b));
        }
      else
        y.push(parseWork(e));
      for (var T = createWorks(y), R = function(X) {
        var $ = S, W = new Fetcher({
          allowHosts: X.allowHosts,
          get requestProxy() {
            return $.requestProxy;
          },
          get networkSubscribe() {
            return $.networkSubscribe;
          }
        });
        registerFetcher(X, W);
      }, S = this, M = 0, w = T; M < w.length; M++) {
        var H = w[M];
        R(H);
      }
      this.lastWorks = this.works, r === void 0 && (r = "inherit"), r === "inherit" && this.lastWorks.length === 0 && (r = "initial");
      var L = T.initial, C = L.work.observers[0], I = C ? {
        workCode: C.work.workCode,
        panoIndex: C.panoIndex
      } : {
        workCode: L.work.workCode,
        panoIndex: 0
      }, _ = (l = L.mode) !== null && l !== void 0 ? l : C ? "Panorama" : "Mapview", O = {};
      if (r === "inherit") {
        _ = this.currentMode;
        var P = T.resolvedObservers[this.panoIndex];
        P ? I = {
          workCode: P.work.workCode,
          panoIndex: P.panoIndex
        } : typeof T.initial.panoIndex == "number" ? I = {
          workCode: T.initial.work.workCode,
          panoIndex: T.initial.panoIndex
        } : (_ === "Panorama" || _ === "VRPanorama" || _ === "XRPanorama") && (_ = "Mapview"), O = {
          longitude: this.camera.pose.longitude,
          latitude: this.camera.pose.latitude,
          fov: this.camera.pose.fov,
          distance: void 0,
          offset: void 0
        };
      } else if (r === "initial")
        typeof L.panoIndex == "number" && (I = {
          workCode: L.work.workCode,
          panoIndex: L.panoIndex
        }), L.mode && (_ = L.mode), O = {
          longitude: L.longitude,
          latitude: L.latitude,
          fov: L.fov,
          distance: L.distance,
          offset: (c = L.offset) === null || c === void 0 ? void 0 : c.clone()
        };
      else {
        if (_ = (f = r.mode) !== null && f !== void 0 ? f : this.currentMode, typeof r.panoIndex == "number") {
          var P = T.getResolvedObserver({
            workCode: (h = (d = r.workCode) !== null && d !== void 0 ? d : L.work.workCode) !== null && h !== void 0 ? h : "",
            panoIndex: r.panoIndex
          });
          P && (I = {
            workCode: P.work.workCode,
            panoIndex: P.panoIndex
          });
        }
        O = {
          longitude: r.longitude,
          latitude: r.latitude,
          fov: r.fov,
          distance: r.distance,
          offset: r.offset
        };
      }
      var N = __assign(__assign(__assign({}, I), { mode: _ }), O), k = this.getCurrentState(), U = (v = p.duration) !== null && v !== void 0 ? v : this.modeChangeDuration;
      (_ === "Floorplan" || _ === "Topview" || _ === "Mapview") && this.currentMode === _ && (U = 0);
      var D = "fly";
      (_ === "Panorama" || _ === "VRPanorama" || _ === "XRPanorama") && this.currentMode === _ && (D = (A = p.effect) !== null && A !== void 0 ? A : "fade"), this.emit("works.request", createEvent("works.request", {
        input: e,
        works: T,
        state: N,
        userAction: s
      }));
      var q = function() {
        u.modelGroup.visible = true, u.pano = I;
        var X = __assign(__assign({ initial: {
          state: N,
          currentState: k,
          duration: U,
          effect: D,
          userAction: s
        } }, u.commonParams()), u.controllerInits[_]), $ = Controllers[_].initAnimationEndState(X);
        if (u.controller && u.currentMode === _)
          u.controller.updateWork(T, $, { effect: D, duration: U }, s) === false && (u.controller.destroy(), u.controller = u.applyController(_, X));
        else {
          var W = u.currentMode;
          if (u.controller)
            u.controller.destroy();
          else {
            var oe = Controllers[_].initAnimationEndState(X);
            u.camera.setFromPose(oe), u.emit("camera.update", createEvent("camera.update", {
              state: u.getCurrentState(),
              userAction: s
            }));
          }
          u.controller = u.applyController(_, X);
          var ie = createEvent("mode.change", {
            prevMode: W,
            mode: _,
            state: $,
            userAction: s
          });
          u.emit("mode.change", ie);
        }
      };
      worksMap.set(this, T);
      var z = Promise.resolve();
      if (_ === t.Mode.Floorplan || _ === t.Mode.Topview || _ === t.Mode.Mapview || _ === t.Mode.Model)
        this.models.loaded === false && (this.camera.setFromPose(N), assignPose(this.state, this.camera.pose)), this.controller || (this.currentMode = _), z = this.loadModel(T, p).then(function() {
          u.needsRender = true, u.modelSceneNeedsRender = true, q(), u.emit("camera.update", createEvent("camera.update", {
            state: u.getCurrentState(),
            userAction: s
          }));
        });
      else {
        q();
        var Q = false, G = function() {
          u.works === T && Q === false && (u.needsRender = true, u.modelSceneNeedsRender = true, u.emit("camera.update", createEvent("camera.update", {
            state: u.getCurrentState(),
            userAction: s
          })), u.loadModel(T, p), Q = true);
        };
        this.controller.once("pano.arrived", G), this.controller.once("pano.cancel", G), setTimeout(G, ((g = p.duration) !== null && g !== void 0 ? g : this.modeChangeDuration) + 1e3);
      }
      return this.emit("works.load", createEvent("works.load", {
        input: e,
        state: this.getCurrentState(),
        userAction: s,
        works: T
      })), z.then(function() {
        return u.ready();
      }).then(function() {
        var X;
        u.emit("works.ready", createEvent("works.ready", {
          input: e,
          state: u.getCurrentState(),
          userAction: s,
          works: T
        })), (X = u.analysis) === null || X === void 0 || X.work(T);
      });
    }, t.prototype.reset = function() {
      var e = this, r = this.lastLoadWorkTask.then(function() {
        return e.reset_();
      });
      return this.lastLoadWorkTask = r.catch(function(o) {
        e.throwError(o);
      }), r;
    }, t.prototype.reset_ = function() {
      var e = this;
      return new Promise(function(r) {
        var o;
        e.controller && (e.controller.destroy(), e.controller = void 0);
        var s = e.models.getMaterial();
        s && (s.pano0 && s.pano0.map.dispose(), s.pano1 && s.pano1.map !== ((o = s.pano0) === null || o === void 0 ? void 0 : o.map) && s.pano1.map.dispose()), e.models.setMaterial({ pano0: null, pano1: null, modelAlpha: 1 }), e.lastModels.setMaterial({ pano0: null, pano1: null, modelAlpha: 1 }), e.renderer && (e.models.update(e.renderer, e.camera, e.currentMode), e.lastModels.update(e.renderer, e.camera, e.currentMode), e.model && e.boundingMesh.update(e.renderer, e.camera, e.model));
        for (var u = 0, l = e.models; u < l.length; u++) {
          var c = l[u];
          e.lastModels.push(c);
        }
        if (e.models.length = 0, e.lastModels.length > 0) {
          for (var f = 0, d = e.lastModels; f < d.length; f++) {
            var c = d[f];
            e.modelGroup.remove(c), c.dispose(), e.needsRender = true, e.modelSceneNeedsRender = true;
          }
          e.lastModels.length = 0;
        }
        e.lastWorks && delete e.lastWorks, worksMap.delete(e), e.currentMode = "Mapview", e.pano = {
          workCode: "",
          panoIndex: 0
        }, e.camera.setFromPose({
          distance: 0,
          fov: DEFAULT_CAMERA_FOV,
          longitude: 0,
          latitude: 0,
          offset: new Vector3(0, 0, 0)
        }), e.state = {
          mode: e.currentMode,
          workCode: e.pano.workCode,
          panoIndex: e.pano.panoIndex,
          longitude: e.camera.pose.longitude,
          latitude: e.camera.pose.latitude,
          fov: e.camera.pose.fov,
          offset: e.camera.pose.offset.clone(),
          distance: e.camera.pose.distance
        }, e.models.needsRender = false, e.camera.needsRender = false, e.needsRender = false, e.modelSceneNeedsRender = false, r();
      });
    }, t.prototype.changeMode = function(e, r, o, s, u) {
      var l = this;
      return r === void 0 && (r = {}), s === void 0 && (s = true), u === void 0 && (u = false), new Promise(function(c, f) {
        var d, h, v, A;
        if (!l.renderer)
          throw new Error("renderer is not initialized.");
        r = __assign({}, r);
        var g = 0;
        l.controller && (typeof o == "number" ? g = o : g = (d = o == null ? void 0 : o.duration) !== null && d !== void 0 ? d : l.modeChangeDuration);
        var p = "fly";
        l.controller && typeof o == "object" && o.effect && (p = o.effect);
        var y = typeof r.panoIndex == "number" ? {
          workCode: (A = (h = r.workCode) !== null && h !== void 0 ? h : (v = l.work) === null || v === void 0 ? void 0 : v.workCode) !== null && A !== void 0 ? A : "",
          panoIndex: r.panoIndex
        } : l.pano;
        if (!t.Mode.hasOwnProperty(e)) {
          var m = new Error('mode "'.concat(e, '" is not existed'));
          l.throwError(m), f(m);
          return;
        }
        if ((e === t.Mode.Panorama || e === t.Mode.VRPanorama || e === t.Mode.XRPanorama) && !l.works.getResolvedObserver(y)) {
          var m = new Error("PanoId ".concat(panoStringify(y), " not existed."));
          l.throwError(m), f(m);
          return;
        }
        (e === t.Mode.Floorplan || e === t.Mode.Topview || e === t.Mode.Mapview || e === t.Mode.Model) && (l.models.loaded || (g = 0));
        var E = l.controller, b = l.currentMode, T = function() {
          if (l.controller && l.controller.stopMomentumMovement(), l.controller && u === false && b === e)
            e === t.Mode.Panorama || e === t.Mode.Model || e === t.Mode.VRPanorama || e === t.Mode.XRPanorama ? !panoEqual(l.pano, y) && "moveToPano" in l.controller && typeof l.controller.moveToPano == "function" ? l.controller.moveToPano(y, __assign({ duration: g }, r), s) : l.controller.updateCamera(r, g, s).catch(noop$1) : (panoEqual(l.pano, y) || (l.pano = y), l.controller.updateCamera(r, g, s).catch(noop$1));
          else {
            var S = __assign(__assign({}, r), y), M = __assign(__assign({ initial: {
              state: S,
              currentState: l.getCurrentState(),
              duration: g,
              effect: p,
              userAction: s
            } }, l.commonParams()), l.controllerInits[e]), w = Controllers[e].initAnimationEndState(M), H = createEvent("mode.change.request", {
              prevMode: l.currentMode,
              mode: e,
              state: w,
              userAction: s
            });
            if (l.emit("mode.change.request", H), !H.defaultPrevented) {
              E && E.destroy(), l.controller = l.applyController(e, M);
              var L = createEvent("mode.change", {
                prevMode: l.currentMode,
                mode: e,
                state: w,
                userAction: s
              });
              l.emit("mode.change", L);
            }
          }
          c();
        };
        if (e === t.Mode.VRPanorama)
          l.requestFullscreen(), requestDeviceOrientationPermission().then(function() {
            return T();
          }).catch(function(S) {
            S instanceof Error && (l.exitFullscreen(), l.throwError(S), f(S));
          });
        else if (e === t.Mode.XRPanorama) {
          var R = AnimationFrameLoop.shared.getContext();
          R ? R.end() : requestXRSessionPermission().then(function(S) {
            AnimationFrameLoop.shared.setContext(S), T();
          }).catch(function(S) {
            S instanceof Error && (l.throwError(S), f(S));
          });
        } else
          T();
      });
    }, t.prototype.getPixels = function(e, r, o, s, u, l, c) {
      if (!this.renderer)
        throw new Error("renderer is not initialized.");
      var f = this.renderer.getPixelRatio(), d = this.renderer.getRenderTarget(), h = this.renderer.getSize(new Vector2()), v = 0, A = 0, g = 1, p = 1, y, m, E, b, T;
      typeof e == "number" ? (v = e, typeof r == "number" && (A = r), typeof o == "number" && (g = o), typeof s == "number" && (p = s), y = u, m = l, T = c) : (v = e.x, A = e.y, g = e.width, p = e.height, y = e.pixelRatio, m = e.flipY, E = e.helperVisible, b = e.skipPanorama, T = e.buffer), v = Math.ceil(v), A = Math.ceil(A), g = Math.ceil(g), p = Math.ceil(p), y = Math.ceil(y != null ? y : f), m = m != null ? m : false;
      var R = this.getPixelsRenderTarget;
      R.setSize(g * y, p * y), this.renderer.setRenderTarget(R), this.camera.pixelRatio = y, this.camera.resolution.set(g, p), this.camera.setViewOffset(h.width, h.height, v, h.height - A - p, g, p);
      for (var S = 0, M = this.scene.children; S < M.length; S++) {
        var w = M[S];
        w instanceof Object3D && w.traverseVisible(function(G) {
          G.setResolution && G.setResolution(g * y / f, p * y / f);
        });
      }
      this.models.autoUpdate = false;
      var H = true, L = 0;
      b && (this.controller instanceof Controllers.Panorama || this.controller instanceof Controllers.VRPanorama || this.controller instanceof Controllers.XRPanorama) && (H = this.controller.tiling.object.visible, this.controller.tiling.object.visible = false, L = this.models.getMaterial().modelAlpha, this.models.setMaterial({ modelAlpha: b === true ? 1 : L }));
      var C = this.helperVisible;
      E === false && (this.helperVisible = false), this.models.update(this.renderer, this.camera, this.currentMode), this.controller ? (this.controller.updateRenderSize(new Vector2(g * y, p * y)), this.controller.render(true, this.postProcessingType)) : (this.renderer.render(this.scene, this.camera), this.renderer.autoClearDepth = false, this.renderer.autoClearColor = false, this.renderer.render(this.modelScene, this.camera), this.renderer.autoClearDepth = true, this.renderer.autoClearColor = true), this.helperVisible = C, b && (this.controller instanceof Controllers.Panorama || this.controller instanceof Controllers.VRPanorama || this.controller instanceof Controllers.XRPanorama) && (this.controller.tiling.object.visible = H, this.models.setMaterial({ modelAlpha: L })), this.models.update(this.renderer, this.camera, this.currentMode), this.models.autoUpdate = true;
      var I = g * y, _ = p * y, O = I * _, P = O * 4, N;
      try {
        if (T) {
          if (T.length !== P)
            throw new Error("buffer length is not equals pixels ".concat(P));
        } else
          T = new Uint8Array(P);
        if (this.renderer.readRenderTargetPixels(R, 0, 0, g * y, p * y, T), m)
          for (var k = O / 2, U = 0, D = 0, q = 0, z = 0; D < k; D++)
            for (z = (_ - Math.floor(D / I) - 1) * I + D % I, q = 0; q < 4; q++)
              U = T[D * 4 + q], T[D * 4 + q] = T[z * 4 + q], T[z * 4 + q] = U;
      } catch (G) {
        N = G;
      }
      if (this.renderer.setRenderTarget(d), this.controller && this.controller.updateRenderSize) {
        var Q = new Vector2();
        this.renderer.getDrawingBufferSize(Q), this.controller.updateRenderSize(Q);
      }
      if (this.camera.clearViewOffset(), this.camera.pixelRatio = f, this.getSize(this.camera.resolution), this.camera.aspect = this.camera.resolution.width / this.camera.resolution.height, N)
        throw N;
      return T;
    }, t.prototype.getElement = function() {
      var e;
      return (e = this.renderer) === null || e === void 0 ? void 0 : e.domElement;
    }, Object.defineProperty(t.prototype, "observers", {
      /**
       * 
       */
      get: function() {
        return this.works.resolvedObservers;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.render = function(e, r) {
      var o = this;
      if (r === void 0 && (r = false), !this.renderer)
        return null;
      if (r) {
        var s = this.renderer.getSize(sharedVector2);
        this.scene.traverseVisible(function(u) {
          u.setResolution && u.setResolution(s.x, s.y);
        });
      }
      return this.aroundScissor(function() {
        if (o.renderer) {
          var u = o.scene.background;
          o.modelScene.background = o.camera.isOrthographicCamera ? null : u, o.modelScene.environment = o.scene.environment, o.scene.background = null, o.controller ? (o.controller.render(o.onlyRenderIfNeeds ? o.modelSceneNeedsRender : true, o.postProcessingType), o.info = {
            memory: __assign({}, o.controller.renderer.info.memory),
            render: __assign({}, o.controller.renderer.info.render)
          }) : (o.renderer.render(o.scene, o.camera), o.info = {
            memory: __assign({}, o.renderer.info.memory),
            render: __assign({}, o.renderer.info.render)
          }), o.scene.background = u, o.modelScene.background = null, o.modelScene.environment = null, o.poweredByRealsee && o.currentMode !== "VRPanorama" && o.currentMode !== "XRPanorama" && o.renderer.getRenderTarget() !== o.getPixelsRenderTarget && renderPoweredByRealsee(o.renderer);
        }
        e && AnimationFrameLoop.shared.add(e, true);
      }), null;
    }, t.prototype.updateTime = function(e, r) {
      for (var o, s = this, u = [], l = 2; l < arguments.length; l++)
        u[l - 2] = arguments[l];
      if (!this.destroyed) {
        if (this.works.update(), this.syncingState = this.syncState(e, r), this.controller && (o = this.controller).updateTime.apply(o, __spreadArray([e, r], u, false)), this.renderer && (this.camera.pixelRatio = this.renderer.getPixelRatio(), this.getSize(this.camera.resolution), this.camera.aspect = this.camera.resolution.width / this.camera.resolution.height), this.camera.environment = this.scene.environment, this.camera.updateTime(e), this.renderer) {
          ktx2.detectSupport(this.renderer);
          var c = this.models.loaded, f = this.models.refined;
          if (this.models.update(this.renderer, this.camera, this.currentMode), this.camera.autoNearFar) {
            var d = this.models.bounding.getBoundingSphere(sharedSphere), h = d.radius * 2;
            d.containsPoint(this.camera.position) || (h = this.camera.position.distanceTo(d.center) + d.radius), h = clamp$1(h, 800, 5e4), this.camera.far !== h && (this.camera.far = h);
            var v = h / 1e4;
            v = clamp$1(v, 0.03, 0.1), this.camera.near !== v && (this.camera.near = v);
          }
          if (c === false && this.models.loaded === true && this.emit("models.load", createEvent("models.load", {
            models: this.models
          })), f === false && this.models.refined === true && this.emit("models.refined", createEvent("models.refined", {
            models: this.models
          })), this.models.loaded) {
            for (var A = 0, g = this.models; A < g.length; A++) {
              var p = g[A];
              p.parent !== this.modelGroup && (this.modelGroup.add(p), this.needsRender = true, this.modelSceneNeedsRender = true);
            }
            if (this.lastModels.length > 0) {
              for (var y = 0, m = this.lastModels; y < m.length; y++) {
                var p = m[y];
                this.modelGroup.remove(p), p.dispose(), this.needsRender = true, this.modelSceneNeedsRender = true;
              }
              this.lastModels.length = 0;
            }
            this.lastWorks && delete this.lastWorks;
          }
          this.lastModels.setMaterial(this.models.getMaterial()), this.lastModels.materialVersion = this.models.materialVersion, this.lastModels.update(this.renderer, this.camera, this.currentMode);
        }
        this.syncingState = false;
        var E = new Vector2(512, 512), b = new Vector2(512, 512);
        this.renderer && (this.renderer.getSize(E), E.x *= this.scissor.width, E.y *= this.scissor.height, this.renderer.getDrawingBufferSize(b), b.x *= this.scissor.width, b.y *= this.scissor.height);
        {
          for (var T = new Box3(), R = new Box3(), S = new Vector3(4, 4, 4), M = 0, w = this.works.resolvedObservers; M < w.length; M++) {
            var H = w[M];
            R.setFromCenterAndSize(H.position, S), T.union(R);
          }
          if (T.union(this.models.bounding), this.lastWorks)
            for (var L = 0, C = this.lastWorks.resolvedObservers; L < C.length; L++) {
              var H = C[L];
              R.setFromCenterAndSize(H.position, S), T.union(R);
            }
          T.union(this.lastModels.bounding), T.getCenter(this.boundingMesh.position), T.getSize(this.boundingMesh.scale), this.boundingMesh.boundingBox.copy(T), this.renderer && this.model && this.boundingMesh.update(this.renderer, this.camera, this.model);
        }
        var I = createEvent("render.prepare", {
          needsRender: true,
          info: null
        });
        if (this.emit("render.prepare", I), !I.defaultPrevented) {
          var _ = [];
          sharedProjScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), sharedFrustum.setFromProjectionMatrix(sharedProjScreenMatrix);
          for (var O = 0, P = this.scene.children; O < P.length; O++) {
            var N = P[O];
            N !== this.modelGroup && N !== this.boundingMesh && N.traverseVisible(function(Q) {
              if (Q.setResolution && Q.setResolution(E.x, E.y), Q.setTime && Q.setTime(e), Q.mixer instanceof AnimationMixer) {
                var G = clockForMixer.get(Q.mixer);
                G || (G = new Clock(), clockForMixer.set(Q.mixer, G)), Q.mixer.update(G.getDelta());
              }
              (Q instanceof Mesh || Q instanceof Line || Q instanceof Points) && (Q instanceof ImmediateRenderObject || !Q.frustumCulled || sharedFrustum.intersectsObject(Q)) && _.push(Q);
            });
          }
          if (b.width * b.height > 4096 * 2048 ? this.renderSwitch01 = this.renderSwitch01 ^ 1 : this.renderSwitch01 = 0, this.renderer && this.paused === false && this.renderSwitch01 === 0) {
            var k = void 0;
            if (this.onlyRenderIfNeeds !== true)
              k = this.render();
            else {
              if (this.controller && (this.controller.needsRender === true && (this.controller.needsRender = false, this.needsRender = true), this.controller.modelSceneNeedsRender === true && (this.controller.modelSceneNeedsRender = false, this.modelSceneNeedsRender = true)), this.camera.needsRender === true && (this.camera.needsRender = false, this.needsRender = true, this.modelSceneNeedsRender = true), this.models.needsRender === true && (this.models.needsRender = false, this.needsRender = true, this.modelSceneNeedsRender = true), this.needsRender !== true)
                for (var U = 0, D = _; U < D.length; U++) {
                  var q = D[U], z = function(Q) {
                    Q.needsRender === true ? (Q.needsRender = false, s.needsRender = true) : Q.mixer && Q.mixer.stats.actions.inUse > 0 && (s.needsRender = true);
                  };
                  z(q), q.traverseAncestors(z);
                }
              (this.needsRender !== false || this.modelSceneNeedsRender !== false) && (k = this.render());
            }
            this.needsRender = false, this.modelSceneNeedsRender = false, this.hasListener("render") && this.emit("render", createEvent("render", {
              needsRender: k !== void 0,
              info: this.info
            }));
          }
          this.needsRender = false, this.modelSceneNeedsRender = false;
        }
        this.fps.testTime && e - this.fps.testTime < 1e3 ? this.fps.testCount++ : (this.emit("fps", this.fps.testCount), this.fps.testTime = e, this.fps.testCount = 0);
      }
    }, t.prototype.pause = function() {
      this.paused = true, this.renderer && this.renderer instanceof InternalWebGLRenderer && this.renderer.clear(true, true, true);
    }, t.prototype.play = function() {
      this.needsRender = true, this.modelSceneNeedsRender = true, this.paused = false;
    }, t.prototype.moveToPano = function(e, r, o) {
      r === void 0 && (r = {}), o === void 0 && (o = true);
      var s = this, u = s.controller, l = s.renderer;
      if (!u)
        return this.throwError(new Error("controller is not initialized.")), Promise.resolve();
      if (!l)
        return this.throwError(new Error("renderer is not initialized.")), Promise.resolve();
      var c = this.works.getResolvedObserver(e);
      if (!c)
        return this.throwError(new Error("pano ".concat(JSON.stringify(e), " not existed."))), Promise.resolve();
      var f = {
        workCode: c.work.workCode,
        panoIndex: c.panoIndex
      };
      return "moveToPano" in u && typeof u.moveToPano == "function" ? u.moveToPano(f, r, o) : c && (this.pano = f, this.once("initAnimation.start", function(d) {
        r.moveStartCallback && r.moveStartCallback(d.state);
      }), this.once("initAnimation.end", function(d) {
        r.moveEndCallback && r.moveEndCallback(d.state);
      }), this.changeMode(t.Mode.Panorama, r, { effect: r.effect }, o)), this.ready();
    }, t.prototype.preloadPano = function(e, r) {
      var o = this;
      r === void 0 && (r = noop$1);
      var s = this.works.getResolvedObserver(e);
      if (!s)
        return Promise.reject(new Error("Pano ".concat(JSON.stringify(e), " never found")));
      var u = ["right", "left", "up", "down", "front", "back"], l = now();
      return Promise.all(u.map(function(c) {
        var f = __assign({ key: "pano.".concat(s.panoId, ".").concat(c) }, pick(o.imageOptions, ["size", "format", "quality", "mappings"])), d = s.images[c], h = o.imageOptions.transform ? o.imageOptions.transform(d, f) : imageURL(d, f);
        return getFetcher(s.work).preload(h);
      })).then(function() {
        var c = now() - l;
        return r(c), c;
      });
    }, t.prototype.project2d = function(e, r) {
      if (r === void 0 && (r = false), !this.renderer)
        return null;
      if (this.models.length > 0 && r) {
        var o = this.camera.position, s = e.clone().sub(o), u = new Raycaster(o, s.clone().normalize());
        u.params.Points = { threshold: 0.1 };
        var l = this.models.intersectRaycaster(u)[0];
        if (l && l.distance + 0.01 < s.length())
          return null;
      }
      var c = e.clone().project(this.camera);
      if (Math.abs(c.z) > 1)
        return null;
      var f = this.renderer.getSize(new Vector2()), d = f.x * this.scissor.width, h = f.y * this.scissor.height, v = f.x * this.scissor.left + (c.x + 1) / 2 * d, A = f.y * (1 - this.scissor.bottom - this.scissor.height) + (-c.y + 1) / 2 * h;
      return new Vector2(v, A);
    }, t.prototype.getRenderObjects = function(e) {
      sharedProjScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), sharedFrustum.setFromProjectionMatrix(sharedProjScreenMatrix), e || (e = this.scene);
      var r = [];
      return e.traverseVisible(function(o) {
        (o instanceof Mesh || o instanceof Line || o instanceof Points) && (o instanceof ImmediateRenderObject || !o.frustumCulled || sharedFrustum.intersectsObject(o)) && r.push(o);
      }), r;
    }, t.prototype.getCurrentState = function() {
      return __assign(__assign({}, this.getPose()), { mode: this.currentMode, workCode: this.pano.workCode, panoIndex: this.pano.panoIndex });
    }, t.prototype.setState = function(e, r, o) {
      var s, u, l, c, f, d, h, v, A, g;
      r === void 0 && (r = false), o === void 0 && (o = true), e = Object.assign({}, e), e.offset && !(e instanceof Vector3) && (e.offset = new Vector3(e.offset.x, e.offset.y, e.offset.z));
      var p;
      if (typeof e.panoIndex == "number")
        if (e.workCode)
          p = {
            workCode: e.workCode,
            panoIndex: e.panoIndex
          };
        else {
          var y = (u = (s = this.work) === null || s === void 0 ? void 0 : s.workCode) !== null && u !== void 0 ? u : "", m = this.state.workCode;
          this.works.filter(function(I) {
            return I.workCode === m;
          }).length > 0 && (y = m), p = {
            workCode: y,
            panoIndex: e.panoIndex
          };
        }
      var E = (l = e.mode) !== null && l !== void 0 ? l : this.state.mode, b, T, R, S, M;
      if (this.controller && this.controller.stopMomentumMovement(), this.state.mode !== E) {
        if (E === "VRPanorama") {
          this.changeMode("VRPanorama", void 0, void 0, true);
          return;
        }
        var w = {
          workCode: p == null ? void 0 : p.workCode,
          panoIndex: p == null ? void 0 : p.panoIndex
        };
        typeof e.longitude == "number" && (w.longitude = e.longitude), typeof e.latitude == "number" && (w.latitude = e.latitude), typeof e.fov == "number" && (w.fov = e.fov), typeof e.distance == "number" && (w.distance = e.distance), e.offset instanceof Vector3 && (w.offset = e.offset);
        var H = __assign(__assign({ initial: {
          state: w,
          currentState: this.getCurrentState(),
          duration: this.modeChangeDuration,
          effect: "fly",
          userAction: false
        } }, this.commonParams()), this.controllerInits[E]), L = Controllers[E].initAnimationEndState(H);
        b = L.longitude, T = L.latitude, R = L.fov, S = L.offset, M = L.distance;
      } else
        b = (c = e.longitude) !== null && c !== void 0 ? c : this.state.longitude, T = (f = e.latitude) !== null && f !== void 0 ? f : this.state.latitude, R = (d = e.fov) !== null && d !== void 0 ? d : this.state.fov, S = (h = e.offset) !== null && h !== void 0 ? h : this.state.offset, M = (v = e.distance) !== null && v !== void 0 ? v : this.state.distance;
      var C = {
        workCode: (p != null ? p : this.pano).workCode,
        panoIndex: (p != null ? p : this.pano).panoIndex,
        mode: E,
        longitude: b,
        latitude: T,
        fov: R,
        offset: S,
        distance: M
      };
      this.emit("state.set", createEvent("state.set", {
        userAction: o,
        state: C
      })), stateEqual(this.state, C) || (this.controller && C.mode === "VRPanorama" && C.mode !== this.state.mode ? (assignState(this.state, C), this.changeMode("VRPanorama")) : this.controller && C.mode === "XRPanorama" && C.mode !== this.state.mode ? (assignState(this.state, C), this.changeMode("XRPanorama")) : (assignState(this.state, C), this.controller && o && (this.controller.userAction = false), r && this.state.mode === C.mode && (this.syncingState = this.syncState(now(), 0, r), this.syncingState && ((A = this.controller) === null || A === void 0 || A.updateTime(now(), 0), this.syncingState = false)), this.emit("state.change", createEvent("state.change", {
        userAction: o,
        state: this.state
      })), (g = this.analysis) === null || g === void 0 || g.state(this.works, this.state)));
    }, t.prototype.aroundScissor = function(e) {
      if (this.renderer) {
        if (this.state.mode === "XRPanorama") {
          e();
          return;
        }
        var r = new Vector2(), o = this.scissor.left !== 0 || this.scissor.bottom !== 0 || this.scissor.width !== 1 || this.scissor.height !== 1;
        if (o) {
          this.renderer.getSize(r);
          var s = Math.floor(r.x * this.scissor.left), u = Math.floor(r.y * this.scissor.bottom), l = Math.floor(r.x * this.scissor.width), c = Math.floor(r.y * this.scissor.height);
          this.renderer.setViewport(s, u, l, c), this.renderer.setScissor(s, u, l, c), this.renderer.setScissorTest(true);
        }
        e(), o && (this.renderer.setViewport(0, 0, r.x, r.y), this.renderer.setScissor(0, 0, r.x, r.y), this.renderer.setScissorTest(false));
      }
    }, t.prototype.syncState = function(e, r, o) {
      o === void 0 && (o = false);
      var s = this.stateSynced;
      if (this.stateSynced = false, !this.controller)
        return false;
      if (this.state.mode !== this.currentMode) {
        var u = {
          mode: this.state.mode,
          workCode: this.state.workCode,
          panoIndex: this.state.panoIndex,
          longitude: this.state.longitude,
          latitude: this.state.latitude,
          fov: this.state.fov,
          offset: this.state.offset,
          distance: this.state.distance
        };
        return this.changeMode(this.state.mode, u, this.modeChangeDuration, this.controller.userAction), true;
      }
      if (!this.controller.isReady())
        return false;
      if (this.controller instanceof Controllers.Model) {
        if (notSimilarVector3(this.camera.pose.offset, this.state.offset)) {
          var l = {
            longitude: this.state.longitude,
            latitude: this.state.latitude,
            fov: this.state.fov,
            offset: this.state.offset
          };
          return this.controller.moveToPosition(this.state.offset, __assign(__assign({}, l), { duration: o ? 0 : void 0 }), false), true;
        }
      } else {
        var c = {
          workCode: this.state.workCode,
          panoIndex: this.state.panoIndex
        };
        if (!panoEqual(c, this.pano) && "moveToPano" in this.controller && typeof this.controller.moveToPano == "function") {
          var l = {
            longitude: this.state.longitude,
            latitude: this.state.latitude,
            fov: this.state.fov,
            offset: this.state.offset,
            distance: this.state.distance
          };
          return this.controller.moveToPano(c, l, false), true;
        }
      }
      if (this.controller instanceof Controllers.Floorplan || this.controller instanceof Controllers.Topview || this.controller instanceof Controllers.Mapview) {
        var f = 1, d = 0.2, h = 0.2, v = Math.PI / 45, A = o ? this.state.fov : stepNumber(this.camera.pose.fov, this.state.fov, f), g = Math.abs(this.camera.pose.distance - this.state.distance), p = g > h * 15 ? g / 15 : d, y = o ? this.state.distance : stepNumber(this.camera.pose.distance, this.state.distance, p), m = this.camera.pose.offset.distanceTo(this.state.offset), E = m > h * 15 ? m / 15 : h, b = o ? new Vector3().copy(this.state.offset) : stepVector(this.camera.pose.offset, this.state.offset, E), T = o ? { longitude: this.state.longitude, latitude: this.state.latitude } : stepCoordinates({ longitude: this.camera.pose.longitude, latitude: this.camera.pose.latitude }, { longitude: this.state.longitude, latitude: this.state.latitude }, v), R = T.longitude, S = T.latitude;
        if (notSimilarValue(A, this.camera.pose.fov) || notSimilarVector3(b, this.camera.pose.offset) || notSimilarValue(y, this.camera.pose.distance) || notSimilarValue(R, this.camera.pose.longitude, Math.PI * 2) || notSimilarValue(S, this.camera.pose.latitude)) {
          var M = { x: b.x, y: b.y, z: b.z }, w = { fov: A };
          return Object.assign(M, {
            distance: y
          }), Object.assign(w, {
            longitude: R,
            latitude: S
          }), this.controller.stopMomentumMovement(), this.controller.cameraMotion.set(w, 0).catch(noop$1), this.controller.locationMotion.set(M, 0).catch(noop$1), true;
        }
      } else {
        var H = 1, L = Math.PI / 45, A = o ? this.state.fov : stepNumber(this.camera.pose.fov, this.state.fov, H), C = o ? { longitude: this.state.longitude, latitude: this.state.latitude } : stepCoordinates({ longitude: this.camera.pose.longitude, latitude: this.camera.pose.latitude }, { longitude: this.state.longitude, latitude: this.state.latitude }, L), R = C.longitude, S = C.latitude, y = this.state.distance, b = new Vector3().copy(this.state.offset);
        if (notSimilarValue(y, this.camera.pose.distance) && (this.state.distance = this.camera.pose.distance), notSimilarVector3(b, this.camera.pose.offset) && (this.state.offset = this.camera.pose.offset.clone()), notSimilarValue(R, this.camera.pose.longitude, Math.PI * 2) || notSimilarValue(S, this.camera.pose.latitude) || notSimilarValue(A, this.camera.pose.fov))
          return this.controller.stopMomentumMovement(), this.controller.cameraMotion.set({ longitude: R, latitude: S, fov: A }, 0).catch(noop$1), true;
      }
      if (this.stateSynced = true, s === false && this.emit("state.synced", createEvent("state.synced", {
        userAction: false,
        state: this.state
      })), this.readyCallbacks.length && this.stateSynced) {
        var I = this.currentMode, _ = I === t.Mode.Floorplan || I === t.Mode.Topview || I === t.Mode.Mapview || I === t.Mode.Model;
        if (!_ || this.models.loaded) {
          var O = this.readyCallbacks.slice();
          this.readyCallbacks.length = 0;
          for (var P = 0, N = O; P < N.length; P++) {
            var k = N[P];
            this.controller instanceof Controllers.Panorama && k.tile === true && !this.controller.isTileReady() ? this.readyCallbacks.push(k) : k();
          }
        }
      }
      return false;
    }, t.prototype.ready = function(e) {
      var r = this;
      return e === void 0 && (e = {}), new Promise(function(o) {
        var s;
        r.readyCallbacks.push(Object.assign(o, { tile: (s = e.tile) !== null && s !== void 0 ? s : false }));
      });
    }, t.prototype.requestFullscreen = function() {
      var e;
      if (isMobile) {
        var r = (e = this.getElement()) === null || e === void 0 ? void 0 : e.parentNode;
        r && "requestFullscreen" in r && typeof document != "undefined" && document.fullscreenElement === null && r.requestFullscreen();
      }
    }, t.prototype.exitFullscreen = function() {
      typeof document != "undefined" && document.fullscreenElement && "exitFullscreen" in document && document.exitFullscreen();
    }, t.prototype.throwError = function(e) {
      this.hasListener("error") ? this.emit("error", e) : console.error(e);
    }, t.prototype.loadModel = function(e, r) {
      for (var o = this, s, u, l, c, f, d, h = [], v = function(S) {
        var M = A.models.filter(function(C) {
          var I;
          return ((I = C.work) === null || I === void 0 ? void 0 : I.workCode) === S.workCode;
        })[0];
        if (M)
          M.work = S, h.push(M);
        else {
          var w = new Model({
            onError: function(C) {
              o.emit("model.error", createEvent("model.error", {
                work: S,
                model: w,
                error: C
              })), o.throwError(C);
            },
            onShownFloorChange: function(C) {
              o.emit("model.changeShownFloor", createEvent("model.changeShownFloor", {
                work: S,
                model: w,
                error: null
              }));
            },
            onLoad: function() {
              o.emit("model.load", createEvent("model.load", {
                work: S,
                model: w,
                error: null
              }));
            }
          });
          h.push(w), A.emit("model.request", createEvent("model.request", {
            work: S,
            model: w,
            error: null
          }));
          var H = (l = (u = (s = r.model) === null || s === void 0 ? void 0 : s.textureOptions) !== null && u !== void 0 ? u : r.textureOptions) !== null && l !== void 0 ? l : A.textureOptions, L = (f = (c = r.model) === null || c === void 0 ? void 0 : c["3d-tiles"]) !== null && f !== void 0 ? f : r["3d-tiles"];
          w.load(S, {
            light: (d = r.model) === null || d === void 0 ? void 0 : d.light,
            textureOptions: H,
            "3d-tiles": L
          });
        }
      }, A = this, g = 0, p = e; g < p.length; g++) {
        var y = p[g];
        v(y);
      }
      if (this.models.length > 0) {
        for (var m = 0, E = this.models; m < E.length; m++) {
          var b = E[m];
          h.indexOf(b) === -1 && this.lastModels.push(b);
        }
        this.models.length = 0;
      }
      for (var T = 0, R = h; T < R.length; T++) {
        var b = R[T];
        this.models.push(b);
      }
      return this.renderer && (this.models.loaded = false), new Promise(function(S) {
        o.on("models.load", function() {
          o.controller && o.controller.updateModel(o.models), S();
        });
      });
    }, t.prototype.commonParams = function() {
      return {
        ident: this.ident,
        scene: this.scene,
        xrCustomObjectsScene: this.xrCustomObjectsScene,
        helper: this.helperGroup,
        boundingMesh: this.boundingMesh,
        camera: this.camera,
        renderer: this.renderer,
        scissor: this.scissor,
        element: this.getElement(),
        models: this.models,
        works: this.works,
        imageOptions: this.imageOptions,
        enableWheel: this.enableWheel,
        enableIOSEDR: this._enableIOSEDR,
        enableEDL: this.enableEDL,
        enableHQ: this.enableHQ,
        extraElements: this.extraElements,
        videoTexture: this.videoTexture,
        modelScene: this.modelScene,
        modelRenderTarget: this.modelRenderTarget,
        enableLayeringRendering: this.enableLayeringRendering
      };
    }, t.prototype.applyController = function(e, r) {
      var o = this;
      if (!this.renderer)
        throw new Error("renderer is not initialized.");
      e !== t.Mode.Mapview && (this.enableEDL = false, this.enableHQ = false);
      var s = Controllers[e];
      this.currentMode = e;
      for (var u = new s(r), l = function(A) {
        u.on(A, function() {
          for (var g = [], p = 0; p < arguments.length; p++)
            g[p] = arguments[p];
          var y = o.emit.apply(o, __spreadArray([A], g, false));
          if (y)
            return false;
        });
      }, c = 0, f = PROXY_CONTROLLER_EVENT_NAMES; c < f.length; c++) {
        var d = f[c];
        l(d);
      }
      {
        var h = Controllers[e].initAnimationEndState(r), v = r.initial.userAction;
        stateEqual(this.state, h) || (assignState(this.state, h), this.emit("state.change", createEvent("state.change", {
          userAction: v,
          state: this.state
        }))), this.emit("currentState.change", createEvent("currentState.change", {
          userAction: v,
          state: this.getCurrentState()
        }));
      }
      return u.on("camera.update", function(A) {
        var g;
        if (o.controller) {
          var p = o.controller.getTargetState();
          A.userAction && o.syncingState === false && o.state.mode === p.mode && !stateEqual(o.state, p) && (assignState(o.state, p), o.emit("state.change", createEvent("state.change", {
            userAction: A.userAction,
            state: o.state
          })), (g = o.analysis) === null || g === void 0 || g.state(o.works, o.state));
        }
        o.emit("currentState.change", createEvent("currentState.change", {
          userAction: A.userAction,
          state: o.getCurrentState()
        }));
      }), u.on("initAnimation.start", function(A) {
        var g, p = A.state, y = A.userAction;
        y && o.state.mode === p.mode && !stateEqual(o.state, p) && (assignState(o.state, p), o.emit("state.change", createEvent("state.change", {
          userAction: y,
          state: o.state
        })), (g = o.analysis) === null || g === void 0 || g.state(o.works, o.state));
      }), u.on("initAnimation.end", function(A) {
        var g, p = A.state, y = A.userAction;
        o.pano = {
          workCode: p.workCode,
          panoIndex: p.panoIndex
        }, y && o.state.mode === p.mode && !stateEqual(o.state, p) && (assignState(o.state, p), o.emit("state.change", createEvent("state.change", {
          userAction: y,
          state: o.state
        })), (g = o.analysis) === null || g === void 0 || g.state(o.works, o.state));
      }), u.on("pano.moveTo", function(A) {
        var g, p = A.state, y = A.userAction;
        o.pano = {
          workCode: p.workCode,
          panoIndex: p.panoIndex
        }, y && o.state.mode === p.mode && !stateEqual(o.state, p) && (assignState(o.state, p), o.emit("state.change", createEvent("state.change", {
          userAction: y,
          state: o.state
        })), (g = o.analysis) === null || g === void 0 || g.state(o.works, o.state));
      }), u.on("pano.arrived", function(A) {
        var g, p = A.state, y = A.userAction;
        o.pano = {
          workCode: p.workCode,
          panoIndex: p.panoIndex
        }, y && o.state.mode === p.mode && !stateEqual(o.state, p) && (assignState(o.state, p), o.emit("state.change", createEvent("state.change", {
          userAction: y,
          state: o.state
        })), (g = o.analysis) === null || g === void 0 || g.state(o.works, o.state));
      }), u.on("pano.cancel", function(A) {
        var g, p = A.state, y = A.userAction;
        y && o.state.mode === p.mode && !stateEqual(o.state, p) && (assignState(o.state, p), o.emit("state.change", createEvent("state.change", {
          userAction: y,
          state: o.state
        })), (g = o.analysis) === null || g === void 0 || g.state(o.works, o.state));
      }), u.on("pano.moveTo", function(A) {
        var g = A.userAction;
        o.emit("currentState.change", createEvent("currentState.change", {
          userAction: g,
          state: o.getCurrentState()
        }));
      }), u.on("pano.request", function(A) {
        o.emit("pano.request", A), A.defaultPrevented || o.moveToPano(A.state, A.options, A.userAction);
      }), u.on("vr.requestExit", function() {
        o.currentMode === t.Mode.VRPanorama && (o.exitFullscreen(), o.changeMode(t.Mode.Panorama));
      }), u.on("error", function(A) {
        return o.throwError(A);
      }), u;
    }, t.prototype.removeEventListeners = function() {
    }, t.prototype.getWorkResources = function(e) {
      var r = this, o, s = this.models.find(function(f) {
        return f.work === e;
      }), u = ((o = s == null ? void 0 : s.viewLayers) !== null && o !== void 0 ? o : []).map(function(f) {
        return f.scene;
      });
      function l(f) {
        var d = /([0-9a-z\.\_\-]+)([\?\#].*)?$/i.exec(f);
        if (d) {
          var h = String(d[1]).trim().split(".").slice(1).reverse()[0];
          if (h)
            return h;
        }
        return "";
      }
      function c(f, d) {
        d === void 0 && (d = 0);
        var h = [];
        if (f.content && f.content.uri) {
          var v = l(f.content.uri);
          if (v === "json") {
            var A = imageURL(f.content.uri, { key: "model.".concat(d) });
            h.push({ url: A, type: "tileset" });
          } else if (v === "at3d" && f.extras[v]) {
            var A = f.content.uri;
            h.push({ url: A, type: "model" });
            for (var g = f.extras[v], p = g.textureArray, y = g.textureOptions, m = 0, E = p; m < E.length; m++) {
              var b = E[m], T = __assign({ key: "texture.pbm" }, pick(y, ["format", "quality", "size", "sharpen", "mappings"])), R = applyImageURLOptions(b, y == null ? void 0 : y.transform, T);
              h.push({ url: R, type: "texture" });
            }
          } else {
            var A = imageURL(f.content.uri, { key: "model.".concat(d) });
            h.push({ url: A, type: "model" });
          }
        }
        if (f.children)
          for (var S = 0; S < f.children.length; S++) {
            var M = f.children[S];
            h.push.apply(h, c(M, S));
          }
        return h;
      }
      return Promise.all(u.map(function(f) {
        return f.loadAllTilesets();
      })).then(function() {
        for (var f = [], d = ["right", "left", "up", "down", "front", "back"], h = 0, v = e.observers; h < v.length; h++) {
          for (var A = v[h], g = 0, p = d; g < p.length; g++) {
            var y = p[g], m = __assign({ key: "pano.".concat(panoStringify(A.pano), ".").concat(y) }, pick(r.imageOptions, ["size", "format", "quality", "mappings"])), E = A.images[y], b = applyImageURLOptions(E, r.imageOptions.transform, m);
            f.push({ url: b, type: "pano" });
          }
          if (A.images.tiles)
            for (var T = 0, R = A.images.tiles; T < R.length; T++)
              for (var S = R[T], M = 0, w = d; M < w.length; M++)
                for (var y = w[M], H = S.size, L = Math.pow(2, S.level), C = 1 / L, I = 0; I < L; I++)
                  for (var _ = 0; _ < L; _++) {
                    var O = "".concat(A.panoId, ".").concat(y, ".").concat(S.level, ".").concat(I, ".").concat(_), m = __assign(__assign({ key: "pano_tile.".concat(O) }, pick(r.imageOptions, ["format", "size", "quality", "sharpen", "mappings"])), { size: S.scale >= 1 ? void 0 : H * C * S.scale, cut: C === 1 ? void 0 : [
                      H * C * _,
                      H * C * I,
                      H * C,
                      H * C
                    ] }), b = applyImageURLOptions(S[y], r.imageOptions.transform, m);
                    f.push({ url: b, type: "pano_tile" });
                  }
        }
        for (var P = 0, N = u; P < N.length; P++) {
          var k = N[P];
          k.tileset.url && f.push({
            url: k.tileset.url,
            type: "model"
          }), f.push.apply(f, c(k.tileset.root));
        }
        return f;
      });
    }, Object.defineProperty(t.prototype, "internalLightsEnabled", {
      get: function() {
        var e = this.scene.children.find(function(r) {
          return r.name === "internalLights";
        });
        return e ? e.visible : false;
      },
      set: function(e) {
        var r = this.scene.children.find(function(o) {
          return o.name === "internalLights";
        });
        r && (r.visible = e), r = this.modelScene.children.find(function(o) {
          return o.name === "internalLights";
        }), r && (r.visible = e);
      },
      enumerable: false,
      configurable: true
    }), t.Mode = {
      Panorama: "Panorama",
      Model: "Model",
      Floorplan: "Floorplan",
      Topview: "Topview",
      Mapview: "Mapview",
      VRPanorama: "VRPanorama",
      XRPanorama: "XRPanorama"
    }, t.Line = null, t;
  }(Subscribe)
);
var __FIVE_DEBUG__ = {
  instances: {},
  constructor: Five
};
typeof window != "undefined" && Object.assign(window, { __FIVE_DEBUG__ });
var XRButton = (
  /** @class */
  function() {
    function n45() {
    }
    return n45.createButton = function(t) {
      var e = document.createElement("button");
      function r() {
        e.style.display = "", e.style.cursor = "pointer", e.style.left = "calc(50% - 50px)", e.style.width = "100px", e.textContent = "ENTER VR", e.onmouseenter = function() {
          e.style.opacity = "1.0";
        }, e.onmouseleave = function() {
          e.style.opacity = "0.5";
        }, e.onclick = function() {
          t && t();
        };
      }
      function o() {
        e.style.display = "", e.style.cursor = "auto", e.style.left = "calc(50% - 75px)", e.style.width = "150px", e.onmouseenter = null, e.onmouseleave = null, e.onclick = null;
      }
      function s() {
        o(), e.textContent = "VR NOT SUPPORTED";
      }
      function u(c) {
        c.style.position = "absolute", c.style.bottom = "20px", c.style.padding = "12px 6px", c.style.border = "1px solid #fff", c.style.borderRadius = "4px", c.style.background = "rgba(0,0,0,0.1)", c.style.color = "#fff", c.style.font = "normal 13px sans-serif", c.style.textAlign = "center", c.style.opacity = "0.5", c.style.outline = "none", c.style.zIndex = "999";
      }
      if ("xr" in navigator)
        return e.id = "VRButton", e.style.display = "none", u(e), navigator.xr.isSessionSupported("immersive-vr").then(function(c) {
          c ? r() : s();
        }), e;
      var l = document.createElement("a");
      return window.isSecureContext === false ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", u(l), l;
    }, n45;
  }()
);

export {
  Subscribe,
  NetworkSubscribe,
  Fetcher,
  AnimationFrameLoop,
  imageSupport,
  imageURL,
  panoStringify,
  panoParse,
  panoEqual,
  isPanoId,
  PBMGroup,
  PBMMesh,
  PBMSkinnedMesh,
  CustomShader,
  defaultPbmParameters,
  PBMPointCloud,
  PBMContainer,
  TileCubeTextureTarget,
  TextureLoader2 as TextureLoader,
  PBMMeshMaterial,
  PBMPointCloudMaterial,
  InternalWebGLRenderer,
  Scene2 as Scene,
  Camera2 as Camera,
  Tile,
  TileRequestScheduler,
  TileCache,
  Trajectory,
  Tileset,
  TileNode,
  draco,
  ktx2,
  loadB3dm,
  loadPnts,
  loadPbm,
  loadAt3d,
  loadDome,
  loadDomez,
  loadGltf,
  loadPly,
  loadFbx,
  loadX3p,
  TrajectoryNode,
  Tile3DModel,
  Work,
  parseWork,
  ModelViewLayer,
  Model,
  PanoCircleMesh,
  PanoCircleMeshSolid,
  PanoCircleMeshCustom,
  IntersectMesh,
  controllersDefaultInitArgs,
  PROXY_CONTROLLER_EVENT_NAMES,
  getViewportScale,
  Five,
  XRButton
};
/*! Bundled license information:

@realsee/five/five/index.mjs:
  (**
   * @license
   * @realsee/five
   * Generated: 6/5/2025
   * Version: 6.4.0-alpha.40
   * Terms:
   * Realsee SDK License Agreement
   * Update: July 28, 2021
   * THIS LICENSE AGREEMENT BETWEEN YOU AND BEIKE REALSEE TECHNOLOGY (HK) 
   * LIMITED(Realsee) FORMS A LEGALLY BINDING CONTRACT BETWEEN YOU AND REALSEE IN 
   * RELATION TO YOUR USE OF THE SDK. This License Agreement accompanies the Realsee 
   * Software Development Kit(s) for the software and related explanatory materials 
   * (the "SDK") and includes any upgrades, modified versions, updates, additions, 
   * and copies of the SDK licensed to You by Realsee.
   * BY DOWNLOADING, INSTALLING, OR OTHERWISE ACCESSING OR USING THE SDK, YOU AGREE 
   * THAT YOU HAVE READ, UNDERSTOOD, AND AGREE TO BE BOUND BY THIS AGREEMENT. YOU ARE 
   * AGREEING ON YOUR OWN BEHALF AND/OR ON BEHALF OF YOUR COMPANY OR ORGANIZATION TO 
   * THE TERMS AND CONDITIONS STATED BELOW.
   * This Agreement applies to Your use of the SDK in the country in which You 
   * legally install it (Territory) and is subject to the laws of such Territory 
   * and further subject to Section 12 below. Different terms, conditions, and 
   * limitations may apply to the use of the SDK in any additional countries.
   * 1. DEFINITIONS.
   * Agreement means this Realsee SDK License Agreement.
   * Developer, You and Your means the person(s) or entity acquiring or using 
   * the SDK or otherwise exercising rights under the terms of this Agreement.
   * Documentation means the technical or other specifications or documentation 
   * that Realsee may provide to You for use in connection with the SDK.
   * Integrated Product means any software, website, or on-line service developed 
   * by You based on or using the SDK (collectively, the Integrated Product).
   * Intellectual Property means any patents, patent rights, trademarks, service 
   * marks, registered and unregistered designs, applications for any of the 
   * foregoing, copyright, and any other similar protected rights in any country and 
   * to the extent recognised by any relevant jurisdiction as intellectual property, 
   * trade secrets, know-how and confidential information. Realsee reserves all 
   * rights not expressly granted to You.
   * Realsee means [Beike Realsee Technology (HK) Limited, a company incorporated 
   * and validly existing under the laws of Hong Kong].
   * SDK means the Realsee-proprietary Software Development Kits (SDK) provided 
   * hereunder, includes all development tools (including any compiler and debugger), 
   * application programming interfaces (APIs), libraries, binary utilities, header 
   * files, Documentation, content, data, code samples, and other materials provided 
   * to You in connection with this Agreement, whether delivered through a download, 
   * or any other media or form, and is licensed, not sold, to You by Realsee for use 
   * only under the terms of this Agreement. The terms of this Agreement will govern 
   * any updates provided by Realsee that replace and/or supplement the original SDK 
   * delivered to You, unless such update is accompanied by a separate license, in 
   * which case the terms of such license will govern.
   * 2. LICENSED USES AND RESTRICTIONS.
   * 2.1 Subject to the restrictions contained in this Section 2, Realsee grants to 
   * You during the term, a limited, non-exclusive, revocable, non-sublicensable, 
   * non-transferable license to install and use the SDK within the Territory only 
   * for the purpose of internal development.
   * 2.2 Restrictions. You acknowledge and agree that, You shall not, and shall 
   * ensure that Your affiliates, employees, agents, representatives, officers, 
   * representatives, and subcontractors do not (directly or indirectly):
   * 2.2.1 decompile, reverse engineer, disassemble or attempt to derive the source 
   * code of, those components of the SDK provided in object code form, or any part 
   * thereof;
   * 2.2.2 remove, alter, or obscure any copyright notice or other proprietary rights 
   * notice on any part of the SDK;
   * 2.2.3 sell, assign, pledge, rent, lease, lend, upload to or host on any website 
   * or server for use by any third party except You, redistribute, or sublicense the 
   * SDK (or any part thereof), or operate the SDK (or any part thereof) in the 
   * capacity of a service bureau or other hosted services provider, in whole or in 
   * part, nor may You enable others to do so;
   * 2.2.4 or alter, modify, customize or improve the SDK, or any part thereof;
   * 2.2.5 use the SDK (or any part thereof) for any illegal purpose, in any manner 
   * that is inconsistent with the terms of this Agreement, or to engage in any 
   * illegal activity;
   * 2.2.6 use the SDK (or any part thereof) in any manner that may damage the 
   * operation of Realsees products or services; or
   * 2.2.7 use the SDK or any information contained therein or otherwise provided by 
   * Realsee for the purpose of developing, or having developed, any product 
   * competitive with any Realsee product or service, as determined by Realsee in its 
   * sole discretion;
   * 2.2.8 include any portion of the SDK in Your Developer products.
   * 2.3 Realsee has the right to impose reasonable conditions such as a reasonable 
   * fee for use of the SDK in Integrated Product in the future.
   * 2.4 You may make a limited number of copies of the SDK to be used by Your 
   * employees or consultants as provided herein, and not for general business 
   * purposes, and such employees or consultants shall be subject to the obligations 
   * and restrictions in this Agreement.
   * 2.5 All licenses not expressly granted in this Agreement are reserved and no 
   * other licenses, immunity, or rights, express or implied, are granted by Realsee, 
   * by implication, estoppel, or otherwise.
   * 3. CONFIDENTIALITY.
   * The SDK and all source code, Documentation, specifications, engineering details, 
   * and related information pertaining to the SDK, whether in oral, written, 
   * graphic, or electronic form, are and shall remain the confidential and 
   * proprietary information of Realsee or its licensors (collectively, the 
   * Confidential Information). You shall (i) disclose Confidential Information to 
   * only those directors and employees (collectively, Affiliates) whose duties 
   * justify their need to know such information and who have been clearly informed 
   * of their obligation to maintain the confidential, proprietary, and/or trade 
   * secret status of such Confidential Information; and (ii) use Confidential 
   * Information solely in accordance with the license granted hereunder. In any 
   * event, You and Your Affiliates shall treat Confidential Information as strictly 
   * confidential and shall use the same care to prevent disclosure of such 
   * information as You use with respect to Your own similar confidential and/or 
   * proprietary information, which shall not be less than the care a reasonable 
   * person would use under similar circumstances. All Confidential Information, and 
   * any copies thereof, shall be returned promptly to Realsee upon request. You 
   * shall ensure that Your Affiliates comply with the provisions of this Section 3, 
   * and You shall be liable for any breach of this Section 3 resulting from the act 
   * or omission of any of Your Affiliates. You shall not disclose Confidential 
   * Information to any third party, including, without limitation, any of Your 
   * subcontractors.
   * 4. PROPRIETARY RIGHTS.
   * 4.1 As between You and Realsee, Realsee and/or its licensors retain ownership of 
   * all right, title, and interest in, to, and under the SDK, including, without 
   * limitation, all patents, copyrights, trade secrets, trademarks and other 
   * intellectual property and other proprietary rights therein, and reserve all 
   * rights not expressly granted to You.
   * 4.2 The items contained in the SDK are the intellectual property of Realsee and 
   * its licensors and are protected by PRC copyright and patent law, international 
   * treaty provisions and applicable laws of the country in which it is being used. 
   * You agree to protect all copyright and other ownership interests of Realsee 
   * and/or its licensors in all items in the SDK supplied under this License 
   * Agreement. You agree that all copies of the items in the SDK, reproduced for any 
   * reason by You, contain the same copyright notices, and other proprietary notices 
   * as appropriate, as appear on or in the original items delivered by Realsee in 
   * the SDK. Realsee and/or its licensors retain title and ownership of the items in 
   * the SDK, the media on which it is loaded, and all subsequent copies, regardless 
   * of the form or media in or on which the original and other copies may exist. 
   * Except as stated above, this Agreement does not grant You any rights to patents, 
   * copyrights, trade secrets, trademarks or any other rights in respect to the 
   * items in the SDK.
   * 5. TERM AND TERMINATION.
   * 5.1 This Agreement is effective until terminated. Realsee has the right to 
   * terminate this Agreement immediately, without judicial intervention, if You fail 
   * to comply with any term herein. Upon any such termination You must remove all 
   * full and partial copies of the items in the SDK from Your computer and 
   * discontinue the use of the items in the SDK.
   * 5.2 Realsee may at any time, terminate the Agreement with You if: (A) You have 
   * breached any provision of the Agreement; or (B) Realsee is required to do so by 
   * law; or (C) Realsee decides to no longer provide the SDK or certain parts of the 
   * SDK to users in the country in which You are resident or from which You use the 
   * service, or the provision of the SDK or certain SDK services to You by Realsee 
   * is, in Realsee's sole discretion, no longer legally or commercially viable.
   * 5.3 When the Agreement comes to an end, all of the legal rights, obligations and 
   * liabilities that You and Realsee have benefited from, been subject to (or which 
   * have accrued over time whilst the Agreement has been in force) or which are 
   * expressed to continue indefinitely, shall be unaffected by this cessation, and 
   * the provisions of Section 3, 4, 6, 7 and 8 shall continue to apply to such 
   * rights, obligations and liabilities indefinitely.
   * 6. DISCLAIMER OF WARRANTY.
   * YOU EXPRESSLY ACKNOWLEDGE AND AGREE THAT, TO THE EXTENT PERMITTED BY APPLICABLE 
   * LAW, USE OF THE SDK (OR ANY PART THEREOF) IS AT YOUR SOLE RISK AND THAT THE 
   * ENTIRE RISK AS TO SATISFACTORY QUALITY, PERFORMANCE, ACCURACY, AND EFFORT IS 
   * WITH YOU. REALSEE LICENSES THE SDK TO YOU ONLY ON AN "AS-IS" BASIS. REALSEE 
   * MAKES NO REPRESENTATION WITH RESPECT TO THE ADEQUACY OF ANY ITEMS IN THE SDK, 
   * WHETHER OR NOT USED BY YOU IN THE DEVELOPMENT OF INTEGRATED PRODUCT, FOR ANY 
   * PARTICULAR PURPOSE OR WITH RESPECT TO THEIR ADEQUACY TO PRODUCE ANY PARTICULAR 
   * RESULT. REALSEE AND ITS LICENSORS SHALL NOT BE LIABLE FOR LOSS OR DAMAGE ARISING 
   * OUT OF THIS AGREEMENT OR FROM THE DISTRIBUTION OR USE OF INTEGRATED PRODUCT 
   * CONTAINING PORTIONS OF THE SDK. REALSEE AND ITS LICENSORS DISCLAIM ALL 
   * WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED 
   * CONDITIONS OR WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
   * OR NONINFRINGEMENT OF ANY THIRD PARTY RIGHT IN RESPECT OF THE ITEMS IN THE SDK 
   * OR ANY SERVICES RELATED TO THE SDK.
   * REALSEE IS UNDER NO OBLIGATION TO PROVIDE ANY SUPPORT UNDER THIS LICENSE 
   * AGREEMENT, INCLUDING UPGRADES OR FUTURE VERSIONS OF THE SDK OR ANY PORTIONS 
   * THEREOF, TO YOU, END USER OR TO ANY OTHER PARTY.
   * 7. LIMITATION OF LIABILITY.
   * TO THE EXTENT NOT PROHIBITED BY APPLICABLE LAW, IN NO EVENT WILL REALSEE OR ITS 
   * LICENSORS BE LIABLE FOR ANY DIRECT, INCIDENTAL, SPECIAL, INDIRECT, OR 
   * CONSEQUENTIAL DAMAGES, INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF USE, 
   * LOSS OF BUSINESS, REVENUE, OR PROFITS, LOSS OF OPPORTUNITY (WHETHER DIRECT OR 
   * INDIRECT), CORRUPTION OR LOSS OF DATA, LOSS OF REPUTATION OR SAVINGS, DOWNTIME, 
   * OR DAMAGE TO, LOSS OF OR REPLACEMENT OF DATA OR TRANSACTIONS, COST OF 
   * PROCUREMENT OF SUBSTITUTE SERVICES, BUSINESS INTERRUPTION, OR ANY OTHER 
   * COMMERCIAL DAMAGES OR LOSSES, ARISING OUT OF OR RELATED TO YOUR USE OR INABILITY 
   * TO USE THE SDK (OR ANY PART THEREOF), ANY INTEGRATED PRODUCT, OR ANY THIRD PARTY 
   * SOFTWARE, APPLICATIONS, OR SERVICES IN CONJUNCTION WITH THE SDK (OR ANY PART 
   * THEREOF), HOWEVER CAUSED, REGARDLESS OF THE THEORY OF LIABILITY (CONTRACT, TORT, 
   * OR OTHERWISE) AND EVEN IF REALSEE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
   * DAMAGES. IN NO EVENT WILL REALSEES TOTAL LIABILITY TO YOU FOR ALL DAMAGES 
   * EXCEED ONE HUNDRED DOLLARS ($100.00). THE FOREGOING LIMITATIONS WILL APPLY EVEN 
   * IF THE ABOVE STATED REMEDY FAILS OF ITS ESSENTIAL PURPOSE. THE LIMITATIONS 
   * CONTAINED IN SECTIONS 6 AND THIS SECTION 7 ARE A FUNDAMENTAL PART OF THE BASIS 
   * OF REALSEES BARGAIN HEREUNDER, AND REALSEE WOULD NOT ENTER INTO THIS AGREEMENT 
   * OR PROVIDE YOU WITH ACCESS TO THE SDK ABSENT SUCH LIMITATIONS.
   * 8. INDEMNIFICATION.
   * To the extent permitted by applicable law, You agree to indemnify, defend and 
   * hold harmless Realsee, its affiliates and each of their directors, officers, 
   * employees, independent contractors, and agents (each a Realsee Indemnified 
   * Party) from any and all claims, losses, liabilities, damages, expenses, and 
   * costs (including without limitation attorneys fees and court costs) incurred by 
   * a Realsee Indemnified Party as a result of: (i) Your non-compliance with any 
   * terms of this Agreement; (ii) Your use of the SDK (or any part thereof); or 
   * (iii) Your use of any Integrated Product, including any claim that Integrated 
   * Product infringes the copyright, trademark, trade secret or other intellectual 
   * property right of a third party.
   * 9. ACKNOWLEDGEMENTS.
   * Portions of the SDK may utilize or include third party software and other 
   * copyrighted material. Acknowledgments, licensing terms, and disclaimers for such 
   * material are contained in Documentation for the SDK or may otherwise accompany 
   * such material, and Your use of such materials governed by their respective 
   * terms. In the event of conflict between the terms of this Agreement and an 
   * applicable open source or third party agreement, the open source or third party 
   * agreement will control solely with respect to the open source software or third 
   * party software. Moreover, You shall not subject any items (including not limited 
   * to source code, object code, and any software)  included in the SDK to any open 
   * source license.
   * 10. NON-BLOCKING OF REALSEE DEVELOPMENT.
   * You acknowledge that Realsee is currently developing or may develop technologies 
   * and products in the future that have or may have design and/or functionality 
   * similar to Integrated Product that You may develop based on Your license herein. 
   * Nothing in this Agreement shall impair, limit or curtail Realsee's right to 
   * continue with its development, maintenance and/or distribution of Realsee's 
   * technology or products.
   * 11. GENERAL.
   * 11.1 Export Control. You may not use or otherwise export or re-export the SDK 
   * (or any part thereof) except as authorized by United States law and the laws of 
   * the jurisdiction(s) in which the SDK (or any part thereof) was obtained. In 
   * particular, but without limitation, the SDK may not be exported or re-exported 
   * (i) into any U.S. embargoed countries or (ii) to anyone on the U.S. Treasury 
   * Department's list of Specially Designated Nationals or the U.S. Department of 
   * Commerce Denied Person's List or Entity List. By using the SDK (or any part 
   * thereof), You represent and warrant that You are not located in any such country 
   * or on any such list.
   * 11.2 Governing Law. This Agreement and the rights of the parties hereunder shall 
   * be governed by and construed in accordance with the laws of Peoples Republic of 
   * China (for purpose of this Agreement, excluding Hong Kong, Taiwan, and Macau), 
   * without reference to its conflict of laws principles. Any dispute, controversy 
   * or claim arising from or in connection with this Agreement, or the breach, 
   * termination or invalidity thereof, shall be submitted to China International 
   * Economic and Trade Arbitration Commission (CIETAC) for arbitration in Beijing 
   * which shall be conducted in accordance with the CIETAC's arbitration rules in 
   * effect at the time of applying for arbitration. The arbitral award is final and 
   * binding upon both parties.
   * 11.3 Severability. If any provision of this Agreement is held by a court of 
   * competent jurisdiction to be unenforceable for any reason, the remaining 
   * provisions hereof will be unaffected and remain in full force and effect.
   * 11.4. Modifications. Realsee reserves the right, from time to time, with or 
   * without notice to You, to make revisions to this Agreement in our sole and 
   * absolute discretion.  The most current version of this Agreement will supersede 
   * all previous versions and shall be made available on the website where the SDK 
   * is made available, or by such other means as Realsee may determine in its 
   * discretion. Any modified versions of this Agreement hereto shall take effect 
   * from the time that it is made available. You shall be responsible for regularly 
   * checking for notice of any such modifications. You agree that Your continued use 
   * of the SDK constitutes Your agreement to the modified Agreement.
   * 11.5 Relationship of the Parties. This Agreement will not be construed as 
   * creating an agency, partnership, joint venture, fiduciary duty, or any other 
   * form of legal association between You and Realsee, and You will not represent to 
   * the contrary, whether expressly, by implication, appearance, or otherwise.
   * 11.6 Entire Agreement; Governing Language. This Agreement constitutes the entire 
   * agreement between You and Realsee with respect to the use of the SDK licensed 
   * hereunder and supersedes all prior understandings regarding such subject matter. 
   * No amendment to or modification of this Agreement will be binding unless in 
   * writing and signed by Realsee. You and Realsee hereto confirm that this 
   * Agreement and all related documents shall be drafted in English.
  *)
  (**
   * @license
   * The 'jsrsasign'(RSA-Sign JavaScript Library) License
   *
   * Copyright (c) 2010-2021 Kenji Urushima
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *
   * LICENSE: MIT License
   *)
  (**
   * @license
   * RSA and ECC in JavaScript
   *
   * Copyright (c) 2003-2005  Tom Wu All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
   *
   * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
   * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
   * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * In addition, the following condition applies:
   *
   * All redistributions must retain an intact copy of this copyright notice
   * and disclaimer.
   *
   * http://www-cs-students.stanford.edu/~tjw/jsbn/
   * LICENSE: BSD License
   * PART: ext/{base64,jsbn,jsbn2,prgn4,rng,rsa,rsa2}
   *)
  (**
   * @license
   * CryptoJS
   *
   * Copyright (c) 2009-2013 Jeff Mott
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * https://code.google.com/p/crypto-js/wiki/License
   * PART: ext/cryptojs
   *)
  (*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
   *)
  (*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/ *)

@realsee/five/five/index.mjs:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=chunk-3FKD32UE.js.map
